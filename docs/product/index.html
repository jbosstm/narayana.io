<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Narayana Product Documentation</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="description" content="The Transactions Overview Guide contains information on how to use Narayana to develop applications that use transaction technology to manage business processes."/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e1"/>Narayana Product Documentation</h1></div><div><h3 class="corpauthor">
        <span class="inlinemediaobject"><object type="image/svg+xml" data="Common_Content/images/title_logo.svg"/></span>
    </h3></div><div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="authorgroup"><div class="authors">by <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Mark</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Little</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Jonathan</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Halliday</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Andrew</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Dinn</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Kevin</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Connor</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Michael</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Musgrove</span>, <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Paul</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Robinson</span>, and <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Gytis</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Trikleris</span></div><div class="editors"/><div class="others"/></div></div><div><a href="ln-d0e26.html">Legal Notice</a></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
            The Transactions Overview Guide contains information on how to use Narayana
            to develop applications that use transaction technology to manage business processes.
        </p></div></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e88">1. Document Conventions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e98">1.1. Typographic Conventions</a></span></dt><dt><span class="section"><a href="#d0e310">1.2. Pull-quote Conventions</a></span></dt><dt><span class="section"><a href="#d0e329">1.3. Notes and Warnings</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e350">2. We Need Feedback!</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e363">1. Transactions Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e415">1.1. What is a transaction?</a></span></dt><dt><span class="section"><a href="#d0e458">1.2. The Coordinator</a></span></dt><dt><span class="section"><a href="#d0e467">1.3. The Transaction Context</a></span></dt><dt><span class="section"><a href="#d0e496">1.4. Participants</a></span></dt><dt><span class="section"><a href="#d0e501">1.5. Commit protocol</a></span></dt><dt><span class="section"><a href="#d0e536">1.6. The Synchronization Protocol</a></span></dt><dt><span class="section"><a href="#d0e573">1.7. Optimizations to the Protocol</a></span></dt><dt><span class="section"><a href="#d0e636">1.8. Non-Atomic Transactions and Heuristic Outcomes</a></span></dt><dt><span class="section"><a href="#d0e724">1.9. Interposition</a></span></dt><dt><span class="section"><a href="#d0e783">1.10. A New Transaction Protocol</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e803">1.10.1. Addressing the Problems of Transactioning in Loosely Coupled Systems</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e823">2. Failure Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e826">2.1. Architecture of the Recovery Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e829">2.1.1. Crash Recovery Overview</a></span></dt><dt><span class="section"><a href="#d0e859">2.1.2. Recovery Manager</a></span></dt><dt><span class="section"><a href="#d0e998">2.1.3. Recovery Modules</a></span></dt><dt><span class="section"><a href="#d0e1030">2.1.4. A Recovery Module for XA Resources</a></span></dt><dt><span class="section"><a href="#d0e1093">2.1.5. Recovering XAConnections</a></span></dt><dt><span class="section"><a href="#d0e1134">2.1.6. Alternative to XAResourceRecovery</a></span></dt><dt><span class="section"><a href="#d0e1166">2.1.7. Shipped XAResourceRecovery implementations</a></span></dt><dt><span class="section"><a href="#d0e1204">2.1.8. TransactionStatusConnectionManager</a></span></dt><dt><span class="section"><a href="#d0e1211">2.1.9. Expired Scanner Thread</a></span></dt><dt><span class="section"><a href="#d0e1244">2.1.10. Application Process</a></span></dt><dt><span class="section"><a href="#d0e1253">2.1.11. TransactionStatusManager</a></span></dt><dt><span class="section"><a href="#d0e1265">2.1.12. Object Store</a></span></dt><dt><span class="section"><a href="#d0e1270">2.1.13. Socket free operation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1281">2.2. How Narayana manages the OTS Recovery Protocol
    </a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1284">2.2.1. Recovery Protocol in OTS - Overview</a></span></dt><dt><span class="section"><a href="#d0e1297">2.2.2. RecoveryCoordinator
            in Narayana
        </a></span></dt><dt><span class="section"><a href="#d0e1395">2.2.3. The default RecoveryCoordinator in JacOrb</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1423">2.3. Configuration Options</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1426">2.3.1. Recovery Protocol in OTS - Overview</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1511">3. Development Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1514">3.1. Transactions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1521">3.1.1. The Java Transaction API (JTA)</a></span></dt><dt><span class="section"><a href="#d0e1580">3.1.2. Introducing the API</a></span></dt><dt><span class="section"><a href="#UserTransaction_Definition">3.1.3. UserTransaction</a></span></dt><dt><span class="section"><a href="#d0e1665">3.1.4. TransactionManager</a></span></dt><dt><span class="section"><a href="#d0e1780">3.1.5. Suspend and resuming a transaction</a></span></dt><dt><span class="section"><a href="#d0e1824">3.1.6. The Transaction interface</a></span></dt><dt><span class="section"><a href="#d0e1884">3.1.7. Resource enlistment</a></span></dt><dt><span class="section"><a href="#d0e1932">3.1.8. Transaction synchronization</a></span></dt><dt><span class="section"><a href="#d0e1980">3.1.9. Transaction equality</a></span></dt><dt><span class="section"><a href="#d0e2008">3.1.10. TransactionSynchronizationRegistry</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2071">3.2. The Resource Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2074">3.2.1. 
            The
            XAResource
            interface
        </a></span></dt><dt><span class="section"><a href="#d0e2303">3.2.2. Opening a resource manager</a></span></dt><dt><span class="section"><a href="#d0e2314">3.2.3. Closing a resource manager</a></span></dt><dt><span class="section"><a href="#d0e2339">3.2.4. Thread of control</a></span></dt><dt><span class="section"><a href="#d0e2370">3.2.5. Transaction association</a></span></dt><dt><span class="section"><a href="#d0e2401">3.2.6. Externally controlled connections</a></span></dt><dt><span class="section"><a href="#d0e2414">3.2.7. Resource sharing</a></span></dt><dt><span class="section"><a href="#d0e2451">3.2.8. Local and global transactions</a></span></dt><dt><span class="section"><a href="#d0e2466">3.2.9. Transaction timeouts</a></span></dt><dt><span class="section"><a href="#d0e2510">3.2.10. Dynamic registration</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2525">3.3. General Transaction Issues</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2528">3.3.1. Advanced transaction issues with TxCore</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2723">3.4. Tools</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2728">3.4.1. ObjectStore command-line browsers and editors</a></span></dt><dt><span class="section"><a href="#d0e3086">3.4.2. GUI Based Tools</a></span></dt><dt><span class="section"><a href="#d0e3117">3.4.3. View Transaction Statistics using an Application Server</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3254">3.5. Configuration options</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3257">3.5.1. Loading a configuration</a></span></dt><dt><span class="section"><a href="#d0e3383">3.5.2. ArjunaCore Options</a></span></dt><dt><span class="section"><a href="#d0e3440">3.5.3. Narayana
            JTA Configuration options
        </a></span></dt><dt><span class="section"><a href="#d0e3458">3.5.4. Narayana
            JTS Options
        </a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3479">3.6. Important Log Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3484">3.6.1. Transaction State Change</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3554">3.7. Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3559">3.7.1. WS-BA Participant-Completion Race Condition</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e3692">4. XTS Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3695">4.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3822">4.1.1. Managing service-Based Processes</a></span></dt><dt><span class="section"><a href="#d0e3842">4.1.2. Servlets</a></span></dt><dt><span class="section"><a href="#d0e3854">4.1.3. SOAP</a></span></dt><dt><span class="section"><a href="#d0e3862">4.1.4. Web Services Description Language (WDSL)</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3870">4.2. Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3887">4.2.1. Enable
            XTS on WildFly Application Server
        </a></span></dt><dt><span class="section"><a href="#d0e3940">4.2.2. Working With WS-AT</a></span></dt><dt><span class="section"><a href="#d0e4053">4.2.3. Working With WS-BA</a></span></dt><dt><span class="section"><a href="#ref-TransactionContextPropagation">4.2.4. Configuration of The Transaction Context Propagation</a></span></dt><dt><span class="section"><a href="#d0e4181">4.2.5. Summary</a></span></dt></dl></dd><dt><span class="section"><a href="#sec-xts-api">4.3. The XTS API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4253">4.3.1. Participants</a></span></dt><dt><span class="section"><a href="#d0e4328">4.3.2. API for the Atomic Transaction Protocol</a></span></dt><dt><span class="section"><a href="#d0e4879">4.3.3. API for the Business Activity Protocol</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5401">4.4. Stand-Alone Coordination</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5413">4.4.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e5438">4.4.2. Configuring the Activation Coordinator</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5617">4.5. Participant Crash Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5664">4.5.1. WS-AT Recovery</a></span></dt><dt><span class="section"><a href="#d0e5914">4.5.2. WS-BA Recovery</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6176">4.6. Web Service Transaction Service (XTS) Management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6181">4.6.1. Transaction manager overview</a></span></dt><dt><span class="section"><a href="#d0e6189">4.6.2. Configuring the transaction manager</a></span></dt><dt><span class="section"><a href="#d0e6208">4.6.3. Deployment descriptors</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6216">4.7. Quickstarts Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#ref-WSATMultiService">4.7.1. WS-AT Multi-Service</a></span></dt><dt><span class="section"><a href="#ref-WSATMultiHop">4.7.2. WS-AT Multi-Hop</a></span></dt><dt><span class="section"><a href="#d0e6249">4.7.3. XTS with SSL</a></span></dt><dt><span class="section"><a href="#d0e6258">4.7.4. Raw XTS API Demo</a></span></dt><dt><span class="section"><a href="#ref-CompensationsNonTransactionalResource">4.7.5. Non-transactional Resource with Compensating Transactions API</a></span></dt><dt><span class="section"><a href="#ref-CompensationsTravelAgent">4.7.6. Travel Agent with Compensating Transactions API</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e6287">5. TXBridge Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6290">5.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6293">5.1.1. Contextual Overview</a></span></dt><dt><span class="section"><a href="#d0e6306">5.1.2. Transaction Bridging</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6335">5.2. Transaction Bridge Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6338">5.2.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e6355">5.2.2. Shared Design Elements</a></span></dt><dt><span class="section"><a href="#d0e6400">5.2.3. Inbound Bridging</a></span></dt><dt><span class="section"><a href="#d0e6433">5.2.4. Outbound Bridging</a></span></dt><dt><span class="section"><a href="#d0e6463">5.2.5. Crash Recovery</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6476">5.3. Using the Transaction Bridge</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6479">5.3.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6484">5.3.2. Enabling</a></span></dt><dt><span class="section"><a href="#d0e6537">5.3.3. Inbound Bridging</a></span></dt><dt><span class="section"><a href="#d0e6554">5.3.4. Outbound Bridging</a></span></dt><dt><span class="section"><a href="#d0e6571">5.3.5. Loops and Diamonds</a></span></dt><dt><span class="section"><a href="#d0e6586">5.3.6. Distributed JTA and the JTS</a></span></dt><dt><span class="section"><a href="#d0e6599">5.3.7. Logging</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6618">5.4. Known Limitations</a></span></dt><dt><span class="section"><a href="#d0e6648">5.5. Design Notes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6651">5.5.1. General Points</a></span></dt><dt><span class="section"><a href="#d0e6664">5.5.2. Crash Recovery Considerations</a></span></dt><dt><span class="section"><a href="#d0e6701">5.5.3. Test framework</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Preface</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e88"/>1. Document Conventions</h2></div></div></div><p>
		This manual uses several conventions to highlight certain words and phrases and draw attention to specific pieces of information.
	</p><p>
		In PDF and paper editions, this manual uses typefaces drawn from the <a class="ulink" href="https://fedorahosted.org/liberation-fonts/">Liberation Fonts</a> set. The Liberation Fonts set is also used in HTML editions if the set is installed on your system. If not, alternative but equivalent typefaces are displayed. Note: Red Hat Enterprise Linux 5 and later includes the Liberation Fonts set by default.
	</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e98"/>1.1. Typographic Conventions</h3></div></div></div><p>
			Four typographic conventions are used to call attention to specific words and phrases. These conventions, and the circumstances they apply to, are as follows.
		</p><p>
			<code class="literal">Mono-spaced Bold</code>
		</p><p>
			Used to highlight system input, including shell commands, file names and paths. Also used to highlight keycaps and key combinations. For example:
		</p><div class="blockquote"><blockquote class="blockquote"><p>
				To see the contents of the file <code class="filename">my_next_bestselling_novel</code> in your current working directory, enter the <code class="command">cat my_next_bestselling_novel</code> command at the shell prompt and press <span class="keycap"><strong>Enter</strong></span> to execute the command.
			</p></blockquote></div><p>
			The above includes a file name, a shell command and a keycap, all presented in mono-spaced bold and all distinguishable thanks to context.
		</p><p>
			Key combinations can be distinguished from keycaps by the hyphen connecting each part of a key combination. For example:
		</p><div class="blockquote"><blockquote class="blockquote"><p>
				Press <span class="keycap"><strong>Enter</strong></span> to execute the command.
			</p><p>
				Press <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F2</strong></span> to switch to the first virtual terminal. Press <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span> to return to your X-Windows session.
			</p></blockquote></div><p>
			The first paragraph highlights the particular keycap to press. The second highlights two key combinations (each a set of three keycaps with each set pressed simultaneously).
		</p><p>
			If source code is discussed, class names, methods, functions, variable names and returned values mentioned within a paragraph will be presented as above, in <code class="literal">mono-spaced bold</code>. For example:
		</p><div class="blockquote"><blockquote class="blockquote"><p>
				File-related classes include <code class="classname">filesystem</code> for file systems, <code class="classname">file</code> for files, and <code class="classname">dir</code> for directories. Each class has its own associated set of permissions.
			</p></blockquote></div><p>
			<span class="application"><strong>Proportional Bold</strong></span>
		</p><p>
			This denotes words or phrases encountered on a system, including application names; dialog box text; labeled buttons; check-box and radio button labels; menu titles and sub-menu titles. For example:
		</p><div class="blockquote"><blockquote class="blockquote"><p>
				Choose <span class="guimenu"><strong>System</strong></span> → <span class="guisubmenu"><strong>Preferences</strong></span> → <span class="guimenuitem"><strong>Mouse</strong></span> from the main menu bar to launch <span class="application"><strong>Mouse Preferences</strong></span>. In the <span class="guilabel"><strong>Buttons</strong></span> tab, click the <span class="guilabel"><strong>Left-handed mouse</strong></span> check box and click <span class="guibutton"><strong>Close</strong></span> to switch the primary mouse button from the left to the right (making the mouse suitable for use in the left hand).
			</p><p>
				To insert a special character into a <span class="application"><strong>gedit</strong></span> file, choose <span class="guimenu"><strong>Applications</strong></span> → <span class="guisubmenu"><strong>Accessories</strong></span> → <span class="guimenuitem"><strong>Character Map</strong></span> from the main menu bar. Next, choose <span class="guimenu"><strong>Search</strong></span> → <span class="guimenuitem"><strong>Find…</strong></span> from the <span class="application"><strong>Character Map</strong></span> menu bar, type the name of the character in the <span class="guilabel"><strong>Search</strong></span> field and click <span class="guibutton"><strong>Next</strong></span>. The character you sought will be highlighted in the <span class="guilabel"><strong>Character Table</strong></span>. Double-click this highlighted character to place it in the <span class="guilabel"><strong>Text to copy</strong></span> field and then click the <span class="guibutton"><strong>Copy</strong></span> button. Now switch back to your document and choose <span class="guimenu"><strong>Edit</strong></span> → <span class="guimenuitem"><strong>Paste</strong></span> from the <span class="application"><strong>gedit</strong></span> menu bar.
			</p></blockquote></div><p>
			The above text includes application names; system-wide menu names and items; application-specific menu names; and buttons and text found within a GUI interface, all presented in proportional bold and all distinguishable by context.
		</p><p>
			<code class="command"><em class="replaceable"><code>Mono-spaced Bold Italic</code></em></code> or <span class="application"><strong><em class="replaceable"><code>Proportional Bold Italic</code></em></strong></span>
		</p><p>
			Whether mono-spaced bold or proportional bold, the addition of italics indicates replaceable or variable text. Italics denotes text you do not input literally or displayed text that changes depending on circumstance. For example:
		</p><div class="blockquote"><blockquote class="blockquote"><p>
				To connect to a remote machine using ssh, type <code class="command">ssh <em class="replaceable"><code>username</code></em>@<em class="replaceable"><code>domain.name</code></em></code> at a shell prompt. If the remote machine is <code class="filename">example.com</code> and your username on that machine is john, type <code class="command">ssh john@example.com</code>.
			</p><p>
				The <code class="command">mount -o remount <em class="replaceable"><code>file-system</code></em></code> command remounts the named file system. For example, to remount the <code class="filename">/home</code> file system, the command is <code class="command">mount -o remount /home</code>.
			</p><p>
				To see the version of a currently installed package, use the <code class="command">rpm -q <em class="replaceable"><code>package</code></em></code> command. It will return a result as follows: <code class="command"><em class="replaceable"><code>package-version-release</code></em></code>.
			</p></blockquote></div><p>
			Note the words in bold italics above — username, domain.name, file-system, package, version and release. Each word is a placeholder, either for text you enter when issuing a command or for text displayed by the system.
		</p><p>
			Aside from standard usage for presenting the title of a work, italics denotes the first use of a new and important term. For example:
		</p><div class="blockquote"><blockquote class="blockquote"><p>
				Publican is a <em class="firstterm">DocBook</em> publishing system.
			</p></blockquote></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e310"/>1.2. Pull-quote Conventions</h3></div></div></div><p>
			Terminal output and source code listings are set off visually from the surrounding text.
		</p><p>
			Output sent to a terminal is set in <code class="computeroutput">mono-spaced roman</code> and presented thus:
		</p><pre class="screen">books        Desktop   documentation  drafts  mss    photos   stuff  svn
books_tests  Desktop1  downloads      images  notes  scripts  svgs</pre><p>
			Source-code listings are also set in <code class="computeroutput">mono-spaced roman</code> but add syntax highlighting as follows:
		</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">package</span><!-- <br/> --><span class="java_plain">&nbsp;org</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">jboss</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">book</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">jca</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">ex1</span><!-- <br/> --><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_keyword">import</span><span class="java_plain">&nbsp;javax</span><span class="java_separator">.</span><span class="java_plain">naming</span><span class="java_separator">.</span><span class="java_type">InitialContext</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">ExClient</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;main</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;args</span><span class="java_separator">[])</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">InitialContext</span><span class="java_plain">&nbsp;iniCtx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Object</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ref&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;iniCtx</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;EchoBean&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">EchoHome</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;home&nbsp;&nbsp;&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">EchoHome</span><span class="java_separator">)</span><span class="java_plain">&nbsp;ref</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Echo</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&nbsp;&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;home</span><span class="java_separator">.</span><span class="java_plain">create</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_literal">&quot;Created&nbsp;Echo&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">System</span><span class="java_separator">.</span><span class="java_plain">out</span><span class="java_separator">.</span><span class="java_plain">println</span><span class="java_separator">(</span><span class="java_literal">&quot;Echo.echo('Hello')&nbsp;=&nbsp;&quot;</span><span class="java_plain">&nbsp;</span><span class="java_operator">+</span><span class="java_plain">&nbsp;echo</span><span class="java_separator">.</span><span class="java_plain">echo</span><span class="java_separator">(</span><span class="java_literal">&quot;Hello&quot;</span><span class="java_separator">));</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_separator">}</span></pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e329"/>1.3. Notes and Warnings</h3></div></div></div><p>
			Finally, we use three visual styles to draw attention to information that might otherwise be overlooked.
		</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
				Notes are tips, shortcuts or alternative approaches to the task at hand. Ignoring a note should have no negative consequences, but you might miss out on a trick that makes your life easier.
			</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
				Important boxes detail things that are easily missed: configuration changes that only apply to the current session, or services that need restarting before an update will apply. Ignoring a box labeled 'Important' will not cause data loss but may cause irritation and frustration.
			</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>
				Warnings should not be ignored. Ignoring warnings will most likely cause data loss.
			</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e350"/>2. We Need Feedback!</h2></div></div></div><a id="d0e353" class="indexterm"/><p>
        Please feel free to raise any issues you find with this document in our
        <a class="ulink" href="https://issues.jboss.org/browse/JBTM">issue tracking system</a>
    </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e363"/>Chapter 1. Transactions Overview</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e415">1.1. What is a transaction?</a></span></dt><dt><span class="section"><a href="#d0e458">1.2. The Coordinator</a></span></dt><dt><span class="section"><a href="#d0e467">1.3. The Transaction Context</a></span></dt><dt><span class="section"><a href="#d0e496">1.4. Participants</a></span></dt><dt><span class="section"><a href="#d0e501">1.5. Commit protocol</a></span></dt><dt><span class="section"><a href="#d0e536">1.6. The Synchronization Protocol</a></span></dt><dt><span class="section"><a href="#d0e573">1.7. Optimizations to the Protocol</a></span></dt><dt><span class="section"><a href="#d0e636">1.8. Non-Atomic Transactions and Heuristic Outcomes</a></span></dt><dt><span class="section"><a href="#d0e724">1.9. Interposition</a></span></dt><dt><span class="section"><a href="#d0e783">1.10. A New Transaction Protocol</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e803">1.10.1. Addressing the Problems of Transactioning in Loosely Coupled Systems</a></span></dt></dl></dd></dl></div><a id="d0e366" class="indexterm"/><a id="d0e369" class="indexterm"/><a id="d0e374" class="indexterm"/><a id="d0e379" class="indexterm"/><a id="d0e384" class="indexterm"/><a id="d0e389" class="indexterm"/><a id="d0e394" class="indexterm"/><a id="d0e397" class="indexterm"/><a id="d0e402" class="indexterm"/><a id="d0e407" class="indexterm"/><a id="d0e410" class="indexterm"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e415"/>1.1. What is a transaction?</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                This chapter deals with the theory of transactional services. If you are familiar with these principles,
                consider this chapter a reference.
            </p></div><p>
            Consider the following situation: a user wishes to purchase access to an on-line newspaper and requires to pay for this
            access from an account maintained by an on-line bank. Once the newspaper site has received the user’s credit
            from the bank, they will deliver an electronic token to the user granting access to their site. Ideally the
            user would like the debiting of the account, and delivery of the token to be “all or nothing” (atomic).
            However, hardware and software failures could prevent either event from occurring, and leave the system in
            an indeterminate state.
        </p><div class="itemizedlist"><a id="tx-properties"/><ul><li><p>
                    Atomic transactions (transactions) possess an “all-or-nothing” property, and are a well-known technique for guaranteeing
                    application consistency in the presence of failures. Transactions possess the following ACID
                    properties:
                </p></li><li><p>
                    Atomicity: The transaction completes successfully (commits) or if it fails (aborts) all of its effects are undone (rolled
                    back).
                </p></li><li><p>
                    Consistency: Transactions produce consistent results and preserve application specific invariants.
                </p></li><li><p>
                    Isolation: Intermediate states produced while a transaction is executing are not visible to others. Furthermore transactions
                    appear to execute serially, even if they are actually executed concurrently.
                </p></li><li><p>
                    Durability: The effects of a committed transaction are never lost (except by a catastrophic failure).
                </p></li></ul></div><p>
            A transaction can be terminated in two ways: committed or aborted (rolled back). When a transaction is committed, all
            changes made within it are made durable (forced on to stable storage, e.g., disk). When a transaction is
            aborted, all of the changes are undone. Atomic actions can also be nested; the effects of a nested action
            are provisional upon the commit/abort of the outermost (top-level) atomic action.
        </p><p>
            Transactions have emerged as the dominant paradigm for coordinating interactions between parties in a (distributed) system, and
            in particular to manage applications that require concurrent access to shared data. A classic transaction is
            a unit of work that either completely succeeds, or fails with all partially completed work being undone.
            When a transaction is committed, all changes made by the associated requests are made durable, normally by
            committing the results of the work to a database. If a transaction should fail and is rolled back, all
            changes made by the associated work are undone. Transactions in distributed systems typically require the
            use of a transaction manager that is responsible for coordinating all of the participants that are part of
            the transaction.
        </p><div class="itemizedlist"><a id="tx-components"/><p class="title"><b>The main components involved in using and defining transactional applications are:</b></p><ul><li><p>
                    A Transaction Service: The Transaction Service captures the model of the underlying transaction protocol and
                    coordinates parties affiliated with the transaction according to that model.
                </p></li><li><p>
                    A Transaction API: Provides an interface for transaction demarcation and the registration of participants.
                </p></li><li><p>
                    A Participant: The entity that cooperates with the transaction service on behalf of its associated business logic.
                </p></li><li><p>
                    The Context: Captures the necessary details of the transaction such that participants can enlist within its scope.
                </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e458"/>1.2. The Coordinator</h2></div></div></div><p>Associated with every transaction is a coordinator, which is responsible for governing the outcome of the
            transaction. The coordinator may be implemented as a separate service or may be co-located with the user for
            improved performance. Each coordinator is created by the transaction manager service, which is in effect a
            factory for those coordinators.</p><p>A coordinator communicates with enrolled participants to inform them of the desired termination
            requirements, i.e., whether they should accept (e.g., confirm) or reject (e.g., cancel) the work done within
            the scope of the given transaction. For example, whether to purchase the (provisionally reserved) flight
            tickets for the user or to release them. An application/client may wish to terminate a transaction in a
            number of different ways (e.g., confirm or cancel). However, although the coordinator will attempt to
            terminate in a manner consistent with that desired by the client, it is ultimately the interactions between
            the coordinator and the participants that will determine the actual final outcome.</p><p>A transaction manager is typically responsible for managing coordinators for many transactions. The
            initiator of the transaction (e.g., the client) communicates with a transaction manager and asks it to start
            a new transaction and associate a coordinator with the transaction. Once created, the context can be
            propagated to Web services in order for them to associate their work with the transaction.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e467"/>1.3. The Transaction Context</h2></div></div></div><p>
            In order for a transaction to span a number of services, certain information has to be shared between those services in
            order to propagate information about the transaction. This information is known as the Context. The context
            is often automatically propagated and processed by transaction-aware components of an application:
        </p><div class="variablelist"><a id="context-contents"/><p class="title"><b>Contents of a Context</b></p><dl><dt><span class="term">Transaction Identifier</span></dt><dd><p>
                        Guarantees global uniqueness for an individual transaction.
                    </p></dd><dt><span class="term">Transaction Coordinator Location</span></dt><dd><p>
                        The endpoint address participants contact to enroll.
                    </p></dd></dl></div><div class="figure"><a id="d0e487"/><div class="figure-contents"><div class="mediaobject"><img src="images/transactions-overview-fig-web-services-context-flow.png" alt="Context Flow" longdesc="/home/gytis/workspace/narayana/documentation/product/target/docbook/publish/en-US/html_single/ld-d0e490.html"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="longdesc-link"><br/><span class="longdesc-link">[<a href="ld-d0e490.html">D</a>]</span></div></div></div><p class="title"><b>Figure 1.1. Context Flow</b></p></div><br class="figure-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e496"/>1.4. Participants</h2></div></div></div><p>
            The coordinator cannot know the details of how every transactional service is implemented; in fact it is not necessary
            for it to do so in order to negotiate a transactional outcome. It treats each service taking part in a
            transaction as a participant and communicates with it according to some predefined participant coordination
            models appropriate to the type of transaction. When a service begins performing work within the scope of a
            transaction it enrolls itself with the coordinator as a participant, specifying the participant model it
            wishes to follow. So, the term participant merely refers a transactional service enrolled in a specific
            transaction using a specific participant model.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e501"/>1.5. Commit protocol</h2></div></div></div><p>
            A two-phase commit protocol is required to guarantee that all of the action participants either commit or
            abort any changes made. See
            <a class="xref" href="#two-phase-commit-overview" title="Figure 1.2. Two-Phase Commit Overview">Figure 1.2, “Two-Phase Commit Overview”</a>
            which illustrates the main aspects of the commit protocol: during phase 1, the action coordinator, C,
            attempts to communicate with all of the action participants, A and B, to determine whether they will commit
            or abort. An abort reply from any participant acts as a veto, causing the entire action to abort. Based upon
            these (lack of) responses, the coordinator arrives at the decision of whether to commit or abort the action.
            If the action will commit, the coordinator records this decision on stable storage, and the protocol enters
            phase 2, where the coordinator forces the participants to carry out the decision. The coordinator also
            informs the participants if the action aborts.
        </p><p>When each participant receives the coordinator’s phase 1 message, they record sufficient information on
            stable storage to either commit or abort changes made during the action. After returning the phase 1
            response, each participant who returned a commit response must remain blocked until it has received the
            coordinator’s phase 2 message. Until they receive this message, these resources are unavailable for use by
            other actions. If the coordinator fails before delivery of this message, these resources remain blocked.
            However, if crashed machines eventually recover, crash recovery mechanisms can be employed to unblock the
            protocol and terminate the action.
        </p><div class="figure"><a id="two-phase-commit-overview"/><div class="figure-contents"><div class="mediaobject"><img src="images/transactions-overview-fig-two-phase-commit-overview.png" alt="Two-Phase Commit Overview" longdesc="/home/gytis/workspace/narayana/documentation/product/target/docbook/publish/en-US/html_single/ld-d0e513.html"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="longdesc-link"><br/><span class="longdesc-link">[<a href="ld-d0e513.html">D</a>]</span></div></div></div><p class="title"><b>Figure 1.2. Two-Phase Commit Overview</b></p></div><br class="figure-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                During two-phase commit transactions, coordinators and resources keep track of activity in non-volatile data stores so
                that they can recover in the case of a failure.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e536"/>1.6. The Synchronization Protocol</h2></div></div></div><p>
            Besides the two-phase commit protocol, traditional transaction processing systems employ an additional
            protocol,
            often referred to as the
            <em class="firstterm">synchronization protocol</em>
            . With the original ACID properties,
            Durability is important when state changes need to be available despite failures. Applications interact with a
            persistence store of some kind, such as a database, and this interaction can impose a significant overhead,
            because disk access is much slower to access than main computer memory.
        </p><p>
            One solution to the problem disk access time is to cache the state in main memory and only operate on the
            cache
            for the duration of a transaction. Unfortunately, this solution needs a way to flush the state back to the
            persistent store before the transaction terminates, or risk losing the full ACID properties. This is what the
            synchronization protocol does, with
            <em class="firstterm">Synchronization Participants</em>
            .
        </p><p>
            Synchronizations are informed that a transaction is about to commit. At that point, they can flush cached state,
            which might be used to improve performance of an application, to a durable representation prior to the transaction
            committing. The synchronizations are then informed about when the transaction completes and its completion
            state.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="procedure"><a id="d0e551"/><p class="title"><b>Procedure 1.1. The "Four Phase Protocol" Created By Synchronizations</b></p><p>
                Synchronizations essentially turn the two-phase commit protocol into a four-phase protocol:
            </p><ol class="1"><li><p class="title"><b>Step 1</b></p><p>
                    Before the transaction starts the two-phase commit, all registered Synchronizations are informed. Any failure at
                    this point will cause the transaction to roll back.
                </p></li><li><p class="title"><b>Steps 2 and 3</b></p><p>
                    The coordinator then conducts the normal two-phase commit protocol.
                </p></li><li><p class="title"><b>Step 4</b></p><p>
                    Once the transaction has terminated, all registered Synchronizations are informed. However, this is a courtesy
                    invocation because any failures at this stage are ignored: the transaction has terminated so there’s
                    nothing to
                    affect.
                </p></li></ol></div><p>
            The synchronization protocol does not have the same failure requirements as the traditional two-phase commit
            protocol. For example, Synchronization participants do not need the ability to recover in the event of failures,
            because any failure before the two-phase commit protocol completes cause the transaction to roll back, and
            failures after it completes have no effect on the data which the Synchronization participants are responsible for.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e573"/>1.7. Optimizations to the Protocol</h2></div></div></div><p>
            There are several variants to the standard two-phase commit protocol that are worth knowing about, because
            they
            can have an impact on performance and failure recovery.
            <a class="xref" href="#two-phase-variants" title="Table 1.1. Variants to the Two-Phase Commit Protocol">Table 1.1, “Variants to the Two-Phase Commit Protocol”</a>
            gives more
            information about each one.
        </p><div class="table"><a id="two-phase-variants"/><p class="title"><b>Table 1.1. Variants to the Two-Phase Commit Protocol</b></p><div class="table-contents"><table summary="Variants to the Two-Phase Commit Protocol" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                            <p>Variant</p>
                        </th><th>
                            <p>Description</p>
                        </th></tr></thead><tbody><tr><td>
                            <p>Presumed Abort</p>
                        </td><td>
                            <p>
                                If a transaction is going to roll back, the coordinator may record this information
                                locally and tell
                                all enlisted participants. Failure to contact a participant has no effect on the transaction outcome. The
                                coordinator is informing participants only as a courtesy. Once all participants have
                                been contacted, the
                                information about the transaction can be removed. If a subsequent request for the status of the transaction
                                occurs, no information will be available and the requester can assume that the transaction has aborted. This
                                optimization has the benefit that no information about participants need be made
                                persistent until the transaction
                                has progressed to the end of the
                                <code class="systemitem">prepare</code>
                                phase and decided to commit, since any failure
                                prior to this point is assumed to be an abort of the transaction.
                            </p>
                        </td></tr><tr><td>
                            <p>One-Phase</p>
                        </td><td>
                            <p>
                                If only a single participant is involved in the transaction, the coordinator does not
                                need to drive
                                it through the
                                <code class="systemitem">prepare</code>
                                phase. Thus, the participant is told to commit, and the
                                coordinator does not need to record information about the decision, since the outcome of the transaction is the
                                responsibility of the participant.
                            </p>
                        </td></tr><tr><td>
                            <p>Read-Only</p>
                        </td><td>
                            <p>When a participant is asked to prepare, it can indicate to the coordinator that no
                                information or
                                data that it controls has been modified during the transaction. Such a participant does not need to be informed
                                about the outcome of the transaction since the fate of the participant has no affect on
                                the
                                transaction. Therefore, a read-only participant can be omitted from the second phase of the commit
                                protocol.</p>
                        </td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e636"/>1.8. Non-Atomic Transactions and Heuristic Outcomes</h2></div></div></div><p>
            In order to guarantee atomicity, the two-phase commit protocol is
            <em class="firstterm">blocking</em>
            . As a result of
            failures, participants may remain blocked for an indefinite period of time, even if failure recovery mechanisms
            exist. Some applications and participants cannot tolerate this blocking.
        </p><p>
            To break this blocking nature, participants that are past the
            <code class="systemitem">prepare</code>
            phase are allowed
            to make autonomous decisions about whether to commit or rollback. Such a participant must record its decision, so
            that it can complete the original transaction if it eventually gets a request to do so. If the coordinator
            eventually informs the participant of the transaction outcome, and it is the same as the choice the participant
            made, no conflict exists. If the decisions of the participant and coordinator are different, the situation is
            referred to as a non-atomic outcome, and more specifically as a
            <em class="firstterm">heuristic outcome</em>
            .
        </p><p>
            Resolving and reporting heuristic outcomes to the application is usually the domain of complex, manually driven
            system administration tools, because attempting an automatic resolution requires semantic information about the
            nature of participants involved in the transactions.
        </p><p>
            Precisely when a participant makes a heuristic decision depends on the specific implementation. Likewise,
            the
            choice the participant makes about whether to commit or to roll back depends upon the implementation, and possibly
            the application and the environment in which it finds itself. The possible heuristic outcomes are discussed in
            <a class="xref" href="#tbl-heuristic-outcomes" title="Table 1.2. Heuristic Outcomes">Table 1.2, “Heuristic Outcomes”</a>
            .
        </p><div class="table"><a id="tbl-heuristic-outcomes"/><p class="title"><b>Table 1.2. Heuristic Outcomes</b></p><div class="table-contents"><table summary="Heuristic Outcomes" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                            <p>Outcome</p>
                        </th><th>
                            <p>Description</p>
                        </th></tr></thead><tbody><tr><td>
                            <p>Heuristic Rollback</p>
                        </td><td>
                            <p>The commit operation failed because some or all of the participants unilaterally
                                rolled back the
                                transaction.</p>
                        </td></tr><tr><td>
                            <p>Heuristic Commit</p>
                        </td><td>
                            <p>
                                An attempted rollback operation failed because all of the participants unilaterally
                                committed. One
                                situation where this might happen is if the coordinator is able to successfully
                                <code class="systemitem">prepare</code>
                                the transaction, but then decides to roll it back because its transaction log could not
                                be updated. While the
                                coordinator is making its decision, the participants decides to commit.
                            </p>
                        </td></tr><tr><td>
                            <p>Heuristic Mixed</p>
                        </td><td>
                            <p>Some participants commit ed, while others were rolled back.</p>
                        </td></tr><tr><td>
                            <p>Heuristic Hazard</p>
                        </td><td>
                            <p>The disposition of some of the updates is unknown. For those which are known, they
                                have either all
                                been committed or all rolled back.</p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><p>
            Heuristic decisions should be used with care and only in exceptional circumstances, since the decision may
            possibly differ from that determined by the transaction service. This type of difference can lead to a loss of
            integrity in the system. Try to avoid needing to perform resolution of heuristics, either by working with services
            and participants that do not cause heuristics, or by using a transaction service that provides assistance in the
            resolution process.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e724"/>1.9. Interposition</h2></div></div></div><p>
            <em class="firstterm">Interposition</em>
            is a scoping mechanism which allows coordination of a transaction to be
            delegated across a hierarchy of coordinators. See
            <a class="xref" href="#fig-interpositions" title="Figure 1.3. Interpositions">Figure 1.3, “Interpositions”</a>
            for a graphical
            representation of this concept.
        </p><div class="figure"><a id="fig-interpositions"/><div class="figure-contents"><div class="mediaobject"><img src="images/transactions-overview-fig-interpositions.png" alt="Interpositions" longdesc="/home/gytis/workspace/narayana/documentation/product/target/docbook/publish/en-US/html_single/ld-d0e737.html"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="longdesc-link"><br/><span class="longdesc-link">[<a href="ld-d0e737.html">D</a>]</span></div></div></div><p class="title"><b>Figure 1.3. Interpositions</b></p></div><br class="figure-break"/><p>
            Interposition is particularly useful for Web Services transactions, as a way of limiting the amount of
            network
            traffic required for coordination. For example, if communications between the top-level coordinator and a web
            service are slow because of network traffic or distance, the web service might benefit from executing in a
            subordinate transaction which employs a local coordinator service. In
            <a class="xref" href="#fig-interpositions" title="Figure 1.3. Interpositions">Figure 1.3, “Interpositions”</a>
            ,to
            <code class="systemitem">prepare</code>
            , the top-level coordinator only needs to send one
            <code class="systemitem">prepare</code>
            message to the subordinate coordinator, and receive one
            <code class="systemitem">prepared</code>
            or
            <code class="systemitem">aborted</code>
            reply. The subordinate coordinator forwards
            a
            <code class="systemitem">prepare</code>
            locally to each participant and combines the results to decide whether to send
            a single
            <code class="systemitem">prepared</code>
            or
            <code class="systemitem">aborted</code>
            reply.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e783"/>1.10. A New Transaction Protocol</h2></div></div></div><p>
            Many component technologies offer mechanisms for coordinating ACID transactions based on two-phase commit
            semantics. Some of these are CORBA/OTS, JTS/JTA, and MTS/MSDTC. ACID transactions are not suitable for all
            Web
            Services transactions, as explained in
            <a class="xref" href="#acid-not-suitable" title="Reasons ACID is Not Suitable for Web Services">Reasons ACID is Not Suitable for Web Services</a>
            .
        </p><div class="itemizedlist"><a id="acid-not-suitable"/><p class="title"><b>Reasons ACID is Not Suitable for Web Services</b></p><ul><li><p>
                    Classic ACID transactions assume that an organization that develops and deploys applications owns the entire
                    infrastructure for the applications. This infrastructure has traditionally taken the form of an
                    Intranet. Ownership
                    implies that transactions operate in a trusted and predictable manner. To assure ACIDity, potentially long-lived
                    locks can be kept on underlying data structures during two-phase commit. Resources can be used for any period of
                    time and released when the transaction is complete.
                </p><p>
                    In Web Services, these assumptions are no longer valid. One obvious reason is that the owners of data exposed
                    through a Web service refuse to allow their data to be locked for extended periods, since allowing such locks
                    invites denial-of-service attacks.
                </p></li><li><p>
                    All application infrastructures are generally owned by a single party. Systems using classical ACID transactions
                    normally assume that participants in a transaction will obey the directives of the transaction
                    manager and only
                    infrequently make unilateral decisions which harm other participants in a transaction.
                </p><p>
                    Web Services participating in a transaction can effectively decide to resign from the transaction at any time, and
                    the consumer of the service generally has little in the way of quality of service guarantees to prevent this.
                </p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e803"/>1.10.1. Addressing the Problems of Transactioning in Loosely Coupled Systems</h3></div></div></div><p>
                Though extended transaction models which relax the ACID properties have been proposed over the years, standards such as
                OASIS WS-TX provide a new transaction protocol to implement these concepts for the Web services
                architecture. The are designed to accommodate four underlying requirements inherent in any loosely
                coupled architecture like Web services:.
            </p><div class="itemizedlist"><a id="web-services-requirements"/><p class="title"><b>Requirements of Web Services</b></p><ul><li><p>
                        Ability to handle multiple successful outcomes to a transaction, and to involve operations whose effects may not
                        be isolated or durable.
                    </p></li><li><p>
                        Coordination of autonomous parties whose relationships are governed by contracts, rather than the dictates of a
                        central design authority.
                    </p></li><li><p>
                        Discontinuous service, where parties are expected to suffer outages during their lifetimes, and coordinated work
                        must be able to survive such outages.
                    </p></li><li><p>
                        Interoperation using XML over multiple communication protocols. XTS uses SOAP encoding carried over HTTP.
                    </p></li></ul></div></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e823"/>Chapter 2. Failure Recovery</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e826">2.1. Architecture of the Recovery Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e829">2.1.1. Crash Recovery Overview</a></span></dt><dt><span class="section"><a href="#d0e859">2.1.2. Recovery Manager</a></span></dt><dt><span class="section"><a href="#d0e998">2.1.3. Recovery Modules</a></span></dt><dt><span class="section"><a href="#d0e1030">2.1.4. A Recovery Module for XA Resources</a></span></dt><dt><span class="section"><a href="#d0e1093">2.1.5. Recovering XAConnections</a></span></dt><dt><span class="section"><a href="#d0e1134">2.1.6. Alternative to XAResourceRecovery</a></span></dt><dt><span class="section"><a href="#d0e1166">2.1.7. Shipped XAResourceRecovery implementations</a></span></dt><dt><span class="section"><a href="#d0e1204">2.1.8. TransactionStatusConnectionManager</a></span></dt><dt><span class="section"><a href="#d0e1211">2.1.9. Expired Scanner Thread</a></span></dt><dt><span class="section"><a href="#d0e1244">2.1.10. Application Process</a></span></dt><dt><span class="section"><a href="#d0e1253">2.1.11. TransactionStatusManager</a></span></dt><dt><span class="section"><a href="#d0e1265">2.1.12. Object Store</a></span></dt><dt><span class="section"><a href="#d0e1270">2.1.13. Socket free operation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1281">2.2. How Narayana manages the OTS Recovery Protocol
    </a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1284">2.2.1. Recovery Protocol in OTS - Overview</a></span></dt><dt><span class="section"><a href="#d0e1297">2.2.2. RecoveryCoordinator
            in Narayana
        </a></span></dt><dt><span class="section"><a href="#d0e1395">2.2.3. The default RecoveryCoordinator in JacOrb</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1423">2.3. Configuration Options</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1426">2.3.1. Recovery Protocol in OTS - Overview</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e826"/>2.1. Architecture of the Recovery Manager</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e829"/>2.1.1. Crash Recovery Overview</h3></div></div></div><p>The main architectural components within Crash Recovery are
            illustrated in the diagram below:
        </p><div class="figure"><a id="d0e834"/><div class="figure-contents"><div class="mediaobject"><img src="images/failure-recovery-fig1-crashrecoveryarchitecture.png" alt="Recovery Manager Architecture" longdesc="/home/gytis/workspace/narayana/documentation/product/target/docbook/publish/en-US/html_single/ld-d0e837.html"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="longdesc-link"><br/><span class="longdesc-link">[<a href="ld-d0e837.html">D</a>]</span></div></div></div><p class="title"><b>Figure 2.1. Recovery Manager Architecture</b></p></div><br class="figure-break"/><p>The Recovery Manager is a daemon process1 responsible for
            performing crash recovery. Only one Recovery Manager runs per
            node. The Object Store provides persistent data storage for
            transactions to log data. During normal transaction processing
            each transaction will log persistent data needed for the commit
            phase to the Object Store. On successfully committing a
            transaction this data is removed, however if the transaction fails
            then this data remains within the Object Store.
        </p><p>The Recovery Manager functions by:</p><div class="itemizedlist"><ul><li><p>Periodically scanning the Object Store for transactions
                    that may have failed. Failed transactions are indicated by the
                    presence of log data after a period of time that the
                    transaction would have normally been expected to finish.
                </p></li><li><p>Checking with the application process which originated the
                    transaction whether the transaction is still in progress or
                    not.
                </p></li><li><p>Recovering the transaction by re-activating the
                    transaction and then replaying phase two of the commit
                    protocol.
                </p></li></ul></div><p>
            The following sections describe the architectural components
            in more
            detail.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e859"/>2.1.2. Recovery Manager</h3></div></div></div><p>
            On initialization the Recovery Manager first loads in
            configuration information via a properties file. This
            configuration includes a number of recovery activators and
            recovery modules, which are then dynamically loaded.
        </p><p>
            The Recovery Manager is not specifically tied to an Object
            Request
            Broker or ORB. Hence, the OTS recovery protocol is not
            implicitly
            enabled. To enable such protocol, we use the concept of
            recovery
            activator, defined with the interface RecoveryActivator,
            which is
            used to instantiate a recovery class related to the
            underlying
            communication protocol. For instance, when used with
            OTS, the
            RecoveryActivitor has the responsibility to create a
            RecoveryCoordinator object able to respond to the
            replay_completion operation.
        </p><p>
            All RecoveryActivator instances inherit the same interface.
            They are
            loaded via the following recovery extension property:
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.recoveryActivators"&gt;
  list_of_class_names
&lt;entry&gt;</pre><p>
        </p><p>
            For instance the RecoveryActivator provided in the
            distribution of
            JTS/OTS, which shall not be commented, is as
            follow:
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.recoveryActivators"&gt;
      com.arjuna.ats.internal.jts.orbspecific.recovery.RecoveryEnablement
&lt;entry&gt;</pre><p>
        </p><p>
            When loaded all RecoveryActivator instances provide the method
            startRCservice invoked by the Recovery Manager and used to create
            the appropriate Recovery Component able to receive recovery
            requests according to a particular transaction protocol. For
            instance the RecoveryCoordinator defined by the OTS protocol.
        </p><p>
            Each recovery module is used to recover a different type of
            transaction/resource, however each recovery module inherits the
            same basic behavior.
        </p><p>
            Recovery consists of two separate passes/phases separated by
            two timeout
            periods. The first pass examines the object store for
            potentially
            failed transactions; the second pass performs crash
            recovery on
            failed transactions. The timeout between the first and
            second pass
            is known as the backoff period. The timeout between the
            end of the
            second pass and the start of the first pass is the
            recovery
            period. The recovery period is larger than the backoff
            period.
        </p><p>
            The Recovery Manager invokes the first pass upon each recovery
            module,
            applies the backoff period timeout, invokes the second pass
            upon
            each recovery module and finally applies the recovery period
            timeout before restarting the first pass again.
        </p><p>
            The recovery modules are loaded via the following recovery
            extension
            property:
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.recoveryExtenstions"&gt;
   list_of_class_names
&lt;entry&gt;</pre><p>
        </p><p>
            The backoff period and recovery period are set using the
            following
            properties:
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.recoveryBackoffPeriod"&gt;</pre><p>
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.periodicRecoveryPeriod"&gt;</pre><p>
        </p><p>
            The following java classes are used to implement the Recovery
            Manager:
        </p><div class="itemizedlist"><ul><li><p>package com.arjuna.ats.arjuna.recovery :</p><p>RecoveryManager – The daemon process that starts up by
                    instantiating an instance of the RecoveryManagerImple class.
                </p><p>RecoveryEnvironment - Properties used by the recovery
                    manager.
                </p><p>RecoveryConfiguration - Specifies the name of the Recovery
                    Manager property file.(ie RecoveryManager-properties.xml)
                </p></li><li><p>package com.arjuna.ats.internal.ts.arjuna.recovery :
                </p><p>RecoveryManagerImple - Creates and starts instances of the
                    RecActivatorLoader, the PeriodicRecovery thread and the
                    ExpiryEntryMonitor thread.
                </p><p>RecActivatorLoader - Dynamically loads in the
                    RecoveryActivator specified in the Recovery Manager property
                    file. Each RecoveryActicator is specified as a recovery
                    extension in the properties file
                </p><p>PeriodicRecovery - Thread which loads each recovery
                    module, then calls the first pass method for each module,
                    applies the backoff period timeout, calls the second pass
                    method for each module and applies the recovery period
                    timeout.
                </p><p>RecoveryClassLoader - Dynamically loads in the recovery
                    modules specified in the Recovery Manager property file. Each
                    module is specified as a recovery extension in the properties
                    file (e.g., com.arjuna.ats.arjuna.recovery.recoveryExtension1=
                    com.arjuna.ats.internal.ts.arjuna.recovery.AtomicActionRecoveryModule).
                </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>By default, the recovery manager listens on the first
                available port on a given machine. If you wish to control the
                port number that it uses, you can specify this using the
                com.arjuna.ats.arjuna.recovery.recoveryPort attribute.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e933"/>2.1.2.1. Managing recovery directly</h4></div></div></div><p>As already mentioned, recovery typically happens at periodic
                intervals. If you require to drive recovery directly, then there
                are two options, depending upon how the RecoveryManager has been
                created.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e938"/>2.1.2.2. Separate Recovery Manager</h4></div></div></div><p>You can either use the
                com.arjuna.ats.arjuna.tools.RecoveryMonitor program to send a
                message to the Recovery Manager instructing it to perform
                recovery, or you can create an instance of the
                com.arjuna.ats.arjuna.recovery.RecoveryDriver class to do
                likewise. There are two types of recovery scan available:
            </p><div class="itemizedlist"><ul><li><p>i. ASYNC_SCAN: here a message is sent to the
                        RecoveryManager to instruct it to perform recovery, but the
                        response returns before recovery has completed.
                    </p></li><li><p>ii. SYNC: here a message is sent to the RecoveryManager
                        to instruct it to perform recovery, and the response occurs
                        only when recovery has completed.
                    </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e950"/>2.1.2.3. In process Recovery Manager</h4></div></div></div><p>You can invoke the scan operation on the RecoveryManager.
                This operation returns only when recovery has completed.
                However, if you wish to have an asynchronous interaction
                pattern, then the RecoveryScan interface is provided:
            </p><div class="example"><a id="d0e955"/><p class="title"><b>Example 2.1. RecoveryScan interface</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">RecoveryScan</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;completed</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
</pre></div></div><br class="example-break"/><p>An instance of an object supporting this interface can be
                passed to the scan operation and its completed method will be
                called when recovery finishes. The scan operation returns
                immediately, however.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e962"/>2.1.2.4. Recovering For Multiple Transaction Coordinators</h4></div></div></div><p>Sometimes
                a single Recovery Manager can be made responsible
                for recovering transactions executing on behalf of multiple
                transaction coordinators. Conversely, due to specific
                configurations it may be that multiple Recovery Managers share
                the same Object Store and in which case should not conflict with
                each other, e.g., roll back transactions that they do not
                understand. Therefore, when running recovery it is necessary to
                tell Narayana
                which types of transactions it can recover and
                which transaction identifiers it should ignore.
            </p><p>When
                necessary each transaction identifier that Narayana
                creates may have a unique node identifier encoded within it and
        Narayana
                will only recover transactions and states that match a
                specified node identifier. The node identifier for each Narayana
                instance should be set via the
                com.arjuna.ats.arjuna.nodeIdentifier property. This value must
                be unique across Narayana
                instances. The contents of this should
                be alphanumeric and not exceed 10 bytes in length. If you do not
                provide a value, then Narayana
                will fabricate one and report the
                value via the logging infrastructure.
            </p><p>How this value is used will depend upon the type of
                resources being recovered and will be discussed within the
                relevant sections for the Recovery Modules.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e971"/>2.1.2.5. Recovery From An Alternate Node</h4></div></div></div><p>
                After failure it is sometimes desirable to recover on a different
                node from the one where the transaction manager failed. This kind of
                usage is only supported in JTA mode running inside an application server
                (with certain restrictions) and is not typical because of the consequences
                of incorrect configuration:
            </p><div class="itemizedlist"><ul><li>
                    Only JTA transactions will be recovered (so the failing node must be
                    configured in JTA mode).
                </li><li>
                    Changing versions of Narayana
                    or the application server on the new node
                    is not supported.
                </li><li>
                    The recovering node must have access to the same object store logs as
                    the failed node (which can be achieved by either copying the logs or by
                    using a shared file system or by using the JDBC object store connected
                    to a database that is accessible to both nodes). If you are using the JDBC
                    object store ensure that it is configured the same way on both nodes.
                </li><li>
                    Both nodes must have access to the same set of resource managers and with
                    the same configuration (minimally, the JNDI names must not change). Often the
                    deployment model for databases is to host the resource manager on a different
                    node from the application server so generally this should not be an issue.
                </li><li>
                    Recovery requires help from Resource Managers which should be configured to
                    support the ability to recover from other nodes. Database recovery is known
                    to work but other resource managers may require case by case consideration.
                </li><li>
                    If application deployments define their own datasources then these
                    applications must also be deployed on the new server.
                </li><li>
                    It is recommended that the transaction subsystem is configured in the
                    same way on the new node as it was on the failed one. In particular the
                    node identifier should not change. The comment made in the previous
                    section about the uniqueness of the node identifier still applies so
                    it is imperative that the failed node is not brought back online without
                    changing its configuration. The same restrictions regarding object stores
                    still apply, namely
                    “<span class="quote">exactly one recovery manager per ObjectStore must
                        run on each node and ObjectStores must not be shared by multiple nodes
                    </span>”
                    .
                </li><li>
                    Before restarting recovery on the new node sanity check your configuration
                    to ensure it does not contain any hard coded IP addresses that refer to
                    network interfaces on the failed node.
                </li></ul></div><p>
                This is a long list of caveats and if it is not possible to simply restart the
                failed node then, in order to avoid the consequences of incorrect configuration,
                we advise that the application server on the recovering node uses the same
                configuration file as the failed node.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e998"/>2.1.3. Recovery Modules</h3></div></div></div><p>As stated before each recovery module is used to recover a
            different type of transaction/resource, but each recovery module
            must implement the following RecoveryModule interface, which
            defines two methods: periodicWorkFirstPass and
            periodicWorkSecondPass invoked by the Recovery Manager.
        </p><div class="example"><a id="d0e1003"/><p class="title"><b>Example 2.2. RecoveryModule interface</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">RecoveryModule</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Called&nbsp;by&nbsp;the&nbsp;RecoveryManager&nbsp;at&nbsp;start&nbsp;up,&nbsp;and&nbsp;then</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;PERIODIC_RECOVERY_PERIOD&nbsp;seconds&nbsp;after&nbsp;the&nbsp;completion,&nbsp;for&nbsp;all</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;RecoveryModules&nbsp;of&nbsp;the&nbsp;second&nbsp;pass</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;periodicWorkFirstPass</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Called&nbsp;by&nbsp;the&nbsp;RecoveryManager&nbsp;RECOVERY_BACKOFF_PERIOD&nbsp;seconds&nbsp;after&nbsp;the</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;completion&nbsp;of&nbsp;the&nbsp;first&nbsp;pass</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;periodicWorkSecondPass</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;</span></pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1008"/>2.1.3.1. Narayana
                Recovery Module Classes
            </h4></div></div></div><p>Narayana
                provides a set of recovery modules that are
                responsible to manage recovery according to the nature of the
                participant and its position in a transactional tree. The
                provided classes (that all implements the RecoveryModule
                interface) are:
            </p><div class="itemizedlist"><ul><li><p>com.arjuna.ats.internal.arjuna.recovery.AtomicActionRecoveryModule
                    </p><p>Recovers AtomicAction transactions. </p></li><li><p>com.arjuna.ats.internal.jts.recovery.transactions.TransactionRecoveryModule
                    </p><p>Recovers JTS Transactions. This is a generic class from
                        which TopLevel and Server transaction recovery modules
                        inherit, respectively
                    </p></li><li><p>com.arjuna.ats.internal.jts.recovery.transactions.TopLevelTransactionRecoveryModule
                    </p></li><li><p>com.arjuna.ats.internal.jts.recovery.transactions.ServerTransactionRecoveryModule
                    </p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1030"/>2.1.4. A Recovery Module for XA Resources</h3></div></div></div><p>During recovery, the Transaction Manager needs to be able to
            communicate to all resource managers that are in use by the
            applications in the system. For each resource manager, the
            Transaction Manager uses the XAResource.recover method to retrieve
            the list of transactions that are currently in a prepared or
            heuristically completed state. Typically, the system administrator
            configures all transactional resource factories that are used by
            the applications deployed on the system. An example of such a
            resource factory is the JDBC XADataSource object, which is a
            factory for the JDBC XAConnection objects.
        </p><p>Because XAResource objects are not persistent across system
            failures, the Transaction Manager needs to have some way to
            acquire the XAResource objects that represent the resource
            managers which might have participated in the transactions prior
            to the system failure. For example, a Transaction Manager might,
            through the use of JNDI lookup mechanism, acquire a connection
            from each of the transactional resource factories, and then obtain
            the corresponding XAResource object for each connection. The
            Transaction Manager then invokes the XAResource.recover method to
            ask each resource manager to return the transactions that are
            currently in a prepared or heuristically completed state.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>When
                running XA recovery it is necessary to tell Narayana
                which types of Xid it can recover. Each Xid that Narayana
                creates
                has a unique node identifier encoded within it and Narayana
                will
                only recover transactions and states that match a specified node
                identifier. The node identifier to use should be provided to
        Narayana
                via the property JTAEnvironmentBean.xaRecoveryNodes;
                multiple values may be provided in a list. A value of ‘*’ will
                force Narayana
                to recover (and possibly rollback) all
                transactions irrespective of their node identifier and should be
                used with caution. The contents of
                com.arjuna.ats.jta.xaRecoveryNode should be alphanumeric and
                match the values of com.arjuna.ats.arjuna.nodeIdentifier.
            </p></div><p>One of the following recovery mechanisms will be used:</p><div class="itemizedlist"><ul><li><p>If the XAResource is serializable, then the serialized
                    form will be saved during transaction commitment, and used
                    during recovery. It is assumed that the recreated XAResource
                    is valid and can be used to drive recovery on the associated
                    database.
                </p></li><li><p>The com.arjuna.ats.jta.recovery.XAResourceRecovery,
                    com.arjuna.ats.jta.recovery.XARecoveryResourceManager and
                    com.arjuna.ats.jta.recovery.XARecoveryResource interfaces are
                    used. These are described in detail later in this document.
                </p></li></ul></div><p>To manage recovery, we have seen in the previous chapter that
            the Recovery Manager triggers a recovery process by calling a set
            of recovery modules that implements the two methods defined by the
            RecoveryModule interface. To enable recovery of participants
            controlled via the XA interface, a specific recovery module named
            XARecoveryModule is provided. The XARecoveryModule, defined in the
            packages com.arjuna.ats.internal.jta.recovery.arjunacore and
            com.arjuna.ats.internal.jta.recovery.jts, handles recovery of XA
            resources (databases etc.) used in JTA.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Narayana
                supports two JTA implementations: a purely local
                version (no distributed transactions) and a version layered on
                the JTS. Recovery for the former is straightforward. In the
                following discussion we shall implicitly consider on the JTS
                implementation.
            </p></div><p>Its behavior consists of two aspects: “transaction-initiated”
            and “resource-initiated” recovery. Transaction-initiated recovery
            is possible where the particular transaction branch had progressed
            far enough for a JTA Resource Record to be written in the
            ObjectStore.
        </p><p>A
            JTA Resource record contains the information needed to link
            the transaction, as known to the rest of Narayana,
            to the database.
            Resource-initiated recovery is necessary for branches where a
            failure occurred after the database had made a persistent record
            of the transaction, but before the JTA ResourceRecord was
            persisted. Resource-initiated recovery is also necessary for
            datasources for which it is not possible to hold information in
            the JTA Resource record that allows the recreation in the
            RecoveryManager of the XAConnection/XAResource that was used in
            the original application.
        </p><p>Transaction-initiated recovery is automatic. The
            XARecoveryModule finds the JTA Resource Record that need recovery,
            then uses the normal recovery mechanisms to find the status of the
            transaction it was involved in (i.e., it calls replay_completion
            on the RecoveryCoordinator for the transaction branch),
            (re)creates the appropriate XAResource and issues commit or
            rollback on it as appropriate. The XAResource creation will use
            the same information, database name, username, password etc., as
            the original application.
        </p><p>Resource-initiated
            recovery has to be specifically configured,
            by supplying the Recovery Manager with the appropriate information
            for it to interrogate all the databases (XADataSources) that have
            been accessed by any Narayana
            application. The access to each
            XADataSource is handled by a class that implements the
            com.arjuna.ats.jta.recovery.XAResourceRecovery interface, as
            illustrated in Figure 4. Instances of classes that implements the
            XAResourceRecovery interface are dynamically loaded, as controlled
            by properties with names beginning
            “com.arjuna.ats.jta.recovery.XAResourceRecovery”.
        </p><div class="figure"><a id="d0e1062"/><div class="figure-contents"><div class="mediaobject"><img src="images/failure-recovery-fig2-resourceinitiatedrecovery.png" alt="Resource-initiated recovery and XA Recovery" longdesc="/home/gytis/workspace/narayana/documentation/product/target/docbook/publish/en-US/html_single/ld-d0e1065.html"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="longdesc-link"><br/><span class="longdesc-link">[<a href="ld-d0e1065.html">D</a>]</span></div></div></div><p class="title"><b>Figure 2.2. Resource-initiated recovery and XA Recovery</b></p></div><br class="figure-break"/><p>The XARecoveryModule will use the XAResourceRecovery
            implementation to get a XAResource to the target datasource. On
            each invocation of periodicWorkSecondPass, the recovery module
            will issue an XAResource.recover request – this will (as described
            in the XA specification) return a list of the transaction
            identifiers (Xid’s) that are known to the datasource and are in an
            indeterminate (in-doubt) state. The list of these in-doubt Xid’s
            received on successive passes (i.e. periodicWorkSecondPass-es) is
            compared. Any Xid that appears in both lists, and for which no JTA
            ResourceRecord was found by the intervening transaction-initiated
            recovery is assumed to belong to a transaction that was involved
            in a crash before any JTA ResourceRecord was written, and a
            rollback is issued for that transaction on the XAResource.
        </p><p>This double-scan mechanism is used because it is possible the
            Xid was obtained from the datasource just as the original
            application process was about to create the corresponding
            JTA_ResourceRecord. The interval between the scans should allow
            time for the record to be written unless the application crashes
            (and if it does, rollback is the right answer).
        </p><p>An XAResourceRecovery implementation class can be written to
            contain all the information needed to perform recovery to some
            datasource. Alternatively, a single class can handle multiple
            datasources. The constructor of the implementation class must have
            an empty parameter list (because it is loaded dynamically), but
            the interface includes an initialise method which passes in
            further information as a string. The content of the string is
            taken from the property value that provides the class name:
            everything after the first semi-colon is passed as the value of
            the string. The use made of this string is determined by the
            XAResourceRecovery implementation class.
        </p><p>For further details on the way to implement a class that
            implements the interface XAResourceRecovery, read the JDBC chapter
            of the JTA Programming Guide. An implementation class is provided
            that supports resource-initiated recovery for any XADataSource.
            This class could be used as a template to build your own
            implementation class.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1079"/>2.1.4.1. Assumed complete</h4></div></div></div><p>If a failure occurs in the transaction environment after the
                transaction coordinator had told the XAResource to commit but
                before the transaction log has been updated to remove the
                participant, then recovery will attempt to replay the commit. In
                the case of a Serialized XAResource, the response from the
                XAResource will enable the participant to be removed from the
                log, which will eventually be deleted when all participants have
                been committed. However, if the XAResource is not recoverable
                then it is extremely unlikely that any XAResourceRecovery
                instance will be able to provide the recovery sub-system with a
                fresh XAResource to use in order to attempt recovery; in which
                case recovery will continually fail and the log entry will never
                be removed.
            </p><p>There are two possible solutions to this problem:</p><div class="itemizedlist"><ul><li><p>Rely on the relevant ExpiryScanner to eventually move
                        the log elsewhere. Manual intervention will then be needed
                        to ensure the log can be safely deleted. If a log entry is
                        moved, suitable warning messages will be output.
                    </p></li><li><p>Set the com.arjuna.ats.jta.xaAssumeRecoveryComplete to
                        true. This option is checked whenever a new XAResource
                        instance cannot be located from any registered
                        XAResourceRecovery instance. If false (the default),
                        recovery assumes that there is a transient problem with the
                        XAResourceRecovery instances (e.g., not all have been
                        registered with the sub-system) and will attempt recovery
                        periodically. If true then recovery assumes that a previous
                        commit attempt succeeded and this instance can be removed
                        from the log with no further recovery attempts. This option
                        is global, so needs to be used with care since if used
                        incorrectly XAResource instances may remain in an
                        uncommitted state.
                    </p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1093"/>2.1.5. Recovering XAConnections</h3></div></div></div><p>When
            recovering from failures, Narayana
            requires the ability to
            reconnect to databases that were in use prior to the failures in
            order to resolve any outstanding transactions. Most connection
            information will be saved by the transaction service during its
            normal execution, and can be used during recovery to recreate the
            connection. However, it is possible that not all such information
            will have been saved prior to a failure (for example, a failure
            occurs before such information can be saved, but after the
            database connection is used). In order to recreate those
            connections it is necessary to provide implementations of the
            following Narayana
            interface
            com.arjuna.ats.jta.recovery.XAResourceRecovery, one for each
            database that may be used by an application.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>if
                using the transactional JDBC driver provided with
        Narayana,
                then no additional work is necessary in order to ensure
                that recovery occurs.
            </p></div><p>To inform the recovery system about each of the
            XAResourceRecovery instances, it is necessary to specify their
            class names through the
            JTAEnvironmentBean.xaResourceRecoveryInstances property variable,
            whose values is a list of space separated strings, each being a
            classname followed by optional configuration information.
        </p><p>JTAEnvironmentBean.xaResourceRecoveryInstances=com.foo.barRecovery
        </p><p>Additional information that will be passed to the instance
            when it is created may be specified after a semicolon:
        </p><p>JTAEnvironmentBean.xaResourceRecoveryInstances=com.foo.barRecovery;myData=hello
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>These properties need to go into the JTA section of the
                property file.
            </p></div><p>Any errors will be reported during recovery.</p><div class="example"><a id="d0e1114"/><p class="title"><b>Example 2.3. XAResourceRecovery interface</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">XAResourceRecovery</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">XAResource</span><span class="java_plain">&nbsp;getXAResource</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">SQLException</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;initialise</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;p</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;hasMoreResources</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">};</span></pre></div></div><br class="example-break"/><p>Each method should return the following information:</p><div class="itemizedlist"><ul><li><p>initialise: once the instance has been created, any
                    additional information which occurred on the property value
                    (anything found after the first semi-colon) will be passed to
                    the object. The object can then use this information in an
                    implementation specific manner to initialise itself, for
                    example.
                </p></li><li><p>hasMoreResources: each XAResourceRecovery implementation
                    may provide multiple XAResource instances. Before any call to
                    getXAResource is made, hasMoreResources is called to determine
                    whether there are any further connections to be obtained. If
                    this returns false, getXAResource will not be called again
                    during this recovery sweep and the instance will not be used
                    further until the next recovery scan. It is up to the
                    implementation to maintain the internal state backing this
                    method and to reset the iteration as required. Failure to do
                    so will mean that the second and subsequent recovery sweeps in
                    the lifetime of the JVM do not attempt recovery.
                </p></li><li><p>
                    getXAResource: returns an instance of the XAResource
                    object. How this is created
                    (and how the parameters to its
                    constructors are obtained) is
                    up to the XAResourceRecovery
                    implementation. The parameters to
                    the constructors of this
                    class should be similar to those used
                    when creating the initial
                    driver or data source, and should
                    obviously be sufficient to
                    create new XAResources that can be
                    used to drive recovery.
                </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If you want your XAResourceRecovery instance to be called
                during each sweep of the recovery manager then you should ensure
                that once hasMoreResources returns false to indicate the end of
                work for the current scan it then returns true for the next
                recovery scan.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1134"/>2.1.6. Alternative to XAResourceRecovery</h3></div></div></div><p>The iterator based approach used by XAResourceRecovery leads
            to a requirement for implementations to manage state, which makes
            them more complex than necessary.
        </p><p>As
            an alternative, starting with Narayana
            4.4, users may
            provide an implementation of the public interface
        </p><div class="example"><a id="d0e1141"/><p class="title"><b>Example 2.4. XAResourceRecoveryHelper</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;com</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">arjuna</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">ats</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">jta</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">recovery</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_type">XAResourceRecoveryHelper</span><!-- <br/> --><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;initialise</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;p</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">XAResource</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;getXAResources</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>During each recovery sweep the getXAResources method will be
            called and recovery attempted on each element of the array. For
            the majority of resource managers it will be necessary to have
            only one XAResource in the array, as the recover() call on it can
            return multiple Xids.
        </p><p>Unlike
            XAResourceRecovery instances, which are configured via
            the xml properties file and instantiated by Narayana,
            instances of
            XAResourceRecoveryHelper and constructed by the application code
            and registered with Narayana
            by calling
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA">&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_type"&gt;XARecoveryModule&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_separator"&gt;.&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_plain"&gt;addXAResourceRecoveryHelper&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_separator"&gt;(...)&lt;/span&gt;</pre><p>
        </p><p>The
            initialize method is not called by Narayana
            in the current
            implementation, but is provided to allow for the addition of
            further configuration options in later releases.
        </p><p>XAResourceRecoveryHelper instances may be deregistered, after
            which they will no longer be called by the recovery manager.
            Deregistration may block for a time if a recovery scan is in
            progress.
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA">&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_type"&gt;XARecoveryModule&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_separator"&gt;.&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_plain"&gt;removeXAResourceRecoveryHelper&lt;/span&gt;&lt;!-- &lt;br/&gt; --&gt;&lt;span class="java_separator"&gt;(...)&lt;/span&gt;</pre><p>
        </p><p>The ability to dynamically add and remove instances of
            XAResourceRecoveryHelper whilst the system is running makes this
            approach an attractive option for environments in which e.g.
            datasources may be deployed or undeployed, such as application
            servers. Care should be taken with classloading behaviour in such
            cases.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1166"/>2.1.7. Shipped XAResourceRecovery implementations</h3></div></div></div><p>Recovery
            of XA datasources can sometimes be implementation
            dependant, requiring developers to provide their own
            XAResourceRecovery instances. However, Narayana
            ships with several
            out-of-the-box implementations that may be useful.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>These
                XAResourceRecovery instances are primarily intended
                for when running Narayana
                outside of a container such as WildFly Application Server,
                since they rely upon XADataSources as the primary handle to
                drive recovery. If you are not running Narayana
                stand-alone then
                you should consult the relevant integration documentation to
                ensure that the right recovery modules are being used.
            </p></div><div class="itemizedlist"><ul><li><p>
                    </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">com.arjuna.ats.internal.jdbc.recovery.BasicXARecovery</pre><p>
                    : this expects an XML property file to be specified upon
                    creation
                    and from which it will read the configuration
                    properties for the
                    datasource. For example:
                </p><div class="example"><a id="d0e1181"/><p class="title"><b>Example 2.5. XML datasource</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">DOCTYPE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">properties</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">SYSTEM</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_value">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span><span class="xml_tag_symbols">&gt;&lt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&lt;</span><span class="xml_attribute_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">entry</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DB_X_DatabaseUser&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">username</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">entry</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">entry</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DB_X_DatabasePassword&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">password&quot;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">entry</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">entry</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DB_X_DatabaseDynamicClass&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">DynamicClass</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">entry</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">entry</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DB_X_DatabaseURL&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">theURL</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">entry</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/></li><li><p>
                    </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">com.arjuna.ats.internal.jdbc.recovery.JDBCXARecovery</pre><p>
                    : this recovery implementation should work on any datasource
                    that is exposed via JNDI. It expects an XML property file to
                    be specified upon creation and from which it will read the
                    database JNDI name, username and password. For example:
                </p><div class="example"><a id="d0e1192"/><p class="title"><b>Example 2.6. JNDI datasource</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">DOCTYPE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">properties</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">SYSTEM</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_value">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span><span class="xml_tag_symbols">&gt;&lt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&lt;</span><span class="xml_attribute_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">entry</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DatabaseJNDIName&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">java:ExampleDS</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">entry</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">entry</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;UserName&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">username</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">entry</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">entry</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Password&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">password</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">entry</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/></li></ul></div><p>Because
            these classes are XAResourceRecovery instances they
            are passed any necessary initialization information via the
            initialise operation. In the case of BasicXARecovery and
            JDBCXARecovery this should be the location of a property file
            and
            is specified in the Narayana
            configuration file. For example:
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">com.arjuna.ats.jta.recovery.XAResourceRecoveryJDBC=com.arjuna.ats.internal.jdbc.recovery.JDBCXAResourceRecovery;thePropertyFile</pre><p>
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1204"/>2.1.8. TransactionStatusConnectionManager</h3></div></div></div><p>The TransactionStatusConnectionManager object is used by the
            recovery modules to retrieve the status of transactions and acts
            like a proxy for TransactionStatusManager objects. It maintains a
            table of TransactionStatusConnector obects each of which connects
            to a TransactionStatusManager object in an Application Process.
        </p><p>The transactions status is retrieved using the
            getTransactionStatus methods which take a transaction Uid and if
            available a transaction type as parameters. The process Uid field
            in the transactions Uid parameter is used to lookup the target
            TransactionStatusManagerItem host/port pair in the Object Store.
            The host/port pair are used to make a TCP connection to the target
            TransactionStatusManager object by a TransactionStatusConnector
            object. The TransactionStatusConnector passes the transaction
            Uid/transaction type to the TransactionStatusManager in order to
            retrieve the transactions status.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1211"/>2.1.9. Expired Scanner Thread</h3></div></div></div><p>When the Recovery Manager initialises an expiry scanner thread
            ExpiryEntryMonitor is created which is used to remove long dead
            items from the ObjectStore. A number of scanner modules are
            dynamically loaded which remove long dead items for a particular
            type.
        </p><p>Scanner modules are loaded at initialisation and are specified
            as properties beginning with
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.expiryScanners"&gt; 
  list of class names
&lt;/entry&gt;</pre><p>
        </p><p>All the scanner modules are called periodically to scan for
            dead items by the ExpiryEntryMonitor thread. This period is set
            with the property:
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.expiryScanInterval"&gt; 
  number_of_hours
&lt;/entry&gt;</pre><p>
        </p><p>All scanners inherit the same behaviour from the java
            interface ExpiryScanner. A scan method is provided by this
            interface and implemented by all scanner modules, this is the
            method that gets called by the scanner thread.
        </p><p>The ExpiredTransactionStatusManagerScanner removes long dead
            TransactionStatusManagerItems from the Object Store. These items
            will remain in the Object Store for a period of time before they
            are deleted. This time is set by the property:
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.transactionStatusManagerExpiryTime"&gt; 
  number_of_hours
&lt;/entry&gt; (default 12 hours)</pre><p>
        </p><p>The
            AtomicActionExpiryScanner moves transaction logs for
            AtomicActions that are assumed to have completed. For instance, if
            a failure occurs after a participant has been told to commit but
            before the transaction system can update the log, then upon
            recovery Narayana
            recovery will attempt to replay the commit
            request, which will obviously fail, thus preventing the log from
            being removed. This is also used when logs cannot be recovered
            automatically for other reasons, such as being corrupt or zero
            length. All logs are moved to a location based on the old location
            appended with /Expired.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>AtomicActionExpiryScanner
                is disabled by default. To enable
                it simply add it to the Narayana
                properties file. You do not need
                to enable it in order to cope with (move) corrupt logs.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1244"/>2.1.10. Application Process</h3></div></div></div><p>This represents the user transactional program. A Local
            transaction (hash) table, maintained within the running
            application process keeps trace of the current status of all
            transactions created by that application process, The Recovery
            Manager needs access to the transaction tables so that it can
            determine whether a transaction is still in progress, if so then
            recovery does not happen.
        </p><p>The transaction tables are accessed via the
            TransactionStatusManager object. On application program
            initialisation the host/port pair that represents the
            TransactionStatusManager is written to the Object Store in
            ‘../Recovery/TransactionStatusManager’ part of the Object Store
            file hierarchy and identified by the process Uid of the
            application process.
        </p><p>The Recovery Manager uses the
            TransactionStatusConnectionManager object to retrieve the status
            of a transaction and a TransactionStatusConnector object is used
            to make a TCP connection to the TransactionStatusManager.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1253"/>2.1.11. TransactionStatusManager</h3></div></div></div><p>This
            object acts as an interface for the Recovery Manager to
            obtain the status of transactions from running Narayana
            application
            processes. One TransactionStatusManager is created per application
            process by the class com.arjuna.ats.arjuna.coordinator.TxControl.
            Currently a tcp connection is used for communication between the
            RecoveryManager and TransactionStatusManager. Any free port is
            used by the TransactionStatusManager by default, however the port
            can be fixed with the property:
        </p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;entry key="RecoveryEnvironmentBean.transactionStatusManagerPort"&gt; 
  port
&lt;/entry&gt;</pre><p>
        </p><p>On creation the TransactionStatusManager obtains a port which
            it stores with the host in the Object Store as a
            TransactionStatusManagerItem. A Listener thread is started which
            waits for a connection request from a TransactionStatusConnector.
            When a connection is established a Connection thread is created
            which runs a Service (AtomicActionStatusService) which accepts a
            transaction Uid and a transaction type (if available) from a
            TransactionStatusConnector, the transaction status is obtained
            from the local thransaction table and returned back to the
            TransactionStatusConnector
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1265"/>2.1.12. Object Store</h3></div></div></div><p>All objects are identified by a unique identifier Uid. One of
            the values of which is a process id in which the object was
            created. The Recovery Manager uses the process id to locate
            transaction status manager items when contacting the originator
            application process for the transaction status. Therefore, exactly
            one recovery manager per ObjectStore must run on each node and
            ObjectStores must not be shared by multiple nodes.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1270"/>2.1.13. Socket free operation</h3></div></div></div><p>The use of TCP/IP sockets for TransactionStatusManager and
            RecoveryManager provides for maximum flexibility in the deployment
            architecture. It is often desirable to run the RecoveryManager in
            a separate JVM from the Transaction manager(s) for increased
            reliability. In such deployments, TCP/IP provides for
            communication between the RecoveryManager and transaction
            manager(s), as detailed in the preceding sections. Specifically,
            each JVM hosting a TransactionManager will run a
            TransactionStatusManager listener, through which the
            RecoveryManager can contact it to determine if a transaction is
            still live or not. The RecoveryManager likewise listens on a
            socket, through which it can be contacted to perform recovery
            scans on demand. The presence of a recovery listener is also used
            as a safety check when starting a RecoveryManager, since at most
            one should be running for a given ObjectStore.
        </p><p>There are some deployment scenarios in which there is only a
            single TransactionManager accessing the ObjectStore and the
            RecoveryManager is co-located in the same JVM. For such cases the
            use of TCP/IP sockets for communication introduces unnecessary
            runtime overhead. Additionally, if several such distinct processes
            are needed for e.g. replication or clustering, management of the
            TCP/IP port allocation can become unwieldy. Therefore it may be
            desirable to configure for socketless recovery operation.
        </p><p>The property
            CoordinatorEnvironmentBean.transactionStatusManagerEnable can be
            set to a value of NO to disable the TransactionStatusManager for
            any given TransactionManager. Note that this must not be done if
            recovery runs in a separate process, as it may lead to incorrect
            recovery behavior in such cases. For an in-process recovery
            manager, the system will use direct access to the
            ActionStatusService instead.
        </p><p>The property RecoveryEnvironmentBean.recoveryListener can
            likewise be used to disable the TCP/IP socket listener used by the
            recovery manager. Care must be taken not to inadvertently start
            multiple recovery managers for the same ObjectStore, as this
            error, which may lead to significant crash recovery problems,
            cannot be automatically detected and prevented without the benefit
            of the socket listener.
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1281"/>2.2. How Narayana manages the OTS Recovery Protocol
    </h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1284"/>2.2.1. Recovery Protocol in OTS - Overview</h3></div></div></div><p>To manage recovery in case of failure, the OTS specification has defined a recovery protocol.
            Transaction’s participants in a doubt status
            could use the RecoveryCoordinator to determine the status of the transaction. According to that transaction status, those
            participants can take
            appropriate decision either by roll backing or committing.</p><div class="figure"><a id="d0e1289"/><div class="figure-contents"><div class="mediaobject"><img src="images/failure-recovery-fig3-resource-recoverycoordinator.png" alt="Resource and RecoveryCoordinator relationship"/></div></div><p class="title"><b>Figure 2.3. Resource and RecoveryCoordinator relationship</b></p></div><br class="figure-break"/><p>A reference to a RecoveryCoordinator is returned as a result of successfully calling register_resource on
            the transaction Coordinator. This
            object, which is implicitly associated with a single Resource, can be used to drive the Resource through recovery procedures
            in the event of a
            failure occurring during the transaction.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1297"/>2.2.2. RecoveryCoordinator
            in Narayana
        </h3></div></div></div><p>On
            each resource registration a RecoveryCoordinator Object is expected to be created and returned to the
            application that invoked the
            register_resource operation. Behind each CORBA object there should be an object implementation or Servant object, in POA terms, which
            performs
            operations made on a RecoveryCoordinator object. Rather than to create a RecoveryCoordinator object with its associated servant
            on each
            register_resource, Narayana
            enhances performance by avoiding the creation of servants but it relies on a default RecoveryCoordinator
            object with
            it’s associated default servant to manage all replay_completion invocations.
        </p><p>In the next sections we first give an overview of the Portable Object Adapter architecture, then we
            describe how this architecture is used
            to provide RecoveryCoordinator creation with optimization as explained above.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1304"/>2.2.2.1. Understanding POA</h4></div></div></div><p>Basically, the Portable Object Adapter, or POA is an object that intercepts a client request and
                identifies the object that satisfies the
                client request. The Object is then invoked and the response is returned to the client.</p><div class="figure"><a id="d0e1309"/><div class="figure-contents"><div class="mediaobject"><img src="images/failure-recovery-fig4-overview-of-poa.png" alt="Overview of the POA"/></div></div><p class="title"><b>Figure 2.4. Overview of the POA</b></p></div><br class="figure-break"/><p>The object that performs the client request is referred as a servant, which provides the
                implementation of the CORBA object requested by
                the client. A servant provides the implementation for one or more CORBA object references. To retreive a servant, each
                POA maintains an Active
                Object Map that maps all objects that have been activated in the POA to a servant. For each incoming request, the POA
                looks up the object
                reference in the Active Object Map and tries to find the responsible servant. If none is found, the request is either
                delegated to a default
                servant, or a servant manager is invoked to activate or locate an appropriate servant. In addition to the name space for the
                objects, which
                are identified by Object Ids, a POA also provides a name space for POAs. A POA is created as a child of an existing
                POA, which forms a
                hierarchy starting with the root POA.</p><p>Each POA has a set of policies that define its characteristics. When creating a new POA, the default
                set of policies can be used or
                different values can be assigned that suit the application requirements. The POA specification defines:</p><div class="itemizedlist"><ul><li><p>Thread policy – Specifies the threading model to be used by the POA. Possible values are:</p><div class="itemizedlist"><ul><li><p>ORB_CTRL_MODEL – (default) The POA is responsible for assigning requests to threads.</p></li><li><p>SINGLE_THREAD_MODEL – the POA processes requests sequentially</p></li></ul></div></li><li><p>Lifespan policy - specifies the lifespan of the objects implemented in the POA. The lifespan
                        policy can have the following values:</p><div class="itemizedlist"><ul><li><p>
                                TRANSIENT (Default) Objects implemented in the POA cannot outlive the process in which they are first created. Once the
                                POA is
                                deactivated, an
                                OBJECT_NOT_EXIST exception occurs when attempting to use any object references generated by the POA.
                            </p></li><li><p>
                                PERSISTENT Objects implemented in the POA can outlive the process in which they are first created.
                            </p></li></ul></div></li><li><p>
                        Object ID Uniqueness policy - allows a single servant to be shared by many abstract objects. The Object ID Uniqueness
                        policy can have
                        the following
                        values:</p><div class="itemizedlist"><ul><li><p>
                                UNIQUE_ID (Default) Activated servants support only one Object ID.
                            </p></li><li><p>
                                MULTIPLE_ID Activated servants can have one or more Object IDs. The Object ID must be determined within the method being
                                invoked
                                at run time.
                            </p></li></ul></div></li><li><p>
                        ID Assignment policy - specifies whether object IDs are generated by server applications or by the POA. The ID
                        Assignment policy can
                        have the
                        following values:</p><div class="itemizedlist"><ul><li><p>
                                USER_ID is for persistent objects, and
                            </p></li><li><p>
                                SYSTEM_ID is for transient objects
                            </p></li></ul></div></li><li><p>
                        Servant Retention policy - specifies whether the POA retains active servants in the Active Object Map. The Servant
                        Retention policy
                        can have the
                        following values:
                    </p><div class="itemizedlist"><ul><li><p>
                                RETAIN (Default) The POA tracks object activations in the Active Object Map. RETAIN is usually used with
                                ServantActivators or
                                explicit activation
                                methods on POA.
                            </p></li><li><p>
                                NON_RETAIN The POA does not retain active servants in the Active Object Map. NON_RETAIN is typically used with
                                ServantLocators.
                            </p></li></ul></div></li><li><p>
                        Request Processing policy - specifies how requests are processed by the POA.
                    </p><div class="itemizedlist"><ul><li><p>
                                USE_ACTIVE_OBJECT_MAP (Default) If the Object ID is not listed in the Active Object Map, an OBJECT_NOT _EXIST exception is
                                returned. The POA must also use the
                                RETAIN policy with this value.
                            </p></li><li><p>
                                USE_DEFAULT_SERVANT If the Object ID is not listed in the Active Object Map or the NON_RETAIN policy is set, the request is
                                dispatched to the default servant. If
                                no default servant has been registered, an OBJ_ADAPTER exception is returned. The POA must also
                                use the MULTIPLE_ID policy with this
                                value.
                            </p></li><li><p>
                                USE_SERVANT_MANAGER If the Object ID is not listed in the Active Object Map or the NON_RETAIN policy is set, the servant manager
                                is used to obtain a servant.
                            </p></li></ul></div></li><li><p>
                        Implicit Activation policy - specifies whether the POA supports implicit activation of servants. The Implicit Activation
                        policy can
                        have the following
                        values:
                    </p><div class="itemizedlist"><ul><li><p>
                                IMPLICIT_ACTIVATION The POA supports implicit activation of servants. Servants can be activated by converting them to an object
                                reference with
                                org.omg.PortableServer.POA.servant_to_reference() or by invoking _this()on the servant. The POA must also use the
                                SYSTEM_ID and RETAIN
                                policies with this value.
                            </p></li><li><p>
                                NO_IMPLICIT_ACTIVATION (Default) The POA does not support implicit activation of servants.
                            </p></li></ul></div></li></ul></div><p>
                It appears that to redirect replay_completion invocations to a default servant we need to create a POA
                with the Request Processing policy
                assigned
                with the value set to USE_DEFAULT_SERVANT. However to reach that default Servant we should first reach the POA that
                forward the
                request to the
                default servant. Indeed, the ORB uses a set of information to retrieve a POA; these information are contained in the object
                reference used by
                the client. Among these information there are the IP address and the port number where resides the server and also the
                POA
                name. To perform
                replay_completion invocations, the solution adopted by Narayana
                is to provide one Servant, per machine, and located in the
                RecoveryManager
                process, a separate process from client or server applications. The next section explains how the indirection to a default
                Servant located on
                a separate process is provided for JacORB.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1395"/>2.2.3. The default RecoveryCoordinator in JacOrb</h3></div></div></div><p>
            JacORB does not define additional policies to redirect any request on a RecoveryCoordinator object to a default servant
            located in the
            Recovery Manager process. However it provides a set of APIs that allows building object references with specific IP address,
            port number and POA
            name in order to reach the appropriate default servant.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1400"/>2.2.3.1. How Does it work</h4></div></div></div><p>
                When the Recovery Manager is launched it seeks in the configuration the RecoveryActivator that need be loaded. Once done
                it invokes the
                startRCservice
                method of each loaded instances. As seen in in the previous chapter (Recovery Manager ) the class to load that implements
                the
                RecoveryActivator interface is the class RecoveryEnablement. This generic class, located in the package
                com.arjuna.ats.internal.jts.orbspecific.recovery, hides the nature of the ORB being used by the
                application (JacORB). The following figure
                illustrates the behavior of the RecoveryActivator that leads to the creation of the default servant that performs
                replay_completion
                invocations requests.
            </p><p>
                In addition to the creation of the default servant, an object reference to a RecoveryCoordinator object is created and
                stored in the
                ObjectStore. As
                we will see this object reference will be used to obtain its IP address, port number and POA name and assign them to
                any
                RecoveryCoordinator
                object reference created on register_resource.
            </p><div class="figure"><a id="d0e1407"/><div class="figure-contents"><div class="mediaobject"><img src="images/failure-recovery-fig5-recoverymanager.png" alt="Recovery Manager"/></div></div><p class="title"><b>Figure 2.5. Recovery Manager</b></p></div><br class="figure-break"/><p>
                When an application registers a resource with a transaction, a RecoveryCoordinator object reference is expected to be
                returned. To build
                that object
                reference, the Transaction Service uses the RecoveryCoordinator object reference created within the Recovery Manager as a
                template.
                The new
                object reference contains practically the same information to retrieve the default servant (IP address, port number, POA
                name, etc.),
                but the
                Object ID is changed; now, it contains the Transaction ID of the transaction in progress and also the Process ID of the
                process that is
                creating the new RecoveryCoordinator object reference, as illustrated in Figure 11.
            </p><div class="figure"><a id="d0e1415"/><div class="figure-contents"><div class="mediaobject"><img src="images/failure-recovery-fig6-resourceregistration.png" alt="Resource registration and returned RecoveryCoordinator Object reference build from a reference stored in the ObjectStore."/></div></div><p class="title"><b>Figure 2.6. Resource registration and returned RecoveryCoordinator Object reference build from a reference
                    stored in the ObjectStore. </b></p></div><br class="figure-break"/><p>
                Since a RecoveryCoordintaor object reference returned to an application contains all information to retrieve the POA then
                the default
                servant located
                in the Recovery Manager, all replay_completion invocation, per machine, are forwarded to the same default
                RecoveryCoordinator
                that is able to
                retreive the Object ID from the incoming request to extract the transaction identifier and the process identifier needed to
                determine the
                status of the requested transaction.
            </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1423"/>2.3. Configuration Options</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1426"/>2.3.1. Recovery Protocol in OTS - Overview</h3></div></div></div><p>Narayana
            is highly configurable. For full details of the configuration mechanism used, see the Programmer's Guide.
        </p><p>The following table shows the configuration features, with default values shown in italics. More details
            about each option can be found in the relevant sections of this document.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>You need to prefix each property in this table with the string com.arjuna.ats.arjuna.recovery. The
                prefix has been removed for formatting reasons, and has been replaced by ...
            </p></div><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Configuration Name</th><th>Possible Values</th><th>Description</th></tr></thead><tbody><tr><td>
                            <p>...periodicRecoveryPeriod</p>
                        </td><td>
                            <p>120/any positive integer</p>
                        </td><td>
                            <p>
                                Interval between recovery attempts, in seconds.
                            </p>
                        </td></tr><tr><td>
                            <p>...recoveryBackoffPeriod</p>
                        </td><td>
                            <p>10/any positive integer</p>
                        </td><td>
                            <p>
                                Interval between first and second recovery passes, in seconds.
                            </p>
                        </td></tr><tr><td>
                            <p>...expiryScanInterval</p>
                        </td><td>
                            <p>12/any integer</p>
                        </td><td>
                            <p>
                                Interval between expiry scans, in hours. 0 disables scanning. Negative values postpone the first run.
                            </p>
                        </td></tr><tr><td>
                            <p>...transactionStatusManagerExpiryTime</p>
                        </td><td>
                            <p>12/any positive integer</p>
                        </td><td>
                            <p>
                                Interval after which a non-contactable process is considered dead. 0 = never.
                            </p>
                        </td></tr></tbody></table></div></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1511"/>Chapter 3. Development Guide</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1514">3.1. Transactions</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1521">3.1.1. The Java Transaction API (JTA)</a></span></dt><dt><span class="section"><a href="#d0e1580">3.1.2. Introducing the API</a></span></dt><dt><span class="section"><a href="#UserTransaction_Definition">3.1.3. UserTransaction</a></span></dt><dt><span class="section"><a href="#d0e1665">3.1.4. TransactionManager</a></span></dt><dt><span class="section"><a href="#d0e1780">3.1.5. Suspend and resuming a transaction</a></span></dt><dt><span class="section"><a href="#d0e1824">3.1.6. The Transaction interface</a></span></dt><dt><span class="section"><a href="#d0e1884">3.1.7. Resource enlistment</a></span></dt><dt><span class="section"><a href="#d0e1932">3.1.8. Transaction synchronization</a></span></dt><dt><span class="section"><a href="#d0e1980">3.1.9. Transaction equality</a></span></dt><dt><span class="section"><a href="#d0e2008">3.1.10. TransactionSynchronizationRegistry</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2071">3.2. The Resource Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2074">3.2.1. 
            The
            XAResource
            interface
        </a></span></dt><dt><span class="section"><a href="#d0e2303">3.2.2. Opening a resource manager</a></span></dt><dt><span class="section"><a href="#d0e2314">3.2.3. Closing a resource manager</a></span></dt><dt><span class="section"><a href="#d0e2339">3.2.4. Thread of control</a></span></dt><dt><span class="section"><a href="#d0e2370">3.2.5. Transaction association</a></span></dt><dt><span class="section"><a href="#d0e2401">3.2.6. Externally controlled connections</a></span></dt><dt><span class="section"><a href="#d0e2414">3.2.7. Resource sharing</a></span></dt><dt><span class="section"><a href="#d0e2451">3.2.8. Local and global transactions</a></span></dt><dt><span class="section"><a href="#d0e2466">3.2.9. Transaction timeouts</a></span></dt><dt><span class="section"><a href="#d0e2510">3.2.10. Dynamic registration</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2525">3.3. General Transaction Issues</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2528">3.3.1. Advanced transaction issues with TxCore</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2723">3.4. Tools</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2728">3.4.1. ObjectStore command-line browsers and editors</a></span></dt><dt><span class="section"><a href="#d0e3086">3.4.2. GUI Based Tools</a></span></dt><dt><span class="section"><a href="#d0e3117">3.4.3. View Transaction Statistics using an Application Server</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3254">3.5. Configuration options</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3257">3.5.1. Loading a configuration</a></span></dt><dt><span class="section"><a href="#d0e3383">3.5.2. ArjunaCore Options</a></span></dt><dt><span class="section"><a href="#d0e3440">3.5.3. Narayana
            JTA Configuration options
        </a></span></dt><dt><span class="section"><a href="#d0e3458">3.5.4. Narayana
            JTS Options
        </a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3479">3.6. Important Log Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3484">3.6.1. Transaction State Change</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3554">3.7. Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3559">3.7.1. WS-BA Participant-Completion Race Condition</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1514"/>3.1. Transactions</h2></div></div></div><p>
        A transaction is a unit of work that encapsulates multiple database actions such that that
        either all the
        encapsulated actions fail or all succeed.
    </p><p>
        Transactions ensure data integrity when an application interacts with multiple datasources.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1521"/>3.1.1. The Java Transaction API (JTA)</h3></div></div></div><p>
            The interfaces specified by the many transaction standards tend to be too low-level for most
            application
            programmers. Therefore, Sun Microsystems created the Java Transaction API (JTA),
            which specifies higher-level
            interfaces to assist in the development of distributed transactional
            applications.
        </p><p>
            Note, these interfaces are still low-level. You still need to implement state management and
            concurrency for
            transactional applications. The interfaces are also optimized for applications
            which require XA resource integration
            capabilities, rather than the more general resources which
            other transactional APIs allow.
        </p><p>
            With reference to JTA 1.1 (
            <a class="ulink" href="http://www.oracle.com/technetwork/java/javaee/tech/jta-138684.html">http://www.oracle.com/technetwork/java/javaee/tech/jta-138684.html</a>
            ),
            distributed transaction services typically involve a number of participants:
        </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>application server</td><td>
                            <p>
                                provides the infrastructure required to support the application run-time
                                environment which includes
                                transaction state management, such as an EJB server.
                            </p>
                        </td></tr><tr><td>transaction manager</td><td>
                            <p>
                                provides the services and management functions required to support transaction
                                demarcation, transactional
                                resource management, synchronization, and transaction
                                context propagation.
                            </p>
                        </td></tr><tr><td>resource manager</td><td>
                            <p>
                                Using a
                                <em class="firstterm">resource adapter</em>
                                , provides the application with access to resources. The
                                resource manager participates
                                in distributed transactions by implementing a transaction resource interface
                                used by
                                the transaction manager to communicate transaction association, transaction completion
                                and
                                recovery.
                            </p>
                            <p>
                                A resource adapter is used by an application server or client to connect to a
                                Resource Manager. JDBC
                                drivers which are used to connect to relational databases are
                                examples of Resource Adapters.
                            </p>
                        </td></tr><tr><td>communication resource manager</td><td>
                            <p>
                                supports transaction context propagation and access to the transaction service for incoming and
                                outgoing
                                requests.
                            </p>
                        </td></tr></tbody></table></div><p>
            From the point of view of the transaction manager, the actual implementation of the
            transaction services does not
            need to be exposed. You only need to define high-level interfaces
            to allow transaction demarcation, resource
            enlistment, synchronization and recovery process to be
            driven from the users of the transaction services. The JTA is
            a high-level application interface
            that allows a transactional application to demarcate transaction boundaries, and
            also contains a
            mapping of the X/Open XA protocol.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Compatibility</h2><p>
                the JTA support provided by Narayana
                is compliant with the 1.1 specification.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1580"/>3.1.2. Introducing the API</h3></div></div></div><p>
            The Java Transaction API consists of three elements:
        </p><div class="itemizedlist"><ul><li><p>
                    a high-level application transaction demarcation interface
                </p></li><li><p>
                    a high-level transaction manager interface intended for application server
                </p></li><li><p>
                    a standard Java mapping of the X/Open XA protocol intended for a transactional
                    resource manager.
                </p></li></ul></div><p>
            All of the JTA classes and interfaces exist within the
            <span class="package">javax.transaction</span>
            package, and the
            corresponding Narayana
            implementations within the
            <span class="package">com.arjuna.ats.jta</span>
            package.
        </p><p>
            Each Xid created by Narayana
            needs a unique node identifier encoded within it, because Narayana
            can only recover
            transactions and states that match a specified node identifier. The node
            identifier to use should be provided to
      Narayana
            via the
            <code class="varname">CoreEnvironmentBean.nodeIdentifier</code>
            property. This value must be unique across
            your Narayana
            instances. The identifier is
            alphanumeric and limited to 10 bytes in length. If you do not provide a
            value, then Narayana
            generates one and reports the value via the logging infrastructure.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="UserTransaction_Definition"/>3.1.3. UserTransaction</h3></div></div></div><p>
            The
            <code class="interfacename">UserTransaction</code>
            interface provides applications with the ability to control
            transaction boundaries. It provides
            methods
            <code class="methodname">begin</code>
            ,
            <code class="methodname">commit</code>
            , and
            <code class="methodname">rollback</code>
            to operate on top-level transactions.
        </p><p>
            Nested transactions are not supported, and method
            <code class="methodname">begin</code>
            throws the exception
            <code class="systemitem">NotSupportedException</code>
            if the calling thread is already associated with a
            transaction.
            <code class="interfacename">UserTransaction</code>
            automatically associates newly created transactions
            with the invoking thread.
        </p><p>
            To obtain a
            <code class="interfacename">UserTransaction</code>
            , call the static method
            <code class="methodname">com.arjuna.ats.jta.UserTransaction.userTransaction()</code>
            .
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="procedure"><a id="d0e1644"/><p class="title"><b>Procedure 3.1. Selecting the local JTA Implementation</b></p><ol class="1"><li><p>
                    Set property
                    <code class="varname">JTAEnvironmentBean.jtaTMImplementation</code>
                    to
                    <code class="literal">com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple
                    </code>
                    .
                </p></li><li><p>
                    Set property
                    <code class="varname">JTAEnvironmentBean.jtaUTImplementation</code>
                    to
                    <code class="literal">com.arjuna.ats.internal.jta.transaction.arjunacore.UserTransactionImple</code>
                    .
                </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1665"/>3.1.4. TransactionManager</h3></div></div></div><p>
            The
            <code class="interfacename">TransactionManager</code>
            interface allows the application server to control
            transaction boundaries on behalf of the
            application being managed.
        </p><p>
            To obtain a
            <code class="interfacename">TransactionManager</code>
            , invoke the static method
            <code class="methodname">com.arjuna.ats.jta.TransactionManager.transactionManager</code>
            .
        </p><p>
            The
            <code class="interfacename">TransactionManager</code>
            maintains the transaction context association with threads
            as part of its internal data
            structure. A thread’s transaction context may be
            <code class="literal">null</code>
            or it may
            refer to a specific global transaction. Multiple threads may be associated with the
            same global transaction. As
            noted in
            <a class="xref" href="#UserTransaction_Definition" title="3.1.3. UserTransaction">Section 3.1.3, “UserTransaction”</a>
            , nested transactions are not supported.
        </p><p>
            Each transaction context is encapsulated by a Transaction object, which can be used to
            perform operations which
            are specific to the target transaction, regardless of the calling
            thread’s transaction context.
        </p><div class="table"><a id="d0e1693"/><p class="title"><b>Table 3.1. 
                <code class="interfacename">TransactionManager</code>
                Methods
            </b></p><div class="table-contents"><table summary="&#xA;                TransactionManager&#xA;                Methods&#xA;            " border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
                            <p>
                                <code class="methodname">begin</code>
                            </p>
                        </td><td>
                            <p>
                                Starts a new top-level transaction and associates the transaction context with the
                                calling thread. If
                                the calling thread is already associated with a transaction,
                                exception
                                <code class="systemitem">NotSupportedException</code>
                                is thrown.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                <code class="methodname">getTransaction</code>
                            </p>
                        </td><td>
                            <p>
                                Returns the Transaction object representing the transaction context which is
                                currently associated with
                                the calling thread. You can use this object to perform
                                various operations on the target transaction.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                <code class="methodname">commit</code>
                            </p>
                        </td><td>
                            <p>
                                Completes the transaction currently associated with the calling thread. After it
                                returns, the calling
                                thread is associated with no transaction. If
                                <code class="methodname">commit</code>
                                is called when the thread
                                is not associated with any transaction context, an
                                exception is thrown. In some implementations, the
                                <code class="methodname">commit</code>
                                operation is restricted to the transaction originator only. If the
                                calling thread is
                                not allowed to commit the transaction, an exception is thrown. Narayana
                                does not
                                currently impose any restriction on the ability of threads to terminate
                                transactions.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                <code class="methodname">rollback</code>
                            </p>
                        </td><td>
                            <p>
                                Rolls back the transaction associated with the current thread. After the
                                <code class="methodname">rollback</code>
                                method completes, the thread is associated with no transaction.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/><p>
            In a multi-threaded environment, multiple threads may be active within the same transaction.
            If checked
            transaction semantics have been disabled, or the transaction times out, a
            transaction may terminated by a thread
            other than the one that created it. In this case, the
            creator usually needs to be notified. Narayana
            notifies the
            creator during operations
            <code class="methodname">commit</code>
            or
            <code class="methodname">rollback</code>
            by throwing
            exception
            <code class="systemitem">IllegalStateException</code>
            .
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1780"/>3.1.5. Suspend and resuming a transaction</h3></div></div></div><p>
            The JTA supports the concept of a thread temporarily suspending and resuming transactions in
            order to perform
            non-transactional work. Call the
            <code class="methodname">suspend</code>
            method to temporarily suspend the current
            transaction that is associated with the calling
            thread. The thread then operates outside of the scope of the
            transaction. If the thread is not
            associated with any transaction, a
            <span class="type">null</span>
            object reference is
            returned. Otherwise, a valid
            <span class="type">Transaction</span>
            object is returned. Pass the
            <span class="type">Transaction</span>
            object
            to the
            <code class="methodname">resume</code>
            method to reinstate the transaction context.
        </p><p>
            The
            <code class="methodname">resume</code>
            method associates the specified transaction context with the calling
            thread. If the transaction
            specified is not a valid transaction, , the thread is associated with no transaction.
            if
            <code class="methodname">resume</code>
            is invoked when the calling thread is already associated with another
            transaction, the
            <code class="systemitem">IllegalStateException</code>
            exception is thrown.
        </p><div class="example"><a id="d0e1811"/><p class="title"><b>Example 3.1. 
                Using the
                <code class="methodname">suspend</code>
                method
            </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tobj&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">TransactionManager</span><span class="java_separator">.</span><span class="java_plain">suspend</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">..</span>
<!--  --><br/><span class="java_type">TransactionManager</span><span class="java_separator">.</span><span class="java_plain">resume</span><span class="java_separator">(</span><span class="java_plain">tobj</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
        Narayana
                allows a suspended transaction to be resumed by a different thread. This
                feature is not required by
                JTA, but is an important feature.
            </p></div><p>
            When a transaction is suspended, the application server must ensure that the resources in
            use by the application
            are no longer registered with the suspended transaction. When a resource
            is de-listed this triggers the
            Transaction Manager to inform the resource manager to
            disassociate the transaction from the specified resource
            object. When the application’s
            transaction context is resumed, the application server must ensure that the
            resources in use by
            the application are again enlisted with the transaction. Enlisting a resource as a result of
            resuming a transaction triggers the Transaction Manager to inform the resource manager to
            re-associate the
            resource object with the resumed transaction.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1824"/>3.1.6. The Transaction interface</h3></div></div></div><p>
            The
            <code class="interfacename">Transaction</code>
            interface allows you to perform operations on the transaction
            associated with the target
            object. Every top-level transaction is associated with one
            <span class="type">Transaction</span>
            object when the transaction is created.
        </p><div class="itemizedlist"><p class="title"><b>
                Uses of the
                <span class="type">Transaction</span>
                object
            </b></p><ul><li><p>
                    enlist the transactional resources in use by the application.
                </p></li><li><p>
                    register for transaction synchronization call backs.
                </p></li><li><p>
                    commit or rollback the transaction.
                </p></li><li><p>
                    obtain the status of the transaction.
                </p></li></ul></div><p>
            The
            <code class="methodname">commit</code>
            and
            <code class="methodname">rollback</code>
            methods allow the target object to be
            committed or rolled back. The calling thread does not
            need to have the same transaction associated with the
            thread. If the calling thread is not
            allowed to commit the transaction, the transaction manager throws an
            exception. At present
      Narayana
            does not impose restrictions on threads terminating transactions.
        </p><p>
            The JTA standard does not provide a means to obtain the transaction identifier. However,
      Narayana
            provides several
            ways to view the transaction identifier. Call method
            <code class="methodname">toString</code>
            to print full information
            about the transaction, including the identifier. Alternatively you
            can cast the
            <span class="type">javax.transaction.Transaction</span>
            instance to a
            <span class="type">com.arjuna.ats.jta.transaction.Transaction</span>
            ,
            then call either method
            <code class="methodname">get_uid</code>
            , which returns an ArjunaCore
            <span class="type">Uid</span>
            representation, or
            <code class="methodname">getTxId</code>
            , which returns an
            <span class="type">Xid</span>
            for the global identifier,
            i.e., no branch qualifier.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1884"/>3.1.7. Resource enlistment</h3></div></div></div><p>
            Typically, an application server manages transactional resources, such as database
            connections, in conjunction
            with some resource adapter and optionally with connection pooling
            optimization. For an external transaction
            manager to coordinate transactional work performed by
            the resource managers, the application server must enlist
            and de-list the resources used in the
            transaction. These resources, called
            <em class="firstterm">participants</em>
            ,
            are enlisted with the transaction so that they can be informed when the transaction
            terminates, by being driven
            through the two-phase commit protocol.
        </p><p>
            As stated previously, the JTA is much more closely integrated with the XA concept of resources
            than the arbitrary
            objects. For each resource the application is using, the application server
            invokes the
            <code class="methodname">enlistResource</code>
            method with an
            <span class="type">XAResource</span>
            object which identifies the
            resource in use.
        </p><p>
            The enlistment request causes the transaction manager to inform the resource manager to start
            associating the
            transaction with the work performed through the corresponding resource. The
            transaction manager passes the
            appropriate flag in its
            <code class="methodname">XAResource.start</code>
            method call to the resource manager.
        </p><p>
            The
            <code class="methodname">delistResource</code>
            method disassociates the specified resource from the transaction
            context in the target object.
            The application server invokes the method with the two parameters: the
            <span class="type">XAResource</span>
            object that represents the resource, and a flag to indicate whether the operation is due
            to the
            transaction being suspended (
            <code class="literal">TMSUSPEND</code>
            ), a portion of the work has failed
            (
            <code class="literal">TMFAIL</code>
            ), or a normal resource release by the application (
            <code class="literal">TMSUCCESS</code>
            ).
        </p><p>
            The de-list request causes the transaction manager to inform the resource manager to end the
            association of the
            transaction with the target
            <span class="type">XAResource</span>
            . The flag value allows the application server to indicate
            whether it intends to come back to
            the same resource whereby the resource states must be kept intact. The
            transaction manager
            passes the appropriate flag value in its
            <code class="methodname">XAResource.end</code>
            method call
            to the underlying resource manager.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1932"/>3.1.8. Transaction synchronization</h3></div></div></div><p>
            Transaction synchronization allows the application server to be notified before and after the
            transaction
            completes. For each transaction started, the application server may optionally
            register a
            <span class="type">Synchronization</span>
            call-back object to be invoked by the transaction manager, which will be one of the
            following:
        </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
                            <p>
                                <code class="methodname">beforeCompletion</code>
                            </p>
                        </td><td>
                            <p>
                                Called before the start of the two-phase transaction complete process. This call is
                                executed in the same
                                transaction context of the caller who initiates the
                                <code class="methodname">TransactionManager.commit</code>
                                or the call is executed with no transaction context if
                                <code class="methodname">Transaction.commit</code>
                                is
                                used.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                <code class="methodname">afterCompletion</code>
                            </p>
                        </td><td>
                            <p>
                                Called after the transaction completes. The status of the transaction is
                                supplied in the parameter. This
                                method is executed without a transaction context.
                            </p>
                            <p>
                                NOTE: If a JTA XAResource throws a RuntimeException, this method will not be called as the transaction has not and
                                cannot complete. Please see JBTM-2148 for more details.
                            </p>
                        </td></tr></tbody></table></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1980"/>3.1.9. Transaction equality</h3></div></div></div><p>
            The transaction manager implements the
            <span class="type">Transaction</span>
            object’s
            <code class="methodname">equals</code>
            method to
            allow comparison between the target object and another
            <span class="type">Transaction</span>
            object. The
            <code class="methodname">equals</code>
            method returns
            <code class="literal">true</code>
            if the target object and the parameter
            object both refer to the same global transaction.
        </p><div class="example"><a id="d0e2000"/><p class="title"><b>Example 3.2. 
                Method
                <code class="methodname">equals</code>
            </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Transaction</span><span class="java_plain">&nbsp;txObj&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">TransactionManager</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;someOtherTxObj&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">..</span>
<!--  --><br/><span class="java_separator">..</span>
</span>
<!--  --><br/><span class="java_type">boolean</span><span class="java_plain">&nbsp;isSame&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;txObj</span><span class="java_separator">.</span><span class="java_plain">equals</span><span class="java_separator">(</span><span class="java_plain">someOtherTxObj</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2008"/>3.1.10. TransactionSynchronizationRegistry</h3></div></div></div><p>
            The
            <code class="interfacename">javax.transaction.TransactionSynchronizationRegistry</code>
            interface, added to the
            JTA API in version 1.1, provides for registering Synchronizations with
            special ordering behavior, and for storing
            key-value pairs in a per-transaction Map. Full
            details are available from the JTA 1.1 API specification and
            javadoc. Here we focus on
            implementation specific behavior.
        </p><div class="example"><a id="d0e2016"/><p class="title"><b>Example 3.3. Accessing the TransactionSynchronizationRegistry in standalone environments</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javax</span><span class="java_separator">.</span><span class="java_plain">transaction</span><span class="java_separator">.</span><span class="java_type">TransactionSynchronizationRegistry</span><span class="java_plain">&nbsp;tsr&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;com</span><span class="java_separator">.</span><span class="java_plain">arjuna</span><span class="java_separator">.</span><span class="java_plain">ats</span><span class="java_separator">.</span><span class="java_plain">internal</span><span class="java_separator">.</span><span class="java_plain">jta</span><span class="java_separator">.</span><span class="java_plain">transaction</span><span class="java_separator">.</span><span class="java_plain">arjunacore</span><span class="java_separator">.</span><span class="java_type">TransactionSynchronizationRegistryImple</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre><p>
                This is a stateless object and hence is cheap to instantiate.
            </p></div></div><br class="example-break"/><h5 xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="formalpara">Accessing the TransactionSynchronizationRegistry via JNDI</h5><p class="formalpara">
                In application server environments, the standard JNDI name binding is
                <code class="literal">java:comp/TransactionSynchronizationRegistry</code>
                .
            </p><p>
            Ordering of interposed Synchronizations is relative to other local Synchronizations only.
            In cases where the
            transaction is distributed over multiple JVMs, global ordering is not
            guaranteed.
        </p><p>
            The per-transaction data storage provided by the
            <code class="interfacename">TransactionSynchronizationRegistry</code>
            methods
            <code class="methodname">getResource</code>
            and
            <code class="methodname">putResource</code>
            are non-persistent and thus
            not available in
            <code class="interfacename">Transactions</code>
            during crash recovery. When running integrated with
            an application server or other container,
            this storage may be used for system purposes. To avoid collisions, use
            an application-specific
            prefix on map keys, such as
            <code class="command">put(“myapp_”+key, value)</code>
            . The behavior of
            the
            <span class="type">Map</span>
            on
            <span class="type">Thread</span>
            s that have status
            <code class="literal">NO_TRANSACTION</code>
            or where the
            transaction they are associated with has been rolled back by another
            <span class="type">Thread</span>
            , such as in the case of a
            timeout, is undefined. A
            <span class="type">Transaction</span>
            can be associated with multiple
            <span class="type">Thread</span>
            s. For such
            cases the
            <span class="type">Map</span>
            is synchronized to provide thread safety.
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2071"/>3.2. The Resource Manager</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2074"/>3.2.1. 
            The
            <code class="interfacename">XAResource</code>
            interface
        </h3></div></div></div><p>
            Some transaction specifications and systems define a generic resource which can be used to register
            arbitrary
            resources with a transaction, the JTA is much more XA-specific. Interface
            <code class="interfacename">javax.transaction.xa.XAResource</code>
            is a Java mapping of the XA interface. The
            <code class="interfacename">XAResource</code>
            interface defines the contract between a
            <code class="interfacename">ResourceManager</code>
            and a
            <code class="interfacename">TransactionManager</code>
            in a
            distributed transaction processing environment. A resource adapter for a
            <code class="interfacename">ResourceManager</code>
            implements the
            <code class="interfacename">XAResource</code>
            interface
            to support association of a top-level transaction to a resource such as a relational database.
        </p><p>
            The
            <code class="interfacename">XAResource</code>
            interface can be supported by any transactional resource adapter
            designed to be used in an environment where transactions are controlled by an external transaction manager, such a
            database management system. An application may access data through multiple database connections. Each database
            connection is associated with an
            <code class="interfacename">XAResource</code>
            object that serves as a proxy object to
            the underlying
            <code class="interfacename">ResourceManager</code>
            instance. The transaction manager obtains an
            <code class="interfacename">XAResource</code>
            for each
            <code class="interfacename">ResourceManager</code>
            participating in
            a top-level transaction. The
            <code class="methodname">start</code>
            method associates the transaction with the resource,
            and the
            <code class="methodname">end</code>
            method disassociates the transaction from the resource.
        </p><p>
            The
            <code class="interfacename">ResourceManager</code>
            associates the transaction with all work performed on its data
            between invocation of
            <code class="methodname">start</code>
            and
            <code class="methodname">end</code>
            methods. At transaction
            commit time, these transactional
            <code class="interfacename">ResourceManager</code>
            s are informed by the transaction
            manager to prepare, commit, or roll back the transaction according to the two-phase commit protocol.
        </p><p>
            For better Java integration, the
            <code class="interfacename">XAResource</code>
            differs from the standard
            <code class="interfacename">XA</code>
            interface in the following ways:
        </p><div class="itemizedlist"><ul><li><p>
                    The resource adapter implicitly initializes the
                    <code class="interfacename">ResourceManager</code>
                    when the
                    resource (the connection) is acquired. There is no equivalent to the
                    <code class="methodname">xa_open</code>
                    method
                    of the interface
                    <code class="interfacename">XA</code>
                    .
                </p></li><li><p>
                    <code class="varname">Rmid</code>
                    is not passed as an argument. Each
                    <code class="varname">Rmid</code>
                    is represented by a
                    separate
                    <code class="interfacename">XAResource</code>
                    object.
                </p></li><li><p>
                    Asynchronous operations are not supported, because Java supports multi-threaded processing and most databases
                    do not support asynchronous operations.
                </p></li><li><p>
                    Error return values caused by the transaction manager’s improper handling of the
                    <code class="interfacename">XAResource</code>
                    object are mapped to Java exceptions via the
                    <code class="classname">XAException</code>
                    class.
                </p></li><li><p>
                    The DTP concept of
                    <span>Thread of Control</span>
                    maps to all Java threads that are given access to the
                    <code class="interfacename">XAResource</code>
                    and
                    <code class="interfacename">Connection</code>
                    objects. For example,
                    it is legal for two different threads to perform the
                    <code class="methodname">start</code>
                    and
                    <code class="methodname">end</code>
                    operations on the same
                    <code class="interfacename">XAResource</code>
                    object.
                </p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2203"/>3.2.1.1. 
                Extended
                <code class="interfacename">XAResource</code>
                control
            </h4></div></div></div><p>
                By default, whenever an
                <code class="interfacename">XAResource</code>
                object is registered with a JTA-compliant
                transaction service, there is no way to manipulate the order in which it is invoked during the two-phase commit
                protocol, with respect to other
                <code class="interfacename">XAResource</code>
                objects. Narayana,
                however, provides
                support for controlling the order via the two interfaces
                <code class="interfacename">com.arjuna.ats.jta.resources.StartXAResource</code>
                and
                <code class="interfacename">com.arjuna.ats.jta.resources.EndXAResource</code>
                . By inheriting your
                <code class="interfacename">XAResource</code>
                instance from either of these interfaces, you control whether an
                instance of your class is invoked first or last, respectively.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                    Only one instance of each interface type may be registered with a specific transaction.
                </p></div><p>
                The
                <em class="citetitle">ArjunaCore Development Guide</em>
                discusses the
                <em class="firstterm">Last Resource Commit
                    optimization (LRCO)
                </em>
                , whereby a single resource that is only one-phase aware, and does not support
                the
                <code class="methodname">prepare</code>
                phase, can be enlisted with a transaction that is manipulating two-phase
                aware participants. This optimization is also supported within the Narayana.
            </p><p>
                In order to use the LRCO, your
                <code class="interfacename">XAResource</code>
                implementation must extend the
                <code class="interfacename">com.arjuna.ats.jta.resources.LastResourceCommitOptimisation</code>
                marker interface. A
                marker interface is an interface which provides no methods. When
                enlisting the resource via method
                <code class="methodname">Transaction.enlistResource</code>, Narayana
                ensures that only a single instance of this
                type of participant is used within each transaction. Your resource is driven last in the commit protocol,
                and no invocation of method
                <code class="methodname">prepare</code>
                occurs.
            </p><p>
                By default an attempt to enlist more than one instance of a LastResourceCommitOptimisation class will fail and
                false will be returned from Transaction.enlistResource. This behavior can be overridden by setting the
                com.arjuna.ats.jta.allowMultipleLastResources to true. However, before doing so you should read the
                section on
                enlisting multiple one-phase aware resources.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
                    You need to disable interposition support to use the LCRO in a distributed environment. You can still use
                    implicit context propagation.
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2259"/>3.2.1.1.1. Enlisting multiple one-phase-aware resources</h5></div></div></div><p>
                    One-phase commit is used to process a single one-phase aware resource, which does not conform to the
                    two-phase commit protocol. You can still achieve an atomic outcome across resources, by using the LRCO, as
                    explained earlier.
                </p><p>
                    Multiple one-phase-aware resources may be enlisted in the same transaction. One example is when a
                    legacy
                    database runs within the same transaction as a legacy JMS implementation. In such a situation, you cannot
                    achieve atomicity of transaction outcome across multiple resources, because none of them enter the
                    <code class="methodname">prepare</code>
                    state. They commit or roll back immediately when instructed by the
                    transaction coordinator, without knowledge of other resource states and without a way to undo if subsequent
                    resources make a different choice. This can result in data corruption or heuristic outcomes.
                </p><p>
                    You can approach these situations in two different ways:
                </p><div class="itemizedlist"><ul><li><p>
                            Wrap the resources in compensating transactions. See the
                            <em class="citetitle">XTS Transactions Development
                                Guide
                            </em>
                            for details.
                        </p></li><li><p>
                            Migrate the legacy implementations to two-phase aware equivalents.
                        </p></li></ul></div><p>
                    If neither of these options is viable, Narayana
                    support enlisting multiple
                    one-phase aware resources within the same transaction, using LRCO, which is discussed in the
                    <em class="citetitle">ArjunaCore Development Guide</em>
                    in detail.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>
                        Even when this support is enabled, Narayana
                        issues a warning when it detects that the option has been
                        enabled:
                        <code class="literal">You have chosen to enable multiple last resources in the transaction manager. This is
                            transactionally unsafe and should not be relied upon.
                        </code>
                        Another warning is issued when multiple
                        one-phase aware resources are enlisted within a transaction:
                        <code class="literal">This is transactionally unsafe and
                            should not be relied on.
                        </code>
                    </p><p>
                        To override the above-mentioned warning at runtime, set the
                        <code class="varname">CoreEnvironmentBean.disableMultipleLastResourcesWarning</code>
                        property to
                        <code class="literal">true</code>.
                        You will see a warning that you have done this when Narayana
                        starts up and see the
                        warning about enlisting multiple one-phase resources only the first time it happens, but after that no
                        further warnings will be output. You should obviously only consider changing the default value of this
                        property (false) with caution.
                    </p></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2303"/>3.2.2. Opening a resource manager</h3></div></div></div><p>
            The X/Open
            <code class="interfacename">XA</code>
            interface requires the transaction manager to initialize a resource
            manager, using method
            <code class="methodname">xa_open</code>
            , before invoking any other of the interface's methods. JTA
            requires initialization of a resource manager to be embedded within the resource adapter that represents the
            resource manager. The transaction manager does not need to know how to initialize a resource manager. It only
            informs the resource manager about when to start and end work associated with a transaction and when to complete
            the transaction. The resource adapter opens the resource manager when the connection to the resource manager is
            established.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2314"/>3.2.3. Closing a resource manager</h3></div></div></div><p>
            The resource adapter closes a resource manager as a result of destroying the transactional resource. A
            transaction resource at the resource adapter level is comprised of two separate objects:
        </p><div class="itemizedlist"><ul><li><p>
                    An
                    <code class="interfacename">XAResource</code>
                    object that allows the transaction manager to start and end the
                    transaction association with the resource in use and to coordinate transaction completion process.
                </p></li><li><p>
                    A connection object that allows the application to perform operations on the underlying resource, such as JDBC
                    operations on an RDBMS.
                </p></li></ul></div><p>
            Once opened, the resource manager is kept open until the resource is released explicitly. When the
            application
            invokes the connection’s
            <code class="methodname">close</code>
            method, the resource adapter invalidates the connection
            object reference that was held by the application and notifies the application server about the close. The
            transaction manager invokes the
            <code class="methodname">XAResource.end</code>
            method to disassociate the transaction
            from that connection.
        </p><p>
            The close notification triggers the application server to perform any necessary cleanup work and to mark the
            physical XA connection as free for reuse, if connection pooling is in place.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2339"/>3.2.4. Thread of control</h3></div></div></div><p>
            The X/Open
            <code class="interfacename">XA</code>
            interface specifies that the transaction-association-related
            <code class="systemitem">xa</code>
            calls must be invoked from the same thread context. This
            <em class="firstterm">thread-of-control</em>
            requirement does not apply to the object-oriented component-based
            application run-time environment, in which application threads are dispatched dynamically as methods are
            invoked.. Different threads may use the same connection resource to access the resource manager if the connection
            spans multiple method invocation. Depending on the implementation of the application server, different threads may
            be involved with the same
            <code class="interfacename">XAResource</code>
            object. The resource context and the
            transaction context operate independent of thread context. This creates the possibility of different threads
            invoking the
            <code class="methodname">start</code>
            and
            <code class="methodname">end</code>
            methods.
        </p><p>
            If the application server allows multiple threads to use a single
            <code class="interfacename">XAResource</code>
            object
            and the associated connection to the resource manager, the application server must ensure that only one
            transaction context is associated with the resource at any point of time. Thus the
            <code class="interfacename">XAResource</code>
            interface requires the resource managers to support the two-phase commit
            protocol from any thread context.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2370"/>3.2.5. Transaction association</h3></div></div></div><p>
            A transaction is associated with a transactional resource via the
            <code class="methodname">start</code>
            method and disassociated from the
            resource via the
            <code class="methodname">end</code>
            method. The resource adapter internally maintains an association between
            the resource connection object and the
            <code class="interfacename">XAResource</code>
            object. At any given time, a
            connection is associated with zero or one transaction. JTA does not support nestedtransactions, so attempting to
            invoke the
            <code class="methodname">start</code>
            method on a thread that is already associated with a transaction is an error.
        </p><p>
            The transaction manager can Interleave multiple transaction contexts using the same resource, as long as
            methods
            <code class="methodname">start</code>
            and
            <code class="methodname">end</code>
            are invoked properly for each transaction context
            switch. Each time the resource is used with a different transaction, the method
            <code class="methodname">end</code>
            must
            be invoked for the previous transaction that was associated with the resource, and method
            <code class="methodname">start</code>
            must be invoked for the current transaction context.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2401"/>3.2.6. Externally controlled connections</h3></div></div></div><p>
            For a transactional application whose transaction states are managed by an application server, its resources
            must
            also be managed by the application server so that transaction association is performed properly. If an application
            is associated with a transaction, the application must not perform transactional work through the
            connection without having the connection’s resource object already associated with the global transaction. The
            application server must ensure that the
            <code class="interfacename">XAResource</code>
            object in use is associated with
            the transaction, by invoking the
            <code class="methodname">Transaction.enlistResource</code>
            method.
        </p><p>
            If a server-side transactional application retains its database connection across multiple client requests, the
            application server must ensure that before dispatching a client request to the application thread, the
            resource is
            enlisted with the application’s current transaction context. This implies that the application server manages the
            connection resource usage status across multiple method invocations.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2414"/>3.2.7. Resource sharing</h3></div></div></div><p>
            When the same transactional resource is used to interleave multiple transactions, the application server must
            ensure that only one transaction is enlisted with the resource at any given time. To initiate the transaction
            commit process, the transaction manager is allowed to use any of the resource objects connected to the same
            resource manager instance. The resource object used for the two-phase commit protocol does not need to have been
            involved with the transaction being completed.
        </p><p>
            The resource adapter must be able to handle multiple threads invoking the
            <code class="interfacename">XAResource</code>
            methods concurrently for transaction commit processing. This is
            illustrated in
            <a class="xref" href="#resource_sharing_example" title="Example 3.4. Resource sharing example">Example 3.4, “Resource sharing example”</a>
            .
        </p><div class="example"><a id="resource_sharing_example"/><p class="title"><b>Example 3.4. Resource sharing example</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">XAResource</span><!-- <br/> --><span class="java_plain">&nbsp;xares&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;r1</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getXAResource</span><!-- <br/> --><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">xares</span><span class="java_separator">.</span><span class="java_plain">start</span><span class="java_separator">(</span><span class="java_plain">xid1</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;associate&nbsp;xid1&nbsp;to&nbsp;the&nbsp;connection</span>
</span>
<!--  --><br/><span class="java_separator">..</span>
<!--  --><br/><span class="java_plain">xares</span><span class="java_separator">.</span><span class="java_plain">end</span><span class="java_separator">(</span><span class="java_plain">xid1</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;disassociate&nbsp;xid1&nbsp;to&nbsp;the&nbsp;connection</span>
<!--  --><br/><span class="java_separator">..</span>
<!--  --><br/><span class="java_plain">xares</span><span class="java_separator">.</span><span class="java_plain">start</span><span class="java_separator">(</span><span class="java_plain">xid2</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;associate&nbsp;xid2&nbsp;to&nbsp;the&nbsp;connection</span>
<!--  --><br/><span class="java_separator">..</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">While</span><span class="java_plain">&nbsp;the&nbsp;connection&nbsp;is&nbsp;associated&nbsp;with&nbsp;xid2</span><span class="java_separator">,</span>
<!--  --><br/><span class="java_operator">//</span><span class="java_plain">&nbsp;the&nbsp;TM&nbsp;starts&nbsp;the&nbsp;commit&nbsp;process&nbsp;</span><span class="java_keyword">for</span><span class="java_plain">&nbsp;xid1</span>
<!--  --><br/><span class="java_plain">status&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;xares</span><span class="java_separator">.</span><span class="java_plain">prepare</span><span class="java_separator">(</span><span class="java_plain">xid1</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">..</span>
<!--  --><br/><span class="java_plain">xares</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">(</span><span class="java_plain">xid1</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_literal">false</span><span class="java_separator">);</span><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
</pre><p>
                A transactional resource
                <code class="systemitem">r1</code>
                . Global transaction
                <code class="systemitem">xid1</code>
                is
                started and ended with r1. Then a different global transaction
                <code class="systemitem">xid2</code>
                is associated with
                <code class="systemitem">r1</code>
                . Meanwhile, the transaction manager may start the two phase commit process for
                <code class="systemitem">xid1</code>
                using
                <code class="systemitem">r1</code>
                or any other transactional resource connected to
                the same resource manager. The resource adapter needs to allow the commit process to be executed while the
                resource is currently associated with a different global transaction.
            </p></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2451"/>3.2.8. Local and global transactions</h3></div></div></div><p>
            The resource adapter must support the usage of both local and global transactions within the same
            transactional
            connection. Local transactions are started and coordinated by the resource manager internally. The
            <code class="interfacename">XAResource</code>
            interface is not used for local transactions. When using the same
            connection to perform both local and global transactions, the following rules apply:
        </p><div class="itemizedlist"><ul><li><p>
                    The local transaction must be committed or rolled back before a global transaction is started in the
                    connection.
                </p></li><li><p>
                    The global transaction must be disassociated from the connection before any local transaction is started.
                </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2466"/>3.2.9. Transaction timeouts</h3></div></div></div><p>
            You can associate timeout values with transactions in order to control their lifetimes. If the timeout value
            elapses before a transaction terminates, by committing or rolling back, the transaction system rolls it
            back. The
            <code class="interfacename">XAResource</code>
            interface supports a
            <code class="methodname">setTransactionTimeout</code>
            operation, which allows the timeout associated with the current transaction to be propagated to the resource
            manager and if supported, overrides any default timeout associated with the resource manager. Overriding the
            timeout can be useful when long-running transactions may have lifetimes that would exceed the default, and
            using
            the default timeout would cause the resource manager to roll back before the transaction terminates, and cause the
            transaction to roll back as well.
        </p><p>
            If You do not explicitly set a timeout value for a transaction, or you use a value of
            <code class="literal">0</code>,
            an
            implementation-specific default value may be used. In Narayana,
            property value
            <code class="varname">CoordinatorEnvironmentBean.defaultTimeout</code>
            represents this implementation-specific default, in
            seconds. The default value is 60 seconds. A value of
            <code class="literal">0</code>
            disables default transaction timeouts.
        </p><p>
            Unfortunately, imposing the same timeout as the transaction on a resource manager is not always appropriate.
            One
            example is that your business rules may require you to have control over the lifetimes on resource managers
            without allowing that control to be passed to some external entity. Narayana
            supports an all-or-nothing approach to
            whether or not method
            <code class="methodname">setTransactionTimeout</code>
            is called on
            <code class="interfacename">XAResource</code>
            instances.
        </p><p>
            If the
            <code class="varname">JTAEnvironmentBean.xaTransactionTimeoutEnabled</code>
            property is set to
            <code class="literal">true</code>
            , which is the default, it is called on all instances. Otherwise, use the
            <code class="methodname">setXATransactionTimeoutEnabled</code>
            method of
            <code class="interfacename">com.arjuna.ats.jta.common.Configuration</code>
            .
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2510"/>3.2.10. Dynamic registration</h3></div></div></div><p>
            Dynamic registration is not supported in
            <code class="interfacename">XAResource</code>
            . There are two reasons this
            makes sense.
        </p><div class="itemizedlist"><ul><li><p>
                    In the Java component-based application server environment, connections to the resource manager are acquired
                    dynamically when the application explicitly requests a connection. These resources are enlisted with
                    the
                    transaction manager on an as-needed basis.
                </p></li><li><p>
                    If a resource manager needs to dynamically register its work to the global transaction, you can implement this
                    at the resource adapter level via a private interface between the resource adapter and the underlying resource
                    manager.
                </p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2525"/>3.3. General Transaction Issues</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2528"/>3.3.1. Advanced transaction issues with TxCore</h3></div></div></div><p>
            Atomic actions (transactions) can be used by both application programmers and class
            developers. Thus entire
            operations (or parts of operations) can be made atomic as required by
            the
            semantics of a particular operation. This
            chapter will describe some of the more subtle
            issues
            involved with using transactions in general and TxCore in
            particular.

        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2533"/>3.3.1.1. Checking transactions</h4></div></div></div><p>
                In a multi-threaded application, multiple threads may be associated with a transaction
                during its lifetime,
                sharing the context. In addition, it is possible that if one thread
                terminates a transaction, other threads may
                still be active within it. In a distributed
                environment, it can be difficult to guarantee that all threads have
                finished with a
                transaction
                when it is terminated. By default, TxCore will issue a warning if a thread
                terminates
                a
                transaction when other threads are still active within it. However, it will allow
                the
                transaction termination to
                continue.
            </p><p>
                Other solutions to this problem are possible. One example would be to block the thread which
                is terminating the
                transaction until all other threads have disassociated themselves from the
                transaction context. Therefore, TxCore
                provides the
                <code class="classname">com.arjuna.ats.arjuna.coordinator.CheckedAction</code>
                class, which allows the thread
                or transaction termination policy to be overridden. Each
                transaction has an instance of this class associated with
                it, and application programmers can
                provide their own implementations on a per transaction basis.
            </p><div class="example"><a id="d0e2543"/><p class="title"><b>Example 3.5. 
                    Class
                    <code class="classname">CheckedAction</code>
                </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">CheckedAction</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">synchronized</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;check&nbsp;</span><span class="java_separator">(</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;isCommit</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">Uid</span><span class="java_plain">&nbsp;actUid</span><span class="java_separator">,</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Hashtable</span><span class="java_plain">&nbsp;list</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">};</span>
</pre></div></div><br class="example-break"/><p>
                When a thread attempts to terminate the transaction and there are active threads within it,
                the system will invoke
                the
                <code class="methodname">check</code>
                method on the transaction’s
                <code class="systemitem">CheckedAction</code>
                object. The
                parameters to the check method are:
            </p><div class="variablelist"><dl><dt><span class="term">isCommit</span></dt><dd><p>
                            Indicates whether the transaction is in the process of committing or rolling back.
                        </p></dd><dt><span class="term">actUid</span></dt><dd><p>
                            The transaction identifier.
                        </p></dd><dt><span class="term">list</span></dt><dd><p>
                            A list of all of the threads currently marked as active within this transaction.
                        </p></dd></dl></div><p>
                When
                <code class="methodname">check</code>
                returns, the transaction termination will continue. Obviously the state of the
                transaction at
                this point may be different from that when
                <code class="methodname">check</code>
                was called, e.g., the
                transaction may subsequently have been committed.
            </p><p>
                A
                <code class="classname">CheckedAction</code>
                instance is created for each transaction. As mentioned above, the default
                implementation
                simply
                issues warnings in the presence of multiple threads active on the transaction when it
                is
                terminated. However, a different instance can be provided to each transaction in one of
                the
                following ways:
            </p><div class="itemizedlist"><ul><li><p>
                        Use the
                        <code class="methodname">setCheckedAction</code>
                        method on the
                        <code class="classname">BasicAction</code>
                        instance.
                    </p></li><li><p>
                        Define an implementation of the
                        <code class="interfacename">CheckedActionFactory</code>
                        interface, which has a
                        single method
                        <code class="methodname">getCheckedAction</code>
                        (
                        <span class="type">final Uid</span>
                        <code class="varname">txId</code>
                        ,
                        <span class="type">final String</span>
                        <code class="varname">actionType</code>
                        ) that returns a
                        <code class="classname">CheckedAction</code>
                        . The factory class name can then be provided to the Transaction Service
                        at runtime by
                        setting the
                        <code class="varname">CoordinatorEnvironmentBean.checkedActionFactory</code>
                        property.
                    </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2628"/>3.3.1.2. Gathering statistics</h4></div></div></div><p>
                By default, the Transaction Service does not maintain any history information about
                transactions. However, by
                setting the
                <code class="varname">CoordinatorEnvironmentBean.enableStatistics</code>
                property variable to
                <code class="literal">YES</code>
                , the transaction service will maintain information about the number of transactions
                created,
                and their outcomes. This information can be obtained during the execution of a
                transactional
                application
                via the
                <code class="classname">com.arjuna.ats.arjuna.coordinator.TxStats</code>
                class.
            </p><div class="example"><a id="d0e2642"/><p class="title"><b>Example 3.6. 
                    Class
                    <code class="classname">TxStats</code>
                </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">TxStats</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;the&nbsp;number&nbsp;of&nbsp;transactions&nbsp;(top-level&nbsp;and&nbsp;nested)&nbsp;created&nbsp;so&nbsp;far.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;numberOfTransactions</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;the&nbsp;number&nbsp;of&nbsp;nested&nbsp;(sub)&nbsp;transactions&nbsp;created&nbsp;so&nbsp;far.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*</span>
</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;numberOfNestedTransactions();</span>
</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;the&nbsp;number&nbsp;of&nbsp;transactions&nbsp;which&nbsp;have&nbsp;terminated&nbsp;with&nbsp;heuristic</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outcomes.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;numberOfHeuristics</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;the&nbsp;number&nbsp;of&nbsp;committed&nbsp;transactions.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;numberOfCommittedTransactions</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;transactions&nbsp;which&nbsp;have&nbsp;rolled&nbsp;back.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;numberOfAbortedTransactions</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;total&nbsp;number&nbsp;of&nbsp;inflight&nbsp;(active)&nbsp;transactions.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="java_plain">&nbsp;&nbsp;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;numberOfInflightTransactions&nbsp;</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;total&nbsp;number&nbsp;of&nbsp;transactions&nbsp;rolled&nbsp;back&nbsp;due&nbsp;to&nbsp;timeout.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="java_plain">&nbsp;&nbsp;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;numberOfTimedOutTransactions&nbsp;</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;the&nbsp;number&nbsp;of&nbsp;transactions&nbsp;rolled&nbsp;back&nbsp;by&nbsp;the&nbsp;application.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="java_plain">&nbsp;&nbsp;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;numberOfApplicationRollbacks&nbsp;</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@return</span><span class="java_javadoc_comment">&nbsp;number&nbsp;of&nbsp;transactions&nbsp;rolled&nbsp;back&nbsp;by&nbsp;participants.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="java_plain">&nbsp;&nbsp;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">int</span><span class="java_plain">&nbsp;numberOfResourceRollbacks&nbsp;</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Print&nbsp;the&nbsp;current&nbsp;information.</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span class="java_plain">&nbsp;&nbsp;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;printStatus</span><span class="java_separator">(</span><span class="java_plain">java</span><span class="java_separator">.</span><span class="java_plain">io</span><span class="java_separator">.</span><span class="java_type">PrintWriter</span><span class="java_plain">&nbsp;pw</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>
                The class
                <code class="classname">ActionManager</code>
                gives further information about specific active transactions
                through the classes
                <code class="classname">getTimeAdded</code>
                , which returns the time (in milliseconds) when the
                transaction was created, and
                <code class="classname">inflightTransactions</code>
                , which returns the list of currently
                active transactions.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2661"/>3.3.1.3. Asynchronously committing a transaction</h4></div></div></div><p>
                By default, the Transaction Service executes the
                <code class="methodname">commit</code>
                protocol of a top-level
                transaction in a synchronous manner. All registered resources will be
                told to prepare in order by a single thread,
                and then they will be told to commit or
                rollback.
                This has several possible disadvantages:
            </p><div class="itemizedlist"><ul><li><p>
                        In the case of many registered resources, the
                        <code class="methodname">prepare</code>
                        operating can logically be
                        invoked in parallel on each resource. The disadvantage is that
                        if an “early” resource in the list of
                        registered resource forces a rollback during
                        <code class="methodname">prepare</code>
                        , possibly many prepare
                        operations will have been made needlessly.
                    </p></li><li><p>
                        In the case where heuristic reporting is not required by the application, the second
                        phase of the commit
                        protocol can be done asynchronously, since its success or failure is
                        not important.
                    </p></li></ul></div><p>
                Therefore, Narayana
                provides runtime options to enable possible threading
                optimizations. By
                setting the
                <code class="varname">CoordinatorEnvironmentBean.asyncPrepare</code>
                environment variable to
                <code class="literal">YES</code>
                , during the
                <code class="methodname">prepare</code>
                phase a separate thread will be created for
                each registered participant within the
                transaction.
                By setting
                <code class="varname">CoordinatorEnvironmentBean.asyncCommit</code>
                to
                <code class="literal">YES</code>
                , a separate thread will be
                created to complete the second phase of the transaction if
                knowledge about heuristics outcomes is not required.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2699"/>3.3.1.4. Transaction Logs</h4></div></div></div><p>Narayana
                supports a number of different transaction log implementations. They are
                outlined
                below.
            </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2704"/>3.3.1.4.1. The ActionStore</h5></div></div></div><p>This is the original version of the transaction log as provided in prior releases. It
                    is
                    simple but slow. Each transaction has an instance of its own log and they are all
                    written to
                    the same location in the file system
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2709"/>3.3.1.4.2. The HashedActionStore</h5></div></div></div><p>This implementation is based on the ActionStore but the individual logs are striped
                    across a number of sub-directories to improve performance. Check the Configuration Options
                    table for how to configure the HashedActionStore.
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e2714"/>3.3.1.4.3. LogStore</h5></div></div></div><p>This implementation is based on a traditional transaction log. All transaction states
                    within the same process (VM instance) are written to the same log (file), which is an
                    append-only entity. When transaction data would normally be deleted, e.g., at the end of
                    the
                    transaction, a delete record is added to the log instead. Therefore, the log just keeps
                    growing. Periodically a thread runs to prune the log of entries that have been deleted.
                </p><p>A log is initially given a maximum capacity beyond which it cannot grow. Once this is
                    reached the system will create a new log for transactions that could not be accommodated
                    in
                    the original log. The new log and the old log are pruned as usual. During the normal
                    execution of the transaction system there may be an arbitrary number of log instances.
                    These
                    should be garbage collected by the system (or the recovery sub-system) eventually.
                </p><p>Check the Configuration Options table for how to configure the LogStore.</p></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2723"/>3.4. Tools</h2></div></div></div><p>
        This chapter describes the various tools for managing transactions.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2728"/>3.4.1. ObjectStore command-line browsers and editors</h3></div></div></div><p>
            There are currently three command-line editors for manipulating the ObjectStore. These tools are used to
            manipulate the lists of heuristic participants maintained by a transaction log. They allow a heuristic
            participant to be moved from that list back to the list of prepared participants so that transaction recovery
            may attempt to resolve them automatically.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2733"/>3.4.1.1. Browse and Manage Transactions Using an Application Server</h4></div></div></div><p>
                The WildFly Application Server
                provides a command-line based Management CLI which supports the ability to browse and manipulate
                transaction records.
                This functionality is provided by the interaction between the Transaction Manager (TM) and the Management API of the
                application server.
                To start the CLI on a non-windows based OS type the following command in application server install directory:
            </p><pre class="screen">./bin/jboss-cli.sh --connect controller=IP_ADDRESS</pre><p>
                On Windows platforms use the jboss-cli.bat script
            </p><p>
                The transaction manager stores information about each active transaction, and the participants involved
                in the transaction, in a persistent storage area
                called the
                <em class="firstterm">object store</em>
                . The Management API exposes the object store as a resource called the
                <code class="code">log-store</code>
                .
                An API operation called
                <code class="code">probe</code>
                reads the transaction logs and creates a node in the management model corresponding to each log.
                These nodes can be inspected using the CLI. Transaction logs are transient so these nodes quickly become out of date but
                you can call the
                <code class="code">probe</code>
                command
                manually whenever you need to refresh the
                <code class="code">log-store</code>
                .
            </p><div class="example"><a id="refresh_log_store"/><p class="title"><b>Example 3.7. Refresh the Log Store</b></p><div class="example-contents"><p>
                    This command refreshes the Log Store for server groups which use the profile
                    <code class="literal">default</code>
                    in a managed domain.
                    For a standalone server, remove the
                    <code class="literal">profile=default</code>
                    from the command.
                </p><pre class="screen">/subsystem=transactions/log-store=log-store/:probe</pre></div></div><br class="example-break"/><div class="example"><a id="d0e2772"/><p class="title"><b>Example 3.8. View All Prepared Transactions</b></p><div class="example-contents"><p>
                    To view all prepared transactions, first refresh the log store (see
                    <a class="xref" href="#refresh_log_store" title="Example 3.7. Refresh the Log Store">Example 3.7, “Refresh the Log Store”</a>
                    ), then run the following command,
                    which functions similarly to a filesystem
                    <code class="command">ls</code>
                    command.
                </p><pre class="screen">ls /subsystem=transactions/log-store=log-store/transactions</pre><p>
                    Each transaction is shown, along with its unique identifier. Individual operations can be run
                    against an individual transaction
                    (see
                    <a class="xref" href="#manage_transaction" title="Manage a Transaction">Manage a Transaction</a>
                    ).
                </p></div></div><br class="example-break"/><div class="variablelist"><a id="manage_transaction"/><p class="title"><b>Manage a Transaction</b></p><dl><dt><span class="term">View a transaction's attributes.</span></dt><dd><p>
                            To view information about a transaction, such as its JNDI name, EIS product name and
                            version, or its status, use the
                            <code class="code">:read-resource</code>
                            CLI command.
                        </p><pre class="screen">/subsystem=transactions/log-store=log-store/transactions=<em class="replaceable"><code>0\:ffff7f000001\:-b66efc2\:4f9e6f8f\:9</code></em>:read-resource</pre></dd><dt><span class="term">View the participants of a transaction.</span></dt><dd><p>
                            Each transaction log contains a child element called
                            <code class="code">participants</code>
                            . Use the
                            <code class="code">read-resource</code>
                            CLI command on this element
                            to see the participants of the transaction. Participants are
                            identified by their JNDI names.
                        </p><pre class="screen">/subsystem=transactions/log-store=log-store/transactions=<em class="replaceable"><code>0\:ffff7f000001\:-b66efc2\:4f9e6f8f\:9</code></em>/participants=<em class="replaceable"><code>java\:\/JmsXA</code></em>:read-resource</pre><p>
                            The result may look similar to this:
                        </p><p>
                            </p><pre class="screen">
{
   "outcome" =&gt; "success",
   "result" =&gt; {
       "eis-product-name" =&gt; "HornetQ",
       "eis-product-version" =&gt; "2.0",
       "jndi-name" =&gt; "java:/JmsXA",
       "status" =&gt; "HEURISTIC",
       "type" =&gt; "/StateManager/AbstractRecord/XAResourceRecord"
   }
}
                        </pre><p>

                        </p><p>
                            The outcome status shown here is in a
                            <code class="code">HEURISTIC</code>
                            state and is eligible for recovery. Refer to
                            <a class="xref" href="#recover_transaction">Recover a transaction.</a>
                            for more details.
                        </p></dd><dt><span class="term">Delete a transaction.</span></dt><dd><p>
                            Each transaction log supports a
                            <code class="code">:delete</code>
                            operation, to delete the transaction log representing the transaction.
                        </p><pre class="screen">/subsystem=transactions/log-store=log-store/transactions=<em class="replaceable"><code>0\:ffff7f000001\:-b66efc2\:4f9e6f8f\:9</code></em>:delete</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>
                                If failures occur, transaction logs may remain in the object store until crash recovery facilities have resolved
                                the transactions they represent.
                                Therefore, it is very important that the contents of the object store are not deleted inadvertently, as this will make it
                                impossible to
                                resolve in-doubt transactions. In addition, if multiple users share the same object store, they must understand that it
                                is not an exclusive resource,
                                and not delete transaction logs without careful consideration.
                            </p></div></dd><dt><a id="recover_transaction"/><span class="term">Recover a transaction.</span></dt><dd><p>
                            Each transaction log supports recovery via the
                            <code class="code">:recover</code>
                            CLI command.
                        </p><div class="itemizedlist"><p class="title"><b>Recovery of Heuristic Transactions and Participants</b></p><ul><li><p>
                                    If the transaction's status is
                                    <code class="literal">HEURISTIC</code>
                                    , the recovery operation changes the state to
                                    <code class="literal">PREPARE</code>
                                    and
                                    triggers a recovery attempt.
                                </p></li><li><p>
                                    If one of the transaction participants is in a heuristic state, the recovery
                                    operation tries to replay the
                                    <code class="code">commit</code>
                                    operation.
                                    If successful, the participant is removed from the transaction log. You
                                    can verify this by re-running the
                                    <code class="code">:probe</code>
                                    operation on
                                    the
                                    <code class="code">log-store</code>
                                    and checking that the participant is no longer listed. If this is the last
                                    participant, the transaction is also
                                    deleted.
                                </p></li></ul></div></dd><dt><span class="term">Refresh the status of a transaction which needs recovery.</span></dt><dd><p>
                            If a transaction needs recovery, you can use the
                            <code class="code">:refresh</code>
                            CLI command to be sure it still requires recovery, before attempting the
                            recovery.
                        </p><pre class="screen">/subsystem=transactions/log-store=log-store/transactions=0\:ffff7f000001\:-b66efc2\:4f9e6f8f\:9:refresh</pre></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2900"/>3.4.1.2. LogEditor</h4></div></div></div><p>
                The LogEditor tool is started by executing the following command:
            </p><pre class="screen">
java -Dcom.arjuna.ats.arjuna.common.ObjectStoreEnvironmentBean.objectStoreDir="path to file based object store" com.arjuna.ats.arjuna.tools.log.LogBrowser
          </pre><p>
                This command works with the file based object store. If you want
                to work with the Hornetq store instead then you need to specify
                a different property for the location of the log store and you
                also need to explicity provide the class name of the
                Hornetq Object Store:
            </p><pre class="screen">
java -Dcom.arjuna.ats.internal.arjuna.objectstore.hornetq.HornetqJournalEnvironmentBean.storeDir="directory path" -Dcom.arjuna.ats.arjuna.common.ObjectStoreEnvironmentBean.objectStoreType="com.arjuna.ats.internal.arjuna.objectstore.hornetq.HornetqObjectStoreAdaptor"
          </pre><p>
                The tool supports the following options that can be provided on the command-line:
            </p><div class="table"><a id="d0e2913"/><p class="title"><b>Table 3.2. LogEditor Options</b></p><div class="table-contents"><table summary="LogEditor Options" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>
                                -tx
                                <em class="replaceable"><code>id</code></em>
                            </td><td>
                                <p>Specifies the transaction log to work on.</p>
                            </td></tr><tr><td>
                                -type
                                <em class="replaceable"><code>name</code></em>
                            </td><td>
                                <p>The transaction type to work on.</p>
                            </td></tr><tr><td>-dump</td><td>
                                <p>Print out the contents of the log identified by the other options.</p>
                            </td></tr><tr><td>
                                -forget
                                <em class="replaceable"><code>index</code></em>
                            </td><td>
                                <p>Move the specified target from the heuristic list to the prepared list.</p>
                            </td></tr><tr><td>-help</td><td>
                                <p>Print out the list of commands and options.</p>
                            </td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2975"/>3.4.1.3. LogBrowser</h4></div></div></div><p>
                The LogBrowser, invoked by calling
                <code class="methodname">com.arjuna.ats.arjuna.tools.log.LogBrowser</code>
                , is
                similar to the LogEditor, but allows multiple log instances to be manipulated. It presents a shell-like
                interface, with the following options:
            </p><div class="table"><a id="d0e2983"/><p class="title"><b>Table 3.3. LogBrowserOptions</b></p><div class="table-contents"><table summary="LogBrowserOptions" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>
                                ls [
                                <em class="replaceable"><code>type</code></em>
                                ]
                            </td><td>
                                <p>List the logs for the specified type. If no type is specified, the editor must
                                    already be
                                    attached to the transaction type.
                                </p>
                            </td></tr><tr><td>
                                select [
                                <em class="replaceable"><code>type</code></em>
                                ]
                            </td><td>
                                <p>Browse a specific transaction type. If already attached to a transaction type, you
                                    are
                                    detached from that type first.
                                </p>
                            </td></tr><tr><td>
                                attach
                                <em class="replaceable"><code>log</code></em>
                            </td><td>
                                <p>Attach the console to the specified transaction log. If you are attached to
                                    another log,
                                    the command will fail.
                                </p>
                            </td></tr><tr><td>detach</td><td>
                                <p>Detach the console from the current log.</p>
                            </td></tr><tr><td>
                                forget
                                <em class="replaceable"><code>pid</code></em>
                            </td><td>
                                <p>
                                    Move the specified heuristic participant back to the
                                    <code class="systemitem">prepared</code>
                                    list. The console must be attached.
                                </p>
                            </td></tr><tr><td>
                                delete
                                <em class="replaceable"><code>pid</code></em>
                            </td><td>
                                <p>Delete the specified heuristic participant. The console must be attached.</p>
                            </td></tr><tr><td>types</td><td>
                                <p>List the supported transaction types.</p>
                            </td></tr><tr><td>quit</td><td>
                                <p>Exit the console tool.</p>
                            </td></tr><tr><td>help</td><td>
                                <p>Print out the supported commands.</p>
                            </td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3086"/>3.4.2. GUI Based Tools</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3089"/>3.4.2.1. Embedded Console</h4></div></div></div><p>
                Transaction management is integrated into the WildFly Application Server.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3094"/>3.4.2.2. Performance Graphing</h4></div></div></div><p>
                There is a transaction statistics graphing tool which can run standalone or inside a
                jconsole tab (jconsole is a tool for managing JVMs and is distributed with the reference JDK):
            </p><p>
                The tool depends on the JFree graphing library. Download and unpack orson from
                http://www.jfree.org/orson.
                Set the env variable ORSON_HOME to the directory where you plan to unpack the downloaded zip.
                If you intend to use the tool with jconsole you will also need to put the JDK tools and
                jconsole jars on the classpath:
            </p><pre class="screen">
export CLASSPATH="$JDK_HOME/lib/tools.jar:$JDK_HOME/lib/jconsole.jar:$ORSON_HOME/orson-0.5.0.jar:$ORSON_HOME/lib/jfreechart-1.0.6.jar:$ORSON_HOME/lib/jcommon-1.0.10.jar:$INSTALL_ROOT/lib/narayana-jta.jar&gt;"
        </pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e3103"/>3.4.2.2.1. Standalone Usage</h5></div></div></div><pre class="screen">
java com.arjuna.ats.arjuna.tools.stats.TxPerfGraph
        </pre><p>
                    (note that standalone usage does not require the JDK tools and jconsole jars)
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e3110"/>3.4.2.2.2. Usage with jconsole</h5></div></div></div><pre class="screen">
jconsole -J-Djava.class.path="$CLASSPATH" -pluginpath $INSTALL_ROOT/lib/narayana-jta.jar
        </pre><p>
                    This command will launch the jconsole GUI in which there will be an
                    extra tab for displaying transaction performance statistics.
                </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3117"/>3.4.3. View Transaction Statistics using an Application Server</h3></div></div></div><p>
            If you are using the Transaction Manager (TM) inside the WildFly Application Server
            and if the TM statistics are enabled, then
            you can view statistics about the TM and transaction subsystem using
            tools provide by the application server.
        </p><p>
            You can view statistics either via the web-based Management Console or the command-line Management CLI. In
            the web-based Management Console, Transaction statistics are available via
            <span class="guimenu"><strong>Runtime</strong></span> → <span class="guimenuitem"><strong>Subsystem Metrics</strong></span> → <span class="guimenuitem"><strong>Transactions</strong></span>
            . Transaction statistics are available for each server in a managed domain, as well. You can specify the
            server in the
            <span class="guilabel"><strong>Server</strong></span>
            selection box at the top left.
        </p><p>
            The following table shows each available statistic, its description, and the CLI command to view the statistic.
        </p><div class="table"><a id="d0e3137"/><p class="title"><b>Table 3.4. Transaction Subsystem Statistics</b></p><div class="table-contents"><table summary="Transaction Subsystem Statistics" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>
                            Statistic
                        </th><th>
                            Description
                        </th><th>
                            CLI Command
                        </th></tr></thead><tbody><tr><td>
                            Total
                        </td><td>
                            <p>
                                The total number of transactions processed by the TM on this server.
                            </p>
                        </td><td>
                            <pre class="screen">/subsystem=transactions/:read-attribute(name=number-of-transactions,include-defaults=true)</pre>
                        </td></tr><tr><td>
                            Committed
                        </td><td>
                            <p>
                                The number of committed transactions processed by the TM on this server.
                            </p>
                        </td><td>
                            <pre class="screen">/subsystem=transactions/:read-attribute(name=number-of-committed-transactions,include-defaults=true)</pre>
                        </td></tr><tr><td>
                            Aborted
                        </td><td>
                            <p>
                                The number of aborted transactions processed by the TM on this server.
                            </p>
                        </td><td>
                            <pre class="screen">/subsystem=transactions/:read-attribute(name=number-of-aborted-transactions,include-defaults=true)</pre>
                        </td></tr><tr><td>
                            Timed Out
                        </td><td>
                            <p>
                                The number of timed out transactions processed by the TM on this server.
                            </p>
                        </td><td>
                            <pre class="screen">/subsystem=transactions/:read-attribute(name=number-of-timed-out-transactions,include-defaults=true)</pre>
                        </td></tr><tr><td>
                            Heuristics
                        </td><td>
                            <p>
                                Not available in the Management Console. Number of transactions in a heuristic state.
                            </p>
                        </td><td>
                            <pre class="screen">/subsystem=transactions/:read-attribute(name=number-of-heuristics,include-defaults=true)</pre>
                        </td></tr><tr><td>
                            In-Flight Transactions
                        </td><td>
                            <p>
                                Not available in the Management Console. Number of transactions which have begun but not yet terminated.
                            </p>
                        </td><td>
                            <pre class="screen">/subsystem=transactions/:read-attribute(name=number-of-inflight-transactions,include-defaults=true)</pre>
                        </td></tr><tr><td>
                            Failure Origin - Applications
                        </td><td>
                            <p>
                                The number of failed transactions whose failure origin was an application.
                            </p>
                        </td><td>
                            <pre class="screen">/subsystem=transactions/:read-attribute(name=number-of-application-rollbacks,include-defaults=true)</pre>
                        </td></tr><tr><td>
                            Failure Origin - Resources
                        </td><td>
                            <p>
                                The number of failed transactions whose failure origin was a resource.
                            </p>
                        </td><td>
                            <pre class="screen">/subsystem=transactions/:read-attribute(name=number-of-resource-rollbacks,include-defaults=true)</pre>
                        </td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3254"/>3.5. Configuration options</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3257"/>3.5.1. Loading a configuration</h3></div></div></div><p>
            Each module of the system contains a
            <code class="classname">
                <em class="replaceable"><code>module</code></em>
                propertyManager
            </code>
            class., which provides static getter methods for one or more
            <code class="classname">
                <em class="replaceable"><code>name</code></em>
                EnvironmentBean
            </code>
            classes. An example is
            <code class="classname">com.arjuna.ats.arjuna.commmon.arjPropertyManager</code>
            . These environment beans are standard
            JavaBean containing properties for each configuration option in the
            system. Typical usage is of the form:
        </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_type">int</span><!-- <br/> --><span class="java_plain">&nbsp;defaultTimeout&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;arjPropertyManager</span><span class="java_separator">.</span><span class="java_plain">getCoordinatorEnvironmentBean</span><span class="java_separator">().</span><span class="java_plain">getDefaultTimeout</span><span class="java_separator">();</span>
</pre><p>
            These beans are singletons, instantiated upon first access, using the following algorithm.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="procedure"><a id="d0e3281"/><p class="title"><b>Procedure 3.2. Algorithm for environment bean instantiation</b></p><ol class="1"><li><p>
                    The properties are loaded and populated from a properties file named and located as follows:
                </p><ol class="a"><li><p>
                            If the properties file name property is set (
                            <code class="methodname">com.arjuna.ats.arjuna.common.propertiesFile</code>
                            ), its value is used as the file name.
                        </p></li><li><p>
                            If not, the default file name is used.
                        </p></li></ol></li><li><p>
                    The file thus named is searched for by, in order
                </p><div class="orderedlist"><ol><li><p>
                            absolute path
                        </p></li><li><p>
                            user.dir
                        </p></li><li><p>
                            user.home
                        </p></li><li><p>
                            java.home
                        </p></li><li><p>
                            directories contained on the classpath
                        </p></li><li><p>
                            a default file embedded in the product .jar file.
                        </p></li></ol></div></li><li><p>
                    The file is treated as being of standard java.util.Properties xml format and loaded accordingly.
                    The
                    entry names are of the form EnvironmentBeanClass.propertyName:
                    <code class="code">&lt;entry
                        key="CoordinatorEnvironmentBean.commitOnePhase"&gt;YES&lt;/entry&gt;</code>
                    or
                    EnvironmentBeanClass.&lt;storeType&gt;propertyName:
                    <code class="code">&lt;entry
                        key="ObjectStoreEnvironmentBean.communicationStore.objectStoreType"&gt;com.arjuna.ats.internal.arjuna.objectstore.VolatileStore&lt;/entry&gt;
                    </code>
                    The second form is required if you want to set properties on configuration beans other that the
                    default bean instances.
                    Valid values for Boolean properties are case-insensitive, and may be one of:
                </p><div class="itemizedlist"><ul><li><p>
                            NO
                        </p></li><li><p>
                            YES
                        </p></li><li><p>
                            FALSE
                        </p></li><li><p>
                            TRUE
                        </p></li><li><p>
                            OFF
                        </p></li><li><p>
                            ON
                        </p></li></ul></div><p>
                    In the case of properties that take multiple values, they are white-space-delimited.
                </p><div class="example"><a id="d0e3349"/><p class="title"><b>Example 3.9. Example Environment Bean</b></p><div class="example-contents"><pre xmlns="" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">entry</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;RecoveryEnvironmentBean.recoveryModuleClassNames&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;com.arjuna.ats.internal.arjuna.recovery.AtomicActionRecoveryModule</span><br />
<span class="xml_plain">&nbsp;&nbsp;com.arjuna.ats.internal.txoj.recovery.TORecoveryModule</span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">entry</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/></li><li><p>
                    After the file is loaded, it is cached and is not re-read until the JVM is restarted. Changes to
                    the
                    properties file require a restart in order to take effect.
                </p></li><li><p>
                    After the properties are loaded, the EnvironmentBean is then inspected and, for each field, if the
                    properties
                    contains a matching key in the search order as follows, the
                    <code class="methodname">setter</code>
                    method for that field is invoked with the
                    value from the properties, or the system properties if
                    different.
                </p><div class="itemizedlist"><ul><li><p>
                            Fully.Qualified.NameEnvironmentBean.propertyName
                        </p></li><li><p>
                            NameEnvironmentBean.propertyName (this is the preferred form used in the properties file)
                        </p></li><li><p>
                            the old com.arjuna... properties key (deprecated, for backwards compatibility only).
                        </p></li></ul></div></li><li><p>
                    The bean is then returned to the caller, which may further override values by calling setter
                    methods.
                </p></li></ol></div><p>
            The implementation reads most bean properties only once, as the consuming component or class is
            instantiated. This
            usually happens the first time a transaction is run. As a result, calling
            <code class="methodname">setter</code>
            methods
            to change the value of bean properties while the system is running typically has no effect, unless it
            is done
            prior to any use of the transaction system. Altered bean properties are not persisted back to the
            properties file.
        </p><p>
            You can configure the system using a bean wiring system such as JBoss Microcontainer or Spring. Take care
            when
            instantiating beans, to obtain the singleton via the static getter (factory) method on the module
            property
            manager. Using a new bean instantiated with the default constructor is ineffective, since it is not
            possible
            to
            pass this configured bean back to the property management system.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3383"/>3.5.2. ArjunaCore Options</h3></div></div></div><p>
            The canonical reference for configuration options is the Javadoc of the various
            <code class="classname">EnvironmentBean</code>
            classes, For ArjunaCore these are:
        </p><div class="itemizedlist"><ul><li><p>
                    <code class="classname">com.arjuna.common.internal.util.logging.LoggingEnvironmentBean.java </code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.common.internal.util.logging.basic.BasicLogEnvironmentBean.java </code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.ats.txoj.common.TxojEnvironmentBean.java </code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.ats.arjuna.common.CoordinatorEnvironmentBean.java </code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.ats.arjuna.common.ObjectStoreEnvironmentBean.java </code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.ats.arjuna.common.RecoveryEnvironmentBean.java </code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.ats.arjuna.common.CoreEnvironmentBean.java </code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.ats.internal.arjuna.objectstore.hornetq.HornetqJournalEnvironmentBean.java
                    </code>
                </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3440"/>3.5.3. Narayana
            JTA Configuration options
        </h3></div></div></div><p>
            The canonical reference for configuration options is the javadoc of the various EnvironmentBean classes. For
      Narayana
            JTA, these classes are the ones provided by ArjunaCore, as well as:
        </p><div class="itemizedlist"><ul><li><p>
                    <code class="classname">com.arjuna.ats.jdbc.common.JDBCEnvironmentBean.java</code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.ats.jta.common.JTAEnvironmentBean.java</code>
                </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3458"/>3.5.4. Narayana
            JTS Options
        </h3></div></div></div><p>
            The canonical reference for configuration options is the javadoc of the various
            <code class="classname">EnvironmentBean</code>
            classes, For Narayana
            JTS these are the ones
            provided by ArjunaCore, as well as:
        </p><div class="itemizedlist"><ul><li><p>
                    <code class="classname">com.arjuna.orbportability.common.OrbPortabilityEnvironmentBean.java</code>
                </p></li><li><p>
                    <code class="classname">com.arjuna.ats.jts.common.JTSEnvironmentBean.java</code>
                </p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3479"/>3.6. Important Log Messages</h2></div></div></div><p>The transaction manager can generate a lot of logging information when configured to log in trace level.
        Here is a list of some of the log messages to check for.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3484"/>3.6.1. Transaction State Change</h3></div></div></div><p> The following table  </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>Transaction Begin</td><td>
                            <p>When a transaction begins the following code is executed:</p>
                            <p>com.arjuna.ats.arjuna.coordinator.BasicAction::Begin:1342</p>
                            <p>tsLogger.logger.trace("BasicAction::Begin() for action-id "+ get_uid());</p>
                        </td></tr><tr><td>Transaction Commit</td><td>
                            <p>When a transaction commits the following code is executed:</p>
                            <p>com.arjuna.ats.arjuna.coordinator.BasicAction::End:1342</p>
                            <p>tsLogger.logger.trace("BasicAction::End() for action-id "+ get_uid());</p>
                        </td></tr><tr><td>Transaction Rollback</td><td>
                            <p>When a transaction commits the following code is executed:</p>
                            <p>com.arjuna.ats.arjuna.coordinator.BasicAction::Abort:1575</p>
                            <p>tsLogger.logger.trace("BasicAction::Abort() for action-id "+ get_uid());</p>
                        </td></tr><tr><td>Transaction Timeout</td><td>
                            <p>When a transaction times out the following code is executed:</p>
                            <p>com.arjuna.ats.arjuna.coordinator.TransactionReaper::doCancellations:349</p>
                            <p>tsLogger.logger.trace("Reaper Worker " + Thread.currentThread() + " attempting to
                                cancel " + e._control.get_uid());</p>
                            <p>You will then see the same thread rolling back the transaction as shown above</p>
                        </td></tr></tbody></table></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>There are many more logging messages to check for, above are those that we are often asked about.
            </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3554"/>3.7. Troubleshooting</h2></div></div></div><p>
        This chapter covers issues that you may hit when developing applications with Narayana.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3559"/>3.7.1. WS-BA Participant-Completion Race Condition</h3></div></div></div><p>
            The WS-BA participant-completion protocol has a benign race condition that, in unusual circumstances, can
            cause some Business Activities to be cancelled that would have otherwise been able to close. This is safe as
            no inconsistency arrises, but it can be annoying for users. This section explains why this can happen, under
            what conditions, and what you can do to tolerate it.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3564"/>3.7.1.1. What's happening, in a nutshell</h4></div></div></div><p>
                Imagine a scenario where the client begins a business activity and then invokes a Web service. If the
                Web service uses participant completion, it will notify the coordinator when it has completed its work
                and then return control to the client. This notification is asynchronous, so it's possible that the
                client will then ask the coordinator to close the activity before the coordinator processes (or even
                receives) the completed notification from the participant. In this situation the coordinator will cancel
                the activity as not all participants (from its perspective) have completed their work. As a result all
                completed participants are compensated (including, eventually, the participant with the late 'completed'
                notification) and the client receives a "TransactionRolledBackException".
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3569"/>3.7.1.2. When is it most likely to happen?</h4></div></div></div><p>
                Typically this happens when the client, coordinator and participant are running inside the same VM.
                This
                scenario is unlikely to happen in production, but can happen regularly during development where a
                single
                VM is used to keep things simple.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3574"/>3.7.1.3. How do I know if this is affecting my application?</h4></div></div></div><p>
                If the client is occasionally receiving a TransactionRolledbackException when calling
                UserBusinessActivity#close(), but none of the machines involved in running the transaction have crashed,
                you could be affected by this. Especially if you are running the client, coordinator and participant(s)
                in the same server.
            </p><p>
                The following log message will help you identify this issue:
            </p><div class="example"><a id="d0e3581"/><p class="title"><b>Example 3.10. Example Environment Bean</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">WARN [com.arjuna.mw.wstx] (TaskWorker-2) ARJUNA045062: Coordinator cancelled the activity</pre></div></div><br class="example-break"/><p>
                This is only an indication that you are seeing this issue as the coordinator can elect to cancel the
                activity for other reasons. For example, network problems might mean the coordinator cannot tell the web
                service to close the activity.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3588"/>3.7.1.4. Why can't it be avoided?</h4></div></div></div><p>
                For the protocol to avoid this issue, it would need to make the complete message synchronous,
                throttling
                throughput by slowing down both the participant and coordinator and holding sockets open for
                longer.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3593"/>3.7.1.5. What can the application do to tolerate this?</h4></div></div></div><p>
                A real, distributed deployment will rarely see this problem because communication latency between
                client, participant and coordinator will dominate the race condition. Even if it does happen your
                application should tolerate it. Transaction rollbacks and activity cancelations are inevitable in a
                distributed environment and can happen for many reasons. When handling TransactionRolledBack exceptions
                you can either retry the Transaction/Activity or notify the caller of the failure. What you choose to do
                will depend on the requirements of your application.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3598"/>3.7.1.6. Why exactly does this happen?</h4></div></div></div><p>
                First consider the following client code:
            </p><div class="example"><a id="d0e3603"/><p class="title"><b>Example 3.11. Client Code Example</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_type">UserBusinessActivity</span><span class="java_plain">&nbsp;uba&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">UserBusinessActivityFactory</span><span class="java_separator">.</span><span class="java_plain">userBusinessActivity</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">uba</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">myWebServiceClient</span><span class="java_separator">.</span><span class="java_plain">invoke</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">uba</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div></div><br class="example-break"/><p>
                The client code is very simple, it just begins a business activity, invokes a Web service and then
                closes the business activity. The Web service uses the Participant-Completion protocol and so notifies
                the coordinator of completion just before returning control to the client.
            </p><p>
                Here's a diagram showing the pertinent message exchanges that occur under a normal situation.
            </p></div><div class="figure"><a id="fig-pcp-race-success"/><div class="figure-contents"><div class="mediaobject"><img src="images/fig-pcp-race-success.png" alt="Successful close of activity"/></div></div><p class="title"><b>Figure 3.1. Successful close of activity</b></p></div><br class="figure-break"/><p>The messages are numbered to indicate the order in which they are sent:</p><div class="itemizedlist"><ul><li><p>
                    1. request. This represents the application request made by the client.
                </p></li><li><p>
                    2. completed. After the participant has completed its work, it notifies the coordinator that it
                    has
                    completed.
                </p></li><li><p>
                    3. response. This represents the response to the client's application request.
                </p></li><li><p>
                    4. close. The client notifies the coordinator that it wishes to close the activity. It then waits
                    for a 'closed' or failure response from the coordinator.
                </p></li><li><p>
                    5a. close/5b. closed. The coordinator has processed the '2.completed' message so can close the
                    activity. It starts by sending the 'close' message to the participant and waits for the 'closed'
                    response as confirmation. These two messages are asynchronous.
                </p></li><li><p>
                    6. closed. The coordinator now has all 'closed' acknowledgments so notifies the client that the
                    activity successfully closed.
                </p></li></ul></div></div><p>
        Messages '2.completed' and '4.close' are asynchronous (or 'one way' in Web services parlance) so effectively,
        there is a race condition with the following competing parties:
    </p><div class="itemizedlist"><ul><li><p>Party 1. The completed message '2.completed'.</p></li><li><p>Party 2. The response '3.response' followed by '4.close'.</p></li></ul></div><p>
        When running in the same VM, or on a low latency network, '3.response' will be sent very quickly. This is
        because it is simply travelling on the HTTP response over an already open socket. This just leaves messages
        '2.completed' and '4.close' which will take much longer relative to '3.response'. To understand this, lets take
        a look at what happens when an asynchronous Web service call is made:
    </p><div class="itemizedlist"><ul><li><p>1. The client sends the message to the Web service.</p></li><li><p>2. The server-side SOAP stack uses an existing thread from a pool dedicated to receiving SOAP
                messages.
            </p></li><li><p>3. As the service is asynchronous, the message will be passed to another thread to be processed.
            </p></li><li><p>4. The receiving thread will now return the HTTP response.</p></li></ul></div><p>
        The race condition occurs because steps 1-3 can happen relatively quickly in a single VM, and thus it's likely
        that both messages 2 and 4, will be waiting to be processed at the same time. The order in which they are
        processed is dependent on the implementation of the thread pool and is also at the mercy of thread scheduling in
        the VM, so it's possible that either could be processed first.
    </p><p>
        This race condition is much less likely to happen in a distributed environment as the network costs will be
        significantly higher. As a result message '3.response' will take long enough to send, so as to give message
        '2.completed' enough of a head start. But it is still possible so the client application must be coded
        defensively to catch and handle a TransactionRollbackException. The client code ought to be doing this anyway to
        deal with server crashes.
    </p><p>
        The following diagram shows what messages are exchanged when the race condition occurs. Notice that the
        activity ends in a consistent state.
    </p><div class="figure"><a id="fig-pcp-race-failure"/><div class="figure-contents"><div class="mediaobject"><img src="images/fig-pcp-race-failure.png" alt="Failure to close the activity"/></div></div><p class="title"><b>Figure 3.2. Failure to close the activity</b></p></div><br class="figure-break"/><p>
        Messages 1-3 are omitted from the following explanation as they are the same as in the success case.
    </p><div class="itemizedlist"><ul><li><p>4. close. This message is processed by the coordinator before message '2.completed'</p></li><li><p>5a. cancel. The coordinator has not yet processed the '2.completed' message so cannot close the
                activity. The coordinator then sends a 'cancel' message to the participant as it thinks it has not yet
                completed. This message and subsequent retires, are dropped by the participant as they are not valid for
                a completed participant.
            </p></li><li><p>5b. compensate/5c. compensated. After one or more unacknowledged 'cancel' messages, the coordinator
                switches to sending 'compensate' messages which will cause the participant to compensate the work. The
                participant acknowledges with a 'compensated' reply.
            </p></li><li><p>6. Transaction rolledback exception. The coordinator notifies the client that the activity failed to
                close.
            </p></li></ul></div><p>As you can see from the steps above, when this race condition arises, any work done by participants is
        compensated and the client is notified of the outcome. Thus a consistent outcome is achieved.
    </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3692"/>Chapter 4. XTS Guide</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e3695">4.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3822">4.1.1. Managing service-Based Processes</a></span></dt><dt><span class="section"><a href="#d0e3842">4.1.2. Servlets</a></span></dt><dt><span class="section"><a href="#d0e3854">4.1.3. SOAP</a></span></dt><dt><span class="section"><a href="#d0e3862">4.1.4. Web Services Description Language (WDSL)</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3870">4.2. Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3887">4.2.1. Enable
            XTS on WildFly Application Server
        </a></span></dt><dt><span class="section"><a href="#d0e3940">4.2.2. Working With WS-AT</a></span></dt><dt><span class="section"><a href="#d0e4053">4.2.3. Working With WS-BA</a></span></dt><dt><span class="section"><a href="#ref-TransactionContextPropagation">4.2.4. Configuration of The Transaction Context Propagation</a></span></dt><dt><span class="section"><a href="#d0e4181">4.2.5. Summary</a></span></dt></dl></dd><dt><span class="section"><a href="#sec-xts-api">4.3. The XTS API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4253">4.3.1. Participants</a></span></dt><dt><span class="section"><a href="#d0e4328">4.3.2. API for the Atomic Transaction Protocol</a></span></dt><dt><span class="section"><a href="#d0e4879">4.3.3. API for the Business Activity Protocol</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5401">4.4. Stand-Alone Coordination</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5413">4.4.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e5438">4.4.2. Configuring the Activation Coordinator</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5617">4.5. Participant Crash Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5664">4.5.1. WS-AT Recovery</a></span></dt><dt><span class="section"><a href="#d0e5914">4.5.2. WS-BA Recovery</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6176">4.6. Web Service Transaction Service (XTS) Management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6181">4.6.1. Transaction manager overview</a></span></dt><dt><span class="section"><a href="#d0e6189">4.6.2. Configuring the transaction manager</a></span></dt><dt><span class="section"><a href="#d0e6208">4.6.3. Deployment descriptors</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6216">4.7. Quickstarts Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#ref-WSATMultiService">4.7.1. WS-AT Multi-Service</a></span></dt><dt><span class="section"><a href="#ref-WSATMultiHop">4.7.2. WS-AT Multi-Hop</a></span></dt><dt><span class="section"><a href="#d0e6249">4.7.3. XTS with SSL</a></span></dt><dt><span class="section"><a href="#d0e6258">4.7.4. Raw XTS API Demo</a></span></dt><dt><span class="section"><a href="#ref-CompensationsNonTransactionalResource">4.7.5. Non-transactional Resource with Compensating Transactions API</a></span></dt><dt><span class="section"><a href="#ref-CompensationsTravelAgent">4.7.6. Travel Agent with Compensating Transactions API</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3695"/>4.1. Introduction</h2></div></div></div><a id="d0e3698" class="indexterm"/><a id="d0e3703" class="indexterm"/><a id="d0e3706" class="indexterm"/><a id="d0e3709" class="indexterm"/><a id="d0e3714" class="indexterm"/><a id="d0e3719" class="indexterm"/><a id="d0e3724" class="indexterm"/><a id="d0e3729" class="indexterm"/><a id="d0e3732" class="indexterm"/><a id="d0e3735" class="indexterm"/><a id="d0e3738" class="indexterm"/><a id="d0e3743" class="indexterm"/><a id="d0e3746" class="indexterm"/><a id="d0e3751" class="indexterm"/><a id="d0e3756" class="indexterm"/><a id="d0e3761" class="indexterm"/><p>
        The
        <em class="firstterm">XML Transaction Service (XTS)</em>
        component of Narayana
        supports the
        coordination of private and public Web Services in a business transaction. Therefore, to understand XTS, you must be
        familiar with Web Services, and also understand something about transactions. This chapter introduces XTS and
        provides a brief overview of the technologies that form the Web Services standard. Additionally, this chapter
        explores some of the fundamentals of transactioning technology and how it can be applied to Web Services. Much of
        the content presented in this chapter is detailed throughout this guide. However, only overview information about
        Web Services is provided. If you are new to creating Web services, please consult your Web Services platform
        documentation.
    </p><p>
    Narayana
        provides the XTS component as a transaction solution for Web Services. Using XTS, business
        partners can coordinate complex business transactions in a controlled and reliable manner. The XTS API supports a
        transactional coordination model based on the
        <em class="firstterm">WS-Coordination</em>
        ,
        <em class="firstterm">WS-Atomic
            Transaction
        </em>
        , and
        <em class="firstterm">WS-Business Activity</em>
        specifications.
    </p><div class="itemizedlist"><a id="protocol-spec-list"/><p class="title"><b>Protocols Included in XTS</b></p><ul><li><p>WS-Coordination (WS-C) is a generic coordination framework developed by IBM, Microsoft and BEA.</p></li><li><p>WS-Atomic Transaction (WS-AT) and WS-Business Activity (WS-BA) together comprise the WS-Transaction
                (WS-T) transaction protocols that utilize this framework.
            </p></li></ul></div><p>
    Narayana
        implements versions 1.1, and 1.2 of these three specifications. Version
        specifications are available from
        <a class="ulink" href="http://www.oasis-open.org/specs/">http://www.oasis-open.org/specs/</a>
        .
    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
            The 1.1, and 1.2 specifications only differ in a small number of details. The rest of this document employs
            version 1.1 of these specifications when providing explanations and example code. On the few occasions where the
            modifications required to adapt these to the 1.1 specifications are not obvious, an explanatory note is
            provided.
        </p></div><p>
        <em class="firstterm">Web Services</em>
        are modular, reusable software components that are created by exposing business
        functionality through a Web service interface. Web Services communicate directly with other Web Services using
        standards-based technologies such as SOAP and HTTP. These standards-based communication technologies enable
        customers, suppliers, and trading partners to access Web Services, independent of hardware operating system, or
        programming environment. The result is a vastly improved collaboration environment as compared to today's EDI and
        <em class="firstterm">business-to-business (B2B)</em>
        solutions, an environment where businesses can expose their
        current and future business applications as Web Services that can be easily discovered and accessed by external
        partners.
    </p><p>
        Web Services, by themselves, are not fault-tolerant. In fact, some of the reasons that the Web Services model is an
        attractive development solution are also the same reasons that service-based applications may have drawbacks.
    </p><div class="itemizedlist"><p class="title"><b>Properties of Web Services</b></p><ul><li><p>Application components that are exposed as Web Services may be owned by third parties, which provides
                benefits in terms of cost of maintenance, but drawbacks in terms of having exclusive control over their
                behavior.</p></li><li><p>Web Services are usually remotely located, increasing risk of failure due to increased network
                travel for invocations.
            </p></li></ul></div><p>
        Applications that have high dependability requirements need a method of minimizing the effects of errors that
        may
        occur when an application consumes Web Services. One method of safeguarding against such failures is to interact
        with an application’s Web Services within the context of a
        <em class="firstterm">transaction</em>
        . A transaction is a
        unit of work which is completed entirely, or in the case of failures is reversed to some agreed consistent
        state. The goal, in the event of a failure, is normally to appear as if the work had never occurred in the first
        place. With XTS, transactions can span multiple Web Services, meaning that work performed across multiple
        enterprises can be managed with transactional support.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3822"/>4.1.1. Managing service-Based Processes</h3></div></div></div><p>
            XTS allows you to create transactions that drive complex business processes, spanning multiple Web
            Services. Current Web Services standards do not address the requirements for a high-level coordination of
            services. This is because in today’s Web Services applications, which use single request/response interactions,
            coordination is typically not a problem. However, for applications that engage multiple services among multiple
            business partners, coordinating and controlling the resulting interactions is essential. This becomes even more
            apparent when you realize that you generally have little in the way of formal guarantees when interacting with
            third-party Web Services.
        </p><p>
            XTS provides the infrastructure for coordinating services during a business process. By organizing processes
            as
            transactions, business partners can collaborate on complex business interactions in a reliable manner, insuring
            the integrity of their data - usually represented by multiple changes to a database – but without the usual
            overheads and drawbacks of directly exposing traditional transaction-processing engines directly onto the
            web.
            <a class="xref" href="#example-application" title="An Evening On the Town">An Evening On the Town</a>
            demonstrates how an application may manage service-based processes as
            transactions:
        </p><p class="formalpara"><a id="example-application"/></p><h5 xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="formalpara">An Evening On the Town</h5><p class="formalpara">
                The application in question allows a user to plan a social evening. This application is responsible for reserving a
                table at a restaurant, and reserving tickets to a show. Both activities are paid for using a credit
                card. In this
                example, each service represents exposed Web Services provided by different service providers. XTS is used to envelop
                the interactions between the theater and restaurant services into a single (potentially) long-running business
                transaction. The business transaction must insure that seats are reserved both at the restaurant and the
                theater. If
                one event fails the user has the ability to decline both events, thus returning both services back to their original
                state. If both events are successful, the user’s credit card is charged and both seats are booked. As
                you may expect,
                the interaction between the services must be controlled in a reliable manner over a period of time. In addition,
                management must span several third-party services that are remotely deployed.
            </p><p>
            Without the backing of a transaction, an undesirable outcome may occur. For example, the user credit card may be
            charged, even if one or both of the bookings fail.
        </p><p>
            <a class="xref" href="#example-application" title="An Evening On the Town">An Evening On the Town</a>
            describes the situations where XTS excels at supporting business processes
            across multiple enterprises. This example is further refined throughout this guide, and appears as a standard
            demonstrator (including source code) with the XTS distribution.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3842"/>4.1.2. Servlets</h3></div></div></div><p>
            The WS-Coordination, WS-Atomic Transaction, and WS-Business Activity protocols are based on one-way
            interactions
            of entities rather than traditional synchronous request/response RPC-style interactions. One group of entities,
            called transaction participants, invoke operations on other entities, such as the transaction coordinator, in
            order to return responses to requests. The programming model is based on peer-to-peer relationships, with the
            result that all services, whether they are participants, coordinators or clients, must have an
            <em class="firstterm">active
                component
            </em>
            that allows them to receive unsolicited messages.
        </p><p>
            
            In XTS, the active component is achieved through deployment of JaxWS
            endpoints. Each XTS endpoint that is reachable through SOAP/XML is
            published via JaxWS, without developer intevention. The only requirement
            is that transactional client applications and transactional web services
            must reside within a domain capable of hosting JaxWS endpoints, such as an
            application server. WildFly Application Server
            can provide this functionality.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3854"/>4.1.3. SOAP</h3></div></div></div><p>
            SOAP has emerged as the
            <span class="foreignphrase"><em class="foreignphrase">de facto</em></span>
            message format for XML-based communication in the
            Web Services arena. It is a lightweight protocol that allows the user to define the content of a message and to
            provide hints as to how recipients should process that message.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3862"/>4.1.4. Web Services Description Language (WDSL)</h3></div></div></div><p>
            <em class="firstterm">Web Services Description Language (WSDL)</em>
            is an XML-based language used to define Web
            service interfaces. An application that consumes a Web service parses the service’s WSDL document to discover the
            location of the service, the operations that the service supports, the protocol bindings the service supports
            (SOAP, HTTP, etc), and how to access them. For each operation, WSDL describes the format that the client must
            follow.
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3870"/>4.2. Getting Started</h2></div></div></div><a id="d0e3873" class="indexterm"/><a id="d0e3876" class="indexterm"/><a id="d0e3879" class="indexterm"/><a id="d0e3882" class="indexterm"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3887"/>4.2.1. Enable
            XTS on WildFly Application Server
        </h3></div></div></div><p>
            XTS, which is the Web Services component of Narayana,
            provides WS-AT and WS-BA support for Web
            Services hosted on the WildFly Application Server.
            XTS is available as an optional SubSystem, enabled using the standalone-xts.xml configuration.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="procedure"><a id="starting-with-xts"/><p class="title"><b>Procedure 4.1. Starting WildFly Application Server
                with XTS Enabled
            </b></p><ol class="1"><li><p>
                    Change to the WildFly Application Server
                    directory:
                </p><p>
                    <code class="filename">
                        <em class="replaceable"><code>cd $JBOSS_HOME</code></em>
                    </code>
                </p></li><li><p>
                    Copy the example XTS configuration into the configurations directory:
                </p><p>
                    <code class="filename">
                        <em class="replaceable"><code>cp docs/examples/configs/standalone-xts.xml standalone/configuration</code></em>
                    </code>
                </p></li><li><p>
                    Start WildFly Application Server,
                    specifying the xts configuration:
                </p><p>
                    Linux:
                </p><p>
                    <code class="filename">
                        <em class="replaceable"><code>bin/standalone.sh --server-config=standalone-xts.xml</code></em>
                    </code>
                </p><p>
                    Windows:
                </p><p>
                    <code class="filename">
                        <em class="replaceable"><code>bin\standalone.bat --server-config=standalone-xts.xml</code></em>
                    </code>
                </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3940"/>4.2.2. Working With WS-AT</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-CreateWSATClient"/>4.2.2.1. Creating Client Applications</h4></div></div></div><p>
                XTS integrates WS-AT transactions with JTA. To invoke a web service inside a WS-AT transaction, simply
                start a new
                JTA transaction and invoke the web service. By default, XTS will create a WS-AT context and pass it with your
                request. See our quickstarts for an example:
                <a class="xref" href="#ref-WSATMultiService" title="4.7.1. WS-AT Multi-Service">Section 4.7.1, “WS-AT Multi-Service”</a>
                and
                <a class="xref" href="#ref-WSATMultiHop" title="4.7.2. WS-AT Multi-Hop">Section 4.7.2, “WS-AT Multi-Hop”</a>
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-CreateWSATService"/>4.2.2.2. Creating Transactional Web Services</h4></div></div></div><p>
                Similarly to the client-side, the service-side is also integrated with JTA. To make your web service
                WS-AT compliant,
                annotate your web service class or method with the EJB 3 javax.ejb.TransactionAttribute annotation or the JTA
                1.2 javax.transaction.Transactional annotation. XTS will automatically translate WS-AT context, received with
                the request, to JTA. See our quickstarts for an example:
                <a class="xref" href="#ref-WSATMultiService" title="4.7.1. WS-AT Multi-Service">Section 4.7.1, “WS-AT Multi-Service”</a>
                and
                <a class="xref" href="#ref-WSATMultiHop" title="4.7.2. WS-AT Multi-Hop">Section 4.7.2, “WS-AT Multi-Hop”</a>
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3961"/>4.2.2.3. Using Raw XTS API</h4></div></div></div><p>
                Sometimes more control is needed over the client and the server applications. Also JTA transactions are not
                always wanted in the application. In such case it is possible to create client and service applications using
                the Raw XTS API.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning!</h2><p>
                    This is not a recommended way to work with WS-AT. Please take a look at
                    <a class="xref" href="#ref-CreateWSATClient" title="4.2.2.1. Creating Client Applications">Section 4.2.2.1, “Creating Client Applications”</a>
                    and
                    <a class="xref" href="#ref-CreateWSATService" title="4.2.2.2. Creating Transactional Web Services">Section 4.2.2.2, “Creating Transactional Web Services”</a>
                    for the recommended and easier XTS usage for WS-AT applications.
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e3975"/>4.2.2.3.1. Creating Client Applications</h5></div></div></div><p>
                    There are two aspects to a client application using Raw XTS, the transaction declaration aspects, and the business
                    logic. The business logic includes the invocation of Web Services.
                </p><p>
                    Transaction declaration aspects are handled automatically with the XTS client API. This API provides
                    simple
                    transaction directives such as
                    <code class="methodname">begin</code>
                    ,
                    <code class="methodname">commit</code>
                    , and
                    <code class="methodname">rollback</code>
                    , which the client application can use to initialize, manage, and terminate
                    transactions. Internally, this API uses SOAP to invoke operations on the various WS-C and WS-AT services,
                    in order to create a coordinator and drive the transaction to completion.
                </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e3991"/>4.2.2.3.1.1. User Transactions</h6></div></div></div><p>
                        A client uses the
                        <code class="classname">UserTransactionFactory</code>
                        and
                        <code class="classname">UserTransaction</code>
                        classes to
                        create and manage WS-AT transactions. These classes provide a simple API which operates in a manner similar to the
                        JTA API. A WS-AT transaction is started and associated with the client thread by calling the
                        <code class="methodname">begin</code>
                        method of the
                        <code class="methodname">UserTransaction</code>
                        class. The transaction can be
                        committed by calling the
                        <code class="methodname">commit</code>
                        method, and rolled back by calling the
                        <code class="methodname">rollback</code>
                        method.
                    </p><p>
                        More complex transaction management, such as suspension and resumption of transactions, is
                        supported by the
                        <code class="classname">TransactionManagerFactory</code>
                        and
                        <code class="classname">TransactionManager</code>
                        classes.
                    </p><p>
                        Full details of the WS-AT APIs are provided in
                        <a class="xref" href="#sec-xts-api" title="4.3. The XTS API">Section 4.3, “The XTS API”</a>
                        .
                    </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="ref-WSATRawCreatingTransactionalWebServices"/>4.2.2.3.2. Creating Transactional Web Services</h5></div></div></div><p>
                    The two parts to implementing a Web service using XTS are the transaction management and the business logic.
                </p><p>
                    The bulk of the transaction management aspects are organized in a clear and easy-to-implement model
                    by means of
                    the XTS’s
                    <em class="firstterm">Participant API</em>
                    , provides a structured model for negotiation between the web
                    service and the transaction coordinator. It allows the web service to manage its own local transactional data, in
                    accordance with the needs of the business logic, while ensuring that its activities are in step with
                    those of the
                    client and other services involved in the transaction. Internally, this API uses SOAP to invokes operations on the
                    various WS-C and WS-AT services, to drive the transaction to completion.
                </p><p>
                    A
                    <em class="firstterm">participant</em>
                    is a software entity which is driven by the transaction manager on behalf of a
                    Web service. When a web service wants to participate in a particular transaction, it must enroll a participant to act
                    as a proxy for the service in subsequent negotiations with the coordinator. The participant
                    implements an API
                    appropriate to the type of transaction it is enrolled in, and the participant model selected when it is enrolled. For
                    example, a Durable2PC participant, as part of a WS-Atomic Transaction, implements the Durable2PCParticipant
                    interface. The use of participants allows the transactional control management aspects of the Web service to be
                    factored into the participant implementation, while staying separate from the the rest of the Web service's business
                    logic and private transactional data management.
                </p><p>
                    The creation of participants is not trivial, since they ultimately reflect the state of a Web
                    service’s back-end
                    processing facilities, an aspect normally associated with an enterprise’s own IT infrastructure. Implementations must
                    use one of the following interfaces:
                    <code class="interfacename">com.arjuna.wst11.Durable2PCParticipant</code>
                    ,
                    <code class="interfacename">com.arjuna.wst11.Volatile2PCParticipant</code>
                    .
                </p><p>
                    A full description of XTS’s participant features is provided in
                    <a class="xref" href="#sec-xts-api" title="4.3. The XTS API">Section 4.3, “The XTS API”</a>
                    .
                </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4053"/>4.2.3. Working With WS-BA</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4056"/>4.2.3.1. Creating Client Applications</h4></div></div></div><p>
                There are two aspects to a client application using XTS, the transaction declaration aspects, and the business
                logic. The business logic includes the invocation of Web Services.
            </p><p>
                Transaction declaration aspects are handled automatically with the XTS client API. This API provides
                simple
                transaction directives such as
                <code class="methodname">begin</code>
                ,
                <code class="methodname">close</code>
                , and
                <code class="methodname">cancel</code>
                , which the client application can use to initialize, manage, and terminate
                transactions. Internally, this API uses SOAP to invoke operations on WS-BA services,
                in order to create a coordinator and drive the transaction to completion.
            </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4072"/>4.2.3.1.1. Business Activities</h5></div></div></div><p>
                    A client creates and manages Business Activities using the
                    <code class="classname">UserBusinessActivityFactory</code>
                    and
                    <code class="classname">UserBusinessActivity</code>
                    classes. A WS-BA activity is started and associated with the client
                    thread by calling the
                    <code class="methodname">begin</code>
                    method of the
                    <code class="methodname">UserBusinessActivity</code>
                    class. A client can terminate a business activity by calling the
                    <code class="methodname">close</code>
                    method, and cancel it
                    by calling the
                    <code class="methodname">cancel</code>
                    method.
                </p><p>
                    If any of the Web Services invoked by the client register for the
                    <code class="systemitem">BusinessActivityWithCoordinatorCompletion</code>
                    protocol, the client can call the
                    <code class="methodname">completed</code>
                    method before calling the
                    <code class="methodname">close</code>
                    method, to notify the
                    services that it has finished making service invocations in the current activity.
                </p><p>
                    More complex business activity management, such as suspension and resumption of business activities,
                    is supported by
                    the
                    <code class="classname">BusinessActivityManagerFactory</code>
                    and
                    <code class="classname">BusinessActivityManager</code>
                    classes.
                </p><p>
                    Full details of the WS-BA APIs are provided in
                    <a class="xref" href="#sec-xts-api" title="4.3. The XTS API">Section 4.3, “The XTS API”</a>
                    .
                </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4118"/>4.2.3.2. Creating Transactional Web Services</h4></div></div></div><p>
                The theory behind creating WS-BA web services is similar to the WS-AT Raw API
                <a class="xref" href="#ref-WSATRawCreatingTransactionalWebServices" title="4.2.2.3.2. Creating Transactional Web Services">Section 4.2.2.3.2, “Creating Transactional Web Services”</a>
                . However, different participant classes are used:
                <code class="interfacename">com.arjuna.wst11.BusinessAgreementWithParticipantCompletionParticipant</code>
                , or
                <code class="interfacename">com.arjuna.wst11.BusinessAgreementWithCoordinatorCompletionParticipant</code>
                .
            </p><p>
                A full description of XTS’s participant features is provided in
                <a class="xref" href="#sec-xts-api" title="4.3. The XTS API">Section 4.3, “The XTS API”</a>
                .
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4135"/>4.2.3.3. New Compensating Transactions API</h4></div></div></div><p>
                There is a new Compensating Transactions API available to work with WS-BA applications. Please consult
                our quickstarts how
                to use it:
                <a class="xref" href="#ref-CompensationsNonTransactionalResource" title="4.7.5. Non-transactional Resource with Compensating Transactions API">Section 4.7.5, “Non-transactional Resource with Compensating Transactions API”</a>
                and
                <a class="xref" href="#ref-CompensationsTravelAgent" title="4.7.6. Travel Agent with Compensating Transactions API">Section 4.7.6, “Travel Agent with Compensating Transactions API”</a>
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="ref-TransactionContextPropagation"/>4.2.4. Configuration of The Transaction Context Propagation</h3></div></div></div><p>
            You can enable transaction propagation for all Web service calls that are invoked within a JTA, WS-AT or WS-BA
            transaction. This is done with the 'default-context-propagation' property in the XTS subsystem config of the
            standalone-xts.xml.
        </p><p>
            As this is enabled by default (for standalone-xts.xml), calls to all Web services that support WS-AT or WS-BA
            will automatically receive the transaction context allowing them to participate in the distributed transaction.
        </p><p>
            The transaction context is simply ignored if the service does not support WS-AT or WS-BA. This is done by
            setting MustUnderstand=”false” on the 'CoordinationContext' SOAP header. Unfortunately, this may cause issues
            when invoking WS-AT or WS-BA enabled Web services on other vendors’ application servers. This is because the
            WS-Coordination specification states that MustUnderstand must be set to true. If you are affected by this
            issue,
            you will need to explicitly enable the transaction propagation for every port.
        </p><p>
            The default context propagation policy can also be overridden on a per Web Service port basis. This allows
            the
            developer to easily state which Web Service clients must and must-not propagate the transaction context. This is
            done through the standard JAX-WS WebServiceFeature facility. A JAX-WS WebServiceFeature allows meta-information
            to be added to a port that describe cross-cutting behaviour, such as logging, security or compression. In our
            case we use the
            <a class="xref" href="#ref-JTAOverWSATFeature" title="4.3.2.10. JTAOverWSATFeature">Section 4.3.2.10, “JTAOverWSATFeature”</a>
            and
            <a class="xref" href="#ref-WSTXFeature" title="4.3.2.9. WSTXFeature">Section 4.3.2.9, “WSTXFeature”</a>
            features.
        </p><p>
            <a class="xref" href="#ref-JTAOverWSATFeature" title="4.3.2.10. JTAOverWSATFeature">Section 4.3.2.10, “JTAOverWSATFeature”</a>
            states that any JTA, WS-AT, or WS-BA transactions should be distributed
            via calls on this client. This feature is recommended to use, if you have a JTA transactions which should be
            propagated.
        </p><p>
            <a class="xref" href="#ref-WSTXFeature" title="4.3.2.9. WSTXFeature">Section 4.3.2.9, “WSTXFeature”</a>
            states that any WS-AT or WS-BA transaction should be distributed via calls on
            this client. You should use this feature, if you use Raw XTS or WS-BA APIs.
        </p><p>
            Calls to the service will fail if the Web service does not support WS-AT or WS-BA (in this case, XTS sets
            MustUnderstand=true on the 'CoordinationContext' SOAP header as the developer has explicitly stated that it
            is
            required).
        </p><p>
            The developer may also state that the transaction must-not be distributed over calls to this Web service.
            This
            is done by setting the
            <a class="xref" href="#ref-JTAOverWSATFeature" title="4.3.2.10. JTAOverWSATFeature">Section 4.3.2.10, “JTAOverWSATFeature”</a>
            or
            <a class="xref" href="#ref-WSTXFeature" title="4.3.2.9. WSTXFeature">Section 4.3.2.9, “WSTXFeature”</a>
            feature to
            disabled.
        </p><p>
            The use of
            <a class="xref" href="#ref-JTAOverWSATFeature" title="4.3.2.10. JTAOverWSATFeature">Section 4.3.2.10, “JTAOverWSATFeature”</a>
            and
            <a class="xref" href="#ref-WSTXFeature" title="4.3.2.9. WSTXFeature">Section 4.3.2.9, “WSTXFeature”</a>
            overrides whatever
            default context propagation is set to in the standalone-xts.xml.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4181"/>4.2.5. Summary</h3></div></div></div><p>
            This chapter gives a high-level overview of each of the major software pieces used by the Web Services
            transactions component of Narayana.
            The Web Services transaction manager provided by Narayana
            is the hub of the architecture and is the only piece of software that user-level software does
            not bind to directly. XTS provides header-processing infrastructure for use with Web Services transactions
            contexts for both client applications and Web Services. XTS provides a simple interface for developing transaction
            participants, along with the necessary document-handling code.
        </p><p>
            This chapter is only an overview, and does not address the more difficult and subtle aspects of programming Web
            Services. For fuller explanations of the components, please continue reading.
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sec-xts-api"/>4.3. The XTS API</h2></div></div></div><a id="d0e4191" class="indexterm"/><a id="d0e4194" class="indexterm"/><a id="d0e4197" class="indexterm"/><a id="d0e4200" class="indexterm"/><a id="d0e4203" class="indexterm"/><a id="d0e4206" class="indexterm"/><a id="d0e4209" class="indexterm"/><a id="d0e4212" class="indexterm"/><a id="d0e4215" class="indexterm"/><a id="d0e4218" class="indexterm"/><a id="d0e4221" class="indexterm"/><a id="d0e4224" class="indexterm"/><a id="d0e4227" class="indexterm"/><a id="d0e4230" class="indexterm"/><a id="d0e4233" class="indexterm"/><a id="d0e4236" class="indexterm"/><a id="d0e4239" class="indexterm"/><a id="d0e4242" class="indexterm"/><a id="d0e4245" class="indexterm"/><a id="d0e4248" class="indexterm"/><p>
        This chapter discusses the XTS API. You can use this information to write client and server applications which
        consume transactional Web Services and coordinate back-end systems.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4253"/>4.3.1. Participants</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4256"/>4.3.1.1. Overview</h4></div></div></div><p>
                The
                <em class="firstterm">participant</em>
                is the entity that performs the work pertaining to transaction management
                on behalf of the business services involved in an application. The Web service (in the example code, a theater
                booking system) contains some business logic to reserve a seat and inquire about availability, but it needs to be
                supported by something that maintains information in a durable manner. Typically this is a database, but it could
                be a file system, NVRAM, or other storage mechanism.
            </p><p>
                Although the service may talk to the back-end database directly, it cannot commit or undo any changes,
                since
                committing and rolling back are ultimately under the control of a transaction. For the transaction to exercise
                this control, it must communicate with the database. In XTS, participant does this communication, as shown in
                <a class="xref" href="#fig-participant-backend-control" title="Figure 4.1. Transactions, Participants, and Back-End Transaction Control">Figure 4.1, “Transactions, Participants, and Back-End Transaction Control”</a>
                .
            </p><div class="figure"><a id="fig-participant-backend-control"/><div class="figure-contents"><div class="mediaobject"><img src="images/xts-guide-fig-participant-backend-control.png" alt="Transactions, Participants, and Back-End Transaction Control"/></div></div><p class="title"><b>Figure 4.1. Transactions, Participants, and Back-End Transaction Control</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4274"/>4.3.1.1.1. Atomic Transaction</h5></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning!</h2><p>
                        This section is relevant for WS-AT applications only if Raw XTS API is used.
                    </p></div><p>
                    All Atomic Transaction participants are instances of the
                    <a class="xref" href="#ref-Durable2PCParticipant" title="4.3.2.1. Durable2PCParticipant">Section 4.3.2.1, “Durable2PCParticipant”</a>
                    or
                    <a class="xref" href="#ref-Volatile2PCParticipant" title="4.3.2.2. Volatile2PCParticipant">Section 4.3.2.2, “Volatile2PCParticipant”</a>
                    .
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4288"/>4.3.1.1.2. Business Activity</h5></div></div></div><p>
                    All Business Activity participants are instances one or the other of the interfaces described in
                    <a class="xref" href="#ref-BusinessAgreementWithParticipantCompletion" title="4.3.3.2. BusinessAgreementWithParticipantCompletionParticipant">Section 4.3.3.2, “BusinessAgreementWithParticipantCompletionParticipant”</a>
                    or
                    <a class="xref" href="#ref-BusinessAgreementWithCoordinatorCompletion" title="4.3.3.3. BusinessAgreementWithCoordinatorCompletion">Section 4.3.3.3, “BusinessAgreementWithCoordinatorCompletion”</a>
                    interface.
                </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4297"/>4.3.1.2. Participant Creation and Deployment</h4></div></div></div><p>
                The participant provides the plumbing that drives the transactional aspects of the service. This section discusses
                the specifics of Participant programming and usage.
            </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4302"/>4.3.1.2.1. Implementing Participants</h5></div></div></div><p>
                    Implementing a participant is a relatively straightforward task. However, depending on the
                    complexity of the
                    transactional infrastructure that the participant needs to manage, the task can vary greatly in complexity and
                    scope. Your implementation needs to implement one of the interfaces found under
                    <span class="package">com.arjuna.wst</span>
                    .
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e4310"/>4.3.1.2.2. Deploying Participants</h5></div></div></div><p>
                    Transactional web services and transactional clients are regular Java EE applications and can be deployed into
                    the application server in the same way as any other Java EE application. The XTS Subsystem exports all the client and
                    web service API
                    classes needed to manage transactions and enroll and manage participant web services. It provides
                    implementations of all the WS-C and WS-T coordination services, not just the coordinator services. In
                    particular, it exposes the client and web service participant endpoints which are needed to receive incoming
                    messages originating from the coordinator.
                </p><p>
                    Normally, a transactional application client and the transaction web service it invokes will be deployed in
                    different application servers. As long as XTS is enabled on each of these containers it will
                    transparently route coordination messages from clients or web services to their coordinator and vice versa. When
                    the client begins a transaction by default it creates a context using the coordination services in its local
                    container. The context holds a reference to the local Registration Service which means that any web
                    services
                    enlisted in the transaction enrol with the coordination services in the same container.
                </p><p>
                    The coordinator does not need to reside in the same container as the client application. By configuring the
                    client deployment appropriately it is possible to use the coordinator services co-located with one of the web
                    services or even to use services deployed in a separate, dedicated container. See Chapter 8 Stand-Alone
                    Coordination for details of how to configure a coordinator located in a different container to the client.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>
                        In previous releases, the XTS and Transaction Manager
                        <code class="filename">.jar</code>
                        ,
                        <code class="filename">.war</code>
                        and configuration files needed to be bundled with the
                        application. This deployment method is no longer supported in the WildFly Application Server
                        as XTS is pre-installed as a
                        SubSystem.
                    </p></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4328"/>4.3.2. API for the Atomic Transaction Protocol</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-Durable2PCParticipant"/>4.3.2.1. Durable2PCParticipant</h4></div></div></div><p>
                All participants which support Durable2PC protocol have to implement
                <code class="interfacename">com.arjuna.wst.Durable2PCParticipant</code>
                interface.
            </p><div class="variablelist"><p class="title"><b>Durable2PCParticipant Methods</b></p><dl><dt><span class="term">prepare</span></dt><dd><p>
                            The participant should perform any work necessary, so that it can either commit or roll back the work
                            performed by the Web service under the scope of the transaction. The implementation is free to do
                            whatever it needs to in order to fulfill the implicit contract between it and the coordinator.
                        </p><p>
                            The participant indicates whether it can
                            <code class="systemitem">prepare</code>
                            by returning an instance of
                            <a class="xref" href="#ref-Vote" title="4.3.2.3. Vote">Section 4.3.2.3, “Vote”</a>
                            .
                        </p></dd><dt><span class="term">commit</span></dt><dd><p>
                            The participant should make its work permanent. How it accomplishes this depends upon its
                            implementation. For instance, in the theater example, the reservation of the ticket is
                            committed. If
                            commit processing cannot complete, the participant should throw a
                            <code class="systemitem">SystemException</code>
                            error, potentially leading to a heuristic outcome for the
                            transaction.
                        </p></dd><dt><span class="term">rollback</span></dt><dd><p>
                            The participant should undo its work. If rollback processing cannot complete, the
                            participant should
                            throw a
                            <code class="systemitem">SystemException</code>
                            error, potentially leading to a heuristic outcome for
                            the transaction.
                        </p></dd><dt><span class="term">unknown</span></dt><dd><p>
                            This method has been deprecated and is slated to be removed from XTS in the future.
                        </p></dd><dt><span class="term">error</span></dt><dd><p>
                            In rare cases when recovering from a system crash, it may be impossible to complete or roll
                            back a
                            previously prepared participant, causing the
                            <code class="methodname">error</code>
                            operation to be invoked.
                        </p></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-Volatile2PCParticipant"/>4.3.2.2. Volatile2PCParticipant</h4></div></div></div><p>
                All participants which support Volatile2PC protocol have to implement
                <code class="interfacename">com.arjuna.wst.Volatile2PCParticipant</code>
                interface.
            </p><div class="variablelist"><p class="title"><b>Volatile2PCParticipant Methods</b></p><dl><dt><span class="term">
                        <code class="methodname">prepare</code>
                    </span></dt><dd><p>
                            The participant should perform any work necessary to flush any volatile data created by the Web service
                            under the scope of the transaction, to the system store. The implementation is free to do whatever it
                            needs to in order to fulfill the implicit contract between it and the coordinator.
                        </p><p>
                            The participant indicates whether it can
                            <code class="systemitem">prepare</code>
                            by returning an instance of
                            <a class="xref" href="#ref-Vote" title="4.3.2.3. Vote">Section 4.3.2.3, “Vote”</a>
                            .
                        </p></dd><dt><span class="term">commit</span></dt><dd><p>
                            The participant should perform any cleanup activities required, in response to a successful
                            transaction
                            commit. These cleanup activities depend upon its implementation. For instance, it may flush cached
                            backup copies of data modified during the transaction. In the unlikely event that commit processing
                            cannot complete, the participant should throw a
                            <code class="systemitem">SystemException</code>
                            error. This
                            will not affect the outcome of the transaction but will cause an error to be logged. This method may not
                            be called if a crash occurs during commit processing.
                        </p></dd><dt><span class="term">rollback</span></dt><dd><p>
                            The participant should perform any cleanup activities required, in response to a transaction
                            abort. In
                            the unlikely event that rollback processing cannot complete, the participant should throw a
                            <code class="systemitem">SystemException</code>
                            error. This will not affect the outcome of the transaction but
                            will cause an error to be logged. This method may not be called if a crash occurs during commit
                            processing.
                        </p></dd><dt><span class="term">unknown</span></dt><dd><p>
                            This method is deprecated and will be removed in a future release of XTS.
                        </p></dd><dt><span class="term">error</span></dt><dd><p>
                            This method should never be called, since volatile participants are not involved in recovery processing.
                        </p></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-Vote"/>4.3.2.3. Vote</h4></div></div></div><p>
                During the two-phase commit protocol, a participant is asked to vote on whether it can prepare to
                confirm the work
                that it controls. It must return an instance of one of the subtypes of
                <code class="interfacename">com.arjuna.wst.Vote</code>
                .
            </p><div class="variablelist"><p class="title"><b>
                    Subclasses of
                    <code class="interfacename">com.arjuna.wst.Vote</code>
                </b></p><dl><dt><span class="term">Prepared</span></dt><dd><p>
                            Indicates that the participant can prepare if the coordinator requests it. Nothing has been committed,
                            because the participant does not know the final outcome of the transaction.
                        </p></dd><dt><span class="term">Aborted</span></dt><dd><p>
                            The participant cannot prepare, and has rolled back. The participant should not expect to get a second phase
                            message.
                        </p></dd><dt><span class="term">ReadOnly</span></dt><dd><p>
                            The participant has not made any changes to state, and it does not need to know the final outcome of the
                            transaction. Essentially the participant is resigning from the transaction.
                        </p></dd></dl></div><div class="example"><a id="d0e4477"/><p class="title"><b>Example 4.1. 
                    Example Implementation of 2PC Participant's
                    <code class="methodname">prepare</code>
                    method
                </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"></span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Vote</span><span class="java_plain">&nbsp;prepare&nbsp;</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">WrongStateException</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">SystemException</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Some</span><span class="java_plain">&nbsp;participant&nbsp;logic&nbsp;here</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_separator">(</span><span class="java_comment">/*&nbsp;some&nbsp;condition&nbsp;based&nbsp;on&nbsp;the&nbsp;outcome&nbsp;of&nbsp;the&nbsp;business&nbsp;logic&nbsp;*/</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Vote</span><span class="java_plain">&nbsp;to&nbsp;confirm</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;com</span><span class="java_separator">.</span><span class="java_plain">arjuna</span><span class="java_separator">.</span><span class="java_plain">wst</span><span class="java_separator">.</span><span class="java_type">Prepared</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_keyword">else</span><span class="java_plain">&nbsp;</span><span class="java_keyword">if</span><span class="java_separator">(</span><span class="java_comment">/*another&nbsp;condition&nbsp;based&nbsp;on&nbsp;the&nbsp;outcome&nbsp;of&nbsp;the&nbsp;business&nbsp;logic*/</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Resign</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;com</span><span class="java_separator">.</span><span class="java_plain">arjuna</span><span class="java_separator">.</span><span class="java_plain">wst</span><span class="java_separator">.</span><span class="java_type">ReadOnly</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_keyword">else</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Vote</span><span class="java_plain">&nbsp;to&nbsp;cancel</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;com</span><span class="java_separator">.</span><span class="java_plain">arjuna</span><span class="java_separator">.</span><span class="java_plain">wst</span><span class="java_separator">.</span><span class="java_type">Aborted</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4485"/>4.3.2.4. TXContext</h4></div></div></div><p>
                <span class="package">com.arjuna.mw.wst.TxContext</span>
                is an opaque representation of a transaction context. It returns one
                of two possible values, as listed below.
            </p><div class="variablelist"><a id="TxContext-values"/><p class="title"><b>TxContext Return Values</b></p><dl><dt><span class="term">valid</span></dt><dd><p>
                            Indicates whether the contents are valid.
                        </p></dd><dt><span class="term">equals</span></dt><dd><p>
                            Can be used to compare two instances for equality.
                        </p></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-UserTransaction"/>4.3.2.5. UserTransaction</h4></div></div></div><p>
                <code class="classname">com.arjuna.mw.wst11.UserTransaction</code>
                is the class that clients typically employ. Before a
                client can begin a new atomic transaction, it must first obtain a
                <code class="classname">UserTransaction</code>
                from the
                <code class="classname">UserTransactionFactory</code>
                . This class isolates the user from the underlying protocol-specific
                aspects of the XTS implementation. A
                <code class="classname">UserTransaction</code>
                does not represent a specific
                transaction. Instead, it provides access to an implicit per-thread transaction context, similar to the
                <code class="classname">UserTransaction</code>
                in the JTA specification. All of the
                <code class="classname">UserTransaction</code>
                methods implicitly act on the current thread of control.
            </p><div class="variablelist"><p class="title"><b>
                    <code class="classname">UserTransaction</code>
                    Methods
                </b></p><dl><dt><span class="term">begin</span></dt><dd><p>
                            Used to begin a new transaction and associate it with the invoking thread.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">timeout</span></dt><dd><p>
                                        This optional parameter, measured in milliseconds, specifies a time interval after which the newly created
                                        transaction may be automatically rolled back by the coordinator
                                    </p></dd></dl></div><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">
                                    <code class="systemitem">WrongStateException</code>
                                </span></dt><dd><p>
                                        A transaction is already associated with the thread.
                                    </p></dd></dl></div></dd><dt><span class="term">commit</span></dt><dd><p>
                            
                            Volatile2PC and Durable2PC participants enrolled in the transaction
                            are requested first to prepare and then to commit their changes. If
                            any of the participants fails to prepare in the first phase then all
                            other participants are requested to abort.
                        </p><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">
                                    <code class="systemitem">UnknownTransactionException</code>
                                </span></dt><dd><p>
                                        No transaction is associated with the invoking thread.
                                    </p></dd><dt><span class="term">
                                    <code class="methodname">TransactionRolledBackException</code>
                                </span></dt><dd><p>
                                        
                                        The transaction was rolled back either because of a timeout or
                                        because a participant was unable to commit.
                                    </p></dd></dl></div></dd><dt><span class="term">rollback</span></dt><dd><p>
                            Terminates the transaction. Upon completion, the
                            <code class="methodname">rollback</code>
                            method disassociates the
                            transaction from the current leaving it unassociated with any transactions.
                        </p><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">
                                    <code class="systemitem">UnknownTransactionException</code>
                                </span></dt><dd><p>
                                        No transaction is associated with the invoking thread.
                                    </p></dd></dl></div></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4616"/>4.3.2.6. UserTransactionFactory</h4></div></div></div><p>
                Call the
                <code class="methodname">getUserTransaction</code>
                method to obtain a
                <a class="xref" href="#ref-UserTransaction" title="4.3.2.5. UserTransaction">Section 4.3.2.5, “UserTransaction”</a>
                instance from a
                <code class="classname">UserTransactionFactory</code>
                .
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-TransactionManager"/>4.3.2.7. TransactionManager</h4></div></div></div><p>
                Defines the interaction between a transactional web service and the underlying transaction service
                implementation. A
                <code class="classname">TransactionManager</code>
                does not represent a specific transaction. Instead, it provides access to
                an implicit per-thread transaction context.
            </p><div class="variablelist"><p class="title"><b>Methods</b></p><dl><dt><span class="term">
                        <code class="methodname">currentTransaction</code>
                    </span></dt><dd><p>
                            Returns a
                            <code class="systemitem">TxContext</code>
                            for the current transaction, or null if there is no context. Use
                            the
                            <code class="methodname">currentTransaction</code>
                            method to determine whether a web service has been invoked from
                            within an existing transaction. You can also use the returned value to enable multiple threads to execute
                            within the scope of the same transaction. Calling the
                            <code class="methodname">currentTransaction</code>
                            method does
                            not disassociate the current thread from the transaction.
                        </p></dd><dt><span class="term">
                        <code class="methodname">suspend</code>
                    </span></dt><dd><p>
                            Dissociates a thread from any transaction. This enables a thread to do work that is not associated with a
                            specific transaction.
                        </p><p>
                            The
                            <code class="methodname">suspend</code>
                            method returns a
                            <code class="systemitem">TxContext</code>
                            instance, which is a handle on the transaction.
                        </p></dd><dt><span class="term">
                        <code class="methodname">resume</code>
                    </span></dt><dd><p>
                            Associates or re-associates a thread with a transaction, using its
                            <code class="systemitem">TxContext</code>
                            . Prior to
                            association or re-association, the thread is disassociated from any transaction with which it may be currently
                            associated. If the
                            <code class="systemitem">TxContext</code>
                            is null, then the thread is associated with no
                            transaction. In this way, the result is the same as if the
                            <code class="methodname">suspend</code>
                            method were used
                            instead.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">txContext</span></dt><dd><p>
                                        A TxContext instance as return by
                                        <code class="methodname">suspend</code>
                                        , identifying the transaction to be resumed.
                                    </p></dd></dl></div><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">
                                    <code class="systemitem">UnknownTransactionException</code>
                                </span></dt><dd><p>
                                        The transaction referred to by the
                                        <code class="systemitem">TxContext</code>
                                        is invalid in the scope of the invoking
                                        thread.
                                    </p></dd></dl></div></dd><dt><span class="term">
                        <code class="varname">enlistForVolitaleTwoPhase</code>
                    </span></dt><dd><p>
                            Enroll the specified participant with the current transaction, causing it to participate in the Volatile2PC
                            protocol. You must pass a unique identifier for the participant.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">participant</span></dt><dd><p>
                                        An implementation of interface Volatile2PCParticipant whose prepare, commit and abort methods are called when
                                        the corresponding coordinator message is received.
                                    </p></dd><dt><span class="term">id</span></dt><dd><p>
                                        A unique identifier for the participant. The value of this String should differ for each enlisted
                                        participant. It should also be possible for a given identifier to determine that the participant belongs to
                                        the enlisting web service rather than some other web service deployed to the same container.
                                    </p></dd></dl></div><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">UnknownTransactionException</span></dt><dd><p>
                                        No transaction is associated with the invoking thread.
                                    </p></dd><dt><span class="term">
                                    <code class="systemitem">WrongStateException</code>
                                </span></dt><dd><p>
                                        The transaction is not in a state that allows participants to be enrolled. For instance, it may be in the
                                        process of terminating.
                                    </p></dd></dl></div></dd><dt><span class="term">
                        <code class="varname">enlistForDurableTwoPhase</code>
                    </span></dt><dd><p>
                            Enroll the specified participant with the current transaction, causing it to participate in the Durable2PC
                            protocol. You must pass a unique identifier for the participant.
                        </p><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">UnknownTransactionException</span></dt><dd><p>
                                        No transaction is associated with the invoking thread.
                                    </p></dd><dt><span class="term">
                                    <code class="systemitem">WrongStateException</code>
                                </span></dt><dd><p>
                                        The transaction is not in a state that allows participants to be enrolled. For instance, it may be in the
                                        process of terminating.
                                    </p></dd></dl></div></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4790"/>4.3.2.8. TransactionManagerFactory</h4></div></div></div><p>
                Use the
                <code class="methodname">getTransactionManager</code>
                method to obtain a
                <a class="xref" href="#ref-TransactionManager" title="4.3.2.7. TransactionManager">Section 4.3.2.7, “TransactionManager”</a>
                from a
                <code class="classname">TransactionManagerFactory</code>
                .
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-WSTXFeature"/>4.3.2.9. WSTXFeature</h4></div></div></div><p>
                Use this JAX-WS feature to enable or disable WS-AT context propagation for specific port. Pass an instance of this
                feature when creating web service port.
            </p><div class="variablelist"><p class="title"><b>Methods</b></p><dl><dt><span class="term">
                        <code class="varname">WSTXFeature</code>
                    </span></dt><dd><p>
                            <code class="classname">WSTXFeature</code>
                            created with default constructor will enable WS-AT context propagation.
                        </p></dd><dt><span class="term">
                        <code class="varname">WSTXFeature</code>
                    </span></dt><dd><p>
                            Parametrised constructor will either enabled or disable WS-AT context propagation.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">enabled</span></dt><dd><p>
                                        Boolean value saying to either enable or disable WS-AT context propagation.
                                    </p></dd></dl></div></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-JTAOverWSATFeature"/>4.3.2.10. JTAOverWSATFeature</h4></div></div></div><p>
                Use this JAX-WS feature to enable or disable JTA context propagation for specific port. Pass an instance of this
                feature when creating web service port.
            </p><div class="variablelist"><p class="title"><b>Methods</b></p><dl><dt><span class="term">
                        <code class="varname">JTAOverWSATFeature</code>
                    </span></dt><dd><p>
                            <code class="classname">JTAOverWSATFeature</code>
                            created with default constructor will enable JTA context propagation.
                        </p></dd><dt><span class="term">
                        <code class="varname">JTAOverWSATFeature</code>
                    </span></dt><dd><p>
                            Parametrised constructor will either enabled or disable JTA context propagation.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">enabled</span></dt><dd><p>
                                        Boolean value saying to either enable or disable JTA context propagation.
                                    </p></dd></dl></div></dd></dl></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4879"/>4.3.3. API for the Business Activity Protocol</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4882"/>4.3.3.1. Compatibility</h4></div></div></div><p>
                Previous implementations of XTS locate the Business Activity Protocol classes in the
                <span class="package">com.arjuna.mw.wst</span>
                package. In the current implementation, these classes are located in the
                <span class="package">com.arjuna.mw.wst11</span>
                package.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-BusinessAgreementWithParticipantCompletion"/>4.3.3.2. BusinessAgreementWithParticipantCompletionParticipant</h4></div></div></div><p>
                Participant which support business agreement with participant completion protocol have to implement
                <code class="interfacename">com.arjuna.wst.BusinessAgreementWithParticipantCompletionParticipant</code>
                interface.
            </p><div class="variablelist"><p class="title"><b>BusinessAgreementWithParticipantCompletion Methods</b></p><dl><dt><span class="term">close</span></dt><dd><p>
                            The transaction has completed successfully. The participant has previously informed the coordinator that
                            it was ready to complete.
                        </p></dd><dt><span class="term">cancel</span></dt><dd><p>
                            The transaction has canceled, and the participant should undo any work. The participant cannot have
                            informed the coordinator that it has completed.
                        </p></dd><dt><span class="term">compensate</span></dt><dd><p>
                            The transaction has canceled. The participant previously informed the coordinator that it
                            had finished
                            work but could compensate later if required, and it is now requested to do so. If compensation cannot be
                            performed, the participant should throw a
                            <code class="systemitem">FaultedException</code>
                            error, potentially
                            leading to a heuristic outcome for the transaction. If compensation processing cannot complete because
                            of a transient condition then the participant should throw a
                            <code class="systemitem">SystemException</code>
                            error, in which case the compensation action may be retried or the transaction may finish
                            with a
                            heuristic outcome.
                        </p></dd><dt><span class="term">status</span></dt><dd><p>
                            Return the status of the participant.
                        </p></dd><dt><span class="term">unknown</span></dt><dd><p>
                            This method is deprecated and will be removed a future XTS release.
                        </p></dd><dt><span class="term">error</span></dt><dd><p>
                            In rare cases when recovering from a system crash, it may be impossible to compensate a
                            previously-completed participant. In such cases the
                            <code class="methodname">error</code>
                            operation is invoked.
                        </p></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-BusinessAgreementWithCoordinatorCompletion"/>4.3.3.3. BusinessAgreementWithCoordinatorCompletion</h4></div></div></div><p>
                Participant which support business agreement with coordinator completion protocol have to implement
                <code class="interfacename">com.arjuna.wst.BusinessAgreementWithCoordinatorCompletionParticipant</code>
                interface.
            </p><div class="variablelist"><p class="title"><b>BusinessAgreementWithCoordinatorCompletion Methods</b></p><dl><dt><span class="term">close</span></dt><dd><p>
                            The transaction completed successfully. The participant previously informed the coordinator that it was
                            ready to complete.
                        </p></dd><dt><span class="term">cancel</span></dt><dd><p>
                            The transaction canceled, and the participant should undo any work.
                        </p></dd><dt><span class="term">compensate</span></dt><dd><p>
                            The transaction canceled. The participant previously informed the coordinator that it had
                            finished work
                            but could compensate later if required, and it is now requested to do so. In the unlikely event that
                            compensation cannot be performed the participant should throw a
                            <code class="systemitem">FaultedException</code>
                            error, potentially leading to a heuristic outcome for the
                            transaction. If compensation processing cannot complete because of a transient condition, the
                            participant should throw a
                            <code class="systemitem">SystemException</code>
                            error, in which case the
                            compensation action may be retried or the transaction may finish with a heuristic outcome.
                        </p></dd><dt><span class="term">complete</span></dt><dd><p>
                            The coordinator is informing the participant all work it needs to do within the scope of this business
                            activity has been completed and that it should make permananent any provisional changes it has made.
                        </p></dd><dt><span class="term">status</span></dt><dd><p>
                            Returns the status of the participant.
                        </p></dd><dt><span class="term">unknown</span></dt><dd><p>
                            This method is deprecated and will be removed in a future release of XTS.
                        </p></dd><dt><span class="term">error</span></dt><dd><p>
                            In rare cases when recovering from a system crash, it may be impossible to compensate a
                            previously
                            completed participant. In such cases, the
                            <code class="methodname">error</code>
                            method is invoked.
                        </p></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5011"/>4.3.3.4. BAParticipantManager</h4></div></div></div><p>
                In order for the Business Activity protocol to work correctly, the participants must be able to autonomously
                notify the coordinator about changes in their status. Unlike the Atomic Transaction protocol, where all
                interactions between the coordinator and participants are instigated by the coordinator when the transaction
                terminates, the BAParticipantManager interaction pattern requires the participant to be able to talk to the
                coordinator at any time during the lifetime of the business activity.
            </p><p>
                Whenever a participant is registered with a business activity, it receives a handle on the
                coordinator. This handle is an instance of interface
                <code class="interfacename">com.arjuna.wst11.BAParticipantManager</code>
                .
            </p><div class="variablelist"><p class="title"><b>BAParticipantManager Methods</b></p><dl><dt><span class="term">exit</span></dt><dd><p>
                            The participant uses the method
                            <code class="methodname">exit</code>
                            to inform the coordinator that is has left
                            the activity. It will not be informed when and how the business activity terminates. This method may
                            only be invoked while the participant is in the
                            <code class="systemitem">active</code>
                            state (or the
                            <code class="systemitem">completing</code>
                            state, in the case of a participant registered for the
                            <code class="systemitem">ParticipantCompletion</code>
                            protocol). If it is called when the participant is in any
                            other state, a
                            <code class="systemitem">WrongStateException</code>
                            error is thrown. An
                            <code class="methodname">exit</code>
                            does not stop the activity as a whole from subsequently being closed or
                            canceled/compensated, but only ensures that the exited participant is no longer involved in
                            completion,
                            close or compensation of the activity.
                        </p></dd><dt><span class="term">completed</span></dt><dd><p>
                            The participant has completed its work, but wishes to continue in the business activity, so that it will
                            eventually be informed when, and how, the activity terminates. The participant may later be asked to
                            compensate for the work it has done or learn that the activity has been closed.
                        </p></dd><dt><span class="term">fault</span></dt><dd><p>
                            The participant encountered an error during normal activation and has done whatever it can
                            to compensate
                            the activity. The
                            <code class="methodname">fault</code>
                            method places the business activity into a mandatory
                            <code class="systemitem">cancel-only</code>
                            mode. The faulted participant is no longer involved in completion,
                            close or compensation of the activity.
                        </p></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-UserBusinessActivity"/>4.3.3.5. UserBusinessActivity</h4></div></div></div><p>
                <code class="classname">com.arjuna.wst11.UserBusinessActivity</code>
                is the class that most clients employ. A client begins a
                new business activity by first obtaining a
                <code class="classname">UserBusinessActivity</code>
                from the
                <code class="classname">UserBusinessActivityFactory</code>
                . This class isolates them from the underlying protocol-specific
                aspects of the XTS implementation. A UserBusinessActivity does not represent a specific business activity. Instead,
                it provides access to an implicit per-thread activity. Therefore, all of the
                <code class="classname">UserBusinessActivity</code>
                methods implicitly act on the current thread of control.
            </p><div class="variablelist"><p class="title"><b>Methods</b></p><dl><dt><span class="term">
                        <code class="methodname">begin</code>
                    </span></dt><dd><p>
                            Begins a new activity, associating it with the invoking thread.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">timeout</span></dt><dd><p>
                                        The interval, in milliseconds, after which an activity times out. Optional.
                                    </p></dd></dl></div><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">
                                    <code class="systemitem">WrongStateException</code>
                                </span></dt><dd><p>
                                        The thread is already associated with a business activity.
                                    </p></dd></dl></div></dd><dt><span class="term">
                        <code class="methodname">close</code>
                    </span></dt><dd><p>
                            First, all Coordinator Completion participants enlisted in the activity are requested to complete the
                            activity. Next all participants, whether they enlisted for Coordinator or Participant Completion, are requested
                            to close the activity. If any of the Coordinator Completion participants fails to complete at the first stage
                            then all completed participants are asked to compensate the activity while any remaining uncompleted
                            participants are requested to cancel the activity.
                        </p><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">UnknownTransactionException</span></dt><dd><p>
                                        No activity is associated with the invoking thread.
                                    </p></dd><dt><span class="term">TransactionRolledBackException</span></dt><dd><p>
                                        The activity has been cancelled because one of the Coordinator Completion participants failed to
                                        complete. This exception may also be thrown if one of the Participant Completion participants has not completed
                                        before the client calls close.
                                    </p></dd></dl></div></dd><dt><span class="term">cancel</span></dt><dd><p>
                            Terminates the business activity. All Participant Completion participants enlisted in the activity which have
                            already completed are requested to compensate the activity. All uncompleted Participant Completion participants
                            and all Coordinator Completion participants are requested to cancel the activity.
                        </p><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">
                                    <code class="systemitem">UnknownTransactionException</code>
                                </span></dt><dd><p>
                                        No activity is associated with the invoking thread. Any participants that previous completed are directed to
                                        compensate their work.
                                    </p></dd></dl></div></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5162"/>4.3.3.6. UserBusinessActivityFactory</h4></div></div></div><p>
                Use the
                <code class="methodname">getUserBusinessActivity</code>
                method to obtain a
                <a class="xref" href="#ref-UserBusinessActivity" title="4.3.3.5. UserBusinessActivity">Section 4.3.3.5, “UserBusinessActivity”</a>
                instance from a
                <code class="classname">userBusinessActivityFactory</code>
                .
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="ref-BusinessActivityManager"/>4.3.3.7. BusinessActivityManager</h4></div></div></div><p>
                <span class="package">com.arjuna.mw.wst11.BusinessActivityManager</span>
                is the class that web services typically
                employ. Defines how a web service interacts with the underlying business activity service implementation. A
                <code class="classname">BusinessActivityManager</code>
                does not represent a specific activity. Instead, it provides access to
                an implicit per-thread activity.
            </p><div class="variablelist"><p class="title"><b>Methods</b></p><dl><dt><span class="term">
                        <code class="methodname">currentTransaction</code>
                    </span></dt><dd><p>
                            Returns the
                            <code class="systemitem">TxContext</code>
                            for the current business activity, or
                            <code class="literal">NULL</code>
                            if
                            there is no
                            <code class="systemitem">TxContext</code>
                            . The returned value can be used to enable multiple threads to
                            execute within the scope of the same business activity. Calling the
                            <code class="methodname">currenTransaction</code>
                            method does not dissociate the current thread from its activity.
                        </p></dd><dt><span class="term">
                        <code class="methodname">suspend</code>
                    </span></dt><dd><p>
                            Dissociates a thread from any current business activity, so that it can perform work not
                            associated with a
                            specific activity. The
                            <code class="methodname">suspend</code>
                            method returns a
                            <code class="systemitem">TxContext</code>
                            instance, which is a handle on the activity. The thread is then no longer associated with
                            any activity.
                        </p></dd><dt><span class="term">
                        <code class="methodname">resume</code>
                    </span></dt><dd><p>
                            Associates or re-associates a thread with a business activity, using its
                            <code class="systemitem">TxContext</code>
                            . Before associating or re-associating the thread, it is disassociated from
                            any business activity with which it is currently associated. If the
                            <code class="systemitem">TxContext</code>
                            is
                            <code class="literal">NULL</code>
                            , the thread is disassociated with all business activities, as though the
                            <code class="methodname">suspend</code>
                            method were called.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">txContext</span></dt><dd><p>
                                        A TxContext instance as returned by
                                        <code class="methodname">suspend</code>
                                        , identifying the transaction to be
                                        resumed.
                                    </p></dd></dl></div><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">
                                    <code class="systemitem">UnknownTransactionException</code>
                                </span></dt><dd><p>
                                        The business activity to which the
                                        <code class="systemitem">TxContext</code>
                                        refers is invalid in the scope of the
                                        invoking thread.
                                    </p></dd></dl></div></dd><dt><span class="term">
                        <code class="varname">enlistForBusinessAgreementWithParticipantCompletion</code>
                    </span></dt><dd><p>
                            Enroll the specified participant with current business activity, causing it to participate
                            in the
                            <code class="systemitem">BusinessAgreementWithParticipantCompletion</code>
                            protocol. A unique identifier for the
                            participant is also required.
                        </p><p>
                            The return value is an instance of BAParticipantManager which can be used to notify the coordinator of changes
                            in the participant state. In particular, since the participant is enlisted for the Participant Completion
                            protcol it is expected to call the completed method of this returned instance when it has completed all the
                            work it expects to do in this activity and has made all its changes permanent. Alternatively, if the
                            participant does not need to perform any compensation actions should some other participant fail it can leave
                            the activity by calling the exit method of the returned BAParticipantManager instance.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">participant</span></dt><dd><p>
                                        An implementation of interface
                                        <code class="interfacename">BusinessAgreementWithParticipantCompletionParticipant
                                        </code>
                                        whose
                                        <code class="methodname">close</code>
                                        ,
                                        <code class="methodname">cancel</code>
                                        , and
                                        <code class="methodname">compensate</code>
                                        methods are called when the corresponding coordinator message is received.
                                    </p></dd><dt><span class="term">id</span></dt><dd><p>
                                        A unique identifier for the participant. The value of this String should differ for each enlisted
                                        participant. It should also be possible for a given identifier to determine that the participant belongs to
                                        the enlisting web service rather than some other web service deployed to the same container.
                                    </p></dd></dl></div><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">UnknownTransactionException</span></dt><dd><p>
                                        No transaction is associated with the invoking thread.
                                    </p></dd><dt><span class="term">WrongStateException</span></dt><dd><p>
                                        The transaction is not in a state where new participants may be enrolled, such as when it is terminating.
                                    </p></dd></dl></div></dd><dt><span class="term">
                        <code class="varname">enlistForBusinessAgreementWithCoordinatorCompletion</code>
                    </span></dt><dd><p>
                            Enroll the specified participant with current activity, causing it to participate in the
                            <code class="systemitem">BusinessAgreementWithCoordinatorCompletion</code>
                            protocol. A unique identifier for the
                            participant is also required.
                        </p><p>
                            The return value is an instance of
                            <code class="interfacename">BAParticipantManager</code>
                            which can be used to
                            notify the coordinator of changes in the participant state. Note that in this case it is an error to call the
                            <code class="methodname">completed</code>
                            method of this returned instance. With the Coordinator Completion protocol
                            the participant is expected to wait until its
                            <code class="methodname">completed</code>
                            method is called before it
                            makes all its changes permanent. Alternatively, if the participant determiens that it has no changes to make,
                            it can leave the activity by calling the
                            <code class="methodname">exit</code>
                            method of the returned
                            <code class="interfacename">BAParticipantManager</code>
                            instance.
                        </p><div class="variablelist"><p class="title"><b>Parameters</b></p><dl><dt><span class="term">participant</span></dt><dd><p>
                                        An implementation of interface BusinessAgreementWithCoordinatorCompletionParticipant whose completed, close,
                                        cancel and compensate methods are called when the corresponding coordinator
                                        message is received.
                                    </p></dd><dt><span class="term">id</span></dt><dd><p>
                                        A unique identifier for the participant. The value of this String should differ for each enlisted
                                        participant. It should also be possible for a given identifier to determine that the participant belongs to
                                        the enlisting web service rather than some other web service deployed to the same container.
                                    </p></dd></dl></div><div class="variablelist"><p class="title"><b>Exceptions</b></p><dl><dt><span class="term">UnknownTransactionException</span></dt><dd><p>
                                        No transaction is associated with the invoking thread.
                                    </p></dd><dt><span class="term">WrongStateException</span></dt><dd><p>
                                        The transaction is not in a state where new participants may be enrolled, such as when it is terminating.
                                    </p></dd></dl></div></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5388"/>4.3.3.8. BusinessActivityManagerFactory</h4></div></div></div><p>
                Use the
                <code class="methodname">getBusinessActivityManager</code>
                method to obtain a
                <a class="xref" href="#ref-BusinessActivityManager" title="4.3.3.7. BusinessActivityManager">Section 4.3.3.7, “BusinessActivityManager”</a>
                instance from a
                <code class="classname">BusinessActivityManagerFactory</code>
                .
            </p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5401"/>4.4. Stand-Alone Coordination</h2></div></div></div><a id="d0e5404" class="indexterm"/><a id="d0e5407" class="indexterm"/><a id="d0e5410" class="indexterm"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5413"/>4.4.1. Introduction</h3></div></div></div><p>
            By default, coordination contexts are obtained from the local coordinator.
            Therefore, WS-AT transactions or WS-BA activities created by a locally-deployed client application
            are supplied with a context which identifies the Registration Service running on the client's machine. Any Web
            Services invoked by the client are coordinated by the Transaction Protocol services running on the client's
            host. This is the case whether the Web Services are running locally or remotely. Such a configuration is called
            <em class="firstterm">local coordination</em>
            .
        </p><p>
            You can reconfigure this setting globally for all clients, causing context creation requests to be
            redirected to
            an Activation Coordinator Service running on a remote host. Normally, the rest of the coordination process is
            executed from the remote host. This configuration is called
            <em class="firstterm">stand-alone coordination</em>
            .
        </p><div class="itemizedlist"><p class="title"><b>Reasons for Choosing a Stand-Alone Coordinator</b></p><ul><li><p>
                    Efficiency: if a client application invokes Web Services on a remote WildFly Application Server,
                    coordinating the transaction
                    from the remote server might be more efficient, since the protocol-specific messages between the coordinator
                    and the participants do not need to travel over the network.
                </p></li><li><p>
                    Reliability: if the coordinator service runs on a dedicated host, there is no danger of failing applications
                    or services affecting the coordinator and causing failures for unrelated transactions.
                </p></li><li><p>
                    A third reason might be to use a coordination service provided by a third party vendor.
                </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5438"/>4.4.2. Configuring the Activation Coordinator</h3></div></div></div><p>
            The simplest way to configure a stand-alone coordinator is to provide a complete URL for the remote
            coordinator. This can be done by changing the 'url' property of the 'xts-environment' element of the
            XTS Subsystem configuration in the
            <code class="filename">standalone-xts.xml</code>
            .
            <a class="xref" href="#example-xts-subsystem.xml" title="Example 4.2.  Example standalone-xts.xml configuration settings">Example 4.2, “
                Example
                standalone-xts.xml
                configuration settings
            ”</a>
            shows the snippet of XML that you should change.
        </p><div class="example"><a id="example-xts-subsystem.xml"/><p class="title"><b>Example 4.2. 
                Example
                <code class="filename">standalone-xts.xml</code>
                configuration settings
            </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version='1.0'&nbsp;encoding='UTF-8'?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">server</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">xmlns</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;urn:jboss:domain:1.4&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;.&nbsp;.&nbsp;.</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subsystem</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">xmlns</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;urn:jboss:domain:xts:1.0&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">xts-environment</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">url</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;http://${jboss.bind.address:127.0.0.1}:8080/ws-c11/ActivationService&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subsystem</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">server</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>
            The XTS module (
            <code class="filename">modules/system/layers/base/org/jboss/xts/main/jbossxts-${XTS_VERSION}.jar</code>)
            in the WildFly Application Server
            includes a configuration file,
            <code class="filename">xts-properties.xml</code>,
            in the root of the jar. These properties can be edited and then
            re-packaged in the jar. The changes will take affect on next boot of the  WildFly Application Server.
            <a class="xref" href="#example-xts-properties.xml" title="Example 4.3.  Example xts-properties.xml configuration settings">Example 4.3, “
                Example
                xts-properties.xml
                configuration settings
            ”</a>
            shows a fragment of this file which details the options for changing the coordinator URL.
        </p><div class="example"><a id="example-xts-properties.xml"/><p class="title"><b>Example 4.3. 
                Example
                <code class="filename">xts-properties.xml</code>
                configuration settings
            </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">DOCTYPE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">properties</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">SYSTEM</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_value">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;.&nbsp;.&nbsp;.</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;coordinator&nbsp;URL</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;following&nbsp;entries&nbsp;are&nbsp;used&nbsp;in&nbsp;the&nbsp;client&nbsp;container&nbsp;only&nbsp;to</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;identify&nbsp;the&nbsp;URL&nbsp;used&nbsp;to&nbsp;address&nbsp;the&nbsp;ActivationCoordinator&nbsp;service.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;the&nbsp;XTS&nbsp;service&nbsp;which&nbsp;is&nbsp;contacted&nbsp;when&nbsp;a&nbsp;begin&nbsp;operation</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;invoked&nbsp;to&nbsp;start&nbsp;a&nbsp;&nbsp;WS-AT&nbsp;or&nbsp;WS-BA&nbsp;transaction.</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;a&nbsp;full&nbsp;URL&nbsp;is&nbsp;provide&nbsp;then&nbsp;it&nbsp;will&nbsp;be&nbsp;used&nbsp;as&nbsp;given.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Otherwise&nbsp;a&nbsp;URL&nbsp;will&nbsp;be&nbsp;constructed&nbsp;using&nbsp;any&nbsp;URL&nbsp;components</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;such&nbsp;as&nbsp;scheme,&nbsp;host&nbsp;etc&nbsp;which&nbsp;have&nbsp;been&nbsp;specified&nbsp;as&nbsp;properties</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;defaulting&nbsp;any&nbsp;remaining&nbsp;unspecified&nbsp;properties.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;no&nbsp;URL&nbsp;or&nbsp;components&nbsp;are&nbsp;specified&nbsp;the&nbsp;URL&nbsp;defaults&nbsp;to&nbsp;that</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;the&nbsp;local&nbsp;coordinator&nbsp;service.</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;1.1&nbsp;properties&nbsp;:&nbsp;only&nbsp;set&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;use&nbsp;a&nbsp;non-local&nbsp;coordinator</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry&nbsp;key=&quot;org.jboss.jbossts.xts11.coordinatorURL&quot;&gt;http://localhost:8080/ws-c11/ActivationService&lt;/entry&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry&nbsp;key=&quot;org.jboss.jbossts.xts11.coordinator.scheme&quot;&gt;http&lt;/entry&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry&nbsp;key=&quot;org.jboss.jbossts.xts11.coordinator.address&quot;&gt;localhost&lt;/entry&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry&nbsp;key=&quot;org.jboss.jbossts.xts11.coordinator.port&quot;&gt;8080&lt;/entry&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;&lt;entry&nbsp;key=&quot;org.jboss.jbossts.xts11.coordinator.path&quot;&gt;ws-c11/ActivationService&lt;/entry&gt;</span><span class="xml_plain"></span><br />
<span class="xml_comment">&nbsp;&nbsp;&nbsp;&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>
            You can also specify the individual elements of the URL using the properties
            <code class="varname">coordinator.scheme</code>
            ,
            <code class="varname">coordinator.address</code>
            , and so forth. These values only
            apply when the
            <code class="varname">coordinator.url</code>
            is not set. The URL is constructed by combining the specified
            values with default values for any missing elements. This is particularly useful for two specific use cases.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                    The first case is where the client is expected to use an XTS coordinator deployed in another WildFly Application Server.
                    If,
                    for example, this WildFly Application Server
                    is bound to address
                    <code class="literal">10.0.1.99</code>
                    , setting property
                    <code class="varname">coordinator.address</code>
                    to
                    <code class="literal">10.0.1.99</code>
                    is normally all that is required to
                    configure the coordinator URL to identity the remote WildFly Application Server's
                    coordination service. If the Web service on
                    the remote WildFly Application Server
                    were reset to
                    <code class="literal">9090</code>
                    then it would also be necessary to set property
                    <code class="varname">coordinator.port</code>
                    to this value.
                </p></li><li><p>
                    The second common use case is where communications between client and coordinator, and between
                    participant and
                    coordinator, must use secure connections. If property
                    <code class="varname">coordinator.scheme</code>
                    is set to value
                    <code class="literal">https</code>,
                    the client's request to begin a transaction is sent to the coordinator service over
                    a secure https connection. The XTS coordinator and participant services will ensure that all subsequent
                    communications between coordinator and client or coordinator and web services also employ secure
                    https
                    connections. Note that this requires configuring the trust stores in the WildFly Application Server
                    running the client,
                    coordinator and participant web services with appropriate trust certificates.
                </p></li></ol></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                The property names have been abbreviated in order to fit into the table. They should each start with
                prefix
                <code class="literal">org.jboss.jbossts.xts11.coordinator</code>
                .
            </p></div><div class="table"><a id="list-option-priority"/><p class="title"><b>Table 4.1. 
                Command-Line Options Passed with the
                <em class="parameter"><code>-D</code></em>
                Parameter, Ordered by Priority
            </b></p><div class="table-contents"><table summary="&#xA;                Command-Line Options Passed with the&#xA;                -D&#xA;                Parameter, Ordered by Priority&#xA;            " border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>
                            <p>Category</p>
                        </th><th>
                            <p>Property</p>
                        </th><th>
                            <p>Format</p>
                        </th></tr></thead><tbody><tr><td>
                            <p>Absolute URL</p>
                        </td><td>
                            <p>
                                <code class="varname">...coordinatorURL</code>
                            </p>
                        </td><td>
                            <p>
                                <a class="ulink" href="http://coord.host:coord.port/ws-c11/ActivationService">http://coord.host:coord.port/ws-c11/ActivationService</a>
                            </p>
                        </td></tr><tr><td>
                            <p>Coordinator Scheme, Host, Port, and Path</p>
                        </td><td>
                            <p>
                                <code class="varname">...coordinator.scheme</code>
                            </p>
                            <p>
                                <code class="varname">...coordinator.address</code>
                            </p>
                            <p>
                                <code class="varname">...coordinator.port</code>
                            </p>
                            <p>
                                <code class="varname">...coordinator.path</code>
                            </p>
                        </td><td>
                            <p>
                                <code class="literal">http</code>
                            </p>
                            <p>
                                <em class="replaceable"><code>server.bind.address</code></em>
                            </p>
                            <p>
                                <em class="replaceable"><code>jboss.web.bind.port</code></em>
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5617"/>4.5. Participant Crash Recovery</h2></div></div></div><a id="d0e5620" class="indexterm"/><a id="d0e5623" class="indexterm"/><a id="d0e5626" class="indexterm"/><p>
        A key requirement of a transaction service is to be resilient to a system crash by a host running a participant,
        as
        well as the host running the transaction coordination services. Crashes which happen before a transaction terminates
        or before a business activity completes are relatively easy to accommodate. The transaction service and participants
        can adopt a
        <em class="firstterm">presumed abort</em>
        policy.
    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="procedure"><a id="d0e5634"/><p class="title"><b>Procedure 4.2. Presumed Abort Policy</b></p><ol class="1"><li><p>
                If the coordinator crashes, it can assume that any transaction it does not know about is invalid, and reject a
                participant request which refers to such a transaction.
            </p></li><li><p>
                If the participant crashes, it can forget any provisional changes it has made, and reject any request from the
                coordinator service to prepare a transaction or complete a business activity.
            </p></li></ol></div><p>
        Crash recovery is more complex if the crash happens during a transaction commit operation, or between completing and
        closing a business activity. The transaction service must ensure as far as possible that participants arrive at
        a
        consistent outcome for the transaction.
    </p><div class="variablelist"><dl><dt><span class="term">WS-AT Transaction</span></dt><dd><p>
                    The transaction needs to commit all provisional changes or roll them all back to the state before the
                    transaction started.
                </p></dd><dt><span class="term">WS-Business Activity Transaction</span></dt><dd><p>
                    All participants need to close the activity or cancel the activity, and run any required compensating
                    actions.
                </p></dd></dl></div><p>
        On the rare occasions where such a consensus cannot be reached, the transaction service must log and report
        transaction failures.

    </p><p>
        XTS includes support for automatic recovery of WS-AT and WS-BA transactions, if either or both of the coordinator
        and participant hosts crashes. The XTS recovery manager begins execution on coordinator and participant hosts when
        the XTS service restarts. On a coordinator host, the recovery manager detects any WS-AT transactions which have
        prepared but not committed, as well as any WS-BA transactions which have completed but not yet closed. It ensures
        that all their participants are rolled forward in the first case, or closed in the second.
    </p><p>
        On a participant host, the recovery manager detects any prepared WS-AT participants which have not responded to a
        transaction rollback, and any completed WS-BA participants which have not yet responded to an activity cancel
        request, and ensures that the former are rolled back and the latter are compensated. The recovery service also
        allows for recovery of subordinate WS-AT transactions and their participants if a crash occurs on a host where
        an
        interposed WS-AT coordinator has been employed.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5664"/>4.5.1. WS-AT Recovery</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5667"/>4.5.1.1. WS-AT Coordinator Crash Recovery</h4></div></div></div><p>
                The WS-AT coordination service tracks the status of each participant in a transaction as the transaction
                progresses through its two-phase commit. When all participants have been sent a
                <code class="systemitem">prepare</code>
                message and have responded with a
                <code class="systemitem">prepared</code>
                message, the coordinator writes a log record
                storing each participant's details, indicating that the transaction is ready to complete. If the coordinator
                service crashes after this point has been reached, completion of the two-phase commit protocol is still
                guaranteed, by reading the log file after reboot and sending a
                <code class="systemitem">commit</code>
                message to each
                participant. Once all participants have responded to the
                <code class="systemitem">commit</code>
                with a
                <code class="systemitem">committed</code>
                message, the coordinator can safely delete the log entry.
            </p><p>
                Since the
                <code class="systemitem">prepared</code>
                messages returned by the participants imply that they are ready to
                commit their provisional changes and make them permanent, this type of recovery is safe. Additionally, the
                coordinator does not need to account for any commit messages which may have been sent before the crash, or
                resend messages if it crashes several times. The XTS participant implementation is resilient to redelivery of
                the
                <code class="systemitem">commit</code>
                messages. If the participant has implemented the recovery functions
                described in
                <a class="xref" href="#ws-at-recovery-api" title="4.5.1.2.1. WS-AT Participant Crash Recovery APIs">Section 4.5.1.2.1, “WS-AT Participant Crash Recovery APIs”</a>
                , the coordinator can guarantee delivery of
                <code class="systemitem">commit</code>
                messages if both it crashes, and one or more of the participant service hosts
                also crash, at the same time.
            </p><p>
                If the coordination service crashes before the
                <code class="systemitem">prepare</code>
                phase completes, the presumed
                abort protocol ensures that participants are rolled back. After system restart, the coordination service has the
                information about about all the transactions which could have entered the
                <code class="systemitem">commit</code>
                phase
                before the reboot, since they have entries in the log. It also knows about any active transactions started after
                the reboot. If a participant is waiting for a response, after sending its
                <code class="systemitem">prepared</code>
                message, it automatically re-sends the
                <code class="systemitem">prepared</code>
                message at regular intervals. When the
                coordinator detects a transaction which is not active and has no entry in the log file after the reboot, it
                instructs the participant to abort, ensuring that the web service gets a chance to roll back any provisional
                state changes it made on behalf of the transaction.
            </p><p>
                A web service may decide to unilaterally commit or roll back provisional changes associated with a given
                participant, if configured to time-out after a specified length of time without a response. In this situation,
                the the web service should record this action and log a message to persistent storage. When the participant
                receives a request to commit or roll back, it should throw an exception if its unilateral decision action does
                not match the requested action. The coordinator detects the exception and logs a message marking the outcome as
                heuristic. It also saves the state of the transaction permanently in the transaction log, to be
                inspected and
                reconciled by an administrator.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5716"/>4.5.1.2. WS-AT Participant Crash Recovery</h4></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning!</h2><p>
                    This part is relevant only if Raw XTS API is used. JTA integration does the recovery automatically.
                </p></div><p>
                WS-AT participants associated with a transactional web service do not need to be involved in crash recovery if
                the Web service's host machine crashes before the participant is told to prepare. The coordinator will assume
                that the transaction has aborted, and the Web service can discard any information associated with unprepared
                transactions when it reboots.
            </p><p>
                When a participant is told to
                <code class="systemitem">prepare</code>
                , the Web service is expected to save to
                persistent storage the transactional state it needs to commit or roll back the transaction. The specific
                information it needs to save is dependent on the implementation and business logic of the Web Service. However,
                the participant must save this state before returning a
                <code class="systemitem">Prepared</code>
                vote from the
                <code class="methodname">prepare</code>
                call. If the participant cannot save the required state, or there is some other
                problem servicing the request made by the client, it must return an
                <code class="systemitem">Aborted</code>
                vote.
            </p><p>
                The XTS participant services running on a Web Service's host machine cooperate with the Web service
                implementation to facilitate participant crash recovery. These participant services are responsible for
                calling
                the participant's
                <code class="methodname">prepare</code>
                ,
                <code class="methodname">commit</code>
                , and
                <code class="systemitem">rollback</code>
                methods. The XTS implementation tracks the local state of every enlisted
                participant. If the
                <code class="systemitem">prepare</code>
                call returns a
                <code class="systemitem">Prepared</code>
                vote, the
                XTS implementation ensures that the participant state is logged to the local transaction log before forwarding a
                <code class="systemitem">prepared</code>
                message to the coordinator.
            </p><p>
                A participant log record contains information identifying the participant, its transaction, and its
                coordinator. This is enough information to allow the rebooted XTS implementation to reinstate the participant as
                active and to continue communication with the coordinator, as though the participant had been enlisted and
                driven to the prepared state. However, a participant instance is still necessary for the commit or rollback
                process to continue.
            </p><p>
                Full recovery requires the log record to contain information needed by the Web service which enlisted
                the
                participant. This information must allow it to recreate an equivalent participant instance, which can continue
                the
                <code class="systemitem">commit</code>
                process to completion, or roll it back if some other Web Service fails to
                <code class="systemitem">prepare</code>
                . This information might be as simple as a String key which the participant can
                use to locate the data it made persistent before returning its Prepared vote. It may be as complex as a
                serialized object tree containing the original participant instance and other objects created by the Web
                service.
            </p><p>
                If a participant instance implements the relevant interface, the XTS implementation will append this
                participant
                recovery state to its log record before writing it to persistent storage. In the event of a crash, the
                participant recovery state is retrieved from the log and passed to the Web Service which created it. The Web
                Service uses this state to create a new participant, which the XTS implementation uses to drive the transaction
                to completion. Log records are only deleted after the participant's
                <code class="methodname">commit</code>
                or
                <code class="methodname">rollback</code>
                method is called.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>
                    If a crash happens just before or just after a
                    <code class="methodname">commit</code>
                    method is called, a
                    <code class="methodname">commit</code>
                    or
                    <code class="methodname">rollback</code>
                    method may be called twice.
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="ws-at-recovery-api"/>4.5.1.2.1. WS-AT Participant Crash Recovery APIs</h5></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e5793"/>4.5.1.2.1.1. Saving Participant Recovery State</h6></div></div></div><p>
                        When a Business Activity participant web service completes its work, it may want to save the information
                        which will be required later to close or compensate actions performed during the activity. The XTS
                        implementation automatically acquires this information from the participant as part of the completion
                        process and writes it to a participant log record. This ensures that the information can be restored and
                        used to recreate a copy of the participant even if the web service container crashes between the complete
                        and close or compensate operations.
                    </p><p>
                        For a Participant Completion participant, this information is acquired when the web service
                        invokes the
                        <code class="methodname">completed</code>
                        method of the
                        <code class="classname">BAParticipantManager</code>
                        instance
                        returned from the call which enlisted the participant. For a Coordinator Completion participant this occurs
                        immediately after the call to it's
                        <code class="methodname">completed</code>
                        method returns. This assumes that the
                        <code class="methodname">completed</code>
                        method does not throw an exception or call the participant manager's
                        <code class="methodname">cannotComplete</code>
                        or
                        <code class="methodname">fail</code>
                        method.
                    </p><p>
                        A participant may signal that it is capable of performing recovery processing, by implementing
                        the
                        <code class="interfacename">java.lang.Serializable</code>
                        interface. An alternative is to implement the
                        <a class="xref" href="#example-PersistableATParticipant" title="Example 4.4.  PersistableATParticipant Interface">Example 4.4, “
                            PersistableATParticipant
                            Interface
                        ”</a>
                        .
                    </p><div class="example"><a id="example-PersistableATParticipant"/><p class="title"><b>Example 4.4. 
                            <code class="interfacename">PersistableATParticipant</code>
                            Interface
                        </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">PersistableATParticipant</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">byte</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;getRecoveryState</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_separator">}</span>
</pre></div></div><br class="example-break"/><p>
                        If a participant implements the
                        <code class="interfacename">Serializable</code>
                        interface, the XTS participant
                        services implementation uses the serialization API to create a version of the participant which can be
                        appended to the participant log entry. If it implements the
                        <code class="interfacename">PersistableATParticipant</code>
                        interface, the XTS participant services
                        implementation call the
                        <code class="methodname">getRecoveryState</code>
                        method to obtain the state to be appended
                        to the participant log entry.
                    </p><p>
                        If neither of these APIs is implemented, the XTS implementation logs a warning message and proceeds without
                        saving any recovery state. In the event of a crash on the host machine for the Web service during commit,
                        the transaction cannot be recovered and a heuristic outcome may occur. This outcome is logged on the host
                        running the coordinator services.
                    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h6 class="title"><a id="d0e5846"/>4.5.1.2.1.2. Recovering Participants at Reboot</h6></div></div></div><p>
                        A Web service must register with the XTS implementation when it is deployed, and unregister when
                        it is
                        undeployed, in order to participate in recovery processing. Registration is performed using class
                        <code class="classname">XTSATRecoveryManager</code>
                        defined in package
                        <span class="package">org.jboss.jbossts.xts.recovery.participant.at</span>
                        .
                    </p><div class="example"><a id="d0e5857"/><p class="title"><b>Example 4.5. Registering for Recovery</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">abstract</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">XTSATRecoveryManager</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_separator">.</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">XTSATRecoveryManager</span><span class="java_plain">&nbsp;getRecoveryManager</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;registerRecoveryModule</span><span class="java_separator">(</span><span class="java_type">XTSATRecoveryModule</span><span class="java_plain">&nbsp;module</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">abstract</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;unregisterRecoveryModule</span><span class="java_separator">(</span><span class="java_type">XTSATRecoveryModule</span><span class="java_plain">&nbsp;module</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">NoSuchElementException</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_separator">.</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>
                        The Web service must provide an implementation of interface
                        <code class="interfacename">XTSBARecoveryModule</code>
                        in package
                        <span class="package">
                            org.jboss.jbossts.xts.recovery.participant.ba
                        </span>
                        , as an argument to the
                        <code class="methodname">register</code>
                        and
                        <code class="methodname">unregister</code>
                        calls. This instance identifies
                        saved participant recovery records and recreates new, recovered participant instances:
                    </p><div class="example"><a id="d0e5876"/><p class="title"><b>Example 4.6. 
                            <code class="interfacename">XTSBARecoveryModule</code>
                            Interface
                        </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">XTSATRecoveryModule</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Durable2PCParticipant</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserialize</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;id</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">ObjectInputStream</span><span class="java_plain">&nbsp;stream</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Durable2PCParticipant</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recreate</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;id</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span><span class="java_type">byte</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;recoveryState</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;endScan</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>
                        If a participant's recovery state was saved using serialization, the recovery module's
                        <code class="methodname">deserialize</code>
                        method is called to recreate the participant. Normally, the recovery
                        module is required to read, cast, and return an object from the supplied input stream. If a participant's
                        recovery state was saved using the
                        <code class="interfacename">PersistableATParticipant</code>
                        interface, the
                        recovery module's
                        <code class="methodname">recreate</code>
                        method is called to recreate the participant from the
                        byte array it provided when the state was saved.
                    </p><p>
                        The XTS implementation cannot identify which participants belong to which recovery modules. A
                        module only
                        needs to return a participant instance if the recovery state belongs to the module's Web service. If the
                        participant was created by another Web service, the module should return
                        <code class="literal">null</code>
                        . The
                        participant identifier, which is supplied as argument to the
                        <code class="methodname">deserialize</code>
                        or
                        <code class="methodname">recreate</code>
                        method, is the identifier used by the Web service when the original
                        participant was enlisted in the transaction. Web Services participating in recovery processing should ensure
                        that participant identifiers are unique per service. If a module recognizes that a participant identifier
                        belongs to its Web service, but cannot recreate the participant, it should throw an exception. This
                        situation might arise if the service cannot associate the participant with any transactional information
                        which is specific to the business logic.
                    </p><p>
                        Even if a module relies on serialization to create the participant recovery state saved by the
                        XTS
                        implementation, it still must be registered by the application. The
                        <code class="methodname">deserialization</code>
                        operation must employ a class loader capable of loading classes specific to the Web service. XTS
                        fulfills
                        this requirement by devolving responsibility for the
                        <code class="methodname">deserialize</code>
                        operation to the
                        recovery module.
                    </p></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5914"/>4.5.2. WS-BA Recovery</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e5917"/>4.5.2.1. WS-BA Coordinator Crash Recovery</h4></div></div></div><p>
                The WS-BA coordination service implementation tracks the status of each participant in an activity as
                the
                activity progresses through completion and closure. A transition point occurs during closure, once all
                <code class="systemitem">CoordinatorCompletion</code>
                participants receive a
                <code class="systemitem">complete</code>
                message
                and respond with a
                <code class="systemitem">completed</code>
                message. At this point, all
                <code class="systemitem">ParticipantCompletion</code>
                participants should have sent a
                <code class="systemitem">completed</code>
                message. The coordinator writes a log record storing the details of each
                participant, and indicating that the transaction is ready to close. If the coordinator service crashes after the
                log record is written, the
                <code class="methodname">close</code>
                operation is still guaranteed to be successful. The
                coordinator checks the log after the system reboots and re-sends a
                <code class="systemitem">close</code>
                message to all
                participants. After all participants respond to the
                <code class="systemitem">close</code>
                with a
                <code class="systemitem">closed</code>
                message, the coordinator can safely delete the log entry.
            </p><p>
                The coordinator does not need to account for any
                <code class="systemitem">close</code>
                messages sent before the crash,
                nor resend messages if it crashes several times. The XTS participant implementation is resilient to redelivery
                of
                <code class="systemitem">close</code>
                messages. Assuming that the participant has implemented the recovery functions
                described below, the coordinator can even guarantee delivery of
                <code class="systemitem">close</code>
                messages if both
                it, and one or more of the participant service hosts, crash simultaneously.
            </p><p>
                If the coordination service crashes before it has written the log record, it does not need to explicitly
                compensate any completed participants. The
                <span>presumed abort protocol</span>
                ensures that all completed
                participants are eventually sent a
                <code class="systemitem">compensate</code>
                message. Recovery must be initiated from
                the participant side.
            </p><p>
                A log record does not need to be written when an activity is being canceled. If a participant does not
                respond
                to a
                <code class="systemitem">cancel</code>
                or
                <code class="systemitem">compensate</code>
                request, the coordinator logs a
                warning and continues. The combination of the
                <span>presumed abort protocol</span>
                and participant-led
                recovery ensures that all participants eventually get canceled or compensated, as appropriate, even if the
                participant host crashes.
            </p><p>
                If a completed participant does not detect a response from its coordinator after resending its
                <code class="systemitem">completed</code>
                response a suitable number of times, it switches to sending
                <code class="systemitem">getstatus</code>
                messages, to determine whether the coordinator still knows about it. If a
                crash occurs before writing the log record, the coordinator has no record of the participant when the
                coordinator restarts, and the
                <code class="systemitem">getstatus</code>
                request returns a fault. The participant
                recovery manager automatically compensates the participant in this situation, just as if the activity had been
                canceled by the client.
            </p><p>
                After a participant crash, the participant recovery manager detects the log entries for each completed
                participant. It sends
                <code class="systemitem">getstatus</code>
                messages to each participant's coordinator host, to
                determine whether the activity still exists. If the coordinator has not crashed and the activity is still
                running, the participant switches back to resending
                <code class="systemitem">completed</code>
                messages, and waits for a
                <code class="systemitem">close</code>
                or
                <code class="systemitem">compensate</code>
                response. If the coordinator has also
                crashed or the activity has been canceled, the participant is automatically canceled.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6005"/>4.5.2.2. WS-BA Participant Crash Recovery APIs</h4></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e6008"/>4.5.2.2.1. Saving Participant Recovery State</h5></div></div></div><p>
                    A participant may signal that it is capable of performing recovery processing, by implementing the
                    <code class="interfacename">java.lang.Serializable</code>
                    interface. An alternative is to implement the
                    <a class="xref" href="#example-PersistableBAParticipant" title="Example 4.7.  PersistableBAParticipant Interface">Example 4.7, “
                        PersistableBAParticipant
                        Interface
                    ”</a>
                    .
                </p><div class="example"><a id="example-PersistableBAParticipant"/><p class="title"><b>Example 4.7. 
                        <code class="interfacename">PersistableBAParticipant</code>
                        Interface
                    </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">PersistableBAParticipant</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">byte</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;getRecoveryState</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_separator">}</span>
</pre></div></div><br class="example-break"/><p>
                    If a participant implements the
                    <code class="interfacename">Serializable</code>
                    interface, the XTS participant
                    services implementation uses the serialization API to create a version of the participant which can be
                    appended to the participant log entry. If the participant implements the
                    <code class="interfacename">PersistableBAParticipant</code>
                    , the XTS participant services implementation call the
                    <code class="methodname">getRecoveryState</code>
                    method to obtain the state, which is appended to the participant log
                    entry.
                </p><p>
                    If neither of these APIs is implemented, the XTS implementation logs a warning message and proceeds without
                    saving any recovery state. If the Web service's host machine crashes while the activity is being closed, the
                    activity cannot be recovered and a heuristic outcome will probably be logged on the coordinator's host
                    machine. If the activity is canceled, the participant is not compensated and the coordinator host machine may
                    log a heuristic outcome for the activity.
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e6039"/>4.5.2.2.2. Recovering Participants at Reboot</h5></div></div></div><p>
                    A Web service must register with the XTS implementation when it is deployed, and unregister when it is
                    undeployed, so it can take part in recovery processing.
                </p><p>
                    Registration is performed using the
                    <code class="classname">XTSBARecoveryManager</code>
                    , defined in the
                    <span class="package">org.jboss.jbossts.xts.recovery.participant.ba</span>
                    package.
                </p><div class="example"><a id="d0e6052"/><p class="title"><b>Example 4.8. 
                        <code class="classname">XTSBARecoveryManager</code>
                        Class
                    </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">abstract</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">class</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">XTSBARecoveryManager</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_separator">.</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">static</span><span class="java_plain">&nbsp;</span><span class="java_type">XTSBARecoveryManager</span><span class="java_plain">&nbsp;getRecoveryManager</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;registerRecoveryModule</span><span class="java_separator">(</span><span class="java_type">XTSBARecoveryModule</span><span class="java_plain">&nbsp;module</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">abstract</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;unregisterRecoveryModule</span><span class="java_separator">(</span><span class="java_type">XTSBARecoveryModule</span><span class="java_plain">&nbsp;module</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">NoSuchElementException</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_separator">.</span><span class="java_plain">&nbsp;</span><span class="java_separator">.</span>
<!--  --><br/><span class="java_separator">}</span>
</pre></div></div><br class="example-break"/><p>
                    The Web service must provide an implementation of the
                    <code class="classname">XTSBARecoveryModule</code>
                    in the
                    <span class="package"> org.jboss.jbossts.xts.recovery.participant.ba</span>
                    , as an argument to the
                    <code class="methodname">register</code>
                    and
                    <code class="methodname">unregister</code>
                    calls. This instance identifies
                    saved participant recovery records and recreates new, recovered participant instances:
                </p><div class="example"><a id="d0e6074"/><p class="title"><b>Example 4.9. 
                        <code class="interfacename">XTSBARecoveryModule</code>
                        Interface
                    </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">XTSBARecoveryModule</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">BusinessAgreementWithParticipantCompletionParticipant</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializeParticipantCompletionParticipant</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;id</span><span class="java_separator">,</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">ObjectInputStream</span><span class="java_plain">&nbsp;stream</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">BusinessAgreementWithParticipantCompletionParticipant</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recreateParticipantCompletionParticipant</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;id</span><span class="java_separator">,</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">byte</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;recoveryState</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">BusinessAgreementWithCoordinatorCompletionParticipant</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deserializeCoordinatorCompletionParticipant</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;id</span><span class="java_separator">,</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">ObjectInputStream</span><span class="java_plain">&nbsp;stream</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">BusinessAgreementWithCoordinatorCompletionParticipant</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recreateCoordinatorCompletionParticipant</span><span class="java_separator">(</span><span class="java_type">String</span><span class="java_plain">&nbsp;id</span><span class="java_separator">,</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">byte</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;recoveryState</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throws</span><span class="java_plain">&nbsp;</span><span class="java_type">Exception</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;endScan</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
</pre></div></div><br class="example-break"/><p>
                    If a participant's recovery state was saved using serialization, one of the recovery module's
                    <code class="methodname">deserialize</code>
                    methods is called, so that it can recreate the participant. Which method
                    to use depends on whether the saved participant implemented the
                    <code class="classname">ParticipantCompletion</code>
                    protocol or the
                    <code class="classname">CoordinatorCompletion</code>
                    protocol. Normally, the recovery module reads,
                    casts and returns an object from the supplied input stream. If a participant's recovery state was saved using
                    the
                    <code class="interfacename">PersistableBAParticipant</code>
                    interface, one of the recovery module's
                    <code class="methodname">recreate</code>
                    methods is called, so that it can recreate the participant from the byte
                    array provided when the state was saved. The method to use depends on which protocol the saved participant
                    implemented.
                </p><p>
                    The XTS implementation does not track which participants belong to which recovery modules. A module
                    is only
                    expected to return a participant instance if it can identify that the recovery state belongs to its Web
                    service. If the participant was created by some other Web service, the module should return
                    <code class="literal">null</code>
                    . The participant identifier supplied as an argument to the
                    <code class="methodname">deserialize</code>
                    or
                    <code class="methodname">recreate</code>
                    calls is the identifier used by the
                    Web service when the original participant was enlisted in the transaction. Web Services which participate in
                    recovery processing should ensure that the participant identifiers they employ are unique per service. If a
                    module recognizes a participant identifier as belonging to its Web service, but cannot recreate the
                    participant, it throws an exception. This situation might arise if the service cannot associate the
                    participant with any transactional information specific to business logic.
                </p><p>
                    A module must be registered by the application, even when it relies upon serialization to create the
                    participant recovery state saved by the XTS implementation. The
                    <code class="methodname">deserialization</code>
                    operation must employ a class loader capable of loading Web service-specific classes. The XTS
                    implementation
                    achieves this by delegating responsibility for the
                    <code class="methodname">deserialize</code>
                    operation to the
                    recovery module.
                </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h5 class="title"><a id="d0e6118"/>4.5.2.2.3. Securing Web Service State Changes</h5></div></div></div><p>
                    When a BA participant completes, it is expected to commit changes to the web service state made during the
                    activity. The web service usually also needs to persist these changes to a local storage device. This leaves
                    open a window where the persisted changes may not be guarded with the necessary compensation information. The
                    web service container may crash after the changes to the service state have been written but before the XTS
                    implementation is able to acquire the recovery state and write a recovery log record for the
                    participant.
                    Participants may close this window by employing a two phase update to the local store used to persist the web
                    service state.
                </p><p>
                    A participant which needs to persist changes to local web service state should implement interface
                    <code class="classname">ConfirmCompletedParticipant</code>
                    in package
                    <span class="package">com.arjuna.wst11</span>
                    . This
                    signals to the XTS implementation that it expects confirmation after a successful write of the participant
                    recovery record, allowing it to roll forward provisionally persisted changes to the web service
                    state. Delivery of this confirmation can be guaranteed even if the web service container crashes after
                    writing the participant log record. Conversely, if a recovery record cannot be written because of a fault or
                    a crash prior to writing, the provisional changes can be guaranteed to be rolled back.
                </p><div class="example"><a id="d0e6131"/><p class="title"><b>Example 4.10. 
                        <code class="interfacename">ConfirmCompletedParticipant</code>
                        Interface
                    </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">public</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_keyword">interface</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">ConfirmCompletedParticipant</span>
<!--  --><br/><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;confirmCompleted</span><span class="java_separator">(</span><span class="java_type">boolean</span><span class="java_plain">&nbsp;confirmed</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_separator">}</span>
</pre></div></div><br class="example-break"/><p>
                    When the participant is ready to complete, it should prepare its persistent changes by temporarily
                    locking
                    access to the relevant state in the local store and writing the changed data to disk, retaining both the old
                    and new versions of the service state. For a Participant Completion participant, this prepare operation should
                    be done just before calling the participant manager's
                    <code class="methodname">completed</code>
                    method. For a
                    Coordinator Completion participant, it should be done just before returning from the call to the participant's
                    <code class="methodname">completed</code>
                    method. After writing the participant log record, the XTS implementation
                    calls the participant's
                    <code class="methodname">confirmCompleted</code>
                    method, providing value
                    <code class="literal">true</code>
                    as the argument. The participant should respond by installing the provisional state
                    changes and releasing any locks. If the log record cannot be written, the XTS implementation calls the
                    participant's
                    <code class="methodname">confirmCompleted</code>
                    method, providing value
                    <code class="literal">false</code>
                    as
                    the argument. The participant should respond by restoring the original state values and releasing any locks.
                </p><p>
                    If a crash occurs before the call to
                    <code class="methodname">confirmCompleted</code>
                    , the application's recovery
                    module can make sure that the provisional changes to the web service state are rolled forward or rolled back
                    as appropriate. The web service must identify all provisional writes to persistent state before it starts
                    serving new requests or processing recovered participants. It must reobtain any locks required to ensure that
                    the state is not changed by new transactions. When the recovery module recovers a participant from the log,
                    its compensation information is available. If the participant still has prepared changes, the recovery code
                    must call
                    <code class="methodname">confirmCompleted</code>
                    , passing value true. This allows the participant to finish
                    the
                    <code class="methodname">complete</code>
                    operation. The XTS implementation then forwards a
                    <code class="systemitem">completed</code>
                    message to the coordinator, ensuring that the participant is subsequently
                    notified either to close or to compensate. At the end of the first recovery scan, the recovery module may find
                    some prepared changes on disk which are still unaccounted for. This means that the participant recovery record
                    is not available. The recovery module should restore the original state values and release any locks. The XTS
                    implementation responds to coordinator requests regarding the participant with an
                    <code class="systemitem">unknown
                        participant
                    </code>
                    fault, forcing the activity as a whole to be rolled back.
                </p></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6176"/>4.6. Web Service Transaction Service (XTS) Management</h2></div></div></div><p>
        The basic building blocks of a transactional Web Services application include the application itself, the Web
        services that the application consumes, the Transaction Manager, and the transaction participants which support
        those Web services. Although it is likely that different developers will be responsible for each piece, the concepts
        are presented here so that you can see the whole picture. Often, developers produce services, or applications that
        consume services, and system administrators run the transaction-management infrastructure.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6181"/>4.6.1. Transaction manager overview</h3></div></div></div><p>
            The transaction manager is a Web service which coordinates XTS transactions. It is the only software component
            in XTS that is designed to be run directly as a network service, rather than to support end-user code. The
            transaction manager runs as a JAXM request/response Web service.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                When starting up an application server instance that has XTS transaction manager deployed within it, you may
                see various “error” messages in the console or log. For example 16:53:38,850 ERROR [STDERR] Message Listener
                Service: started, message listener jndi name activationcoordinator". These are for information purposes only and
                are not actual errors.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6189"/>4.6.2. Configuring the transaction manager</h3></div></div></div><p>
            You can configure the Transaction Manager and related infrastructure by using two properties files.
            The
            <code class="filename">standalone-xts.xml</code>
            file contains the common configuration options. More advanced options
            can be configured in the
            <code class="filename">xts-properties.xml</code>
            .
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
            The XTS module (
            <code class="filename">modules/system/layers/base/org/jboss/xts/main/jbossxts-${XTS_VERSION}.jar</code>)
            in the WildFly Application Server
            includes the configuration file,
            <code class="filename">xts-properties.xml</code>,
            in the root of the jar. These properties can be edited and then
            re-packaged in the jar. The changes will take affect on next boot of the  WildFly Application Server.
        </div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6208"/>4.6.3. Deployment descriptors</h3></div></div></div><p>
            In general, changing the contents of the various deployment descriptors used by XTS is not necessary.
            However,
            if you do need to modify them they are all included in
            <code class="filename">modules/system/layers/base/org/jboss/xts/main/jbossxts-${XTS_VERSION}.jar</code>
            .
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6216"/>4.7. Quickstarts Overview</h2></div></div></div><p>
    There are multiple quickstarts provided on Narayana GitHub repository which should give you a better understanding
    of how to use our software. This chapter will give you a brief overview where to find them and what technologies
    they demonstrate.
  </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="ref-WSATMultiService"/>4.7.1. WS-AT Multi-Service</h3></div></div></div><p>
      Quickstart URL: <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/XTS/wsat-jta-multi_service">https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/XTS/wsat-jta-multi_service</a>
    </p><p>
      This quickstart uses JTA to manage WS-AT applications. The quickstart is composed of a client (the test) and two
      Web services (FirstServiceAT and SecondServiceAT). Both services are invoked by the test from within the same JTA
      transaction.
    </p><p>
      The Client begins a JTA transaction and then invokes an operation on each service. Transaction context propagation
      is enabled by default. Therefore XTS automatically bridges the JTA transaction to a WS-AT transaction before each
      invocation is made.
    </p><p>
      Each service uses JPA to persist its data (the value of a counter). Therefore, the service class is annotated with
      javax.ejb.TransactionAttribute which tells XTS to automatically bridge WS-AT transaction to JTA.
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="ref-WSATMultiHop"/>4.7.2. WS-AT Multi-Hop</h3></div></div></div><p>
      Quickstart URL: <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/XTS/wsat-jta-multi_hop">https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/XTS/wsat-jta-multi_hop</a>
    </p><p>
      This quickstart uses JTA to manage WS-AT applications. The quickstart is composed of a client (the test) and two
      Web services (FirstServiceAT and SecondServiceAT).
    </p><p>
      The Client begins a JTA transaction and then invokes an operation on FirstServiceAT. Transaction context
      propagation is enabled by default. Therefore XTS automatically bridges the JTA transaction to a WS-AT transaction
      before the invocation is made.
    </p><p>
      FirstServiceAT uses JPA to persist its data. Therefore, the service class is annotated with
      javax.ejb.TransactionAttribute which tells XTS to automatically bridge WS-AT transaction to JTA. The
      FirstServiceAT Web Service updates some local data and then invokes the SecondServiceAT Web services.
    </p><p>
      Similarly, to when invoking FirstServiceAT, the JTA transaction is bridged to a WS-AT transaction when invoking
      SecondServiceAT. SecondServiceAT also uses JPA for persistence, so the incoming WS-AT transaction is again bridged
      to JTA.
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6249"/>4.7.3. XTS with SSL</h3></div></div></div><p>
      Quickstart URL: <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/XTS/ssl">https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/XTS/ssl</a>
    </p><p>
      This example walks you through the steps required to setup two servers (client and server) that communicate via
      Web services over a secure connection. The example show how this can be done for WS-Atomic Transaction, but the
      same applies for WS Business Activity.
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6258"/>4.7.4. Raw XTS API Demo</h3></div></div></div><p>
      Quickstart URL: <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/XTS/raw-xts-api-demo">https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/XTS/raw-xts-api-demo</a>
    </p><p>
      This example demonstrates the whole range of XTS possibilities, including WS-AT and WS-BA.
    </p><p>
      This example uses the Raw XTS API. It is only recommended for scenarios where the WS-AT to JTA integration is not
      appropriate; or where the Compensating Transactions API support for WS-BA is not appropriate.
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="ref-CompensationsNonTransactionalResource"/>4.7.5. Non-transactional Resource with Compensating Transactions API</h3></div></div></div><p>
      Quickstart URL: <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/compensating-transactions/non-transactional_resource">https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/compensating-transactions/non-transactional_resource</a>
    </p><p>
      This example demonstrates the simple use case of our API for developing applications that use Compensating
      Transactions. It shows how a non-transactional activity (such as sending an email, or printing a document) can be
      coordinated in a compensating transaction.
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="ref-CompensationsTravelAgent"/>4.7.6. Travel Agent with Compensating Transactions API</h3></div></div></div><p>
      Quickstart URL: <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/compensating-transactions/travel-agent">https://github.com/jbosstm/quickstart/tree/5.0.4.Final-SNAPSHOT/compensating-transactions/travel-agent</a>
    </p><p>
      This example demonstrates the more complex use case of our API for developing applications that use Compensating
      Transactions. It shows how a long running compensating transaction can be composed of a series of short-running
      ACID transactions. The example also involves multiple organisations and forms a distributed transaction over Web
      Services.
    </p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6287"/>Chapter 5. TXBridge Guide</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e6290">5.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6293">5.1.1. Contextual Overview</a></span></dt><dt><span class="section"><a href="#d0e6306">5.1.2. Transaction Bridging</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6335">5.2. Transaction Bridge Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6338">5.2.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e6355">5.2.2. Shared Design Elements</a></span></dt><dt><span class="section"><a href="#d0e6400">5.2.3. Inbound Bridging</a></span></dt><dt><span class="section"><a href="#d0e6433">5.2.4. Outbound Bridging</a></span></dt><dt><span class="section"><a href="#d0e6463">5.2.5. Crash Recovery</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6476">5.3. Using the Transaction Bridge</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6479">5.3.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6484">5.3.2. Enabling</a></span></dt><dt><span class="section"><a href="#d0e6537">5.3.3. Inbound Bridging</a></span></dt><dt><span class="section"><a href="#d0e6554">5.3.4. Outbound Bridging</a></span></dt><dt><span class="section"><a href="#d0e6571">5.3.5. Loops and Diamonds</a></span></dt><dt><span class="section"><a href="#d0e6586">5.3.6. Distributed JTA and the JTS</a></span></dt><dt><span class="section"><a href="#d0e6599">5.3.7. Logging</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6618">5.4. Known Limitations</a></span></dt><dt><span class="section"><a href="#d0e6648">5.5. Design Notes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6651">5.5.1. General Points</a></span></dt><dt><span class="section"><a href="#d0e6664">5.5.2. Crash Recovery Considerations</a></span></dt><dt><span class="section"><a href="#d0e6701">5.5.3. Test framework</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6290"/>5.1. Introduction</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6293"/>5.1.1. Contextual Overview</h3></div></div></div><p>Transactions provide a structuring mechanism for business logic. Use of transactions
            allows for grouping of data manipulations into constructs with certain properties. Traditional
            ACID transactions provide for properties of Atomicity, Consistency, Isolation and Durability.
        </p><p>In JavaEE applications, transaction support is provided via the Java Transaction API
            (JTA). The classes and interfaces in the javax.transaction and javax.transaction.xa packages
            provide a means by which the programmer may manage transaction demarcation (begin, commit,
            rollback) and, where necessary, interact with the transaction management system (e.g.
            enlistResource). In many JavaEE applications, further abstractions are provided on top of the
            JTA. For example, EJB3 @TransactionAttribute annotations may be used for transaction boundary
            demarcation in preference to explicit calls to the JTA's UserTransaction interface.
        </p><p>In
            distributed applications, the JTA implementation may provide propagation of transaction
            context and transaction control calls between containers (JVMs) using either a propriety
            transport or JTS, the Java mapping of the CORBA OTS standard on an RMI/IIOP transport. In
      Narayana,
            both local and distributed (JTS) implementations of the JTA are available.
        </p><p>In
            Web Services applications, ACID transaction management and interoperable context
            propagation is provided for by the WS-AT standard. Narayana
            XTS provides an implementation of
            both the 1.0 and 1.2 versions of this standard. Bridging is provided only on the more recent
            version. At the time of writing the standard covers only the web services API and protocol,
            not the Java API through which the protocol may be driven. Therefore, XTS provides a custom
            Java API to users, with characteristics broadly similar to the JTA.
        </p><p>For applications that combine traditional JavaEE transaction management and Web Service
            transaction management, it is often desirable to have some mechanism for linking these
            transaction types, such that a single transaction may span business logic written for either
            transaction type. Examples include exposing existing JavaEE transactional business logic (e.g.
            EJBs) as transactional Web Services, or allowing JavaEE transactional components to utilize
            transactional Web Services.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6306"/>5.1.2. Transaction Bridging</h3></div></div></div><p>We
            use the term Transaction Bridging to describe the process of linking the JavaEE and Web
            Services transaction domains. The transaction bridge component (txbridge) of Narayana
            provides
            bi-directional linkage, such that either type of transaction may encompass business logic
            designed for use with the other type.
        </p><p>The technique used by the bridge is a combination of interposition and protocol mapping.
        </p><p>Interposition is used in transaction systems to allow a tree of transaction coordinators
            to be constructed, usually for performance reasons. Interposed coordinators function as
            transaction managers for nodes below them in the tree, whilst appearing as resources
            (participants in WS-AT terminology) to the node above them.
        </p><p>Within a single transaction domain, interposition may be used to allow remote nodes to
            minimize the number of network calls necessary at transaction termination. The top level node
            is known as the root coordinator, whilst interposed coordinators are termed subordinate. This
            name indicates that they are not autonomously responsible for determining the transaction
            outcome, but rather are driven by their parent coordinator. Therefore, whilst a top level
            coordinator exposes only the commit and rollback methods for transaction termination and
            handles the 2PC internally, the subordinates additionally expose the prepare method to their
            parent, behaving much like resources during the termination protocol.
        </p><div class="figure"><a id="d0e6317"/><div class="figure-contents"><div class="mediaobject"><img src="images/txbridge-guide-interposition.png" alt="Transaction interposition in a distributed JTA environment"/></div></div><p class="title"><b>Figure 5.1. Transaction interposition in a distributed JTA environment</b></p></div><br class="figure-break"/><p>In the transaction bridge, an interposed coordinator is registered into the existing
            transaction and performs the additional task of protocol mapping. That is, it appears to its
            parent coordinator to be a resource of its native transaction type, whilst appearing to its
            children to be a coordinator of their native transaction type, even though these transaction
            types differ.
        </p><div class="figure"><a id="d0e6325"/><div class="figure-contents"><div class="mediaobject"><img src="images/txbridge-guide-bridgeinterposition.png" alt="Transactional bridging interposition"/></div></div><p class="title"><b>Figure 5.2. Transactional bridging interposition</b></p></div><br class="figure-break"/><p>The interposed coordinator is responsible for performing mapping between the transaction
            protocols. There is a strong correspondence between the API and protocol used by the JTA and
            WS-AT transaction types, which is unsurprising given their common heritage and shared problem
            domain. However, method signatures, exception types and such do differ. The bridge provides a
            abstraction layer to mask these distinctions as far as possible.
        </p><p>The net result of this is that existing business logic perceives its expected transaction
            environment, even though the transaction in which it is executing may be subordinate to one of
            a different type. No changes are necessary to existing transactional applications to allow
            them to operate in the scope of foreign transactions. This facilitates reuse of existing
            business logic components in new environments and increases the possibilities for new
            architectures and interoperability.
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6335"/>5.2. Transaction Bridge Architecture</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6338"/>5.2.1. Overview</h3></div></div></div><p>The transaction bridge resides in the package org.jboss.jbossts.txbridge and its
            subpackages.. It consists of two distinct sets of classes, one for bridging in each direction.
        </p><p>The process of inflowing a WS-AT transaction context on a Web Service call into the
            container and converting it to a local JTA transaction context such that existing
            transactional
            JavaEE code (e.g. EJBs) may be called within its scope, is termed Inbound
            Transaction Bridging.
            When using inbound bridging, a parent WS-AT transaction coordinator has a
            subordinate JTA
            coordinator interposed into it via the transaction bridge.
        </p><p>The process of outflowing a WS-AT transaction context on a call to a transactional Web
            Service from a business logic method operating in a JavaEE transaction scope, is termed
            Outbound
            Transaction Bridging. When using outbound bridging, a parent JTA transaction
            coordinator has a
            subordinate WS-AT coordinator interposed into it via the transaction bridge.
        </p><p>For
            the purpose of understanding this naming convention, it is simplest to view the JTA as
            being local to the container in which it operates, whilst the Web Service protocol provides
            for
            transaction context propagation between servers. This is an accurate representation of the
            situation that exists where the local JTA version of Narayana
            is being used alongside Narayana
            XTS
            in an application server. However, it is an oversimplification of the situation where the
            JTS
            option is used. We will return to this case later.
        </p><div class="figure"><a id="d0e6349"/><div class="figure-contents"><div class="mediaobject"><img src="images/txbridge-guide-architecture.png" alt="Simplified Bridge Architecture"/></div></div><p class="title"><b>Figure 5.3. Simplified Bridge Architecture</b></p></div><br class="figure-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6355"/>5.2.2. Shared Design Elements</h3></div></div></div><p>The design of the inbound and outbound bridges is conceptually very similar. Each provides
            the following:
        </p><div class="itemizedlist"><ul><li><p>
                    A
                    <span class="emphasis"><em>BridgeManager</em></span>
                    , essentially a factory singleton, providing a means of managing Bridge and
                    resource/participant instances. The chief role of the BridgeManager is to ensure a
                    distinct mapping of a parent transaction context to a single Bridge and
                    resource/participant instance.
                </p></li><li><p>
                    A
                    <span class="emphasis"><em>Bridge</em></span>
                    , which provides Thread to transaction context association and disassociation functions
                    for the subordinate transaction. The Bridge is usually called from the Handler, but may
                    optionally be driven directly.
                </p></li><li><p>
                    A
                    <span class="emphasis"><em>Handler</em></span>
                    , which is registered into the JAX-WS processing pipeline to provide minimally invasive
                    management of Thread to transaction context bindings via the Bridge, an appropriate
                    instance of which it obtains from the BridgeManager. Whilst the bridge provides handlers
                    only for JAX-WS, it's possible to use these as a model for the implementation of JAX-RPC
                    versions if desired.
                </p></li><li><p>
                    A
                    <span class="emphasis"><em>VolatileParticipant</em></span>
                    and
                    <span class="emphasis"><em>DurableParticipant</em></span>
                    (in the case of the InboundBridge) or
                    <span class="emphasis"><em>Synchronization</em></span>
                    and
                    <span class="emphasis"><em>XAResource</em></span>
                    (in the case of the OutboundBridge) which are enlisted into the parent transaction and
                    wrap the Subordinate transaction coordinator, providing mapping of the transaction
                    termination protocol operations.
                </p></li><li><p>
                    A
                    <span class="emphasis"><em>RecoveryManager</em></span>
                    , which is responsible for automatically restoring the state of crashed transactions and
                    allowing them to complete correctly.
                </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6400"/>5.2.3. Inbound Bridging</h3></div></div></div><p>The process flow when using the inbound bridge is as follows:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>A remote client starts a WS-AT transaction and invokes a transactional Web Service in
                    the scope of that transaction. The inbound WS invocation therefore has SOAP headers
                    containing the WS-AT transaction context. The coordinator used for this transaction is the
                    root coordinator. It may be remote from either or both of the client and the service it is
                    invoking. The client needs access to a WS-AT implementation, but not a JTA or the
                    transaction bridge deployed.
                </p></li><li><p>The
                    call arrives at a web service container, which must have Narayana
                    JTA or JTS, XTS
                    and the transaction bridge deployed. The JAX-WS handler chain for the web service should
                    have both the XTS WS-AT transaction header processor and the inbound bridge handler
                    registered, such that they are invoked in that order.
                </p></li><li><p>The transaction header processor takes the WS-AT transaction context from XML, creates
                    a corresponding WS-AT TxContext and associates it to the Thread. The bridge handler calls
                    the InboundBridgeManager to obtain an InboundBridge instance corresponding to the
                    TxContext.
                </p></li><li><p>As the BridgeManager is seeing the TxContext for the first time, it creates a new
                    Bridge instance. It also creates a new Bridge VolatileParticipant and DurableParticipant
                    and registers them with the WS-AT transaction coordinator. These Participants wrap a
                    subordinate JTA transaction.
                </p></li><li><p>The bridge header processor starts the bridge, which associates the JTA subordinate
                    transaction context to the Thread. At this point the Thread has transaction contexts for
                    both WS-AT and JTA.
                </p></li><li><p>The JAX-WS pipeline processing continues, eventually calling whatever business logic
                    is exposed. This may be e.g. an EJB using JSR-181 annotations. The business logic may use
                    the JTA transaction in the normal manner e.g. enlisting Synchronizations and XAResources
                    or performing other transactional activity either directly or though the usual JavaEE
                    abstractions.
                </p></li><li><p>On the return path, the bridge header processor disassociates the JTA transaction
                    context from the Thread via the Bridge. The XTS context processor then does likewise for
                    the WS-AT TxContext.
                </p></li><li><p>On subsequent web services calls to the same or other web services from the same
                    client, the process is repeated. However, the BridgeManager will, upon seeing the same
                    WS-AT transaction context again, return the existing Bridge instance and not register
                    further Participant instances. This allows substantially better performance than
                    registering one Participant per web service invocation.
                </p></li><li><p>Upon transaction termination by the client, the WS-AT transaction coordinator will
                    drive the enlisted bridge Participants through the transaction termination protocol. The
                    Participants maps these calls down to the JTA subtransaction coordinator, which in turn
                    passes them on to any Synchronizations or XAResources enlisted in the transaction. This
                    process is not visible to the business logic, except in so far as it may have registered
                    its own Synchronizations, XAResources or Participants with the transaction.
                </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6433"/>5.2.4. Outbound Bridging</h3></div></div></div><p>The process flow when using the outbound bridge is as follows:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>A
                    client starts a JTA transaction and invokes a remote transactional Web Service in
                    the scope of that transaction. The client must have Narayana
                    JTA (or JTS) and XTS deployed,
                    as well as the transaction bridge. The coordinator used for the JTA transaction is the
                    root coordinator. The server hosting the target web service needs a WS-AT transaction
                    implementation but not a JTA or the transaction bridge.
                </p></li><li><p>The outbound WS invocation flows though a handler chain that has the outbound
                    transaction bridge handler and XTS header context processor registered, such that they are
                    invoked in that order.
                </p></li><li><p>The bridge handler calls the outbound bridge manager to obtain an outbound bridge
                    instance corresponding to the JTA transaction context. As the BridgeManager is seeing the
                    context for the first time, it creates a new Bridge instance. It also creates a
                    Synchronization and XAResource instance to wrap the subordinate WS-AT transaction and
                    registers these with the JTA transaction.
                </p></li><li><p>The bridge handler starts the bridge, which associates the subordinate WS-AT
                    transaction context to the Thread. The WS-AT header context processor then serializes this
                    into XML in the headers of the outbound Web Services call.
                </p></li><li><p>The receiving Web Service sees a WS-AT context and can work with it in the normal
                    manner, without knowing it is a subordinate context.
                </p></li><li><p>On the return path, the bridge handler disassociates the WS-AT TxContext from the
                    Thread via the Bridge.
                </p></li><li><p>On subsequent calls to the same or other transactional Web Services in the scope of
                    the same JTA transaction, the process is repeated. However, the BridgeManager will, upon
                    seeing the same JTA transaction context again, return the existing Bridge and not register
                    another Synchronization or XAResource with the parent JTA transaction. This allows
                    substantially better performance than registering once per web service invocation.
                </p></li><li><p>Upon transaction termination by the client, the JTA transaction coordinator will drive
                    the enlisted bridge Synchronization and XAResource through the transaction termination
                    protocol. The XAResource maps these calls down to the WS-AT subtransaction coordinator,
                    which in turn passes them on to any Volatile or Durable Participants enlisted in the
                    transaction. This process is not visible to the business logic, except in so far as it may
                    have registered its own Participants, XAResources or Synchronizatons with the transaction.
                </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6463"/>5.2.5. Crash Recovery</h3></div></div></div><p>The bridge includes independent crash recovery systems for the inbound and outbound sides.
            These are automatically installed and activated as part of the bridge deployment. They rely
            upon the recovery mechanisms in the JTA and XTS components, which are likewise deployed and
            activated by default as part of their respective components.
        </p><p>It
            is the responsibility of the application(s) to use suitable XAResources (inbound) or
            DurableParticipants (outbound). In general the former will be from XA datasources or messaging
            systems, whilst the latter will be custom implementations. In either case it is important to
            ensure recovery is correctly configured for the resource manager(s) before using them in
            production, via the bridge or otherwise. The Narayana
            documentation set details crash recovery
            configuration, as does the application server administration guide. For resource manager
            specific information e.g. Oracle db permissions settings for recovery connections, please
            consult the vendor's documentation.
        </p><p>A
            bridged transaction will involve several distinct log writes, potentially on multiple
            hosts. Resolving the transaction may require more than one crash recovery cycle, due to
            ordering constrains on the events taking place during recovery. If a transaction fails to
            recover after all servers have been restored to service for more than two recovery cycles
            duration, the Narayana
            objectstore browser and server logs may be useful for diagnosing the
            issue. Where a transaction involves multiple bridges the number of recovery cycles required to
            resolve it may further increase. For systems requiring maximum availability it is therefore
            not recommended to span a transaction through more than one bridge.
        </p><p>
            Note that the 1PC commit optimization should not be used with outbound bridged
            transactions in
            which the subordinate may contain more than one Participant. Even where only
            one Participant
            is used, crash recovery logs may not correctly reflect the actual transaction
            outcome. The 1PC
            optimization is on be default and may be disabled by setting
            &lt;property
            name="commitOnePhase"&gt;false &lt;/property&gt; on CoordinatorEnvironmentBean.
        </p><p>See the 'Design Notes' appendix for detailed information on potential crash recovery
            scenarios and how each is handled.
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6476"/>5.3. Using the Transaction Bridge</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6479"/>5.3.1. Introduction</h3></div></div></div><p>This section describes how to use the transaction bridge in your applications. It is
            recommended you first read the preceding chapters for a theoretical background in the way the
            bridge functions.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6484"/>5.3.2. Enabling</h3></div></div></div><p>
            TXBridge is integrated with the XTS subsystem of the WildFly Application Server.
            The XTS subsystem is enabled using the
            standalone-xts.xml configuration
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="procedure"><a id="starting-with-xts"/><p class="title"><b>Procedure 5.1. Starting WildFly Application Server
                with XTS Enabled
            </b></p><ol class="1"><li><p>
                    Change to the WildFly Application Server
                    directory:
                </p><p>
                    <code class="filename">
                        <em class="replaceable"><code>cd $JBOSS_HOME</code></em>
                    </code>
                </p></li><li><p>
                    Copy the example XTS configuration into the configurations directory:
                </p><p>
                    <code class="filename">
                        <em class="replaceable"><code>cp docs/examples/configs/standalone-xts.xml standalone/configuration</code></em>
                    </code>
                </p></li><li><p>
                    Start WildFly Application Server,
                    specifying the xts configuration:
                </p><p>
                    Linux:
                </p><p>
                    <code class="filename">
                        <em class="replaceable"><code>bin/standalone.sh --server-config=standalone-xts.xml</code></em>
                    </code>
                </p><p>
                    Windows:
                </p><p>
                    <code class="filename">
                        <em class="replaceable"><code>bin\standalone.bat --server-config=standalone-xts.xml</code></em>
                    </code>
                </p></li></ol></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6537"/>5.3.3. Inbound Bridging</h3></div></div></div><p>To use the inbound bridge, register the JAX-WS handler into the handler chain of any Web
            Service as follows:
        </p><div class="example"><a id="d0e6542"/><p class="title"><b>Example 5.1. 
                Registering the
                <code class="literal">handler</code>
                for Inbound Bridging
            </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-chain</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">protocol-bindings</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">##SOAP11_HTTP</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">protocol-bindings</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-name</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">TransactionBridgeHandler</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-name</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.jbossts.txbridge.inbound.JaxWSTxInboundBridgeHandler</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-name</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">WebServicesTxContextHandler</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-name</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">com.arjuna.mw.wst11.service.JaxWSHeaderContextProcessor</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-chain</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>The web service may then operate as though running in the scope of a JTA transaction, as
            indeed it is. For example, it can call (or indeed simply be) an EJB3 business logic method
            annotated with @TansactionAttribute(TransactionAttributeType.MANDATORY).
        </p><p>Note that the handlers expect a WS-AT transaction context to be present on all inbound
            invocations. If you wish deploy your service in such a way as to make transactional invocation
            optional, you must expose it though two different endpoints, one transactional and one not,
            with the handlers registered only on the former. This limitation may be addressed in future
            versions.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6554"/>5.3.4. Outbound Bridging</h3></div></div></div><p>To use the outbound bridge, register the JAX-WS handler into the handler chain of any Web
            Service client application as follows:
        </p><div class="example"><a id="d0e6559"/><p class="title"><b>Example 5.2. 
                Registering the
                <code class="literal">handler</code>
                for Outbound Bridging
            </b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-chain</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">protocol-bindings</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">##SOAP11_HTTP</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">protocol-bindings</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-name</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">TransactionBridgeHandler</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-name</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.jboss.jbossts.txbridge.outbound.JaxWSTxOutboundBridgeHandler</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-name</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">WebServicesTxContextHandler</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-name</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">handler-class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">com.arjuna.mw.wst11.client.JaxWSHeaderContextProcessor</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">handler-chain</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>The web service client may then make calls to web service implementations that expect to
            be invoked in the scope of a WS-AT transaction.
        </p><p>Note that the handlers expect a JTA transaction context to be present on the client thread
            used to make the outbound web service invocation. If the context is not always present,
            different stubs must be used for the transactional and non-transactional cases and the handler
            chain registered only on the former. This limitation may be addressed in future versions.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6571"/>5.3.5. Loops and Diamonds</h3></div></div></div><p>In distributed environments that utilize transaction bridging, it is possible to construct
            arrangements of servers such that a transaction context passes though more than one
            interposition. These can give rise to some undesirable issues, including locking and
            performance problems.
        </p><p>A simple case would be a loop in which a JTA transaction context is bridged outbound to a
            WS-AT context, passed though one or more remote servers and inflowed back to the original
            server through an inbound bridge. This may result in a new subordinate JTA context, rather
            than reuse of the existing parent context in the original server.
        </p><p>This situation has two main observable effects. Firstly, the parent JTA transaction and
            indirectly subordinate JTA transaction are considered distinct and XAResources may not be
            shared between them. In most cases this will cause isolation between the transactions, such
            that they do not share locks or see eachother's changes. This may cause deadlocks in the
            application. Secondly, performance will be poor relative to reuse of the original context,
            particularly if the interposition chain becomes long.
        </p><p>A similar problem exists where a transaction context is propagated from a single source to
            a single destination server via two or more separate routes, the abstract paths forming a
            diamond shape. In such case the intermediate nodes operate independently and will bridge the
            original context to two separate interposed contexts. To the destination server these will
            appear unrelated, rather than as representations of the same transaction. Thus instead of
            recombining into a single shared transaction context at the destination, they will behave as
            different transactions, giving rise once again to potential deadlock and performance issues.
        </p><p>These problems may be partially addressed by having a shared context mapping service
            available on the network, which each bridge consults when working with a previously unseen
            transaction context for the first time. Using such a mechanism, bridge instances may identify
            transactions for which an established mapping already exists and reuse that relationship
            rather than creating a new one.
        </p><p>This shared service model does however cause some issues of its own with regard to
            performance and availability. It is not currently implemented. Therefore, users are urged to
            be cautious when constructing distributed applications. Whilst location abstraction is
            sometimes desirable, is is important to maintain a clear understanding of the deployment
            relationships between transactional components in the system.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6586"/>5.3.6. Distributed JTA and the JTS</h3></div></div></div><p>The
            JavaEE transaction engine in Narayana
            comes in two varieties. These are the local only
            JTA, which does not support propagation of transaction context or transaction control calls
            between JVMs and the JTAX, which provides the JTA API implemented by a JTS engine that does
            support distributed usage.
        </p><p>WildFly Application Server
            uses the local JTA implementation by default, but can be reconfigured to use the
            JTS via the JTA API, such that it supports distributed transactions without requiring any
            changes to business applications.
        </p><p>In environments requiring transaction propagation of JTA transactions, it is feasible to
            use either the JTS or an outbound and inbound bridge pair to achieve this. In the former case
            the transport is RMI/IIOP for the transaction control and RMI/IIOP or JRMP for the
            transactional business logic calls. In the latter case the transport is Web Services for both
            transaction control and business logic.
        </p><p>From
            a transaction management perspective the JTS solution is preferred, due to simplicity
            (no protocol mapping is needed), maturity (Narayana
            JTS was the world's first JTS
            implementation and has been extensively used and tested in production environments) and
            performance (binary vs. xml).
        </p><p>It is possible to use transactions that propagate context on some calls via JTS and on
            others via Web Services, such as a client invoking both EJBs via RMI/IIOP and Web services
            with WS-AT context. In such cases it's possible for a transaction to have multiple
            representations that the infrastructure cannot determine are related, even if they actually
            represent different contexts in the same interposition hierarchy. Care must therefore be taken
            to avoid the problems described previously in 'Loops and Diamonds'.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6599"/>5.3.7. Logging</h3></div></div></div><p>The
            transaction bridge uses the jboss-logging system. When running inside WildFly Application Server,
            logging is configured via logging subsystem's configuration in standalone-xts.xml file. To enable full
            logging
            for the transaction bridge, which may be useful for debug purposes, the following logger should be added:
        </p><div class="example"><a id="d0e6604"/><p class="title"><b>Example 5.3. Configuring Transaction Bridge Logging</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">logger</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">category</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.jboss.jbossts.txbridge&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">level</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ALL&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">logger</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">&nbsp;</span><br />
</pre></div></div><br class="example-break"/><p>Note
            that the transaction bridge is a thin layer on top of the XTS and JTA/JTS components
            of
      Narayana,
            and that it also interacts with other parts of the application server. To gain a
            comprehensive understanding of the system's operation, it may be necessary to enable verbose
            logging for some of these other components also. The Narayana
            logging system is discussed in
            detail in the accompanying documentation set, but for ease of reference the following may be
            used to enable verbose logging:
        </p><div class="example"><a id="d0e6611"/><p class="title"><b>Example 5.4. Configuring verbose logging</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">logger</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">category</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;com.arjuna&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">level</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ALL&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">logger</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>Note
            also that deployment ordering issues can result in Narayana
            components, including the
            transaction bridge, becoming active before the logging system is fully configured. In such
            cases a default logging level may apply during startup, resulting in some more detailed debug
            messages being missed.
        </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6618"/>5.4. Known Limitations</h2></div></div></div><p>The current transaction bridge release has the following limitations:</p><div class="itemizedlist"><ul><li><p>The bridge operates only on WS-AT 1.2, not 1.0, although XTS includes implementations of
                both versions of WS-AT. Care must therefore be taken to deploy and configure the system
                correctly.
            </p></li><li><p>The bridge provides JAX-WS handlers only, not JAX-RPC, although it is possible to create
                such if required.
            </p></li><li><p>Long running activities that occur during the transaction termination process may cause
                timeouts in the transaction system, which can in turn cause inconsistent transaction
                outcomes or incomplete transaction termination. To minimize this problem, it is advised to
                manually flush data that would otherwise be flushed by Synchronizations during termination,
                such as hibernate session state.
            </p></li><li><p>A transaction context must always be present on the Thread in order for the context
                processors to operate correctly, as detailed previously in 'Using the Transaction Bridge'.
            </p></li><li><p>A subordinate transaction context will be created and registered into the parent
                transaction unconditionally, which can cause unnecessary overhead in situations where no
                transactional activity takes place in the scope of the subordinate. Care should be taken to
                register the bridge handlers only on methods that do require them. In future releases this
                may be addressed by the use of WS-Policy or lazy initialization techniques.
            </p></li><li><p>Transaction mappings are local to BridgeManagers, which are singletons. This means
                mappings are classloader scoped and not shared across JVMs. This gives rise to issues where
                transactional resources are accessed indirectly though multiple bridges or transaction
                context transports, as described in 'Loops and Diamonds'.
            </p></li><li><p>Crash
                recovery is subject to certain timing issues, due to the interaction between
                recovery of the JTA/XA and XTS sides of the transaction. It may take more than one crash
                recovery cycle for a bridged transaction to recover fully. Note that recovery of subordinate
                transactions is dependent on the recovery of their parent, so care must be taken to ensure
                the correct recovery of any external transaction manager used in that role. The transaction
                bridge does not currently provide dedicated tooling for the manual resolution of orphaned
                subordinates, instead relying on the general purpose objectstore maintenance tooling
                provided by Narayana.
            </p></li><li><p>Note that crash recovery will not behave correctly for outbound bridged transactions if
                1PC commit optimization is used in the parent JTA transaction. This is not specific to the
                bridge, but rather is a generic issue with any transaction in which a single resource is an
                interposed subordinate coordinator. Inbound bridges transactions are unaffected as XTS
                (WS-AT) does not utilize a 1PC optimization.
            </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6648"/>5.5. Design Notes</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6651"/>5.5.1. General Points</h3></div></div></div><p>This
            section records key design points relating to the bridge implementation. The target
            audience for this section is software engineers maintaining or extending the transaction
            bridge implementation. It is unlikely to contain material useful to users, except in so far as
            they wish to contribute to the project. An in-depth knowledge of Narayana
            internals may be
            required to make sense of some parts of this appendix.
        </p><p>The txbridge is written as far as possible as a user application layered on top of the JTA
            and XTS implementations. It accesses these underlying components through standard or supported
            APIs as far as possible. For example, XAResource is favored over AbstractRecord, the JCA
            standard XATerminator is used for driving subordinates and so on. This facilitates modularity
            and portability.
        </p><p>It follows that functionality required by the bridge should first be evaluated for
            inclusion in one of the underlying modules, as experience has shown it is often also useful
            for other user applications. For example, improvements to allows subordinate termination code
            portability between JTA and JTS, and support for subordinate crash recovery have benefited
            from this approach. The txbridge remains a thin layer on top of this functionality, containing
            only purpose specific code.
        </p><p>The 'loops and diamonds' problem boils down to providing deterministic, bi-directional 1:1
            mapping between an Xid (which is fixed length) and a WS-AT context (which is unbounded length
            in the spec, although bounded for instances created by the XTS). Consistent hashing techniques
            get you so far with independent operation, but the only 100% solution is to have a shared
            service on the network providing the mapping lookup. Naturally this then becomes a single
            point of failure as well as a scalability issue. For some scenarios it may be possible to use
            interceptors to propagate the Xid on the web services call as extra data, instead of trying to
            reproduce the mapping at the other end. Unfortunately XA does not provide for this kind of
            extensibility, although CORBA does, leading to the possibility of solving the issue without a
            centralized approach in mixed JTS+WS-AT environments.
        </p><p>Requiring a tx context on all calls is a bit limiting, but JBossWS native lacks a
            WS-Policy implementation. Things may change with the move to CXF. This is really a wider issue
            with XTS, not just the bridge.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6664"/>5.5.2. Crash Recovery Considerations</h3></div></div></div><p>As usual with transactions, it's the crash recovery that provides for the most complexity.
            Recovery for the inbound and outbound sides is handled independently. Because of event
            ordering between recovery modules (JTA, XTS), it requires two complete cycles to resolve some
            of these crash recovery situations.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6669"/>5.5.2.1. Inbound Crash Recovery</h4></div></div></div><p>An inbound transaction involves at least
                four log writes. Top down (i.e. in reverse order
                of log creation) these are: The WS-AT coordinator
                log
                (assumed here to be XTS, but may be 3rd
                party), the XTS Participant log in the receiving server, the
                JCA Subordinate transaction log
                and at least one XA Resource Manager log (which are 3rd party e.g.
                Oracle).
            </p><p>There is no separate log created by the txbridge. The XTS Participant log inlines the
                Serializable
                BridgeDurableParticipant via its writeObject method. Recorded state includes its
                identity (the Xid) and
                the identity of the separately logged JTA subordinate tx (a Uid).
            </p><p>XTS
                is responsible for
                the top level coordinator log. Narayana
                is responsible for the JTA
                subordinate tx log and 3rd party
                RMs
                are each responsible for their own.
            </p><p>The following situations may exist at recovery time,
                according to the point in time at
                which the crash occurred:
            </p><p>RM
                log only: In this case, the
                InboundBridgeRecoveryManager's XAResourceOrphanFilter
                implementation will be invoked via Narayana
                XARecoveryModule,
                will recognize the orphaned Xids
                by their formatId (which they inherit from the JCA subordinate,
                which
                the txbridge previously
                created with a specially constructed inflowed Xid) and will vote to have
                the
                XARecoveryModule
                roll them back as no corresponding JCA subordinate log exists, so presumed abort applies.
            </p><p>RM log and JTA subordinate tx log: The InboundBridgeRecoverytManager's scan of indoubt
                subordinate JTA transactions identifies the JTA subordinate as being orphaned and rolls it
                back, which
                in turn causes the rollback of the RM's XAResource.
            </p><p>RM log, JTA subordinate log and XTS
                Participant log: XTS is responsible for detecting
                that the Participant is orphaned (by re-sending Prepared
                to the Coordinator and receiving
                'unknown tx' back) and initiating rollback under the
                presumed abort
                convention.
            </p><p>WS-AT coordinator log and all downstream logs: The coordinator re-sends Commit
                to the
                Participant and the transaction completes.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6688"/>5.5.2.2. Outbound Crash Recovery</h4></div></div></div><p>An outbound transaction involves log writes for the JTA parent transaction and the XTS
                BridgeWrapper coordinator. There is not a separate log created by the txbridge. The JTA tx
                log inlines the Serializable BridgeXAResource via its writeObject method. Recorded state
                includes the JTA tx id and bridgeWrapper id String. In addition a Web Service participating
                in the subordinate transaction will create a log. Assuming it's XTS, the participant side
                log will inline any Serializable Durable2PCParticipant, effectively forming the RM log.
            </p><p>The following situations may exist at recovery time, according to the point in time at
                which the crash occurred:
            </p><p>RM log (i.e. XTS Participant log, inlining Serializable Durable2PCParticipant) only: XTS
                is responsible for detecting that the Participant is orphaned (its direct parent, the
                subordinate coordinator, is missing) and rolling it back. The bridge recovery code is not
                involved – XTS recovery deserializes and drives any app DurableParticipants directly.
            </p><p>RM log and XTS subordinate log: The DurableParticipant(s) (i.e. client side) and XTS
                subordinate coordinator / BridgeWrapper (i.e. server side) and reinstantiated by XTS. The
                BridgeWrapper, being subordinate to a missing parent, must be identified and explicitly
                rolledback by the bridge recovery code. The bridge recovery manager is itself a
                RecoveryModule, thus invoked periodically to perform this task. It identified its own
                BridgeWrapper instance from amongst all those awaiting recovery by means of an id prefix
                specific to the txbridge code. See JBTM-725 for further details.
            </p><p>RM log, XTS subordinate log and JTA parent log (with inlined BridgeXAResource): Top down
                recovery by the JTA recovery module drives tx to completion, taking the normal JTA
                parent-&gt;BridgeXAResource-&gt;XTS subordinate-&gt;DurableParticipant path. Note that if the bridge
                is the only XAResource in the parent, the JTA must have 1PC commit optimization disabled or
                it won't write a log for recovery.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6701"/>5.5.3. Test framework</h3></div></div></div><p>The test suite for the txbridge is split along two axis. Firstly, the inbound and outbound
            sides of the bridge have their own test suites in a parallel code package hierarchy. These are
            largely mirrors, containing tests which have matching intent but different implementation
            details. Secondly, the tests are split between those for normal execution and those for crash
            recovery.
        </p><p>The tests use a framework consisting of a basic servlet acting as client (the code
            pre-dates the availability of XTS lightweight client), a basic web service as server and a set
            of utility classes implementing the appropriate interfaces
            (Participant/Synchronization/XAResource). These classes contain the bare minimum of test
            logic. In order to make the tests as easy to understand and modify as possible, an attempt is
            made to capture the entirety of the test logic within the junit test function instead of
            splitting it over the framework classes. To facilitate this, extensive use is made of byteman
            and its associated dtest library, which provides basic distributed mock-like execution tracing
            and configuration. You probably need to take a detour and read the dtest docs before
            proceeding further.
        </p><p>The basic tests all follow the same pattern: make a call through the bridge, following
            different logic paths in each test, and verify that the test resources see the expected method
            calls. For example, in a test that runs a transaction successfully, expect to see commit
            called on enlisted resources and rollback not called. For a test that configures the prepare
            to fail, expect to see rollback called and commit not called. The tests verify behavior in the
            presence of 'expected' errors e.g. prepare failures, but generally don't cover unexpected
            failures e.g. exceptions thrown from commit.
        </p><p>Test normal execution targets in the tests/build.xml assume the server is started manually
            with byteman installed and has XTS, txbridge and the test artifacts deployed. Note that it
            also contains targets that may be called to achieve the last of these steps.
        </p><p>The crash rec tests start (and subsequently restart) the server automatically, but assume
            the that XTS, txbridge and the test artifacts are deployed. To manage the server they need to
            be provided with JBOSS_HOME and JAVA_HOME values in the build.xml.
        </p></div></div></div></div></body></html>