<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Narayana Project Documentation</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><meta name="description" content="The Narayana Project Documentation contains information on how to use Narayana to develop applications that use transaction technology to manage business processes."/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div class="book" title="Narayana Project Documentation"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d5e1"/>Narayana Project Documentation</h1></div><div><h3 class="corpauthor">
        <span class="inlinemediaobject"><object type="image/svg+xml" data="Common_Content/images/title_logo.svg"/></span>
    </h3></div><div><div class="authorgroup">
    <div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Little</span></h3><code class="email">&lt;<a class="email" href="mailto:mlittle@redhat.com">mlittle@redhat.com</a>&gt;</code></div>
    <div class="author"><h3 class="author"><span class="firstname">Jonathan</span> <span class="surname">Halliday</span></h3><code class="email">&lt;<a class="email" href="mailto:jhallida@redhat.com">jhallida@redhat.com</a>&gt;</code></div>
    <div class="author"><h3 class="author"><span class="firstname">Andrew</span> <span class="surname">Dinn</span></h3><code class="email">&lt;<a class="email" href="mailto:adinn@redhat.com">adinn@redhat.com</a>&gt;</code></div>
    <div class="author"><h3 class="author"><span class="firstname">Kevin</span> <span class="surname">Connor</span></h3><code class="email">&lt;<a class="email" href="mailto:kconnor@redhat.com">kconnor@redhat.com</a>&gt;</code></div>
    <div class="author"><h3 class="author"><span class="firstname">Michael</span> <span class="surname">Musgrove</span></h3><code class="email">&lt;<a class="email" href="mailto:mmusgrov@redhat.com">mmusgrov@redhat.com</a>&gt;</code></div>
    <div class="author"><h3 class="author"><span class="firstname">Paul</span> <span class="surname">Robinson</span></h3><code class="email">&lt;<a class="email" href="mailto:paul.robinson@redhat.com">paul.robinson@redhat.com</a>&gt;</code></div>
    <div class="author"><h3 class="author"><span class="firstname">Gytis</span> <span class="surname">Trikleris</span></h3><code class="email">&lt;<a class="email" href="mailto:gytis@redhat.com">gytis@redhat.com</a>&gt;</code></div>
    <div class="author"><h3 class="author"><span class="firstname">Amos</span> <span class="surname">Feng</span></h3><code class="email">&lt;<a class="email" href="mailto:zfeng@redhat.com">zfeng@redhat.com</a>&gt;</code></div>
</div></div><div><a href="ln-d5e16.html">Legal Notice</a></div><div><div class="abstract" title="Abstract"><p class="title"><strong>Abstract</strong></p>
        <p>
            The Narayana Project Documentation contains information on how to use Narayana
            to develop applications that use transaction technology to manage business processes.
        </p>
    </div></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e55">1. Document Conventions</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e60">1.1. Typographic Conventions</a></span></dt><dt><span class="section"><a href="#d5e154">1.2. Pull-quote Conventions</a></span></dt><dt><span class="section"><a href="#d5e163">1.3. Notes and Warnings</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e175">2. We Need Feedback!</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e182">1. Narayana Core</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e184">1.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e195">1.1.1. ArjunaCore</a></span></dt><dt><span class="section"><a href="#d5e211">1.1.2. Saving object states</a></span></dt><dt><span class="section"><a href="#d5e229">1.1.3. The object store</a></span></dt><dt><span class="section"><a href="#d5e237">1.1.4. Recovery and persistence</a></span></dt><dt><span class="section"><a href="#d5e288">1.1.5. The life cycle of a Transactional Object for Java</a></span></dt><dt><span class="section"><a href="#d5e315">1.1.6. The concurrency controller</a></span></dt><dt><span class="section"><a href="#d5e348">1.1.7. The transactional protocol engine</a></span></dt><dt><span class="section"><a href="#d5e379">1.1.8. The class hierarchy</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e497">1.2. Using ArjunaCore</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e502">1.2.1. State management</a></span></dt><dt><span class="section"><a href="#d5e712">1.2.2. Lock management and concurrency control</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e855">1.3. Advanced transaction issues with ArjunaCore</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e858">1.3.1. Last resource commit optimization (LRCO)</a></span></dt><dt><span class="section"><a href="#d5e872">1.3.2. Heuristic outcomes</a></span></dt><dt><span class="section"><a href="#d5e876">1.3.3. Nested transactions</a></span></dt><dt><span class="section"><a href="#d5e881">1.3.4. Asynchronously committing a transaction</a></span></dt><dt><span class="section"><a href="#d5e907">1.3.5. Independent top-level transactions</a></span></dt><dt><span class="section"><a href="#d5e919">1.3.6. 
            Transactions within
            <code class="methodname">save_state</code>
            and
            <code class="methodname">restore_state</code>
            methods
        </a></span></dt><dt><span class="section"><a href="#d5e936">1.3.7. Garbage collecting objects</a></span></dt><dt><span class="section"><a href="#d5e939">1.3.8. Transaction timeouts</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e975">1.4. Hints and tips</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e977">1.4.1. General</a></span></dt><dt><span class="section"><a href="#d5e1033">1.4.2. Direct use of StateManager</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1068">1.5. Constructing a Transactional Objects for Java application</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1082">1.5.1. Queue description</a></span></dt><dt><span class="section"><a href="#d5e1092">1.5.2. Constructors and finalizers</a></span></dt><dt><span class="section"><a href="#d5e1107">1.5.3. Required methods</a></span></dt><dt><span class="section"><a href="#d5e1157">1.5.4. The client</a></span></dt><dt><span class="section"><a href="#d5e1163">1.5.5. Comments</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1171">1.6. Failure Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1174">1.6.1. Embedding the Recovery Manager</a></span></dt><dt><span class="section"><a href="#d5e1191">1.6.2. Understanding Recovery Modules</a></span></dt><dt><span class="section"><a href="#d5e1237">1.6.3. Writing a Recovery Module</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d5e1286">2. JTA</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1288">2.1. Administration</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1290">2.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e1304">2.1.2. Starting and Stopping the Transaction Manager</a></span></dt><dt><span class="section"><a href="#d5e1324">2.1.3. ObjectStore Management</a></span></dt><dt><span class="section"><a href="#d5e1330">2.1.4. Narayana
        Runtime Information
    </a></span></dt><dt><span class="section"><a href="#d5e1336">2.1.5. Failure Recovery Administration</a></span></dt><dt><span class="section"><a href="#d5e1445">2.1.6. Errors and Exceptions</a></span></dt><dt><span class="section"><a href="#d5e1468">2.1.7. Selecting the JTA implementation</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1495">2.2. Development</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1497">2.2.1. JDBC and Transactions</a></span></dt><dt><span class="section"><a href="#d5e1634">2.2.2. Examples</a></span></dt><dt><span class="section"><a href="#d5e1659">2.2.3. Using Narayana
        in application servers
    </a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1701">2.3. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1703">2.3.1. Preparing Your System</a></span></dt><dt><span class="section"><a href="#d5e1727">2.3.2. Operating System Services</a></span></dt><dt><span class="section"><a href="#d5e1822">2.3.3. Logging</a></span></dt><dt><span class="section"><a href="#d5e1841">2.3.4. Additional JAR Requirements</a></span></dt><dt><span class="section"><a href="#chap-JBossJTA_Installation_Guide-Test_Chapter">2.3.5. Setting Properties</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1877">2.4. Quick Start to JTA</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1879">2.4.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e1882">2.4.2. Package layout</a></span></dt><dt><span class="section"><a href="#d5e1894">2.4.3. Setting properties</a></span></dt><dt><span class="section"><a href="#d5e1904">2.4.4. Demarcating Transactions</a></span></dt><dt><span class="section"><a href="#d5e1933">2.4.5. Local vs Distributed JTA implementations</a></span></dt><dt><span class="section"><a href="#d5e1948">2.4.6. JDBC and Transactions</a></span></dt><dt><span class="section"><a href="#d5e1955">2.4.7. Configurable options</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d5e1995">3. JTS</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1997">3.1. Administration</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1999">3.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e2015">3.1.2. Starting and Stopping the Transaction Manager</a></span></dt><dt><span class="section"><a href="#d5e2035">3.1.3. OTS and Jakarta EE Transaction Service Management</a></span></dt><dt><span class="section"><a href="#d5e2176">3.1.4. Failure Recovery Administration</a></span></dt><dt><span class="section"><a href="#d5e2285">3.1.5. ORB-specific Configurations</a></span></dt><dt><span class="section"><a href="#d5e2323">3.1.6. Initializing 
        Applications
    </a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2331">3.2. Development</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2333">3.2.1. Transaction Processing Overview</a></span></dt><dt><span class="section"><a href="#d5e2448">3.2.2. 
        Basics
    </a></span></dt><dt><span class="section"><a href="#d5e2612">3.2.3. Introduction to the OTS</a></span></dt><dt><span class="section"><a href="#d5e3706">3.2.4. Constructing an OTS application</a></span></dt><dt><span class="section"><a href="#d5e3924">3.2.5. 
        interfaces for extending the OTS
    </a></span></dt><dt><span class="section"><a href="#d5e4129">3.2.6. Example</a></span></dt><dt><span class="section"><a href="#d5e4273">3.2.7. Trail map</a></span></dt><dt><span class="section"><a href="#d5e6201">3.2.8. Failure Recovery</a></span></dt><dt><span class="section"><a href="#d5e6425">3.2.9. JTA and JTS</a></span></dt><dt><span class="section"><a href="#d5e6443">3.2.10. ORB-specific configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e6450">3.3. ORB Portability</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6452">3.3.1. ORB Portability Introduction</a></span></dt><dt><span class="section"><a href="#d5e6458">3.3.2. ORB Portability API</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e6661">3.4. Quick Start to JTS/OTS</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6663">3.4.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e6666">3.4.2. Package layout</a></span></dt><dt><span class="section"><a href="#d5e6684">3.4.3. Setting properties</a></span></dt><dt><span class="section"><a href="#d5e6701">3.4.4. Starting and terminating the ORB and BOA/POA</a></span></dt><dt><span class="section"><a href="#d5e6715">3.4.5. Specifying the object store location</a></span></dt><dt><span class="section"><a href="#d5e6722">3.4.6. Implicit transaction propagation and interposition</a></span></dt><dt><span class="section"><a href="#d5e6752">3.4.7. Obtaining Current</a></span></dt><dt><span class="section"><a href="#d5e6755">3.4.8. Transaction termination</a></span></dt><dt><span class="section"><a href="#d5e6759">3.4.9. Transaction factory</a></span></dt><dt><span class="section"><a href="#d5e6772">3.4.10. Recovery manager</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d5e6775">4. XTS</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6777">4.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6849">4.1.1. Managing service-Based Processes</a></span></dt><dt><span class="section"><a href="#d5e6860">4.1.2. Servlets</a></span></dt><dt><span class="section"><a href="#d5e6865">4.1.3. SOAP</a></span></dt><dt><span class="section"><a href="#d5e6869">4.1.4. Web Services Description Language (WDSL)</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e6873">4.2. Transactions Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6935">4.2.1. The Coordinator</a></span></dt><dt><span class="section"><a href="#d5e6941">4.2.2. The Transaction Context</a></span></dt><dt><span class="section"><a href="#d5e6962">4.2.3. Participants</a></span></dt><dt><span class="section"><a href="#d5e6965">4.2.4. ACID Transactions</a></span></dt><dt><span class="section"><a href="#d5e6992">4.2.5. Two Phase Commit</a></span></dt><dt><span class="section"><a href="#d5e7015">4.2.6. The Synchronization Protocol</a></span></dt><dt><span class="section"><a href="#d5e7035">4.2.7. Optimizations to the Protocol</a></span></dt><dt><span class="section"><a href="#d5e7068">4.2.8. Non-Atomic Transactions and Heuristic Outcomes</a></span></dt><dt><span class="section"><a href="#d5e7110">4.2.9. Interposition</a></span></dt><dt><span class="section"><a href="#d5e7136">4.2.10. A New Transaction Protocol</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e7160">4.3. Overview of Protocols Used by XTS</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7198">4.3.1. WS-Coordination</a></span></dt><dt><span class="section"><a href="#d5e7254">4.3.2. WS-Transaction</a></span></dt><dt><span class="section"><a href="#d5e7499">4.3.3. Summary</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d5e7502">5. Long Running Actions (LRA)</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7504">5.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e7511">5.2. JAX-RS services</a></span></dt><dt><span class="section"><a href="#d5e7516">5.3. Non JAX-RS services</a></span></dt><dt><span class="section"><a href="#lra-examples">5.4. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7522">5.4.1. LRA Quickstart Examples</a></span></dt><dt><span class="section"><a href="#d5e7527">5.4.2. Participating in Long Running Actions</a></span></dt><dt><span class="section"><a href="#d5e7531">5.4.3. Making JAX-RS Invocations from JAX-RS Resource Methods</a></span></dt></dl></dd><dt><span class="section"><a href="#lra-integration">5.5. Runtime Integration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e7539">6. RTS</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7541">6.1. Overview</a></span></dt><dt><span class="section"><a href="#_transaction_model">6.2. Transaction Model</a></span></dt><dd><dl><dt><span class="section"><a href="#_architecture">6.2.1. Architecture</a></span></dt><dt><span class="section"><a href="#_state_transitions">6.2.2. State Transitions</a></span></dt><dt><span class="section"><a href="#_the_transaction_manager_resource">6.2.3. The Transaction Manager Resource</a></span></dt></dl></dd><dt><span class="section"><a href="#_client_responsibilities">6.3. Client Responsibilities</a></span></dt><dd><dl><dt><span class="section"><a href="#_starting_a_transaction">6.3.1. Starting a Transaction</a></span></dt><dt><span class="section"><a href="#_obtaining_the_transaction_status">6.3.2. Obtaining The Transaction Status</a></span></dt><dt><span class="section"><a href="#_propagating_the_context">6.3.3. Propagating the Context</a></span></dt><dt><span class="section"><a href="#_discovering_existing_transactions">6.3.4. Discovering Existing Transactions</a></span></dt><dt><span class="section"><a href="#_ending_the_transaction">6.3.5. Ending the Transaction</a></span></dt></dl></dd><dt><span class="section"><a href="#_service_responsibilities">6.4. Service Responsibilities</a></span></dt><dd><dl><dt><span class="section"><a href="#_joining_the_transaction">6.4.1. Joining the Transaction</a></span></dt><dt><span class="section"><a href="#_leaving_the_transaction">6.4.2. Leaving the Transaction</a></span></dt><dt><span class="section"><a href="#2PC">6.4.3. Preparing and Committing Work</a></span></dt><dt><span class="section"><a href="#_recovery">6.4.4. Recovery</a></span></dt><dt><span class="section"><a href="#_pre_and_post_two_phase_commit_processing">6.4.5. Pre- and Post- Two-Phase Commit Processing</a></span></dt></dl></dd><dt><span class="section"><a href="#_container_integration">6.5. Container Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#_deploying_as_a_wildfly_subsystem">6.5.1. Deploying as a Wildfly Subsystem</a></span></dt><dt><span class="section"><a href="#_deploying_into_a_servlet_container">6.5.2. Deploying into a Servlet Container</a></span></dt></dl></dd><dt><span class="section"><a href="#_examples">6.6. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#_support_for_java_based_services">6.6.1. Support For Java based Services</a></span></dt></dl></dd><dt><span class="section"><a href="#_interoperating_with_other_transaction_models">6.7. Interoperating With Other Transaction Models</a></span></dt><dd><dl><dt><span class="section"><a href="#_jta_bridge">6.7.1. JTA Bridge</a></span></dt><dt><span class="section"><a href="#_web_services_transactions">6.7.2. Web Services Transactions</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d5e7814">7. STM</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7831">7.1. An STM Example</a></span></dt><dt><span class="section"><a href="#d5e7863">7.2. Annotations</a></span></dt><dt><span class="section"><a href="#d5e7882">7.3. Containers, Volatility and Durability</a></span></dt><dt><span class="section"><a href="#d5e7896">7.4. Sharing STM Objects</a></span></dt><dt><span class="section"><a href="#d5e7914">7.5. State Management</a></span></dt><dt><span class="section"><a href="#d5e7930">7.6. Optimistic Concurrency Control</a></span></dt><dt><span class="section"><a href="#d5e7942">7.7. A Typical Use Case</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e7952">8. Compensating transactions</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7954">8.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e7971">8.2. Compensations Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7974">8.2.1. CDI annotations</a></span></dt><dt><span class="section"><a href="#d5e8049">8.2.2. Recovery</a></span></dt><dt><span class="section"><a href="#d5e8068">8.2.3. Limitation</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e8072">8.3. Resources</a></span></dt><dt><span class="section"><a href="#d5e8091">8.4. Notes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e8097">9. OSGi</a></span></dt><dd><dl><dt><span class="section"><a href="#chap-integrate-with-karaf">9.1. Integrate with Karaf</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8101">9.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e8124">9.1.2. Quickstart</a></span></dt><dt><span class="section"><a href="#d5e8128">9.1.3. Admin Commands Support</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d5e8163">10. Appendixes</a></span></dt></dl></div>
    
    <div class="preface" title="Preface"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Preface</h2></div></div></div>
    
    
    
            <div class="section" title="1. Document Conventions"><div class="titlepage"><div><div><h2 class="title"><a id="d5e55"/>1. Document Conventions</h2></div></div></div>
	
	 <p>
		This manual uses several conventions to highlight certain words and phrases and draw attention to specific pieces of information.
	</p>
	 <p>
		In PDF and paper editions, this manual uses typefaces drawn from the <a class="ulink" href="https://fedorahosted.org/liberation-fonts/">Liberation Fonts</a> set. The Liberation Fonts set is also used in HTML editions if the set is installed on your system. If not, alternative but equivalent typefaces are displayed. Note: Red Hat Enterprise Linux 5 and later includes the Liberation Fonts set by default.
	</p>
	 <div class="section" title="1.1. Typographic Conventions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e60"/>1.1. Typographic Conventions</h3></div></div></div>
		
		 <p>
			Four typographic conventions are used to call attention to specific words and phrases. These conventions, and the circumstances they apply to, are as follows.
		</p>
		 <p>
			<code class="literal">Mono-spaced Bold</code>
		</p>
		 <p>
			Used to highlight system input, including shell commands, file names and paths. Also used to highlight keycaps and key combinations. For example:
		</p>
		 <div class="blockquote"><blockquote class="blockquote">
			<p>
				To see the contents of the file <code class="filename">my_next_bestselling_novel</code> in your current working directory, enter the <span class="command"><strong>cat my_next_bestselling_novel</strong></span> command at the shell prompt and press <span class="keycap"><strong>Enter</strong></span> to execute the command.
			</p>

		</blockquote></div>
		 <p>
			The above includes a file name, a shell command and a keycap, all presented in mono-spaced bold and all distinguishable thanks to context.
		</p>
		 <p>
			Key combinations can be distinguished from keycaps by the hyphen connecting each part of a key combination. For example:
		</p>
		 <div class="blockquote"><blockquote class="blockquote">
			<p>
				Press <span class="keycap"><strong>Enter</strong></span> to execute the command.
			</p>
			 <p>
				Press <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F2</strong></span> to switch to the first virtual terminal. Press <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F1</strong></span> to return to your X-Windows session.
			</p>

		</blockquote></div>
		 <p>
			The first paragraph highlights the particular keycap to press. The second highlights two key combinations (each a set of three keycaps with each set pressed simultaneously).
		</p>
		 <p>
			If source code is discussed, class names, methods, functions, variable names and returned values mentioned within a paragraph will be presented as above, in <code class="literal">mono-spaced bold</code>. For example:
		</p>
		 <div class="blockquote"><blockquote class="blockquote">
			<p>
				File-related classes include <code class="classname">filesystem</code> for file systems, <code class="classname">file</code> for files, and <code class="classname">dir</code> for directories. Each class has its own associated set of permissions.
			</p>

		</blockquote></div>
		 <p>
			<span class="application">Proportional Bold</span>
		</p>
		 <p>
			This denotes words or phrases encountered on a system, including application names; dialog box text; labeled buttons; check-box and radio button labels; menu titles and sub-menu titles. For example:
		</p>
		 <div class="blockquote"><blockquote class="blockquote">
			<p>
				Choose <span class="guimenu">System</span> → <span class="guisubmenu">Preferences</span> → <span class="guimenuitem">Mouse</span> from the main menu bar to launch <span class="application">Mouse Preferences</span>. In the <span class="guilabel">Buttons</span> tab, click the <span class="guilabel">Left-handed mouse</span> check box and click <span class="guibutton">Close</span> to switch the primary mouse button from the left to the right (making the mouse suitable for use in the left hand).
			</p>
			 <p>
				To insert a special character into a <span class="application">gedit</span> file, choose <span class="guimenu">Applications</span> → <span class="guisubmenu">Accessories</span> → <span class="guimenuitem">Character Map</span> from the main menu bar. Next, choose <span class="guimenu">Search</span> → <span class="guimenuitem">Find…</span> from the <span class="application">Character Map</span> menu bar, type the name of the character in the <span class="guilabel">Search</span> field and click <span class="guibutton">Next</span>. The character you sought will be highlighted in the <span class="guilabel">Character Table</span>. Double-click this highlighted character to place it in the <span class="guilabel">Text to copy</span> field and then click the <span class="guibutton">Copy</span> button. Now switch back to your document and choose <span class="guimenu">Edit</span> → <span class="guimenuitem">Paste</span> from the <span class="application">gedit</span> menu bar.
			</p>

		</blockquote></div>
		 <p>
			The above text includes application names; system-wide menu names and items; application-specific menu names; and buttons and text found within a GUI interface, all presented in proportional bold and all distinguishable by context.
		</p>
		 <p>
			<span class="command"><strong><em class="replaceable"><code>Mono-spaced Bold Italic</code></em></strong></span> or <span class="application"><em class="replaceable"><code>Proportional Bold Italic</code></em></span>
		</p>
		 <p>
			Whether mono-spaced bold or proportional bold, the addition of italics indicates replaceable or variable text. Italics denotes text you do not input literally or displayed text that changes depending on circumstance. For example:
		</p>
		 <div class="blockquote"><blockquote class="blockquote">
			<p>
				To connect to a remote machine using ssh, type <span class="command"><strong>ssh <em class="replaceable"><code>username</code></em>@<em class="replaceable"><code>domain.name</code></em></strong></span> at a shell prompt. If the remote machine is <code class="filename">example.com</code> and your username on that machine is john, type <span class="command"><strong>ssh john@example.com</strong></span>.
			</p>
			 <p>
				The <span class="command"><strong>mount -o remount <em class="replaceable"><code>file-system</code></em></strong></span> command remounts the named file system. For example, to remount the <code class="filename">/home</code> file system, the command is <span class="command"><strong>mount -o remount /home</strong></span>.
			</p>
			 <p>
				To see the version of a currently installed package, use the <span class="command"><strong>rpm -q <em class="replaceable"><code>package</code></em></strong></span> command. It will return a result as follows: <span class="command"><strong><em class="replaceable"><code>package-version-release</code></em></strong></span>.
			</p>

		</blockquote></div>
		 <p>
			Note the words in bold italics above — username, domain.name, file-system, package, version and release. Each word is a placeholder, either for text you enter when issuing a command or for text displayed by the system.
		</p>
		 <p>
			Aside from standard usage for presenting the title of a work, italics denotes the first use of a new and important term. For example:
		</p>
		 <div class="blockquote"><blockquote class="blockquote">
			<p>
				Publican is a <em class="firstterm">DocBook</em> publishing system.
			</p>

		</blockquote></div>

	</div>
	
	 <div class="section" title="1.2. Pull-quote Conventions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e154"/>1.2. Pull-quote Conventions</h3></div></div></div>
		
		 <p>
			Terminal output and source code listings are set off visually from the surrounding text.
		</p>
		 <p>
			Output sent to a terminal is set in <code class="computeroutput">mono-spaced roman</code> and presented thus:
		</p>
		 
<pre class="screen">books        Desktop   documentation  drafts  mss    photos   stuff  svn
books_tests  Desktop1  downloads      images  notes  scripts  svgs</pre>
		 <p>
			Source-code listings are also set in <code class="computeroutput">mono-spaced roman</code> but add syntax highlighting as follows:
		</p>
		 
<pre><code class="language-java">package org.jboss.book.jca.ex1;

import javax.naming.InitialContext;

public class ExClient
{
   public static void main(String args[]) 
       throws Exception
   {
      InitialContext iniCtx = new InitialContext();
      Object         ref    = iniCtx.lookup("EchoBean");
      EchoHome       home   = (EchoHome) ref;
      Echo           echo   = home.create();

      System.out.println("Created Echo");

      System.out.println("Echo.echo('Hello') = " + echo.echo("Hello"));
   }
}</code></pre>

	</div>
	
	 <div class="section" title="1.3. Notes and Warnings"><div class="titlepage"><div><div><h3 class="title"><a id="d5e163"/>1.3. Notes and Warnings</h3></div></div></div>
		
		 <p>
			Finally, we use three visual styles to draw attention to information that might otherwise be overlooked.
		</p>
		 <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
			
			 <p>
				Notes are tips, shortcuts or alternative approaches to the task at hand. Ignoring a note should have no negative consequences, but you might miss out on a trick that makes your life easier.
			</p>

		</div>
		 <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
			
			 <p>
				Important boxes detail things that are easily missed: configuration changes that only apply to the current session, or services that need restarting before an update will apply. Ignoring a box labeled 'Important' will not cause data loss but may cause irritation and frustration.
			</p>

		</div>
		 <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
			
			 <p>
				Warnings should not be ignored. Ignoring warnings will most likely cause data loss.
			</p>

		</div>

	</div>

</div>
        
    
            
            
                    <div class="section" title="2. We Need Feedback!"><div class="titlepage"><div><div><h2 class="title"><a id="d5e175"/>2. We Need Feedback!</h2></div></div></div>
    
    <a id="d5e177" class="indexterm"/>
    <p>
        Please feel free to raise any issues you find with this document in our
        <a class="ulink" href="https://issues.jboss.org/browse/JBTM">issue tracking system</a>
    </p>
</div>
                
        
</div>
    <div class="chapter" title="Chapter 1. Narayana Core"><div class="titlepage"><div><div><h2 class="title"><a id="d5e182"/>Chapter 1. Narayana Core</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d5e184">1.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e195">1.1.1. ArjunaCore</a></span></dt><dt><span class="section"><a href="#d5e211">1.1.2. Saving object states</a></span></dt><dt><span class="section"><a href="#d5e229">1.1.3. The object store</a></span></dt><dt><span class="section"><a href="#d5e237">1.1.4. Recovery and persistence</a></span></dt><dt><span class="section"><a href="#d5e288">1.1.5. The life cycle of a Transactional Object for Java</a></span></dt><dt><span class="section"><a href="#d5e315">1.1.6. The concurrency controller</a></span></dt><dt><span class="section"><a href="#d5e348">1.1.7. The transactional protocol engine</a></span></dt><dt><span class="section"><a href="#d5e379">1.1.8. The class hierarchy</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e497">1.2. Using ArjunaCore</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e502">1.2.1. State management</a></span></dt><dt><span class="section"><a href="#d5e712">1.2.2. Lock management and concurrency control</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e855">1.3. Advanced transaction issues with ArjunaCore</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e858">1.3.1. Last resource commit optimization (LRCO)</a></span></dt><dt><span class="section"><a href="#d5e872">1.3.2. Heuristic outcomes</a></span></dt><dt><span class="section"><a href="#d5e876">1.3.3. Nested transactions</a></span></dt><dt><span class="section"><a href="#d5e881">1.3.4. Asynchronously committing a transaction</a></span></dt><dt><span class="section"><a href="#d5e907">1.3.5. Independent top-level transactions</a></span></dt><dt><span class="section"><a href="#d5e919">1.3.6. 
            Transactions within
            <code class="methodname">save_state</code>
            and
            <code class="methodname">restore_state</code>
            methods
        </a></span></dt><dt><span class="section"><a href="#d5e936">1.3.7. Garbage collecting objects</a></span></dt><dt><span class="section"><a href="#d5e939">1.3.8. Transaction timeouts</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e975">1.4. Hints and tips</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e977">1.4.1. General</a></span></dt><dt><span class="section"><a href="#d5e1033">1.4.2. Direct use of StateManager</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1068">1.5. Constructing a Transactional Objects for Java application</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1082">1.5.1. Queue description</a></span></dt><dt><span class="section"><a href="#d5e1092">1.5.2. Constructors and finalizers</a></span></dt><dt><span class="section"><a href="#d5e1107">1.5.3. Required methods</a></span></dt><dt><span class="section"><a href="#d5e1157">1.5.4. The client</a></span></dt><dt><span class="section"><a href="#d5e1163">1.5.5. Comments</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1171">1.6. Failure Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1174">1.6.1. Embedding the Recovery Manager</a></span></dt><dt><span class="section"><a href="#d5e1191">1.6.2. Understanding Recovery Modules</a></span></dt><dt><span class="section"><a href="#d5e1237">1.6.3. Writing a Recovery Module</a></span></dt></dl></dd></dl></div>
    
    <div class="section" title="1.1. Overview"><div class="titlepage"><div><div><h2 class="title"><a id="d5e184"/>1.1. Overview</h2></div></div></div>
    
    <p>
        A transaction is a unit of work that encapsulates multiple database actions such that that either all the
        encapsulated actions fail or all succeed.
    </p>
    <p>
        Transactions ensure data integrity when an application interacts with multiple datasources.
    </p>
    <p>
        This chapter contains a description of the use of the ArjunaCore transaction engine and the
        <span class="application">Transactional
            Objects for Java (TXOJ)
        </span>
        classes and facilities. The classes mentioned in this chapter are the key to
        writing fault-tolerant applications using transactions. Thus, they are described and then applied in the
        construction of a simple application. The classes to be described in this chapter can be found in the
        <span class="package">com.arjuna.ats.txoj</span>
        and
        <span class="package">com.arjuna.ats.arjuna</span>
        packages.
    </p>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Stand-Alone Transaction Manager</h2>
        
        <p>
            Although Narayana
            can be embedded in various containers, such as WildFly Application Server,
            it
            remains a stand-alone transaction manager as well. There are no dependencies between the core Narayana
            and any
            container implementations.
        </p>
    </div>

    <div class="section" title="1.1.1. ArjunaCore"><div class="titlepage"><div><div><h3 class="title"><a id="d5e195"/>1.1.1. ArjunaCore</h3></div><div><h4 class="subtitle">The Transaction Engine</h4></div></div></div>
        
        
        <p>
            In keeping with the object-oriented view, the mechanisms needed to construct reliable distributed applications are
            presented to programmers in an object-oriented manner. Some mechanisms need to be inherited, for example,
            concurrency control and state management. Other mechanisms, such as object storage and transactions, are
            implemented as ArjunaCore objects that are created and manipulated like any other object.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                When the manual talks about using persistence and concurrency control facilities it assumes that the
                <span class="application">Transactional Objects for Java (TXOJ)</span>
                classes are being used. If this is not the case
                then the programmer is responsible for all of these issues.
            </p>
        </div>
        <p>
            ArjunaCore exploits object-oriented techniques to present programmers with a toolkit of Java classes from which
            application classes can inherit to obtain desired properties, such as persistence and concurrency control.
            These
            classes form a hierarchy, part of which is shown in
            <a class="xref" href="#txcore_class_hierarchy" title="Figure 1.1. ArjunaCore Class Hierarchy">Figure 1.1, “ArjunaCore Class Hierarchy”</a>
            and which will be
            described later in this document.
        </p>
        <div class="figure"><a id="txcore_class_hierarchy"/><p class="title"><strong>Figure 1.1. ArjunaCore Class Hierarchy</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/core-txcore_class_hierarchy.png" alt="ArjunaCore Class Hierarchy"/></div>
        </div></div><br class="figure-break"/>
        <p>
            Apart from specifying the scopes of transactions, and setting appropriate locks within objects, the
            application
            programmer does not have any other responsibilities: ArjunaCore and
            <span class="application">TXOJ</span>
            guarantee that
            transactional objects will be registered with, and be driven by, the appropriate transactions, and crash recovery
            mechanisms are invoked automatically in the event of failures.
        </p>
    </div>

    <div class="section" title="1.1.2. Saving object states"><div class="titlepage"><div><div><h3 class="title"><a id="d5e211"/>1.1.2. Saving object states</h3></div></div></div>
        
        <p>
            ArjunaCore needs to be able to remember the state of an object for several purposes.
        </p>
        <div class="variablelist"><dl><dt><span class="term">recovery</span></dt><dd>
                    <p>
                        The state represents some past state of the object.
                    </p>
                </dd><dt><span class="term">persistence</span></dt><dd>
                    <p>
                        The state represents the final state of an object at application termination.
                    </p>
                </dd></dl></div>
        <p>
            Since these requirements have common functionality they are all implemented using the same mechanism: the
            classes
            <code class="classname">InputObjectState</code>
            and
            <code class="classname">OutputObjectState</code>
            . The classes maintain an
            internal array into which instances of the standard types can be contiguously packed or unpacked using appropriate
            <code class="methodname">pack</code>
            or
            <code class="methodname">unpack</code>
            operations. This buffer is automatically resized
            as required should it have insufficient space. The instances are all stored in the buffer in a standard form
            called
            <em class="firstterm">network byte order</em>
            , making them machine independent. Any other
            architecture-independent format, such as XDR or ASN.1, can be implemented simply by replacing the operations with
            ones appropriate to the encoding required.
        </p>
    </div>

    <div class="section" title="1.1.3. The object store"><div class="titlepage"><div><div><h3 class="title"><a id="d5e229"/>1.1.3. The object store</h3></div></div></div>
        
        <p>
            Implementations of persistence can be affected by restrictions imposed by the Java SecurityManager. Therefore, the
            object store provided with ArjunaCore is implemented using the techniques of interface and implementation. The current
            distribution includes implementations which write object states to the local file system or database, and
            remote
            implementations, where the interface uses a client stub (proxy) to remote services.
        </p>
        <p>
            Persistent objects are assigned unique identifiers, which are instances of the
            <code class="classname">Uid</code>
            class,
            when they are created. These identifiers are used to identify them within the object store. States are read using
            the
            <code class="methodname">read_committed</code>
            operation and written by the
            <code class="methodname">write_committed</code>
            and
            <code class="methodname">write_uncommitted</code>
            operations.
        </p>
    </div>

    <div class="section" title="1.1.4. Recovery and persistence"><div class="titlepage"><div><div><h3 class="title"><a id="d5e237"/>1.1.4. Recovery and persistence</h3></div></div></div>
        
        <p>
            At the root of the class hierarchy is the class
            <code class="classname">StateManager</code>
            .
            <code class="classname">StateManager</code>
            is responsible for object activation and
            deactivation, as well as object recovery. Refer to
            <a class="xref" href="#StateManager-signature" title="Example 1.1.  Statemanager">Example 1.1, “
                <code class="classname">Statemanager</code>
            ”</a>
            for the simplified
            signature of the class.
        </p>
        <div class="example"><a id="StateManager-signature"/><p class="title"><strong>Example 1.1. 
                <code class="classname">Statemanager</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java"> public abstract class StateManager
{
    public boolean activate ();
    public boolean deactivate (boolean commit);

    public Uid get_uid (); // object’s identifier.

    // methods to be provided by a derived class

    public boolean restore_state (InputObjectState os);
    public boolean save_state (OutputObjectState os);

    protected StateManager ();
    protected StateManager (Uid id);
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            Objects are assumed to be of three possible flavors.
        </p>
        <div class="variablelist" title="Three Flavors of Objects"><p class="title"><strong>Three Flavors of Objects</strong></p><dl><dt><span class="term">Recoverable</span></dt><dd>
                    <p>
                        <code class="classname">StateManager</code>
                        attempts to generate and maintain appropriate recovery information for
                        the object. Such objects have lifetimes that do not exceed the application program that creates them.
                    </p>
                </dd><dt><span class="term">Recoverable and Persistent</span></dt><dd>
                    <p>
                        The lifetime of the object is assumed to be greater than that of the creating or accessing
                        application, so
                        that in addition to maintaining recovery information,
                        <code class="classname">StateManager</code>
                        attempts to
                        automatically load or unload any existing persistent state for the object by calling the
                        <code class="methodname">activate</code>
                        or
                        <code class="methodname">deactivate</code>
                        operation at appropriate times.
                    </p>
                </dd><dt><span class="term">Neither Recoverable nor Persistent</span></dt><dd>
                    <p>
                        No recovery information is ever kept, nor is object activation or deactivation ever automatically attempted.
                    </p>
                </dd></dl></div>
        <p>
            If an object is
            <span>recoverable</span>
            or
            <span>recoverable and persistent</span>
            , then
            <code class="classname">StateManager</code>
            invokes the operations
            <code class="methodname">save_state</code>
            while performing
            <code class="methodname">deactivate</code>
            , and
            <code class="methodname">restore_state</code>
            while performing
            <code class="methodname">activate</code>
            ,) at various points during the execution of the application. These operations
            must be implemented by the programmer since
            <code class="classname">StateManager</code>
            cannot detect user-level state
            changes. 
            This gives the programmer the ability to decide which parts of an object’s state should be made
            persistent. For example, for a spreadsheet it may not be necessary to save all entries if some values can simply
            be recomputed. The
            <code class="methodname">save_state</code>
            implementation for a class
            <code class="classname">Example</code>
            that has integer member variables called A, B and C might be implemented as in
            <a class="xref" href="#example-save_state" title="Example 1.2.  save_state Implementation">Example 1.2, “
                <code class="methodname">save_state</code>
                Implementation
            ”</a>
            .
        </p>
        <div class="example"><a id="example-save_state"/><p class="title"><strong>Example 1.2. 
                <code class="methodname">save_state</code>
                Implementation
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">public boolean save_state(OutputObjectState o)
{
    if (!super.save_state(o))
        return false;

    try
        {
            o.packInt(A);
            o.packInt(B);
            o.packInt(C));
}
catch (Exception e)
    {
        return false;
    }

return true;
}
</code></pre>
        </div></div><br class="example-break"/>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                it is necessary for all
                <code class="methodname">save_state</code>
                and
                <code class="methodname">restore_state</code>
                methods
                to call
                <code class="methodname">super.save_state</code>
                and
                <code class="methodname">super.restore_state</code>
                . This is to
                cater for improvements in the crash recovery mechanisms.
            </p>
        </div>
    </div>

    <div class="section" title="1.1.5. The life cycle of a Transactional Object for Java"><div class="titlepage"><div><div><h3 class="title"><a id="d5e288"/>1.1.5. The life cycle of a Transactional Object for Java</h3></div></div></div>
        
        <p>
            A persistent object not in use is assumed to be held in a passive state, with its state residing in an
            object
            store and activated on demand. The fundamental life cycle of a persistent object in TXOJ is shown in
            <a class="xref" href="#txoj-lifecycle" title="Figure 1.2. Life cycle of a persistent Object in TXOJ">Figure 1.2, “Life cycle of a persistent Object in TXOJ”</a>
            .
        </p>
        <div class="figure"><a id="txoj-lifecycle"/><p class="title"><strong>Figure 1.2. Life cycle of a persistent Object in TXOJ</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/core-txoj-lifecycle.png" alt="Life cycle of a persistent Object in TXOJ" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e294.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e294.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                During its life time, a persistent object may be made active then passive many times.
            </p>
        </div>
    </div>

    <div class="section" title="1.1.6. The concurrency controller"><div class="titlepage"><div><div><h3 class="title"><a id="d5e315"/>1.1.6. The concurrency controller</h3></div></div></div>
        
        <p>
            The concurrency controller is implemented by the class
            <code class="classname">LockManager</code>
            , which provides sensible
            default behavior while allowing the programmer to override it if deemed necessary by the particular semantics of
            the class being programmed. As with
            <code class="classname">StateManager</code>
            and persistence, concurrency control
            implementations are accessed through interfaces. As well as providing access to remote services, the current
            implementations of concurrency control available to interfaces include:
        </p>
        <div class="variablelist"><dl><dt><span class="term">Local disk/database implementation</span></dt><dd>
                    <p>
                        Locks are made persistent by being written to the local file system or database.
                    </p>
                </dd><dt><span class="term">A purely local implementation</span></dt><dd>
                    <p>
                        Locks are maintained within the memory of the virtual machine which created them. This implementation has
                        better performance than when writing locks to the local disk, but objects cannot be shared between virtual
                        machines. Importantly, it is a basic Java object with no requirements which can be affected by the
                        SecurityManager.
                    </p>
                </dd></dl></div>
        <p>
            The primary programmer interface to the concurrency controller is via the
            <code class="methodname">setlock</code>
            operation. By default, the runtime system enforces strict two-phase locking following a multiple reader,
            single
            writer policy on a per object basis. However, as shown in
            <a class="xref" href="#txcore_class_hierarchy" title="Figure 1.1. ArjunaCore Class Hierarchy">Figure 1.1, “ArjunaCore Class Hierarchy”</a>
            , by inheriting
            from the
            <code class="classname">Lock</code>
            class, you can provide your own lock implementations with different lock
            conflict rules to enable type specific concurrency control.
        </p>
        <p>
            Lock acquisition is, of necessity, under programmer control, since just as
            <code class="classname">StateManager</code>
            cannot determine if an operation modifies an object,
            <code class="classname">LockManager</code>
            cannot determine if an
            operation requires a read or write lock. Lock release, however, is under control of the system and requires no
            further intervention by the programmer. This ensures that the two-phase property can be correctly maintained.
        </p>
        <pre><code class="language-java">public class LockResult
{
    public static final int GRANTED;
    public static final int REFUSED;
    public static final int RELEASED;
};

public class ConflictType
{
    public static final int CONFLICT;
    public static final int COMPATIBLE;
    public static final int PRESENT;
};

public abstract class LockManager extends StateManager
{
    public static final int defaultRetry;
    public static final int defaultTimeout;
    public static final int waitTotalTimeout;

    public final synchronized boolean releaselock (Uid lockUid);
    public final synchronized int setlock (Lock toSet);
    public final synchronized int setlock (Lock toSet, int retry);
    public final synchronized int setlock (Lock toSet, int retry, int sleepTime);
    public void print (PrintStream strm);
    public String type ();
    public boolean save_state (OutputObjectState os, int ObjectType);
    public boolean restore_state (InputObjectState os, int ObjectType);

    protected LockManager ();
    protected LockManager (int ot);
    protected LockManager (int ot, int objectModel);
    protected LockManager (Uid storeUid);
    protected LockManager (Uid storeUid, int ot);
    protected LockManager (Uid storeUid, int ot, int objectModel);

    protected void terminate ();
};
</code></pre>
        <p>
            The
            <code class="classname">LockManager</code>
            class is primarily responsible for managing requests to set a lock on an
            object or to release a lock as appropriate. However, since it is derived from
            <code class="classname">StateManager</code>
            ,
            it can also control when some of the inherited facilities are invoked. For example,
            <code class="classname">LockManager</code>
            assumes that the setting of a write lock implies that the invoking operation
            must be about to modify the object. This may in turn cause recovery information to be saved if the object is
            recoverable. In a similar fashion, successful lock acquisition causes
            <code class="methodname">activate</code>
            to be
            invoked.
        </p>
        <p>
            <a class="xref" href="#Example_extends_LockManager" title="Example 1.3.  Example Class">Example 1.3, “
                <code class="classname">Example</code>
                Class
            ”</a>
            shows how to try to obtain a write lock on an object.
        </p>
        <div class="example"><a id="Example_extends_LockManager"/><p class="title"><strong>Example 1.3. 
                <code class="classname">Example</code>
                Class
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">public class Example extends LockManager
{
    public boolean foobar ()
    {
        AtomicAction A = new AtomicAction;
        boolean result = false;

        A.begin();

        if (setlock(new Lock(LockMode.WRITE), 0) == Lock.GRANTED)
            {
                /*
                 * Do some work, and TXOJ will
                 * guarantee ACID properties.
                 */

                // automatically aborts if fails

                if (A.commit() == AtomicAction.COMMITTED)
                    {
                        result = true;
                    }
            }
        else
            A.rollback();

        return result;
    }
}
</code></pre>
        </div></div><br class="example-break"/>
    </div>

    <div class="section" title="1.1.7. The transactional protocol engine"><div class="titlepage"><div><div><h3 class="title"><a id="d5e348"/>1.1.7. The transactional protocol engine</h3></div></div></div>
        
        <p>
            The transaction protocol engine is represented by the
            <code class="classname">AtomicAction</code>
            class, which uses
            <code class="classname">StateManager</code>
            to record sufficient information for crash recovery mechanisms to complete the
            transaction in the event of failures. It has methods for starting and terminating the transaction, and, for those
            situations where programmers need to implement their own resources, methods for registering them with the current
            transaction. Because ArjunaCore supports sub-transactions, if a transaction is begun within the scope of an already
            executing transaction it will automatically be nested.
        </p>
        <p>
            You can use ArjunaCore with multi-threaded applications. Each thread within an application can share a transaction or
            execute within its own transaction. Therefore, all ArjunaCore classes are also thread-safe.
        </p>
        <div class="example"><a id="activation_termination_commitment"/><p class="title"><strong>Example 1.4. Relationships Between Activation, Termination, and Commitment</strong></p><div class="example-contents">
            
            <pre><code class="language-java">{
    . . .
    O1 objct1 = new objct1(Name-A);/* (i) bind to "old" persistent object A */
    O2 objct2 = new objct2();  /* create a "new" persistent object */
    OTS.current().begin();     /* (ii) start of atomic action */

    objct1.op(...);           /* (iii) object activation and invocations */
    objct2.op(...);
    . . .
    OTS.current().commit(true);  /* (iv) tx commits &amp; objects deactivated */
}              /* (v) */
</code></pre>
            <div class="variablelist"><dl><dt><span class="term">Creation of bindings to persistent objects</span></dt><dd>
                        <p>
                            This could involve the creation of stub objects and a call to remote objects. Here, we
                            re-bind to an
                            existing persistent object identified by
                            <code class="systemitem">Name-A</code>
                            , and a new persistent object. A
                            naming system for remote objects maintains the mapping between object names and locations and is described
                            in a later chapter.
                        </p>
                    </dd><dt><span class="term">Start of the atomic transaction</span></dt><dd>
                        <p/>
                    </dd><dt><span class="term">Operation invocations</span></dt><dd>
                        <p>
                            As a part of a given invocation, the object implementation is responsible to ensure that it is locked in
                            read or write mode, assuming no lock conflict, and initialized, if necessary, with the latest committed
                            state from the object store. The first time a lock is acquired on an object within a transaction the
                            object’s state is acquired, if possible, from the object store.
                        </p>
                    </dd><dt><span class="term">Commit of the top-level action</span></dt><dd>
                        <p>
                            This includes updating of the state of any modified objects in the object store.
                        </p>
                    </dd><dt><span class="term">Breaking of the previously created bindings</span></dt><dd>
                        <p>
                        </p>
                    </dd></dl></div>
        </div></div><br class="example-break"/>
    </div>

    <div class="section" title="1.1.8. The class hierarchy"><div class="titlepage"><div><div><h3 class="title"><a id="d5e379"/>1.1.8. The class hierarchy</h3></div></div></div>
        
        <p>
            The principal classes which make up the class hierarchy of ArjunaCore are depicted below.
        </p>

        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    <code class="classname">StateManager</code>
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>
                            <code class="classname">LockManager</code>
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                <p>User-Defined Classes</p>
                            </li></ul></div>
                    </li><li class="listitem">
                        <p>
                            <code class="classname">Lock</code>
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                <p>User-Defined Classes</p>
                            </li></ul></div>
                    </li><li class="listitem">
                        <p>
                            <code class="classname">AbstractRecord</code>
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                <p>
                                    <code class="classname">RecoveryRecord</code>
                                </p>
                            </li><li class="listitem">
                                <p>
                                    <code class="classname">LockRecord</code>
                                </p>
                            </li><li class="listitem">
                                <p>
                                    <code class="classname">RecordList</code>
                                </p>
                            </li><li class="listitem">
                                <p>Other management record types</p>
                            </li></ul></div>
                    </li></ul></div>
            </li><li class="listitem">
                <p>
                    <code class="classname">AtomicAction</code>
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>
                            <code class="classname">TopLevelTransaction</code>
                        </p>
                    </li></ul></div>
            </li><li class="listitem">
                <p>
                    <code class="classname">Input/OutputObjectBuffer</code>
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>
                            <code class="classname">Input/OutputObjectState</code>
                        </p>
                    </li></ul></div>
            </li><li class="listitem">
                <p>
                    <code class="classname">ObjectStore</code>
                </p>
            </li></ul></div>

        
        <p>
            Programmers of fault-tolerant applications will be primarily concerned with the classes
            <code class="classname">LockManager</code>
            ,
            <code class="classname">Lock</code>
            , and
            <code class="classname">AtomicAction</code>
            . Other
            classes important to a programmer are
            <code class="classname">Uid</code>
            and
            <code class="classname">ObjectState</code>
            .
        </p>
        <p>
            Most ArjunaCore classes are derived from the base class
            <code class="classname">StateManager</code>
            , which provides primitive
            facilities necessary for managing persistent and recoverable objects. These facilities include support for the
            activation and de-activation of objects, and state-based object recovery.
        </p>
        <p>
            The class
            <code class="classname">LockManager</code>
            uses the facilities of
            <code class="classname">StateManager</code>
            and
            <code class="classname">Lock</code>
            to provide the concurrency control required for implementing the serializability
            property of atomic actions. The concurrency control consists of two-phase locking in the current implementation.
            The implementation of atomic action facilities is supported by
            <code class="classname">AtomicAction</code>
            and
            <code class="classname">TopLevelTransaction</code>
            .
        </p>
        <p>
            Consider a simple example. Assume that
            <code class="classname">Example</code>
            is a user-defined persistent class suitably
            derived from the
            <code class="classname">LockManager</code>
            . An application containing an atomic transaction
            <code class="systemitem">Trans</code>
            accesses an object called
            <code class="systemitem">O</code>
            of type
            <span class="type">Example</span>
            ,
            by invoking the operation
            <code class="methodname">op1</code>
            , which involves state changes to
            <code class="systemitem">O</code>
            . The serializability property requires that a write lock must be acquired on
            <code class="systemitem">O</code>
            before it is modified. Therefore, the body of
            <code class="methodname">op1</code>
            should
            contain a call to the
            <code class="methodname">setlock</code>
            operation of the concurrency controller.
        </p>
        <div class="example"><a id="simple_concurrency_control"/><p class="title"><strong>Example 1.5. Simple Concurrency Control</strong></p><div class="example-contents">
            
            <pre><code class="language-java">public boolean op1 (...)
{  
    if (setlock (new Lock(LockMode.WRITE) == LockResult.GRANTED)
    {
        // actual state change operations follow 
        ...
    }
}
</code></pre>
        </div></div><br class="example-break"/>
        <div class="procedure" title="Procedure 1.1.  Steps followed by the operation setlock"><a id="d5e459"/><p class="title"><strong>Procedure 1.1. 
                Steps followed by the operation
                <code class="methodname">setlock</code>
            </strong></p><p>
                The operation
                <code class="methodname">setlock</code>
                , provided by the
                <code class="classname">LockManager</code>
                class,
                performs the following functions in
                <a class="xref" href="#simple_concurrency_control" title="Example 1.5. Simple Concurrency Control">Example 1.5, “Simple Concurrency Control”</a>
                .
            </p><ol class="procedure" type="1"><li class="step" title="Step 1">
                <p>Check write lock compatibility with the currently held locks, and if allowed, continue.</p>
            </li><li class="step" title="Step 2">
                <p>
                    Call the StateManager operation
                    <code class="methodname">activate</code>
                    .
                    <code class="methodname">activate</code>
                    will load,
                    if not done already, the latest persistent state of
                    <code class="classname">O</code>
                    from the object store, then call
                    the
                    <code class="classname">StateManager</code>
                    operation
                    <code class="methodname">modified</code>
                    , which has the effect of
                    creating an instance of either
                    <code class="classname">RecoveryRecord</code>
                    or
                    <code class="classname">PersistenceRecord</code>
                    for
                    <code class="classname">O</code>
                    , depending upon whether
                    <code class="classname">O</code>
                    was persistent or not. The Lock is a WRITE lock so the old state of the object must
                    be retained prior to modification. The record is then inserted into the RecordList of Trans.
                </p>
            </li><li class="step" title="Step 3">
                <p>
                    Create and insert a
                    <code class="classname">LockRecord</code>
                    instance in the
                    <code class="classname">RecordList</code>
                    of
                    <code class="systemitem">Trans</code>
                    .
                </p>
            </li></ol></div>
        <p>
            Now suppose that action
            <code class="systemitem">Trans</code>
            is aborted sometime after the lock has been acquired. Then
            the
            <code class="methodname">rollback</code>
            operation of
            <code class="classname">AtomicAction</code>
            will process the
            <code class="classname">RecordList</code>
            instance associated with
            <code class="systemitem">Trans</code>
            by invoking an
            appropriate
            <code class="methodname">Abort</code>
            operation on the various records. The implementation of this operation
            by the
            <code class="classname">LockRecord</code>
            class will release the WRITE lock while that of
            <code class="classname">RecoveryRecord</code>
            or
            <code class="classname">PersistenceRecord</code>
            will restore the prior state of
            <code class="classname">O</code>
            .
        </p>
        <p>
            It is important to realize that all of the above work is automatically being performed by ArjunaCore on behalf
            of the
            application programmer. The programmer need only start the transaction and set an appropriate lock; ArjunaCore and
            <span class="application">TXOJ</span>
            take care of participant registration, persistence, concurrency control and
            recovery.
        </p>
    </div>
</div>
    <div class="section" title="1.2. Using ArjunaCore"><div class="titlepage"><div><div><h2 class="title"><a id="d5e497"/>1.2. Using ArjunaCore</h2></div></div></div>
    
    <p>
        This section describes ArjunaCore and
        <span class="application">Transactional Objects for Java (TXOJ)</span>
        in more detail,
        and shows how to use ArjunaCore to construct transactional applications.
    </p>
    <p>
	Note: in previous releases ArjunaCore was often referred to as TxCore.
    </p>
    <div class="section" title="1.2.1. State management"><div class="titlepage"><div><div><h3 class="title"><a id="d5e502"/>1.2.1. State management</h3></div></div></div>
        
        <div class="section" title="1.2.1.1. Object states"><div class="titlepage"><div><div><h4 class="title"><a id="d5e504"/>1.2.1.1. Object states</h4></div></div></div>
            
            <p>
                ArjunaCore needs to be able to remember the state of an object for several purposes, including recovery (the state
                represents some past state of the object), and for persistence (the state represents the final state of an
                object at application termination). Since all of these requirements require common functionality they are all
                implemented using the same mechanism - the classes Input/OutputObjectState and Input/OutputBuffer.
            </p>
            <div class="example"><a id="d5e507"/><p class="title"><strong>Example 1.6. 
                    <code class="classname">OutputBuffer</code>
                    and
                    <code class="classname">InputBuffer</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">public class OutputBuffer
{
    public OutputBuffer ();

    public final synchronized boolean valid ();
    public synchronized byte[] buffer();
    public synchronized int length ();

    /* pack operations for standard Java types */

    public synchronized void packByte (byte b) throws IOException;
    public synchronized void packBytes (byte[] b) throws IOException;
    public synchronized void packBoolean (boolean b) throws IOException;
    public synchronized void packChar (char c) throws IOException;
    public synchronized void packShort (short s) throws IOException;
    public synchronized void packInt (int i) throws IOException;
    public synchronized void packLong (long l) throws IOException;
    public synchronized void packFloat (float f) throws IOException;
    public synchronized void packDouble (double d) throws IOException;
    public synchronized void packString (String s) throws IOException;
};
</code></pre>
                <pre><code class="language-java">public class InputBuffer
{
    public InputBuffer ();

    public final synchronized boolean valid ();
    public synchronized byte[] buffer();
    public synchronized int length ();

    /* unpack operations for standard Java types */

    public synchronized byte unpackByte () throws IOException;
    public synchronized byte[] unpackBytes () throws IOException;
    public synchronized boolean unpackBoolean () throws IOException;
    public synchronized char unpackChar () throws IOException;
    public synchronized short unpackShort () throws IOException;
    public synchronized int unpackInt () throws IOException;
    public synchronized long unpackLong () throws IOException;
    public synchronized float unpackFloat () throws IOException;
    public synchronized double unpackDouble () throws IOException;
    public synchronized String unpackString () throws IOException;
};
</code></pre>
                <p>
                    The
                    <code class="classname">InputBuffer</code>
                    and
                    <code class="classname">OutputBuffer</code>
                    classes maintain an internal
                    array into which instances of the standard Java types can be contiguously packed or unpacked, using the
                    <code class="methodname">pack</code>
                    or
                    <code class="methodname">unpack</code>
                    operations. This buffer is automatically
                    resized as required should it have insufficient space. The instances are all stored in the buffer in a
                    standard form called
                    <code class="systemitem">network byte order</code>
                    to make them machine independent.
                </p>
            </div></div><br class="example-break"/>
            <div class="example"><a id="d5e519"/><p class="title"><strong>Example 1.7. 
                    <code class="classname">OutputObjectState</code>
                    and
                    <code class="classname">InputObjectState</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">class OutputObjectState extends OutputBuffer
{
    public OutputObjectState (Uid newUid, String typeName);

    public boolean notempty ();
    public int size ();
    public Uid stateUid ();
    public String type ();
};
</code></pre>
                <pre><code class="language-java">class InputObjectState extends InputBuffer
{
    public OutputObjectState (Uid newUid, String typeName, byte[] b);

    public boolean notempty ();
    public int size ();
    public Uid stateUid ();
    public String type ();
};
</code></pre>
                <p>
                    The
                    <code class="classname">InputObjectState</code>
                    and
                    <code class="classname">OutputObjectState</code>
                    classes provides all
                    the functionality of
                    <code class="classname">InputBuffer</code>
                    and
                    <code class="classname">OutputBuffer</code>
                    , through
                    inheritance, and add two additional instance variables that signify the Uid and type of the object for which
                    the
                    <code class="classname">InputObjectStat</code>
                    or
                    <code class="classname">OutputObjectState</code>
                    instance is a
                    compressed image. These are used when accessing the object store during storage and retrieval of the object
                    state.
                </p>
            </div></div><br class="example-break"/>
        </div>

        <div class="section" title="1.2.1.2. The object store"><div class="titlepage"><div><div><h4 class="title"><a id="d5e532"/>1.2.1.2. The object store</h4></div></div></div>
            
            <p>
                The object store provided with ArjunaCore deliberately has a fairly restricted interface so that it can be
                implemented in a variety of ways. For example, object stores are implemented in shared memory, on the
                Unix file
                system (in several different forms), and as a remotely accessible store. More complete information about the
                object stores available in ArjunaCore can be found in the Appendix. 
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    As with all ArjunaCore classes, the default object stores are pure Java implementations. to access the shared
                    memory and other more complex object store implementations, you need to use native methods.
                </p>
            </div>
            <p>
                All of the object stores hold and retrieve instances of the class
                <code class="classname">InputObjectState</code>
                or
                <code class="classname">OutputObjectState</code>
                . These instances are named by the Uid and Type of the object that they
                represent. States are read using the
                <code class="methodname">read_committed</code>
                operation and written by the system
                using the
                <code class="methodname">write_uncommitted</code>
                operation. Under normal operation new object states do not
                overwrite old object states but are written to the store as shadow copies. These shadows replace the original
                only when the
                <code class="methodname">commit_state</code>
                operation is invoked. Normally all interaction with the
                object store is performed by ArjunaCore system components as appropriate thus the existence of any shadow versions
                of objects in the store are hidden from the programmer.
            </p>
            <div class="example"><a id="d5e543"/><p class="title"><strong>Example 1.8. StateStatus</strong></p><div class="example-contents">
                
                <pre><code class="language-java">public StateStatus
{
    public static final int OS_COMMITTED;
    public static final int OS_UNCOMMITTED;
    public static final int OS_COMMITTED_HIDDEN;
    public static final int OS_UNCOMMITTED_HIDDEN;
    public static final int OS_UNKNOWN;
}
</code></pre>
            </div></div><br class="example-break"/>
            <div class="example"><a id="d5e546"/><p class="title"><strong>Example 1.9. ObjectStore</strong></p><div class="example-contents">
                
                <pre><code class="language-java">public abstract class ObjectStore 
{
    /* The abstract interface */
    public abstract boolean commit_state (Uid u, String name)
        throws ObjectStoreException;
    public abstract InputObjectState read_committed (Uid u, String name)
        throws ObjectStoreException;
    public abstract boolean write_uncommitted (Uid u, String name,
                                               OutputObjectState os) throws ObjectStoreException;
    . . .
};
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                When a transactional object is committing, it must make certain state changes persistent, so it can
                recover in
                the event of a failure and either continue to commit, or rollback. When using
                <span class="application">TXOJ</span>
                ,
                ArjunaCore will take care of this automatically. To guarantee
                <code class="systemitem">ACID</code>
                properties, these state
                changes must be flushed to the persistence store implementation before the transaction can proceed to
                commit. Otherwise, the application may assume that the transaction has committed when in fact the state changes
                may still reside within an operating system cache, and may be lost by a subsequent machine failure. By default,
                ArjunaCore ensures that such state changes are flushed. However, doing so can impose a significant performance
                penalty on the application.
            </p>
            <p>
                To prevent transactional object state flushes, set the
                <code class="varname">ObjectStoreEnvironmentBean.objectStoreSync</code>
                variable to
                <code class="literal">OFF</code>
                .
            </p>
        </div>

        <div class="section" title="1.2.1.3. Selecting an object store implementation"><div class="titlepage"><div><div><h4 class="title"><a id="d5e555"/>1.2.1.3. Selecting an object store implementation</h4></div></div></div>
            
            <p>
                ArjunaCore comes with support for several different object store implementations. The Appendix
                describes these implementations, how to select and configure a given implementation on a per-object
                basis using
                the
                <code class="varname">ObjectStoreEnvironmentBean.objectStoreType</code>
                property variable, and indicates how
                additional implementations can be provided.
            </p>

            <div class="section" title="1.2.1.3.1. StateManager"><div class="titlepage"><div><div><h5 class="title"><a id="d5e559"/>1.2.1.3.1. StateManager</h5></div></div></div>
                
                <p>
                    The ArjunaCore class
                    <code class="classname">StateManager</code>
                    manages the state of an object and provides all of the
                    basic support mechanisms required by an object for state management
                    purposes.
                    <code class="classname">StateManager</code>
                    is responsible for creating and registering appropriate
                    resources concerned with the persistence and recovery of the transactional object. If a transaction is nested,
                    then
                    <code class="classname">StateManager</code>
                    will also propagate these resources between child transactions and
                    their parents at commit time.
                </p>
                <p> 
                    Objects are assumed to be of three possible flavors.
                </p>
                <div class="variablelist" title="Three Flavors of Objects"><p class="title"><strong>Three Flavors of Objects</strong></p><dl><dt><span class="term">Recoverable</span></dt><dd>
                            <p>
                                <code class="classname">StateManager</code>
                                attempts to generate and maintain appropriate recovery information for
                                the object. Such objects have lifetimes that do not exceed the application program that creates them.
                            </p>
                        </dd><dt><span class="term">Recoverable and Persistent</span></dt><dd>
                            <p>
                                The lifetime of the object is assumed to be greater than that of the creating or
                                accessing application, so
                                that in addition to maintaining recovery information,
                                <code class="classname">StateManager</code>
                                attempts to
                                automatically load or unload any existing persistent state for the object by calling the
                                <code class="methodname">activate</code>
                                or
                                <code class="methodname">deactivate</code>
                                operation at appropriate times.
                            </p>
                        </dd><dt><span class="term">Neither Recoverable nor Persistent</span></dt><dd>
                            <p>
                                No recovery information is ever kept, nor is object activation or deactivation ever automatically
                                attempted.
                            </p>
                        </dd></dl></div>
                <p>
                    This object property is selected at object construction time and cannot be changed thereafter. Thus an object
                    cannot gain (or lose) recovery capabilities at some arbitrary point during its lifetime.
                </p>

                <div class="example"><a id="d5e585"/><p class="title"><strong>Example 1.10. 
                        Object Store Implementation Using
                        <code class="classname">StateManager</code>
                    </strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">public class ObjectStatus
{
    public static final int PASSIVE;
    public static final int PASSIVE_NEW;
    public static final int ACTIVE;
    public static final int ACTIVE_NEW;
    public static final int UNKNOWN_STATUS;
};

public class ObjectType
{
    public static final int RECOVERABLE;
    public static final int ANDPERSISTENT;
    public static final int NEITHER;
};

public abstract class StateManager
{
    public synchronized boolean activate ();
    public synchronized boolean activate (String storeRoot);
    public synchronized boolean deactivate ();
    public synchronized boolean deactivate (String storeRoot, boolean commit);

    public synchronized void destroy ();
 
    public final Uid get_uid ();

    public boolean restore_state (InputObjectState, int ObjectType);
    public boolean save_state (OutputObjectState, int ObjectType);
    public String type ();
    . . .

        protected StateManager ();
    protected StateManager (int ObjectType, int objectModel);
    protected StateManager (Uid uid);
    protected StateManager (Uid uid, int objectModel);
    . . .

        protected final void modified ();
    . . .
};

public class ObjectModel
{
    public static final int SINGLE;
    public static final int MULTIPLE;
};
</code></pre>
                </div></div><br class="example-break"/>

                <p>
                    If an object is recoverable or persistent,
                    <code class="classname">StateManager</code>
                    will invoke the operations
                    <code class="methodname">save_state</code>
                    (while performing deactivation),
                    <code class="methodname">restore_state</code>
                    (while performing activation), and
                    <code class="methodname">type</code>
                    at various points during the execution of the
                    application. These operations must be implemented by the programmer since
                    <code class="classname">StateManager</code>
                    does not have access to a runtime description of the layout of an arbitrary Java object in memory
                    and thus
                    cannot implement a default policy for converting the in memory version of the object to its passive
                    form. However, the capabilities provided by
                    <code class="classname">InputObjectState</code>
                    and
                    <code class="classname">OutputObjectState</code>
                    make the writing of these routines fairly simple. For example, the
                    <code class="methodname">save_state</code>
                    implementation for a class
                    <code class="classname">Example</code>
                    that had member
                    variables called
                    <code class="varname">A</code>
                    ,
                    <code class="varname">B</code>
                    , and
                    <code class="varname">C</code>
                    could simply be
                    <a class="xref" href="#example_methods_for_StateManager" title="Example 1.11.  Example Implementation of Methods for StateManager">Example 1.11, “
                        Example Implementation of Methods for
                        <code class="classname">StateManager</code>
                    ”</a>
                    .
                </p>
                <div class="example"><a id="example_methods_for_StateManager"/><p class="title"><strong>Example 1.11. 
                        Example Implementation of Methods for
                        <code class="classname">StateManager</code>
                    </strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">public boolean save_state ( OutputObjectState os, int ObjectType )
{
    if (!super.save_state(os, ObjectType))
        return false;

    try
        {
            os.packInt(A);
            os.packString(B);
            os.packFloat(C);

            return true;
        }
    catch (IOException e)
        {
            return false;
        }
}
</code></pre>
                </div></div><br class="example-break"/>
                <p>
                    In order to support crash recovery for persistent objects, all
                    <code class="methodname">save_state</code>
                    and
                    <code class="methodname">restore_state</code>
                    methods of user objects must call
                    <code class="methodname">super.save_state</code>
                    and
                    <code class="methodname">super.restore_state</code>
                    .
                </p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                    <p>
                        The
                        <code class="methodname">type</code>
                        method is used to determine the location in the object store where the
                        state of instances of that class will be saved and ultimately restored. This location can actually be any
                        valid string. However, you should avoid using the hash character (#) as this is reserved for special
                        directories that ArjunaCore requires.
                    </p>
                </div>
                <p>
                    The
                    <code class="methodname">get_uid</code>
                    operation of
                    <code class="classname">StateManager</code>
                    provides read-only
                    access to an object’s internal system name for whatever purpose the programmer requires, such as registration
                    of the name in a name server. The value of the internal system name can only be set when an object is
                    initially constructed, either by the provision of an explicit parameter or by generating a new identifier when
                    the object is created.
                </p>
                <p>
                    The
                    <code class="methodname">destroy</code>
                    method can be used to remove the object’s state from the object
                    store. This is an atomic operation, and therefore will only remove the state if the top-level transaction
                    within which it is invoked eventually commits. The programmer must obtain exclusive access to the object prior
                    to invoking this operation.
                </p>
                <p>
                    Since object recovery and persistence essentially have complimentary requirements (the only
                    difference being
                    where state information is stored and for what purpose),
                    <code class="classname">StateManager</code>
                    effectively
                    combines the management of these two properties into a single mechanism. It uses instances of the classes
                    <code class="classname">InputObjectState</code>
                    and
                    <code class="classname">OutputObjectState</code>
                    both for recovery and
                    persistence purposes. An additional argument passed to the
                    <code class="methodname">save_state</code>
                    and
                    <code class="methodname">restore_state</code>
                    operations allows the programmer to determine the purpose for which any
                    given invocation is being made. This allows different information to be saved for recovery and persistence
                    purposes.
                </p>
            </div>

            <div class="section" title="1.2.1.3.2. Object models"><div class="titlepage"><div><div><h5 class="title"><a id="d5e626"/>1.2.1.3.2. Object models</h5></div></div></div>
                
                <p>
                    ArjunaCore supports two models for objects, which affect how an objects state and concurrency control are implemented.
                </p>
                <div class="variablelist" title="ArjunaCore Object Models"><p class="title"><strong>ArjunaCore Object Models</strong></p><dl><dt><span class="term">Single</span></dt><dd>
                            <p>
                                Only a single copy of the object exists within the application. This copy resides within a single JVM,
                                and all clients must address their invocations to this server. This model provides better performance,
                                but represents a single point of failure, and in a multi-threaded environment may not protect the
                                object from corruption if a single thread fails.
                            </p>
                            <div class="figure"><a id="d5e635"/><p class="title"><strong>Figure 1.3. Single Object Model</strong></p><div class="figure-contents">
                                
                                <div class="mediaobject"><img src="images/single_object_model.png" alt="Single Object Model" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e637.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e637.html" target="longdesc">D</a>]</span></div></div>
                            </div></div><br class="figure-break"/>
                        </dd><dt><span class="term">Multiple</span></dt><dd>
                            <p>
                                Logically, a single instance of the object exists, but copies of it are distributed across different
                                JVMs. The performance of this model is worse than the SINGLE model, but it provides better failure
                                isolation.
                            </p>
                            <div class="figure"><a id="d5e646"/><p class="title"><strong>Figure 1.4. Multiple Object Model</strong></p><div class="figure-contents">
                                
                                <div class="mediaobject"><img src="images/multiple_object_model.png" alt="Multiple Object Model" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e648.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e648.html" target="longdesc">D</a>]</span></div></div>
                            </div></div><br class="figure-break"/>
                        </dd></dl></div>
                <p>
                    The default model is SINGLE. The programmer can override this on a per-object basis by using the appropriate
                    constructor.
                </p>
            </div>

            <div class="section" title="1.2.1.3.3. Summary"><div class="titlepage"><div><div><h5 class="title"><a id="d5e654"/>1.2.1.3.3. Summary</h5></div></div></div>
                
                <p>
                    In summary, the ArjunaCore class
                    <code class="classname">StateManager</code>
                    manages the state of an object and provides
                    all of the basic support mechanisms required by an object for state management purposes. Some operations must
                    be defined by the class developer. These operations are:
                    <code class="methodname">save_state</code>
                    ,
                    <code class="methodname">restore_state</code>
                    , and
                    <code class="methodname">type</code>
                    .
                </p>
                <div class="variablelist"><dl><dt><span class="term">
                            <span class="type">boolean</span>
                            <code class="methodname">save_state</code>
                            (
                            <span class="type">OutputObjectState</span>
                            <code class="varname">state</code>
                            ,
                            <span class="type">int</span>
                            <code class="varname">objectType</code>
                            )
                        </span></dt><dd>
                            <p>
                                Invoked whenever the state of an object might need to be saved for future use, primarily
                                for recovery
                                or persistence purposes. The
                                <em class="parameter"><code>objectType</code></em>
                                parameter indicates the reason that
                                <code class="methodname">save_state</code>
                                was invoked by ArjunaCore. This enables the programmer to save different
                                pieces of information into the
                                <code class="classname">OutputObjectState</code>
                                supplied as the first parameter
                                depending upon whether the state is needed for recovery or persistence purposes. For example, pointers
                                to other ArjunaCore objects might be saved simply as pointers for recovery purposes but as
                                <span class="type">Uid</span>
                                s
                                for persistence purposes. As shown earlier, the
                                <code class="classname">OutputObjectState</code>
                                class provides
                                convenient operations to allow the saving of instances of all of the basic types in Java. In order to
                                support crash recovery for persistent objects it is necessary for all
                                <code class="methodname">save_state</code>
                                methods to call
                                <code class="methodname">super.save_state</code>
                                .
                            </p>
                            <p>
                                <code class="methodname">save_state</code>
                                assumes that an object is internally consistent and that all
                                variables saved have valid values. It is the programmer's responsibility to ensure that this is the
                                case.
                            </p>
                        </dd><dt><span class="term">
                            <span class="type">boolean</span>
                            <code class="methodname">restore_state</code>
                            (
                            <span class="type">InputObjectState</span>
                            <code class="varname">state</code>
                            ,
                            <span class="type">int</span>
                            <code class="varname">objectType</code>
                            )
                        </span></dt><dd>
                            <p>
                                Invoked whenever the state of an object needs to be restored to the one supplied. Once
                                again the second
                                parameter allows different interpretations of the supplied state. In order to support crash recovery for
                                persistent objects it is necessary for all
                                <code class="methodname">restore_state</code>
                                methods to call
                                <code class="methodname">super.restore_state</code>
                                .
                            </p>
                        </dd><dt><span class="term">
                            <span class="type">String</span>
                            <code class="methodname">type</code>
                            ()
                        </span></dt><dd>
                            <p>
                                The ArjunaCore persistence mechanism requires a means of determining the type of an object
                                as a string so
                                that it can save or restore the state of the object into or from the object store. By convention this
                                information indicates the position of the class in the hierarchy. For example,
                                <code class="literal">/StateManager/LockManager/Object</code>
                                .
                            </p>
                            <p>
                                The
                                <code class="methodname">type</code>
                                method is used to determine the location in the object store where the
                                state of instances of that class will be saved and ultimately restored. This can actually be any valid
                                string. However, you should avoid using the hash character (#) as this is reserved for special
                                directories that ArjunaCore requires.
                            </p>
                        </dd></dl></div>
            </div>

            <div class="section" title="1.2.1.3.4. Example"><div class="titlepage"><div><div><h5 class="title"><a id="d5e702"/>1.2.1.3.4. Example</h5></div></div></div>
                
                <p>
                    Consider the following basic
                    <code class="classname">Array</code>
                    class derived from the
                    <code class="classname">StateManager</code>
                    class. In this example, to illustrate saving and restoring of an object’s
                    state, the
                    <code class="varname">highestIndex</code>
                    variable is used to keep track of the highest element of the array
                    that has a non-zero value.
                </p>
                <div class="example"><a id="array-example"/><p class="title"><strong>Example 1.12. 
                        <code class="classname">Array</code>
                        Class
                    </strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">public class Array extends StateManager
{
    public Array ();
    public Array (Uid objUid);
    public void finalize ( super.terminate(); super.finalize(); };

    /* Class specific operations. */

    public boolean set (int index, int value);
    public int get (int index);

    /* State management specific operations. */

    public boolean save_state (OutputObjectState os, int ObjectType);
    public boolean restore_state (InputObjectState os, int ObjectType);
    public String type ();

    public static final int ARRAY_SIZE = 10;

    private int[] elements = new int[ARRAY_SIZE];
    private int highestIndex;
};
The save_state, restore_state and type operations can be defined as follows:
    /* Ignore ObjectType parameter for simplicity */

    public boolean save_state (OutputObjectState os, int ObjectType)
    {
        if (!super.save_state(os, ObjectType))
            return false;

        try
            {
                packInt(highestIndex);

                /*
                 * Traverse array state that we wish to save. Only save active elements
                 */

                for (int i = 0; i &lt;= highestIndex; i++)
                    os.packInt(elements[i]);

                return true;
            }
        catch (IOException e)
            {
                return false;
            }
    }
public boolean restore_state (InputObjectState os, int ObjectType)
{
    if (!super.restore_state(os, ObjectType))
        return false;

    try
        {
            int i = 0;

            highestIndex = os.unpackInt();

            while (i &lt; ARRAY_SIZE)
                {
                    if (i &lt;= highestIndex)
                        elements[i] =  os.unpackInt();
                    else
                        elements[i] = 0;
                    i++;
                }

            return true;
        }
    catch (IOException e)
        {
            return false;
        }
}
public String type ()
{
    return "/StateManager/Array";
}
</code></pre>
                </div></div><br class="example-break"/>
            </div>

        </div>
    </div>

    <div class="section" title="1.2.2. Lock management and concurrency control"><div class="titlepage"><div><div><h3 class="title"><a id="d5e712"/>1.2.2. Lock management and concurrency control</h3></div></div></div>
        
        <p>
            Concurrency control information within ArjunaCore is maintained by locks. Locks which are required to be shared
            between objects in different processes may be held within a lock store, similar to the object store facility
            presented previously. The lock store provided with ArjunaCore deliberately has a fairly restricted interface so
            that
            it can be implemented in a variety of ways. For example, lock stores are implemented in shared memory, on the Unix
            file system (in several different forms), and as a remotely accessible store. More information about the object
            stores available in ArjunaCore can be found in the Appendix.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                As with all ArjunaCore classes, the default lock stores are pure Java implementations. To access the shared memory
                and other more complex lock store implementations it is necessary to use native methods.
            </p>
        </div>
        <div class="example"><a id="d5e717"/><p class="title"><strong>Example 1.13. 
                <code class="classname">LockStore</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">public class LockStore
{
    public abstract InputObjectState read_state (Uid u, String tName)
        throws LockStoreException;

    public abstract boolean remove_state (Uid u, String tname);
    public abstract boolean write_committed (Uid u, String tName,
                                             OutputObjectState state);
};
</code></pre>
        </div></div><br class="example-break"/>

        <div class="section" title="1.2.2.1. Selecting a lock store implementation"><div class="titlepage"><div><div><h4 class="title"><a id="d5e721"/>1.2.2.1. Selecting a lock store implementation</h4></div></div></div>
            
            <p>
                ArjunaCore comes with support for several different object store implementations. If the object model being
                used is
                SINGLE, then no lock store is required for maintaining locks, since the information about the object is not
                exported from it. However, if the MULTIPLE model is used, then different run-time environments (processes, Java
                virtual machines) may need to share concurrency control information. The implementation type of the lock store
                to use can be specified for all objects within a given execution environment using the
                <code class="varname">TxojEnvironmentBean.lockStoreType</code>
                property variable. Currently this can have one of the
                following values:
            </p>
            <div class="variablelist"><dl><dt><span class="term">BasicLockStore</span></dt><dd>
                        <p>
                            This is an in-memory implementation which does not, by default, allow sharing of stored information
                            between execution environments. The application programmer is responsible for sharing the store
                            information.
                        </p>
                    </dd><dt><span class="term">BasicPersistentLockStore</span></dt><dd>
                        <p>
                            This is the default implementation, and stores locking information within the local file
                            system. Therefore
                            execution environments that share the same file store can share concurrency control information. The root
                            of the file system into which locking information is written is the
                            <code class="filename">LockStore</code>
                            directory within the ArjunaCore installation directory. You can override this at runtime by
                            setting the
                            <code class="varname">TxojEnvironmentBean.lockStoreDir</code>
                            property variable accordingly, or placing the location
                            within the
                            <code class="varname">CLASSPATH</code>
                            .
                        </p>
                        <pre class="screen">java -D TxojEnvironmentBean.lockStoreDir=/var/tmp/LockStore myprogram</pre>
                        <pre class="screen">java –classpath $CLASSPATH;/var/tmp/LockStore myprogram</pre>
                        <p>
                            If neither of these approaches is taken, then the default location will be at the same level
                            as the
                            <code class="filename">etc</code>
                            directory of the installation.
                        </p>
                    </dd></dl></div>
        </div>

        <div class="section" title="1.2.2.2. LockManager"><div class="titlepage"><div><div><h4 class="title"><a id="d5e741"/>1.2.2.2. LockManager</h4></div></div></div>
            
            <p>
                The concurrency controller is implemented by the class
                <code class="classname">LockManager</code>
                , which provides
                sensible default behavior, while allowing the programmer to override it if deemed necessary by the particular
                semantics of the class being programmed. The primary programmer interface to the concurrency controller is via
                the
                <code class="methodname">setlock</code>
                operation. By default, the ArjunaCore runtime system enforces strict two-phase
                locking following a multiple reader, single writer policy on a per object basis. Lock acquisition is under
                programmer control, since just as
                <code class="classname">StateManager</code>
                cannot determine if an operation modifies
                an object,
                <code class="classname">LockManager</code>
                cannot determine if an operation requires a read or write
                lock. Lock release, however, is normally under control of the system and requires no further intervention by the
                programmer. This ensures that the two-phase property can be correctly maintained.
            </p>
            <p>
                The
                <code class="classname">LockManager</code>
                class is primarily responsible for managing requests to set a lock on an
                object or to release a lock as appropriate. However, since it is derived from
                <code class="classname">StateManager</code>
                , it can also control when some of the inherited facilities are invoked. For
                example, if a request to set a write lock is granted, then
                <code class="classname">LockManager</code>
                invokes modified
                directly assuming that the setting of a write lock implies that the invoking operation must be about to modify
                the object. This may in turn cause recovery information to be saved if the object is recoverable. In a similar
                fashion, successful lock acquisition causes activate to be invoked.
            </p>
            <p>
                Therefore,
                <code class="classname">LockManager</code>
                is directly responsible for activating and deactivating persistent
                objects, as well as registering
                <code class="systemitem">Resources</code>
                for managing concurrency control. By driving
                the
                <code class="classname">StateManager</code>
                class, it is also responsible for registering
                <code class="systemitem">Resources</code>
                for persistent or recoverable state manipulation and object recovery. The
                application programmer simply sets appropriate locks, starts and ends transactions, and extends the
                <code class="methodname">save_state</code>
                and
                <code class="methodname">restore_state</code>
                methods of
                <code class="classname">StateManager</code>
                .
            </p>
            <div class="example"><a id="d5e760"/><p class="title"><strong>Example 1.14. 
                    <code class="classname">LockResult</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java"> public class LockResult
{
    public static final int GRANTED;
    public static final int REFUSED;
    public static final int RELEASED;
};

public class ConflictType
{
    public static final int CONFLICT;
    public static final int COMPATIBLE;
    public static final int PRESENT;
};

public abstract class LockManager extends StateManager
{
    public static final int defaultTimeout;
    public static final int defaultRetry;
    public static final int waitTotalTimeout;

    public synchronized int setlock (Lock l);
    public synchronized int setlock (Lock l, int retry);
    public synchronized int setlock (Lock l, int retry, int sleepTime);
    public synchronized boolean releaselock (Uid uid);
 
    /* abstract methods inherited from StateManager */

    public boolean restore_state (InputObjectState os, int ObjectType);
    public boolean save_state (OutputObjectState os, int ObjectType);
    public String type ();

    protected LockManager ();
    protected LockManager (int ObjectType, int objectModel);
    protected LockManager (Uid storeUid);
    protected LockManager (Uid storeUid, int ObjectType, int objectModel);
    . . .
};
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                The
                <code class="methodname">setlock</code>
                operation must be parametrized with the type of lock required (READ or
                WRITE), and the number of retries to acquire the lock before giving up. If a lock conflict occurs, one of the
                following scenarios will take place:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        If the retry value is equal to
                        <code class="varname">LockManager.waitTotalTimeout</code>
                        , then the thread which called
                        <code class="methodname">setlock</code>
                        will be blocked until the lock is released, or the total timeout specified
                        has elapsed, and in which
                        <code class="literal">REFUSED</code>
                        will be returned.
                    </p>
                </li><li class="listitem">
                    <p>
                        If the lock cannot be obtained initially then
                        <code class="classname">LockManager</code>
                        will try for the specified
                        number of retries, waiting for the specified timeout value between each failed attempt. The default is 100
                        attempts, each attempt being separated by a 0.25 seconds delay. The time between retries is specified in
                        micro-seconds.
                    </p>
                </li><li class="listitem">
                    <p>
                        If a lock conflict occurs the current implementation simply times out lock requests, thereby
                        preventing
                        deadlocks, rather than providing a full deadlock detection scheme. If the requested lock is obtained, the
                        <code class="methodname">setlock</code>
                        operation will return the value GRANTED, otherwise the value
                        <code class="literal">REFUSED</code>
                        is returned. It is the responsibility of the programmer to ensure that the
                        remainder of the code for an operation is only executed if a lock request is granted. Below are examples of
                        the use of the setlock operation.
                    </p>
                </li></ul></div>
            <div class="example"><a id="d5e779"/><p class="title"><strong>Example 1.15. 
                    <code class="methodname">setlock</code>
                    Method Usage
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java"> res = setlock(new Lock(WRITE), 10); // Will attempt to set a
                  // write lock 11 times (10
                  // retries) on the object
                  // before giving up.
res = setlock(new Lock(READ), 0);      // Will attempt to set a read
                  // lock 1 time (no retries) on
                  // the object before giving up.
res = setlock(new Lock(WRITE);      // Will attempt to set a write
                  // lock 101 times (default of
                  // 100 retries) on the object
                  // before giving up.
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                The concurrency control mechanism is integrated into the atomic action mechanism, thus ensuring that as
                locks
                are granted on an object appropriate information is registered with the currently running atomic action to
                ensure that the locks are released at the correct time. This frees the programmer from the burden of explicitly
                freeing any acquired locks if they were acquired within atomic actions. However, if locks are acquired on an
                object outside of the scope of an atomic action, it is the programmer's responsibility to release the locks when
                required, using the corresponding
                <code class="methodname">releaselock</code>
                operation.
            </p>
        </div>

        <div class="section" title="1.2.2.3. Locking policy"><div class="titlepage"><div><div><h4 class="title"><a id="d5e785"/>1.2.2.3. Locking policy</h4></div></div></div>
            
            <p>
                Unlike many other systems, locks in ArjunaCore are not special system types. Instead they are simply
                instances of
                other ArjunaCore objects (the class
                <code class="classname">Lock</code>
                which is also derived from
                <code class="classname">StateManager</code>
                so that locks may be made persistent if required and can also be named in a
                simple fashion). Furthermore,
                <code class="classname">LockManager</code>
                deliberately has no knowledge of the semantics
                of the actual policy by which lock requests are granted. Such information is maintained by the actual
                <code class="classname">Lock</code>
                class instances which provide operations (the
                <code class="methodname">conflictsWith</code>
                operation) by which
                <code class="classname">LockManager</code>
                can determine if two locks conflict or not. This
                separation is important in that it allows the programmer to derive new lock types from the basic
                <code class="classname">Lock</code>
                class and by providing appropriate definitions of the conflict operations enhanced
                levels of concurrency may be possible.
            </p>
            <div class="example"><a id="d5e795"/><p class="title"><strong>Example 1.16. 
                    <code class="classname">LockMode</code>
                    Class
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">public class LockMode
{
    public static final int READ;
    public static final int WRITE;
};

public class LockStatus
{
    public static final int LOCKFREE;
    public static final int LOCKHELD;
    public static final int LOCKRETAINED;
};

public class Lock extends StateManager
{
    public Lock (int lockMode);

    public boolean conflictsWith  (Lock otherLock);
    public boolean modifiesObject ();

    public boolean restore_state (InputObjectState os, int ObjectType);
    public boolean save_state (OutputObjectState os, int ObjectType);
    public String type ();
    . . .
};
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                The
                <code class="classname">Lock</code>
                class provides a
                <code class="methodname">modifiesObject</code>
                operation which
                <code class="classname">LockManager</code>
                uses to determine if granting this locking request requires a call on
                modified. This operation is provided so that locking modes other than simple read and write can be
                supported. The supplied
                <code class="classname">Lock</code>
                class supports the traditional multiple reader/single writer
                policy.
            </p>
        </div>

        <div class="section" title="1.2.2.4. Object constructor and finalizer"><div class="titlepage"><div><div><h4 class="title"><a id="d5e804"/>1.2.2.4. Object constructor and finalizer</h4></div></div></div>
            
            <p>
                Recall that ArjunaCore objects can be recoverable, recoverable and persistent, or neither. Additionally each
                object
                possesses a unique internal name. These attributes can only be set when that object is constructed. Thus
                <code class="classname">LockManager</code>
                provides two protected constructors for use by derived classes, each of which
                fulfills a distinct purpose
            </p>
            <div class="variablelist" title="Protected Constructors Provided by LockManager"><p class="title"><strong>
                    Protected Constructors Provided by
                    <code class="classname">LockManager</code>
                </strong></p><dl><dt><span class="term">
                        <code class="methodname">LockManager ()</code>
                    </span></dt><dd>
                        <p>
                            This constructor allows the creation of new objects, having no prior state.
                        </p>
                    </dd><dt><span class="term">
                        <code class="methodname">LockManager</code>
                        (
                        <span class="type">int</span>
                        <code class="varname">objectType</code>
                        ,
                        <span class="type">int</span>
                        <code class="varname">objectModel)</code>
                    </span></dt><dd>
                        <p>
                            As above, this constructor allows the creation of new objects having no prior state. exist.
                            The
                            <code class="varname">objectType</code>
                            parameter determines whether an object is simply recoverable (indicated by
                            <code class="literal">RECOVERABLE</code>
                            ), recoverable and persistent (indicated by
                            <code class="literal">ANDPERSISTENT</code>
                            ), or neither (indicated by
                            <code class="literal">NEITHER</code>
                            ). If an object is
                            marked as being persistent then the state of the object will be stored in one of the object stores. The
                            shared parameter only has meaning if it is
                            <code class="literal">RECOVERABLE</code>
                            . If the object model is
                            <code class="literal">SINGLE</code>
                            (the default behavior) then the recoverable state of the object is maintained
                            within the object itself, and has no external representation). Otherwise an in-memory (volatile) object
                            store is used to store the state of the object between atomic actions.
                        </p>
                        <p>
                            Constructors for new persistent objects should make use of atomic actions within themselves. This will
                            ensure that the state of the object is automatically written to the object store either when the action in
                            the constructor commits or, if an enclosing action exists, when the appropriate top-level action
                            commits. Later examples in this chapter illustrate this point further.
                        </p>
                    </dd><dt><span class="term">
                        <code class="methodname">LockManager</code>
                        (
                        <span class="type">Uid</span>
                        <code class="varname">objUid</code>
                        )
                    </span></dt><dd>
                        <p>
                            This constructor allows access to an existing persistent object, whose internal name is
                            given by the
                            <code class="varname">objUid</code>
                            parameter. Objects constructed using this operation will normally have their
                            prior state (identified by
                            <code class="varname">objUid</code>
                            ) loaded from an object store automatically by the
                            system.
                        </p>
                    </dd><dt><span class="term">
                        <code class="methodname">LockManager</code>
                        (
                        <span class="type">Uid</span>
                        <code class="varname">objUid</code>
                        ,
                        <span class="type">int</span>
                        <code class="varname">objectModel</code>
                        )
                    </span></dt><dd>
                        <p>
                            As above, this constructor allows access to an existing persistent object, whose internal
                            name is given by
                            the
                            <code class="varname">objUid</code>
                            parameter. Objects constructed using this operation will normally have their
                            prior state (identified by
                            <code class="varname">objUid</code>
                            ) loaded from an object store automatically by the
                            system. If the object model is
                            <code class="literal">SINGLE</code>
                            (the default behavior), then the object will not
                            be reactivated at the start of each top-level transaction.
                        </p>
                    </dd></dl></div>
            <p>
                The finalizer of a programmer-defined class must invoke the inherited operation
                <code class="methodname">terminate</code>
                to inform the state management mechanism that the object is about to be
                destroyed. Otherwise, unpredictable results may occur.
            </p>
        </div>
    </div>
</div>
    <div class="section" title="1.3. Advanced transaction issues with ArjunaCore"><div class="titlepage"><div><div><h2 class="title"><a id="d5e855"/>1.3. Advanced transaction issues with ArjunaCore</h2></div></div></div>
    
    <p>
        Atomic actions (transactions) can be used by both application programmers and class developers. Thus entire
        operations (or parts of operations) can be made atomic as required by the semantics of a particular operation. This
        chapter will describe some of the more subtle issues involved with using transactions in general and ArjunaCore in
        particular.

    </p>

    <div class="section" title="1.3.1. Last resource commit optimization (LRCO)"><div class="titlepage"><div><div><h3 class="title"><a id="d5e858"/>1.3.1. Last resource commit optimization (LRCO)</h3></div></div></div>
        
        <p>
            In some cases it may be necessary to enlist participants that are not two-phase commit aware into a
            two-phase
            commit transaction. If there is only a single resource then there is no need for two-phase commit. However, if
            there are multiple resources in the transaction, the
            <em class="firstterm">Last Resource Commit Optimization
                (LRCO)
            </em>
            comes into play. It is possible for a single resource that is one-phase aware (i.e., can only
            commit or roll back, with no prepare), to be enlisted in a transaction with two-phase commit aware resources.
            This feature is implemented by logging the decision to commit after committing the one-phase aware participant: The
            coordinator asks each two-phase aware participant if they are able to prepare and if they all vote yes then
            the one-phase aware participant is asked to commit. If the one-phase aware participant commits successfully
            then the decision to commit is logged and then commit is called on each two-phase aware participant. A
            heuristic outcome will occur if the coordinator fails before logging its commit decision but after the
            one-phase participant has committed since each two-phase aware participant will eventually rollback (as
            required under
            <em class="firstterm">presumed abort</em>
            semantics).
            This strategy delays the logging of the decision to commit so that in failure scenarios we have avoided a write
            operation. But this choice does mean that there is no record in the system of the fact that a heuristic
            outcome has occurred.
        </p>
        <p>
            In order to utilize the LRCO, your participant must implement the
            <code class="interfacename">com.arjuna.ats.arjuna.coordinator.OnePhase</code>
            interface and be registered with the
            transaction through the
            <code class="methodname">BasicAction.add</code>
            operation. Since this operation expects instances
            of
            <code class="classname">AbstractRecord</code>
            , you must create an instance of
            <code class="classname">com.arjuna.ats.arjuna.LastResourceRecord</code>
            and give your participant as the constructor
            parameter.
        </p>
        <div class="example"><a id="d5e868"/><p class="title"><strong>Example 1.17. 
                Class
                <code class="classname">com.arjuna.ats.arjuna.LastResourceRecord</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">try
    {
        boolean success = false;
        AtomicAction A = new AtomicAction();
        OnePhase opRes = new OnePhase();  // used OnePhase interface
       
        System.out.println("Starting top-level action.");

        A.begin();
        A.add(new LastResourceRecord(opRes));
        A.add( "other participants" );
       
        A.commit();
    }
</code></pre>
        </div></div><br class="example-break"/>
    </div>

    <div class="section" title="1.3.2. Heuristic outcomes"><div class="titlepage"><div><div><h3 class="title"><a id="d5e872"/>1.3.2. Heuristic outcomes</h3></div></div></div>
        
        <p>
	  In some situations the application thread may not want to be informed of heuristics during completion.
	  However, it is possible some other component in the application, thread or admin may still want to be informed.
	  Therefore, special participants can be registered with the transaction which are
	  triggered during the Synchronization phase and given the true outcome of
	  the transaction. We do not dictate a specific implementation for what these
	  participants do with the information (e.g., OTS allows for the CORBA Notification Service
	  to be used).
        </p>
        <p>
            To use this capability, create classes derived from the HeuristicNotification class and define the heuristicOutcome
	    method to use whatever mechanism makes sense for your application. Instances of this class should be registered with
	    the tranasction as Synchronizations.
        </p>
    </div>

    <div class="section" title="1.3.3. Nested transactions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e876"/>1.3.3. Nested transactions</h3></div></div></div>
        
        <p>
            There are no special constructs for nesting of transactions. If an action is begun while another action is running
            then it is automatically nested. This allows for a modular structure to applications, whereby objects can be
            implemented using atomic actions within their operations without the application programmer having to worry about
            the applications which use them, and whether or not the applications will use atomic actions as well. Thus, in
            some applications actions may be top-level, whereas in others they may be nested. Objects written in this way can
            then be shared between application programmers, and ArjunaCore will guarantee their consistency.
        </p>
        <p>
            If a nested action is aborted, all of its work will be undone, although strict two-phase locking means that
            any locks it may have obtained will be retained until the top-level action commits or aborts. If a nested action
            commits then the work it has performed will only be committed by the system if the top-level action commits. If
            the top-level action aborts then all of the work will be undone.
        </p>
        <p>
            The committing or aborting of a nested action does not automatically affect the outcome of the action within which
            it is nested. This is application dependent, and allows a programmer to structure atomic actions to contain
            faults, undo work, etc.
        </p>
    </div>

    <div class="section" title="1.3.4. Asynchronously committing a transaction"><div class="titlepage"><div><div><h3 class="title"><a id="d5e881"/>1.3.4. Asynchronously committing a transaction</h3></div></div></div>
        
        <p>
            By default, the Transaction Service executes the
            <code class="methodname">commit</code>
            protocol of a top-level
            transaction in a synchronous manner. All registered resources will be told to prepare in order by a single thread,
            and then they will be told to commit or rollback. A similar comment
            applies to the volatile phase of the protocol which provides a
            synchronization mechanism that allows an interested party to be notified
            before and after the transaction completes. This has several possible
            disadvantages:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    In the case of many registered synchronizations, the
                    <code class="methodname">beforeSynchronization</code>
                    operation can
                    logically be invoked in parallel on each non interposed
                    synchronization (and similary for the interposed synchronizations).
                    The disadvantage is that if an “early” synchronization in the list of
                    registered resource forces a rollback by throwing an unchecked
                    exception, possibly many beforeCompletion operations will have been
                    made needlessly.
                </p>
            </li><li class="listitem">
                <p>
                    In the case of many registered resources, the
                    <code class="methodname">prepare</code>
                    operation can logically be
                    invoked in parallel on each resource. The disadvantage is that if an “early” resource in the list of
                    registered resource forces a rollback during
                    <code class="methodname">prepare</code>
                    , possibly many prepare
                    operations will have been made needlessly.
                </p>
            </li><li class="listitem">
                <p>
                    In the case where heuristic reporting is not required by the
                    application, the second phase of the commit protocol (including any
                    afterCompletion synchronizations) can be done asynchronously, since
                    its success or failure is not important to the outcome of the
                    transaction.
                </p>
            </li></ul></div>
        <p>
            Therefore, Narayana
            provides runtime options to enable possible threading optimizations. By setting the
            <code class="varname">CoordinatorEnvironmentBean.asyncBeforeSynchronization</code>
            environment variable to
            <code class="literal">YES</code>
            , during the
            <code class="methodname">beforeSynchronization</code>
            phase a separate thread
            will be created for each synchronization registered with the transaction.
            By setting the
            <code class="varname">CoordinatorEnvironmentBean.asyncPrepare</code>
            environment variable to
            <code class="literal">YES</code>
            , during the
            <code class="methodname">prepare</code>
            phase a separate thread will be created for
            each registered participant within the transaction. By setting
            <code class="varname">CoordinatorEnvironmentBean.asyncCommit</code>
            to
            <code class="literal">YES</code>
            , a separate thread will be
            created to complete the second phase of the transaction provided knowledge about heuristics outcomes is not required.
            By setting the
            <code class="varname">CoordinatorEnvironmentBean.asyncAfterSynchronization</code>
            environment variable to
            <code class="literal">YES</code>
            , during the
            <code class="methodname">afterSynchronization</code>
            phase a separate thread
            will be created for each synchronization registered with the transaction
            provided knowledge about heuristics outcomes is not required.
        </p>
    </div>

    <div class="section" title="1.3.5. Independent top-level transactions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e907"/>1.3.5. Independent top-level transactions</h3></div></div></div>
        
        <p>
            In addition to normal top-level and nested atomic actions, ArjunaCore also supports independent top-level actions,
            which can be used to relax strict serializability in a controlled manner. An independent top-level action can be
            executed from anywhere within another atomic action and behaves exactly like a normal top-level action. Its
            results are made permanent when it commits and will not be undone if any of the actions within which it was
            originally nested abort.
        </p>
        <div class="figure"><a id="d5e910"/><p class="title"><strong>Figure 1.5. Independent Top-Level Action</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/independent_top_level_action.png" alt="Independent Top-Level Action" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e912.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e912.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <p>
            Top-level actions can be used within an application by declaring and using instances of the class
            <code class="classname">TopLevelTransaction</code>
            . They are used in exactly the same way as other transactions.
        </p>
    </div>

    <div class="section" title="1.3.6.  Transactions within save_state and restore_state methods"><div class="titlepage"><div><div><h3 class="title"><a id="d5e919"/>1.3.6. 
            Transactions within
            <code class="methodname">save_state</code>
            and
            <code class="methodname">restore_state</code>
            methods
        </h3></div></div></div>
        
        <p>
            Exercise caution when writing the
            <code class="methodname">save_state</code>
            and
            <code class="methodname">restore_state</code>
            operations to ensure that no atomic actions are started, either explicitly in the operation or implicitly
            through
            use of some other operation. This restriction arises due to the fact that ArjunaCore may invoke
            <code class="methodname">restore_state</code>
            as part of its commit processing resulting in the attempt to execute an
            atomic action during the commit or abort phase of another action. This might violate the atomicity properties of
            the action being committed or aborted and is thus discouraged.
        </p>

        <div class="example"><a id="d5e927"/><p class="title"><strong>Example 1.18. </strong></p><div class="example-contents">
            
            <p>
                If we consider the
                <a class="xref" href="#array-example" title="Example 1.12.  Array Class">Example 1.12, “
                        <code class="classname">Array</code>
                        Class
                    ”</a>
                given previously, the
                <code class="methodname">set</code>
                and
                <code class="methodname">get</code>
                operations could be implemented as shown below.
            </p>
            <p>
                This is a simplification of the code, ignoring error conditions and exceptions.
            </p>

            <pre><code class="language-java">public boolean set (int index, int value)
{
   boolean result = false;
   AtomicAction A = new AtomicAction();

   A.begin();

   // We need to set a WRITE lock as we want to modify the state.

   if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
   {
      elements[index] = value;
      if ((value &gt; 0) &amp;&amp;(index &gt; highestIndex
         highestIndex = index;
      A.commit(true);
      result = true;
   }
   else
      A.rollback();

   return result;
}
</code></pre>
            <pre><code class="language-java">public int get (int index)  // assume -1 means error
{
   AtomicAction A = new AtomicAction();

   A.begin();

   // We only need a READ lock as the state is unchanged.

   if (setlock(new Lock(LockMode.READ), 0) == LockResult.GRANTED)
   {
      A.commit(true);

             return elements[index];
   }
   else
      A.rollback();

   return -1;
}
</code></pre>
        </div></div><br class="example-break"/>
    </div>

    <div class="section" title="1.3.7. Garbage collecting objects"><div class="titlepage"><div><div><h3 class="title"><a id="d5e936"/>1.3.7. Garbage collecting objects</h3></div></div></div>
        
        <p>
            Java objects are deleted when the garbage collector determines that they are no longer required. Deleting an
            object that is currently under the control of a transaction must be approached with caution since if the object is
            being manipulated within a transaction its fate is effectively determined by the transaction. Therefore,
            regardless of the references to a transactional object maintained by an application, ArjunaCore will always retain its
            own references to ensure that the object is not garbage collected until after any transaction has terminated.
        </p>
    </div>

    <div class="section" title="1.3.8. Transaction timeouts"><div class="titlepage"><div><div><h3 class="title"><a id="d5e939"/>1.3.8. Transaction timeouts</h3></div></div></div>
        
        <p>
            By default, transactions live until they are terminated by the application that created them or a failure
            occurs. However, it is possible to set a timeout (in seconds) on a per-transaction basis such that if the
            transaction has not terminated before the timeout expires it will be automatically rolled back.
        </p>
        <p>
            In ArjunaCore, the timeout value is provided as a parameter to the
            <code class="methodname">AtomicAction</code>
            constructor. If a value of
            <code class="literal">AtomicAction.NO_TIMEOUT</code>
            is provided (the default) then the
            transaction will not be automatically timed out. Any other positive value is assumed to be the timeout for the
            transaction (in seconds). A value of zero is taken to be a global default timeout, which can be provided by the
            property
            <code class="varname">CoordinatorEnvironmentBean.defaultTimeout</code>
            , which has a default value of 60 seconds.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                Default timeout values for other Narayana
                components, such as JTS, may be different and you should consult the
                relevant documentation to be sure.
            </p>
        </div>
        <p>
            When a top-level transaction is created with a non-zero timeout, it is subject to being rolled back if it
            has not
            completed within the specified number of seconds. Narayana
            uses a separate reaper thread which
            monitors all locally created transactions, and forces them to roll back if their timeouts elapse. If the
            transaction cannot be rolled back at that point, the reaper will force it into a rollback-only state so that it
            will eventually be rolled back.
        </p>
        <p>
            By default this thread is dynamically scheduled to awake according to the timeout values for any
            transactions
            created, ensuring the most timely termination of transactions. It may alternatively be configured to awake at a
            fixed interval, which can reduce overhead at the cost of less accurate rollback timing. For periodic operation,
            change the
            <code class="varname">CoordinatorEnvironmentBean.txReaperMode</code>
            property from its default value of
            <code class="literal">DYNAMIC</code>
            to
            <code class="literal">PERIODIC</code>
            and set the interval between runs, in milliseconds,
            using the property
            <code class="varname">CoordinatorEnvironmentBean.txReaperTimeout</code>
            . The default interval in
            <code class="literal">PERIODIC</code>
            mode is 120000 milliseconds.
        </p>
        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
            <p>
                In earlier versions the
                <code class="literal">PERIODIC</code>
                mode was known as
                <code class="literal">NORMAL</code>
                and was the
                default behavior. The use of the configuration value
                <code class="literal">NORMAL</code>
                is deprecated and
                <code class="literal">PERIODIC</code>
                should be used instead if the old scheduling behavior is still required.
            </p>
        </div>
        <p>
            If a value of
            <code class="literal">0</code>
            is specified for the timeout of a top-level transaction, or no timeout is
            specified, then Narayana
            will not impose any timeout on the transaction, and the transaction will
            be allowed to run indefinitely. This default timeout can be overridden by setting the
            <code class="varname">CoordinatorEnvironmentBean.defaultTimeout</code>
            property variable when using to the required timeout
            value in seconds, when using ArjunaCore, ArjunaJTA or ArjunaJTS.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                As of JBoss Transaction Service 4.5, transaction timeouts have been unified across all transaction components
                and are controlled by ArjunaCore.
            </p>
        </div>
        <div class="section" title="1.3.8.1. Monitoring transaction timeouts"><div class="titlepage"><div><div><h4 class="title"><a id="d5e966"/>1.3.8.1. Monitoring transaction timeouts</h4></div></div></div>
            
            <p>
                If you want to be informed when a transaction is rolled back or forced into a rollback-only mode by the
                reaper,
                you can create a class that inherits from class
                <code class="classname">com.arjuna.ats.arjuna.coordinator.listener.ReaperMonitor</code>
                and overrides the
                <code class="methodname">rolledBack</code>
                and
                <code class="methodname">markedRollbackOnly</code>
                methods. When registered
                with the reaper via the
                <code class="methodname">TransactionReaper.addListener</code>
                method, the reaper will invoke
                one of these methods depending upon how it tries to terminate the transaction.
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    The reaper will not inform you if the transaction is terminated (committed or rolled back) outside of its
                    control, such as by the application.
                </p>
            </div>
        </div>
    </div>
</div>
    <div class="section" title="1.4. Hints and tips"><div class="titlepage"><div><div><h2 class="title"><a id="d5e975"/>1.4. Hints and tips</h2></div></div></div>
    
    <div class="section" title="1.4.1. General"><div class="titlepage"><div><div><h3 class="title"><a id="d5e977"/>1.4.1. General</h3></div></div></div>
        

        <div class="section" title="1.4.1.1. Using transactions in constructors"><div class="titlepage"><div><div><h4 class="title"><a id="d5e979"/>1.4.1.1. Using transactions in constructors</h4></div></div></div>
            
            <p>
                Examples throughout this manual use transactions in the implementation of constructors for new persistent
                objects. This is deliberate because it guarantees correct propagation of the state of the object to the object
                store. The state of a modified persistent object is only written to the object store when the top-level
                transaction commits. Thus, if the constructor transaction is top-level and it commits, the newly-created object
                is written to the store and becomes available immediately. If, however, the constructor transaction commits but
                is nested because another transaction that was started prior to object creation is running, the state is written
                only if all of the parent transactions commit.
            </p>
            <p>
                On the other hand, if the constructor does not use transactions, inconsistencies in the system can arise. For
                example, if no transaction is active when the object is created, its state is not saved to the store until the
                next time the object is modified under the control of some transaction.
            </p>
            <div class="example"><a id="d5e983"/><p class="title"><strong>Example 1.19. Nested Transactions In Constructors</strong></p><div class="example-contents">
                
                <pre><code class="language-java">AtomicAction A = new AtomicAction();
Object obj1;
Object obj2;

obj1 = new Object();       // create new object
obj2 = new Object("old");     // existing object

A.begin(0);
obj2.remember(obj1.get_uid());   // obj2 now contains reference to obj1
A.commit(true);            // obj2 saved but obj1 is not
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                The two objects are created outside of the control of the top-level action
                <code class="systemitem">A</code>
                .
                <code class="systemitem">obj1</code>
                is a new object.
                <code class="systemitem">obj2</code>
                is an
                old existing object. When the
                <code class="methodname">remember</code>
                operation of
                <code class="systemitem">obj2</code>
                is
                invoked, the object will be activated and the
                <span class="type">Uid</span>
                of
                <code class="systemitem">obj1</code>
                remembered. Since this action commits, the persistent state of
                <code class="systemitem">obj2</code>
                may now contain the
                <span class="type">Uid</span>
                of
                <code class="systemitem">obj1</code>
                . However, the state of
                <code class="systemitem">obj1</code>
                itself
                has not been saved since it has not been manipulated under the control of any action. In fact, unless it is
                modified under the control of an action later in the application, it will never be saved. If, however, the
                constructor had used an atomic action, the state of
                <code class="systemitem">obj1</code>
                would have automatically been
                saved at the time it was constructed and this inconsistency could not arise.
            </p>
        </div>

        <div class="section" title="1.4.1.2.  save_state and restore_state methods"><div class="titlepage"><div><div><h4 class="title"><a id="d5e999"/>1.4.1.2. 
                <code class="methodname">save_state</code>
                and
                <code class="methodname">restore_state</code>
                methods
            </h4></div></div></div>
            
            <p>
                ArjunaCore may invoke the user-defined
                <code class="methodname">save_state</code>
                operation of an object at any time during
                the lifetime of an object, including during the execution of the body of the object’s constructor. This is
                particularly a possibility if it uses atomic actions. It is important, therefore, that all of the variables
                saved by
                <code class="methodname">save_state</code>
                are correctly initialized. Exercise caution when writing the
                <code class="methodname">save_state</code>
                and
                <code class="methodname">restore_state</code>
                operations, to ensure that no
                transactions are started, either explicitly in the operation, or implicitly through use of some other
                operation. The reason for this restriction is that ArjunaCore may invoke
                <code class="methodname">restore_state</code>
                as
                part of its commit processing. This would result in the attempt to execute an atomic transaction during the
                commit or abort phase of another transaction. This might violate the atomicity properties of the transaction
                being committed or aborted, and is thus discouraged. In order to support crash recovery for persistent objects,
                all
                <code class="methodname">save_state</code>
                and
                <code class="methodname">restore_state</code>
                methods of user objects must
                call
                <code class="methodname">super.save_state</code>
                and
                <code class="methodname">super.restore_state</code>
                .
            </p>

            <div class="section" title="1.4.1.2.1. Packing objects"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1013"/>1.4.1.2.1. Packing objects</h5></div></div></div>
                
                <p>
                    All of the basic types of Java (
                    <span class="type">int</span>
                    ,
                    <span class="type">long</span>
                    , etc.) can be saved and restored from an
                    <code class="classname">InputObjectState</code>
                    or
                    <code class="classname">OutputObjectState</code>
                    instance by using the
                    <code class="methodname">pack</code>
                    and
                    <code class="methodname">unpack</code>
                    routines provided by
                    <code class="classname">InputObjectState</code>
                    and
                    <code class="classname">OutputObjectState</code>
                    . However packing and
                    unpacking objects should be handled differently. This is because packing objects brings in the additional
                    problems of aliasing. Aliasing happens when two different object references may point at the same item. For
                    example:
                </p>
                <div class="example"><a id="d5e1024"/><p class="title"><strong>Example 1.20. Aliasing</strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">public class Test
{
    public  Test (String s);
    ...
        private String s1;
    private String s2;
};

public Test (String s)
{
    s1 = s;
    s2 = s;
}
</code></pre>
                </div></div><br class="example-break"/>
                <p>
                    Here, both
                    <code class="varname">s1</code>
                    and
                    <code class="varname">s2</code>
                    point at the same string. A naive implementation of
                    <code class="methodname">save_state</code>
                    might copy the string twice. From a
                    <code class="methodname">save_state</code>
                    perspective this is simply inefficient. However,
                    <code class="methodname">restore_state</code>
                    would unpack the two
                    strings into different areas of memory, destroying the original aliasing information. The current version of
                    ArjunaCore packs and unpacks separate object references.
                </p>
            </div>
        </div>
    </div>

    <div class="section" title="1.4.2. Direct use of StateManager"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1033"/>1.4.2. Direct use of StateManager</h3></div></div></div>
        
        <p>
            The examples throughout this manual derive user classes from
            <code class="classname">LockManager</code>
            . These are two
            important reasons for this.
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>
                    Firstly, and most importantly, the serializability constraints of atomic actions require it.
                </p>
            </li><li class="listitem">
                <p>
                    It reduces the need for programmer intervention.
                </p>
            </li></ol></div>
        <p>
            However, if you only require access to ArjunaCore's persistence and recovery mechanisms, direct derivation of a
            user
            class from
            <code class="classname">StateManager</code>
            is possible.
        </p>
        <p>
            Classes derived directly from
            <code class="classname">StateManager</code>
            must make use of its state management mechanisms
            explicitly. These interactions are normally undertaken by
            <code class="classname">LockManager</code>
            . From a programmer's
            point of view this amounts to making appropriate use of the operations
            <code class="methodname">activate</code>
            ,
            <code class="methodname">deactivate</code>
            , and
            <code class="methodname">modified</code>
            , since
            <code class="classname">StateManager</code>
            's constructors are effectively identical to those of
            <code class="classname">LockManager</code>
            .
        </p>
        <div class="example"><a id="d5e1052"/><p class="title"><strong>Example 1.21. 
                <code class="methodname">activate</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">boolean activate ()
boolean activate (String storeRoot)
</code></pre>
            <p>
                Activate loads an object from the object store. The object’s UID must already have been set via the constructor
                and the object must exist in the store. If the object is successfully read then restore_state is called to build
                the object in memory. Activate is idempotent so that once an object has been activated further calls are
                ignored. The parameter represents the root name of the object store to search for the object. A value of null
                means use the default store.
            </p>
        </div></div><br class="example-break"/>
        <div class="example"><a id="d5e1057"/><p class="title"><strong>Example 1.22. 
                <code class="methodname">deactivate</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">boolean deactivate ()
boolean deactivate (String storeRoot)
</code></pre>
            <p>
                The inverse of activate. First calls save_state to build the compacted image of the object which is then saved
                in the object store. Objects are only saved if they have been modified since they were activated. The parameter
                represents the root name of the object store into which the object should be saved. A value of null
                means use
                the default store.
            </p>
        </div></div><br class="example-break"/>
        <div class="example"><a id="d5e1062"/><p class="title"><strong>Example 1.23. 
                <code class="methodname">modified</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">void modified ()
</code></pre>
            <p>
                Must be called prior to modifying the object in memory. If it is not called, the object will not be
                saved in the
                object store by
                <code class="methodname">deactivate</code>
                .
            </p>
        </div></div><br class="example-break"/>
    </div>
</div>
    <div class="section" title="1.5. Constructing a Transactional Objects for Java application"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1068"/>1.5. Constructing a Transactional Objects for Java application</h2></div></div></div>
    
    <div class="orderedlist" title="Development Phases of a ArjunaCore Application"><p class="title"><strong>Development Phases of a ArjunaCore Application</strong></p><ol class="orderedlist" type="1"><li class="listitem">
            <p>
                First, develop new classes with characteristics like persistence, recoverability, and concurrency control.
            </p>
        </li><li class="listitem">
            <p>
                Then develop the applications that make use of the new classes of objects.
            </p>
        </li></ol></div>
    <p>
        Although these two phases may be performed in parallel and by a single person, this guide refers to the first
        step
        as the job of the class developer, and the second as the job of the applications developer.
        The
        class developer defines appropriate
        <code class="methodname">save_state</code>
        and
        <code class="methodname">restore_state</code>
        operations for the class, sets appropriate locks in operations, and invokes the appropriate ArjunaCore class
        constructors. The applications developer defines the general structure of the application, particularly with
        regard
        to the use of atomic actions.
    </p>
    <p>
        This chapter outlines a simple application, a simple FIFO Queue class for integer values. The Queue is implemented
        with a doubly linked list structure, and is implemented as a single object. This example is used throughout the rest
        of this manual to illustrate the various mechanisms provided by ArjunaCore. Although this is an unrealistic example
        application, it illustrates all of the ArjunaCore modifications without requiring in depth knowledge of the
        application
        code.
    </p>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            The application is assumed not to be distributed. To allow for distribution, context information must be
            propagated either implicitly or explicitly.
        </p>
    </div>


    <div class="section" title="1.5.1. Queue description"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1082"/>1.5.1. Queue description</h3></div></div></div>
        
        <p>
            The queue is a traditional FIFO queue, where elements are added to the front and removed from the back. The
            operations provided by the queue class allow the values to be placed on to the queue (
            <code class="methodname">enqueue</code>
            ) and to be removed
            from it (
            <code class="methodname">dequeue</code>
            ), and values of elements in the queue can also be changed or inspected. In this
            example implementation, an array represents the queue. A limit of
            <code class="varname">QUEUE_SIZE</code>
            elements has been imposed
            for this example.
        </p>
        <div class="example"><a id="d5e1088"/><p class="title"><strong>Example 1.24. 
                Java interface definition of class
                <code class="classname">queue</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">public class TransactionalQueue extends LockManager
{
    public TransactionalQueue (Uid uid);
    public TransactionalQueue ();
    public void finalize ();

    public void enqueue (int v) throws OverFlow, UnderFlow,
                                       QueueError, Conflict;
    public int dequeue  () throws OverFlow, UnderFlow,
                                  QueueError, Conflict;

    public int queueSize ();
    public int inspectValue (int i) throws OverFlow,
                                           UnderFlow, QueueError, Conflict;
    public void setValue (int i, int v) throws OverFlow,
                                               UnderFlow, QueueError, Conflict;

    public boolean save_state (OutputObjectState os, int ObjectType);
    public boolean restore_state (InputObjectState os, int ObjectType);
    public String type ();

    public static final int QUEUE_SIZE = 40; // maximum size of the queue

    private int[QUEUE_SIZE] elements;
    private int numberOfElements;
};
</code></pre>
        </div></div><br class="example-break"/>

    </div>

    <div class="section" title="1.5.2. Constructors and finalizers"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1092"/>1.5.2. Constructors and finalizers</h3></div></div></div>
        
        <p>
            Using an existing persistent object requires the use of a special constructor
            that takes the Uid of the persistent object, as shown in
            <a class="xref" href="#example-TransactionalQueue" title="Example 1.25.  Class TransactionalQueue">Example 1.25, “
                Class
                <code class="classname">TransactionalQueue</code>
            ”</a>
            .
        </p>
        <div class="example"><a id="example-TransactionalQueue"/><p class="title"><strong>Example 1.25. 
                Class
                <code class="classname">TransactionalQueue</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java"> public TransactionalQueue (Uid u)
{
    super(u);

    numberOfElements = 0;
}
The constructor that creates a new persistent object is similar:
    public TransactionalQueue ()
{
    super(ObjectType.ANDPERSISTENT);

    numberOfElements = 0;

    try
        {
            AtomicAction A = new AtomicAction();

            A.begin(0); // Try to start atomic action

            // Try to set lock

            if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
                {
                    A.commit(true); // Commit
                }
            else           // Lock refused so abort the atomic action
                A.rollback();
        }
    catch (Exception e)
        {
            System.err.println(“Object construction error: “+e);
            System.exit(1);
        }
}
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            The use of an atomic action within the constructor for a new object follows the guidelines outlined earlier and
            ensures that the object’s state will be written to the object store when the appropriate top level atomic action
            commits (which will either be the action A or some enclosing action active when the TransactionalQueue was
            constructed). The use of atomic actions in a constructor is simple: an action must first be declared and its begin
            operation invoked; the operation must then set an appropriate lock on the object (in this case a WRITE lock must
            be acquired), then the main body of the constructor is executed. If this is successful the atomic action can be
            committed, otherwise it is aborted.
        </p>
        <p>
            The finalizer of the
            <code class="classname">queue</code>
            class is only required to call the
            <code class="methodname">terminate</code>
            and
            <code class="methodname">finalizer</code>
            operations of
            <code class="classname">LockManager</code>
            .
        </p>
        <pre><code class="language-java">public void finalize ()
{
    super.terminate();
    super.finalize();
}     
</code></pre>

    </div>

    <div class="section" title="1.5.3. Required methods"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1107"/>1.5.3. Required methods</h3></div></div></div>
        
        <div class="section" title="1.5.3.1.  save_state , restore_state , and type"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1109"/>1.5.3.1. 
                <code class="methodname">save_state</code>
                ,
                <code class="methodname">restore_state</code>
                , and
                <code class="methodname">type</code>
            </h4></div></div></div>
            
            <div class="example"><a id="d5e1114"/><p class="title"><strong>Example 1.26. 
                    Method
                    <code class="methodname">save_state</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">public boolean save_state (OutputObjectState os, int ObjectType)
{
    if (!super.save_state(os, ObjectType))
        return false;

    try
        {
            os.packInt(numberOfElements);

            if (numberOfElements &gt; 0)
                {
                    for (int i = 0; i &lt; numberOfElements; i++)
                        os.packInt(elements[i]);
                }

            return true;
        }
    catch (IOException e)
        {
            return false;
        }
}
</code></pre>
            </div></div><br class="example-break"/>

            <div class="example"><a id="d5e1118"/><p class="title"><strong>Example 1.27. 
                    Method
                    <code class="methodname">restore_state</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">public boolean restore_state (InputObjectState os, int ObjectType)
{
    if (!super.restore_state(os, ObjectType))
        return false;

    try
        {
            numberOfElements = os.unpackInt();

            if (numberOfElements &gt; 0)
                {
                    for (int i = 0; i &lt; numberOfElements; i++)
                        elements[i] = os.unpackInt();
                }

            return true;
        }
    catch (IOException e)
        {
            return false;
        }
}
</code></pre>
            </div></div><br class="example-break"/>
            <div class="example"><a id="d5e1122"/><p class="title"><strong>Example 1.28. 
                    Method
                    <code class="methodname">type</code>
                </strong></p><div class="example-contents">
                
                <p>
                    Because the Queue class is derived from the LockManager class, the operation type should be:
                </p>
                <pre><code class="language-java">public String type ()
{
    return "/StateManager/LockManager/TransactionalQueue";
}       
</code></pre>
            </div></div><br class="example-break"/>
        </div>

        <div class="section" title="1.5.3.2.  enqueue and dequeue methods"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1127"/>1.5.3.2. 
                <code class="methodname">enqueue</code>
                and
                <code class="methodname">dequeue</code>
                methods
            </h4></div></div></div>
            
            <p>
                If the operations of the
                <code class="classname">queue</code>
                class are to be coded as atomic actions, then the enqueue
                operation might have the structure given below. The
                <code class="methodname">dequeue</code>
                operation is similarly
                structured, but is not implemented here.
            </p>
            <div class="example"><a id="d5e1134"/><p class="title"><strong>Example 1.29. 
                    Method
                    <code class="methodname">enqueue</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">public void enqueue (int v) throws OverFlow, UnderFlow, QueueError
{
    AtomicAction A = new AtomicAction();
    boolean res = false;

    try
        {
            A.begin(0);

            if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
                {
                    if (numberOfElements &lt; QUEUE_SIZE)
                        {
                            elements[numberOfElements] = v;
                            numberOfElements++;
                            res = true;
                        }
                    else
                        {
                            A.rollback();
                            throw new UnderFlow();
                        }
                }

            if (res)
                A.commit(true);
            else
                {
                    A.rollback();
                    throw new Conflict();
                }
        }
    catch (Exception e1)
        {
            throw new QueueError();
        }
}       
</code></pre>
            </div></div><br class="example-break"/>
        </div>


        <div class="section" title="1.5.3.3.  queueSize method"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1138"/>1.5.3.3. 
                <code class="methodname">queueSize</code>
                method
            </h4></div></div></div>
            
            <div class="example"><a id="d5e1141"/><p class="title"><strong>Example 1.30. 
                    Method
                    <code class="methodname">queueSize</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">public int queueSize () throws QueueError, Conflict
{
    AtomicAction A = new AtomicAction();
    int size = -1;

    try
        {
            A.begin(0);

            if (setlock(new Lock(LockMode.READ), 0) == LockResult.GRANTED)
                size = numberOfElements;
    
            if (size != -1)
                A.commit(true);
            else
                {
                    A.rollback();

                    throw new Conflict();
                }
        }
    catch (Exception e1)
        {
            throw new QueueError();
        }

    return size;
}       
</code></pre>
            </div></div><br class="example-break"/>
        </div>


        <div class="section" title="1.5.3.4.  inspectValue and setValue methods"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1145"/>1.5.3.4. 
                <code class="methodname">inspectValue</code>
                and
                <code class="methodname">setValue</code>
                methods
            </h4></div></div></div>
            
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    The
                    <code class="methodname">setValue</code>
                    method is not implemented here, but is similar in structure to
                    <a class="xref" href="#example_queue-inspectValue" title="Example 1.31.  Method inspectValue">Example 1.31, “
                    Method
                    <code class="methodname">inspectValue</code>
                ”</a>
                    .
                </p>
            </div>
            <div class="example"><a id="example_queue-inspectValue"/><p class="title"><strong>Example 1.31. 
                    Method
                    <code class="methodname">inspectValue</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">public int inspectValue (int index) throws UnderFlow,
                                           OverFlow, Conflict, QueueError
{
    AtomicAction A = new AtomicAction();
    boolean res = false;
    int val = -1;

    try
        {
            A.begin();

            if (setlock(new Lock(LockMode.READ), 0) == LockResult.GRANTED)
                {
                    if (index &lt; 0)
                        {
                            A.rollback();
                            throw new UnderFlow();
                        }
                    else
                        {
                            // array is 0 - numberOfElements -1

                            if (index &gt; numberOfElements -1)
                                {
                                    A.rollback();
                                    throw new OverFlow();
                                }
                            else
                                {
                                    val = elements[index];
                                    res = true;
                                }
                        }
                }

            if (res)
                A.commit(true);
            else
                {
                    A.rollback();
                    throw new Conflict();
                }
        }
    catch (Exception e1)
        {
            throw new QueueError();
        }

    return val;
}
</code></pre>
            </div></div><br class="example-break"/>
        </div>
    </div>


    <div class="section" title="1.5.4. The client"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1157"/>1.5.4. The client</h3></div></div></div>
        
        <p>
            Rather than show all of the code for the client, this example concentrates on a representative portion. Before
            invoking operations on the object, the client must first bind to the object. In the local case this simply
            requires the client to create an instance of the object.
        </p>
        <div class="example"><a id="d5e1160"/><p class="title"><strong>Example 1.32. Binding to the Object</strong></p><div class="example-contents">
            
            <pre><code class="language-java"> public static void main (String[] args)
{
    TransactionalQueue myQueue = new TransactionalQueue();
    Before invoking one of the queue’s operations, the client starts a transaction. The queueSize operation is shown below:
    AtomicAction A = new AtomicAction();
    int size = 0;
 
    try
        {
            A.begin(0);

            try
                {
                    size = queue.queueSize();
                }
            catch (Exception e)
                {
                }

            if (size &gt;= 0)
                {
                    A.commit(true);

                    System.out.println(“Size of queue: “+size);
                }
            else
                A.rollback();
        }
    catch (Exception e)
        {
            System.err.println(“Caught unexpected exception!”);
        }
}
</code></pre>
        </div></div><br class="example-break"/>

    </div>


    <div class="section" title="1.5.5. Comments"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1163"/>1.5.5. Comments</h3></div></div></div>
        
        <p>
            Since the
            <code class="systemitem">queue</code>
            object is persistent, the state of the object survives any failures of
            the node on which it is located. The state of the object that survives is the state produced by the last top-level
            committed atomic action performed on the object. If an application intends to perform two
            <code class="methodname">enqueue</code>
            operations atomically, for example, you can nest the
            <code class="methodname">enqueue</code>
            operations in another enclosing atomic action. In addition, concurrent operations
            on such a persistent object are serialized, preventing inconsistencies in the state of the object.
        </p>
        <p>
            However, since the elements of the
            <code class="systemitem">queue</code>
            objects are not individually concurrency
            controlled, certain combinations of concurrent operation invocations are executed serially, even though logically
            they could be executed concurrently. An example of this is modifying the states of two different elements in the
            queue. The platform Development Guide addresses some of these issues.
        </p>

    </div>

</div>
    <div class="section" title="1.6. Failure Recovery"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1171"/>1.6. Failure Recovery</h2></div></div></div>
    
    <p>In
        this chapter we shall cover information on failure recovery that is specific to ArjunaCore, TXOJ or using Narayana
        outside the scope of a
        supported application server.
    </p>
    <div class="section" title="1.6.1. Embedding the Recovery Manager"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1174"/>1.6.1. Embedding the Recovery Manager</h3></div></div></div>
        
        <p>In some situations it may be required to embed the RecoveryManager in the same process as the transaction
            service. In this case you can
            create an instance of the RecoveryManager through the manager method on com.arjuna.ats.arjuna.recovery.RecoveryManager. A
            RecoveryManager can
            be created in one of two modes, selected via the parameter to the manager method:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>i. INDIRECT_MANAGEMENT: the manager runs periodically but can also be instructed to run when
                    desired via the scan operation or through
                    the RecoveryDriver class to be described below.
                </p>
            </li><li class="listitem">
                <p>ii. DIRECT_MANAGEMENT: the manager does not run periodically and must be driven directly via the
                    scan operation or RecoveryDriver.
                </p>
            </li></ul></div>
        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
            <p>By default, the recovery manager listens on the first available port on a given machine. If you wish
                to control the port number that it
                uses, you can specify this using the com.arjuna.ats.arjuna.recovery.recoveryPort attribute.
            </p>
        </div>
        <div class="section" title="1.6.1.1. Additional Recovery Module Classes"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1184"/>1.6.1.1. Additional Recovery Module Classes</h4></div></div></div>
            
            <p>Narayana
                provides a set of recovery modules that are responsible to manage recovery according to the nature of
                the participant and its
                position in a transactional tree. The provided classes over and above the ones covered elsewhere (that all implements the
                RecoveryModule
                interface) are:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>com.arjuna.ats.internal.txoj.recovery.TORecoveryModule </p>
                    <p>Recovers Transactional Objects for Java.</p>
                </li></ul></div>
        </div>
    </div>
    <div class="section" title="1.6.2. Understanding Recovery Modules"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1191"/>1.6.2. Understanding Recovery Modules</h3></div></div></div>
        
        <p>The
            failure recovery subsystem of Narayana
            will ensure that results of a transaction are applied consistently to all resources affected
            by
            the
            transaction, even if any of the application processes or the machine hosting them crash or lose network connectivity. In the case
            of
            machine
            (system) crash or network failure, the recovery will not take place until the system or network are restored, but the
            original
            application does
            not need to be restarted – recovery responsibility is delegated to the Recovery Manager process (see below). Recovery
            after
            failure requires that
            information about the transaction and the resources involved survives the failure and is accessible afterward: this
            information is held in the
            ActionStore, which is part of the ObjectStore.
        </p>
        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
            <p>If the ObjectStore is destroyed or modified, recovery may not be possible.</p>
        </div>
        <p>Until the recovery procedures are complete, resources affected by a transaction that was in progress at
            the time of the failure may be
            inaccessible. For database resources, this may be reported as tables or rows held by “in-doubt transactions”. For
            TransactionalObjects for
            Java
            resources, an attempt to activate the Transactional Object (as when trying to get a lock) will fail.
        </p>
        <div class="section" title="1.6.2.1. The Recovery Manager"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1197"/>1.6.2.1. The Recovery Manager</h4></div></div></div>
            
            <p>The
                failure recovery subsystem of Narayana
                requires that the stand-alone Recovery Manager process be running for each ObjectStore
                (typically one for each node on the network that is running Narayana
                applications). The RecoveryManager file is located in the package
                com.arjuna.ats.arjuna.recovery.RecoveryManager. To start the Recovery Manager issue the following
                command:
            </p>
            <p>
                </p><pre><code class="language-java">java com.arjuna.ats.arjuna.recovery.RecoveryManager</code></pre><p>
            </p>
            <p>If the -test flag is used with the Recovery Manager then it will display a “Ready” message when
                initialised, i.e.,</p>
            <p>
                </p><pre><code class="language-java">java com.arjuna.ats.arjuna.recovery.RecoveryManager -test</code></pre><p>
            </p>
        </div>
        <div class="section" title="1.6.2.2. Configuring the Recovery Manager"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1205"/>1.6.2.2. Configuring the Recovery Manager</h4></div></div></div>
            
            <p>The RecoveryManager reads the properties defined in the arjuna.properties file and then also reads the
                property file
                RecoveryManager.properties, from the same directory as it found the arjuna properties file. An entry for a property in the RecoveryManager
                properties file will override an entry for the same property in the main TransactionService properties
                file. Most of the entries are
                specific
                to the Recovery Manager.
            </p>
            <p>A default version of RecoveryManager.properties is supplied with the distribution – this can be used
                without modification, except
                possibly
                the debug tracing fields (see below, Output). The rest of this section discusses the issues relevant in setting the
                properties to
                other values
                (in the order of their appearance in the default version of the file).
            </p>
        </div>
        <div class="section" title="1.6.2.3. Periodic Recovery"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1209"/>1.6.2.3. Periodic Recovery</h4></div></div></div>
            
            <p>The RecoveryManager scans the ObjectStore and other locations of information, looking for transactions
                and resources that require, or
                may
                require recovery. The scans and recovery processing are performed by recovery modules, (instances of classes that implement
                the
                com.arjuna.ats.arjuna.recovery.RecoveryModule interface), each with responsibility for a particular category of transaction or resource.
                The
                set of recovery modules used are dynamically loaded, using properties found in the RecoveryManager property file.
            </p>
            <p>The interface has two methods: periodicWorkFirstPass and periodicWorkSecondPass. At an interval
                (defined by property
                com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod), the RecoveryManager will call the first pass method on each property, then wait
                for a
                brief period (defined by property com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod), then call the second pass of
                each module.
                Typically,
                in the first pass, the module scans (e.g. the relevant part of the ObjectStore) to find transactions or resources that
                are
                in-doubt (i.e. are
                part way through the commitment process). On the second pass, if any of the same items are still in-doubt, it is
                possible
                the original
                application process has crashed and the item is a candidate for recovery.
            </p>
            <p>An attempt, by the RecoveryManager, to recover a transaction that is still progressing in the original
                process(es) is likely to break
                the
                consistency. Accordingly, the recovery modules use a mechanism (implemented in the
                com.arjuna.ats.arjuna.recovery.TransactionStatusManager
                package) to check to see if the original process is still alive, and if the
                transaction is still in progress. The RecoveryManager only proceeds
                with recovery if the original process has gone, or, if still alive,
                the
                transaction is completed. (If a server process or machine crashes, but
                the transaction-initiating process survives, the transaction
                will
                complete, usually generating a warning. Recovery of such a transaction is the
                RecoveryManager’s responsibility).
            </p>
            <p>It is clearly important to set the interval periods appropriately. The total iteration time will be
                the sum of the
                periodicRecoveryPeriod,
                recoveryBackoffPeriod and the length of time it takes to scan the stores and to attempt recovery of any in-doubt
                transactions found, for all
                the recovery modules. The recovery attempt time may include connection timeouts while trying to communicate
                with
                processes or machines that have
                crashed or are inaccessible (which is why there are mechanisms in the recovery system to avoid trying
                to
                recover the same transaction for ever).
                The total iteration time will affect how long a resource will remain inaccessible after a
                failure –
                periodicRecoveryPeriod should be set
                accordingly (default is 120 seconds). The recoveryBackoffPeriod can be comparatively short
                (default is
                10 seconds) – its purpose is mainly to
                reduce the number of transactions that are candidates for recovery and which thus
                require a “call to
                the original process to see if they are
                still in progress
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>In
                    previous versions of Narayana
                    there was no contact mechanism, and the backoff period had to be long enough to avoid catching
                    transactions in flight at all. From 3.0, there is no such risk.
                </p>
            </div>
            <p>Two
                recovery modules (implementations of the com.arjuna.ats.arjuna.recovery.RecoveryModule interface) are
                supplied with Narayana,
                supporting various aspects of transaction recovery including JDBC recovery. It is possible for advanced
                users to create their own recovery
                modules and register them with the Recovery Manager. The recovery modules are registered with the RecoveryManager using
                RecoveryEnvironmentBean.recoveryExtensions. These will be invoked on each pass of the periodic recovery
                in the sort-order of the property
                names – it is thus possible to predict the ordering (but note that a failure in an application process might occur while
                a periodic
                recovery
                pass is in progress). The default Recovery Extension settings are:
            </p>
            <div class="example"><a id="d5e1218"/><p class="title"><strong>Example 1.33. Recovery Environment Bean XML</strong></p><div class="example-contents">
                
                <pre><code class="language-xml">&lt;entry key="RecoveryEnvironmentBean.recoveryExtensions"&gt;
  com.arjuna.ats.internal.arjuna.recovery.AtomicActionRecoveryModule
  com.arjuna.ats.internal.txoj.recovery.TORecoveryModule
&lt;/entry&gt;
</code></pre>
            </div></div><br class="example-break"/>
        </div>
        <div class="section" title="1.6.2.4. Expired entry removal"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1221"/>1.6.2.4. Expired entry removal</h4></div></div></div>
            
            <p>The operation of the recovery subsystem will cause some entries to be made in the ObjectStore that
                will not be removed in normal
                progress.
                The RecoveryManager has a facility for scanning for these and removing items that are very old. Scans and removals are
                performed
                by
                implementations of the com.arjuna.ats.arjuna.recovery.ExpiryScanner interface. Implementations of this interface are loaded by
                giving
                the
                class
                names as the value of a property RecoveryEnvironmentBean.expiryScanners. The RecoveryManager calls the scan() method on
                each
                loaded
                Expiry
                Scanner implementation at an interval determined by the property RecoveryEnvironmentBean.expiryScanInterval”. This value is
                given in
                hours –
                default is 12. An expiryScanInterval value of zero will suppress any expiry scanning. If the value as supplied is
                positive, the first
                scan is
                performed when RecoveryManager starts; if the value is negative, the first scan is delayed until after the
                first interval (using the
                absolute
                value)
            </p>
            <p>The kinds of item that are scanned for expiry are:</p>
            <p>TransactionStatusManager
                items: one of these is created by every application process that uses Narayana
                – they contain the information
                that
                allows the RecoveryManager to determine if the process that initiated the transaction is still alive, and what the
                transaction status
                is. The
                expiry time for these is set by the property com.arjuna.ats.arjuna.recovery.transactionStatusManagerExpiryTime (in hours –
                default
                is 12, zero
                means never expire). The expiry time should be greater than the lifetime of any single Narayana-using
                process.
            </p>
            <p>The Expiry Scanner properties for these are:</p>
            <div class="example"><a id="d5e1227"/><p class="title"><strong>Example 1.34. Recovery Environment Bean XML</strong></p><div class="example-contents">
                
                <pre><code class="language-xml">&lt;entry key="RecoveryEnvironmentBean.expiryScanners"&gt;
  com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner
&lt;/entry&gt;
</code></pre>
            </div></div><br class="example-break"/>
            <p>To illustrate the behavior of a recovery module, the following pseudo code describes the basic
                algorithm used for Atomic Action
                transactions and Transactional Objects for java.
            </p>
            <div class="example"><a id="d5e1231"/><p class="title"><strong>Example 1.35. AtomicAction pseudo code</strong></p><div class="example-contents">
                
                <pre><code class="language-java">First Pass:
&lt; create a collection containing all transactions currently in the log &gt;

Second Pass:
while &lt; there are transactions in the collection &gt;
do
 if &lt; the intention list for the transaction still exists &gt;
 then
   &lt; create new transaction cached item &gt;
   &lt; obtain the status of the transaction &gt;
 
   if &lt; the transaction is not in progress (ie phase 2 has finished ) &gt;
   then
     &lt; replay phase two of the commit protocol &gt;
   endif.
 endif.
end while.

        </code></pre>
            </div></div><br class="example-break"/>
            <div class="example"><a id="d5e1234"/><p class="title"><strong>Example 1.36. Transactional Object pseudo code</strong></p><div class="example-contents">
                
                <pre><code class="language-java">First Pass:
&lt; Create a hash table for uncommitted transactional objects. &gt;
&lt; Read in all transactional objects within the object store. &gt;
while &lt; there are transactional objects &gt;
do
   if &lt; the transactional object has an Uncommited status in the object store &gt;
   then
      &lt; add the transactional Object o the hash table for uncommitted transactional objects&gt;
   end if.
end while.

Second Pass:
while &lt; there are transactions in the hash table for uncommitted transactional objects &gt;
do
   if &lt; the transaction is still in the Uncommitted state &gt;
   then
      if &lt; the transaction is not in the Transaction Cache &gt;
      then
         &lt; check the status of the transaction with the original application process &gt;
         if &lt; the status is Rolled Back or the application process is inactive &gt;
            &lt; rollback the transaction by removing the Uncommitted status from the Object Store &gt;
         endif.
      endif.
   endif.
end while.
        </code></pre>
            </div></div><br class="example-break"/>
        </div>
    </div>
    <div class="section" title="1.6.3. Writing a Recovery Module"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1237"/>1.6.3. Writing a Recovery Module</h3></div></div></div>
        
        <p>In
            order to recover from failure, we have seen that the Recovery Manager contacts recovery modules by invoking
            periodically the methods
            periodicWorkFirstPass and periodicWorkSecondPass. Each Recovery Module is then able to manage recovery according the type of resources
            that
            need
            to be recovered. The Narayana
            product is shipped with a set of recovery modules (TOReceveryModule, XARecoveryModule…), but it is
            possible for a user to define its own recovery module that fit his application. The following basic example illustrates the
            steps needed to
            build such recovery module
        </p>
        <div class="section" title="1.6.3.1. A basic scenario"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1240"/>1.6.3.1. A basic scenario</h4></div></div></div>
            
            <p>This basic example does not aim to present a complete process to recover from failure, but mainly to
                illustrate the way to implement a
                recovery module.
            </p>
            <p>The application used here consists to create an atomic transaction, to register a participant within
                the created transaction and finally
                to terminate it either by commit or abort. A set of arguments are provided:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>to decide to commit or abort the transaction,</p>
                </li><li class="listitem">
                    <p>to decide generating a crash during the commitment process. </p>
                </li></ul></div>
            <p>The code of the main class that control the application is given below</p>
            <div class="example"><a id="d5e1250"/><p class="title"><strong>Example 1.37. TestRecoveryModule.java</strong></p><div class="example-contents">
                
                <pre><code class="language-java">package com.arjuna.demo.recoverymodule;

import com.arjuna.ats.arjuna.AtomicAction;
import com.arjuna.ats.arjuna.coordinator.*;

public class TestRecoveryModule {
	public static void main(String args[]) {
		try {
			AtomicAction tx = new AtomicAction();
			tx.begin(); // Top level begin

			// enlist the participant
			tx.add(SimpleRecord.create());

			System.out.println("About to complete the transaction ");
			for (int i = 0; i &lt; args.length; i++) {
				if ((args[i].compareTo("-commit") == 0))
					_commit = true;
				if ((args[i].compareTo("-rollback") == 0))
					_commit = false;
				if ((args[i].compareTo("-crash") == 0))
					_crash = true;
			}
			if (_commit)
				tx.commit(); // Top level commit
			else
				tx.abort(); // Top level rollback
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	protected static boolean _commit = true;
	protected static boolean _crash = false;
}

        </code></pre>
            </div></div><br class="example-break"/>
            <p>The registered participant has the following behavior: </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>During the prepare phase, it writes a simple message - “I’m prepared”- on the disk such The
                        message is written in a well known file
                    </p>
                </li><li class="listitem">
                    <p>During the commit phase, it writes another message - “I’m committed”- in the same file used
                        during prepare</p>
                </li><li class="listitem">
                    <p>If it receives an abort message, it removes from the disk the file used for prepare if any.
                    </p>
                </li><li class="listitem">
                    <p>If a crash has been decided for the test, then it crashes during the commit phase – the file
                        remains with the message “I’m prepared”.
                    </p>
                </li></ul></div>
            <p>The main portion of the code illustrating such behavior is described hereafter.</p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
                <p>that the location of the file given in variable filename can be changed</p>
            </div>
            <div class="example"><a id="d5e1266"/><p class="title"><strong>Example 1.38. SimpleRecord.java</strong></p><div class="example-contents">
                
                <pre><code class="language-java">package com.arjuna.demo.recoverymodule;

import com.arjuna.ats.arjuna.coordinator.*;
import java.io.File;

public class SimpleRecord extends AbstractRecord {
	public String filename = "c:/tmp/RecordState";

	public SimpleRecord() {
		System.out.println("Creating new resource");
	}

	public static AbstractRecord create() {
		return new SimpleRecord();
	}

	public int topLevelAbort() {
		try {
			File fd = new File(filename);
			if (fd.exists()) {
				if (fd.delete())
					System.out.println("File Deleted");
			}
		} catch (Exception ex) {
			// …
		}
		return TwoPhaseOutcome.FINISH_OK;
	}

	public int topLevelCommit() {
		if (TestRecoveryModule._crash)
			System.exit(0);
		try {
			java.io.FileOutputStream file = new java.io.FileOutputStream(
					filename);
			java.io.PrintStream pfile = new java.io.PrintStream(
					file);
			pfile.println("I'm Committed");
			file.close();
		} catch (java.io.IOException ex) {
			// ...
		}
		return TwoPhaseOutcome.FINISH_OK;
	}

	public int topLevelPrepare() {
		try {
			java.io.FileOutputStream file = new java.io.FileOutputStream(
					filename);
			java.io.PrintStream pfile = new java.io.PrintStream(
					file);
			pfile.println("I'm prepared");
			file.close();
		} catch (java.io.IOException ex) {
			// ...
		}
		return TwoPhaseOutcome.PREPARE_OK;
	}
	// …
}

        </code></pre>
            </div></div><br class="example-break"/>
            <p>The role of the Recovery Module in such application consists to read the content of the file used to
                store the status of the participant,
                to determine that status and print a message indicating if a recovery action is needed or not.
            </p>
            <div class="example"><a id="d5e1270"/><p class="title"><strong>Example 1.39. SimpleRecoveryModule.java</strong></p><div class="example-contents">
                
                <pre><code class="language-java">package com.arjuna.demo.recoverymodule;

import com.arjuna.ats.arjuna.recovery.RecoveryModule;

public class SimpleRecoveryModule implements RecoveryModule {
	public String filename = "c:/tmp/RecordState";

	public SimpleRecoveryModule() {
		System.out
				.println("The SimpleRecoveryModule is loaded");
	}

	public void periodicWorkFirstPass() {
		try {
			java.io.FileInputStream file = new java.io.FileInputStream(
					filename);
			java.io.InputStreamReader input = new java.io.InputStreamReader(
					file);
			java.io.BufferedReader reader = new java.io.BufferedReader(
					input);
			String stringState = reader.readLine();
			if (stringState.compareTo("I'm prepared") == 0)
				System.out
						.println("The transaction is in the prepared state");
			file.close();
		} catch (java.io.IOException ex) {
			System.out.println("Nothing found on the Disk");
		}
	}

	public void periodicWorkSecondPass() {
		try {
			java.io.FileInputStream file = new java.io.FileInputStream(
					filename);
			java.io.InputStreamReader input = new java.io.InputStreamReader(
					file);
			java.io.BufferedReader reader = new java.io.BufferedReader(
					input);
			String stringState = reader.readLine();
			if (stringState.compareTo("I'm prepared") == 0) {
				System.out
						.println("The record is still in the prepared state");
				System.out.println("– Recovery is needed");
			} else if (stringState
					.compareTo("I'm Committed") == 0) {
				System.out
						.println("The transaction has completed and committed");
			}
			file.close();
		} catch (java.io.IOException ex) {
			System.out.println("Nothing found on the Disk");
			System.out
					.println("Either there was no transaction");
			System.out.println("or it as been rolled back");
		}
	}
}

        </code></pre>
            </div></div><br class="example-break"/>
            <p>The recovery module should now be deployed in order to be called by the Recovery Manager. To do so, we
                just need to add an entry in the
                the config file for the extension:
            </p>
            <div class="example"><a id="d5e1274"/><p class="title"><strong>Example 1.40. Recovery Environment Bean Recovery Extensions XML</strong></p><div class="example-contents">
                
                <pre><code class="language-xml">&lt;entry key="RecoveryEnvironmentBean.recoveryExtenstions"&gt;
  com.arjuna.demo.recoverymodule.SimpleRecoveryModule
&lt;/entry&gt;
</code></pre>
            </div></div><br class="example-break"/>
            <p>Once started, the Recovery Manager will automatically load the listed Recovery modules.</p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>The
                    source of the code can be retrieved under the trailmap directory of the Narayana
                    installation.
                </p>
            </div>
        </div>
        <div class="section" title="1.6.3.2. Another scenario"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1280"/>1.6.3.2. Another scenario</h4></div></div></div>
            
            <p>As mentioned, the basic application presented above does not present the complete process to recover
                from failure, but it was just
                presented to describe how the build a recovery module. In case of the OTS protocol, let’s consider how a recovery module that
                manages recovery
                of OTS resources can be configured.
            </p>
            <p>To manage recovery in case of failure, the OTS specification has defined a recovery protocol.
                Transaction’s participants in a doubt status
                could use the RecoveryCoordinator to determine the status of the transaction. According to that transaction status, those
                participants can
                take appropriate decision either by roll backing or committing. Asking the RecoveryCoordinator object to determine the
                status consists to
                invoke the replay_completion operation on the RecoveryCoordinator.
            </p>
            <p>For each OTS Resource in a doubt status, it is well known which RecoveyCoordinator to invoke to
                determine the status of the transaction in
                which the Resource is involved – It’s the RecoveryCoordinator returned during the Resource registration process.
                Retrieving such
                RecoveryCoordinator per resource means that it has been stored in addition to other information describing the resource.
            </p>
            <p>A recovery module dedicated to recover OTS Resources could have the following behavior. When requested
                by the recovery Manager on the
                first pass it retrieves from the disk the list of resources that are in the doubt status. During the second pass, if the
                resources that were
                retrieved in the first pass still remain in the disk then they are considered as candidates for recovery. Therefore, the
                Recovery Module
                retrieves for each candidate its associated RecoveryCoordinator and invokes the replay_completion operation that the status
                of the
                transaction. According to the returned status, an appropriate action would be taken (for instance, rollback the resource is the
                status is
                aborted or inactive).
            </p>
        </div>
    </div>
</div>
</div>
    <div class="chapter" title="Chapter 2. JTA"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1286"/>Chapter 2. JTA</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d5e1288">2.1. Administration</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1290">2.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e1304">2.1.2. Starting and Stopping the Transaction Manager</a></span></dt><dt><span class="section"><a href="#d5e1324">2.1.3. ObjectStore Management</a></span></dt><dt><span class="section"><a href="#d5e1330">2.1.4. Narayana
        Runtime Information
    </a></span></dt><dt><span class="section"><a href="#d5e1336">2.1.5. Failure Recovery Administration</a></span></dt><dt><span class="section"><a href="#d5e1445">2.1.6. Errors and Exceptions</a></span></dt><dt><span class="section"><a href="#d5e1468">2.1.7. Selecting the JTA implementation</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1495">2.2. Development</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1497">2.2.1. JDBC and Transactions</a></span></dt><dt><span class="section"><a href="#d5e1634">2.2.2. Examples</a></span></dt><dt><span class="section"><a href="#d5e1659">2.2.3. Using Narayana
        in application servers
    </a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1701">2.3. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1703">2.3.1. Preparing Your System</a></span></dt><dt><span class="section"><a href="#d5e1727">2.3.2. Operating System Services</a></span></dt><dt><span class="section"><a href="#d5e1822">2.3.3. Logging</a></span></dt><dt><span class="section"><a href="#d5e1841">2.3.4. Additional JAR Requirements</a></span></dt><dt><span class="section"><a href="#chap-JBossJTA_Installation_Guide-Test_Chapter">2.3.5. Setting Properties</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1877">2.4. Quick Start to JTA</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1879">2.4.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e1882">2.4.2. Package layout</a></span></dt><dt><span class="section"><a href="#d5e1894">2.4.3. Setting properties</a></span></dt><dt><span class="section"><a href="#d5e1904">2.4.4. Demarcating Transactions</a></span></dt><dt><span class="section"><a href="#d5e1933">2.4.5. Local vs Distributed JTA implementations</a></span></dt><dt><span class="section"><a href="#d5e1948">2.4.6. JDBC and Transactions</a></span></dt><dt><span class="section"><a href="#d5e1955">2.4.7. Configurable options</a></span></dt></dl></dd></dl></div>
    
    <div class="section" title="2.1. Administration"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1288"/>2.1. Administration</h2></div></div></div>
        
        <div class="section" title="2.1.1. Introduction"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1290"/>2.1.1. Introduction</h3></div></div></div>
    
    <p>
        Apart from ensuring that the run-time system is executing normally, there is little continuous administration
        needed
        for the Narayana
        software. Refer to
        <a class="xref" href="#important_points_for_administrators" title="Important Points for Administrators">Important Points for Administrators</a>
        for some specific
        concerns.
    </p>
    <div class="itemizedlist" title="Important Points for Administrators"><a id="important_points_for_administrators"/><p class="title"><strong>Important Points for Administrators</strong></p><ul class="itemizedlist"><li class="listitem">
            <p>
                The present implementation of the Narayana
                system provides no security or protection for data. The objects
                stored in the Narayana
                object store are (typically) owned by the user who ran the application that created
                them. The Object Store and Object Manager facilities make no attempt to enforce even the limited form of
                protection that Unix/Windows provides. There is no checking of user or group IDs on access to objects for either
                reading or writing.
            </p>
        </li><li class="listitem">
            <p>
                Persistent objects created in the Object Store never go away unless the StateManager.destroy method is invoked
                on the object or some application program explicitly deletes them. This means that the Object Store gradually
                accumulates garbage (especially during application development and testing phases). At present we have
                no
                automated garbage collection facility. Further, we have not addressed the problem of dangling references. That
                is, a persistent object, A, may have stored a Uid for another persistent object, B, in its passive
                representation on disk. There is nothing to prevent an application from deleting B even though A still contains
                a reference to it. When A is next activated and attempts to access B, a run-time error will occur.
            </p>
        </li><li class="listitem">
            <p>
                There is presently no support for version control of objects or database reconfiguration in the event of
                class
                structure changes. This is a complex research area that we have not addressed. At present, if you change the
                definition of a class of persistent objects, you are entirely responsible for ensuring that existing instances
                of the object in the Object Store are converted to the new representation. The Narayana
                software can neither
                detect nor correct references to old object state by new operation versions or vice versa.
            </p>
        </li><li class="listitem">
            <p>
                Object store management is critically important to the transaction service.
            </p>
        </li></ul></div>
</div>
        <div class="section" title="2.1.2. Starting and Stopping the Transaction Manager"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1304"/>2.1.2. Starting and Stopping the Transaction Manager</h3></div></div></div>
    
    <p>
        By default the transaction manager starts up in an active state such that new transactions can be created
        immediately. If you wish to have more control over this it is possible to set the
        <code class="option">CoordinatorEnvironmentBean.startDisabled</code>
        configuration option to
        <code class="literal">YES</code>
        and in
        which case no transactions can be created until the transaction manager is enabled via a call to method
        <code class="methodname">TxControl.enable</code>
        ).
    </p>
    <p>
        It is possible to stop the creation of new transactions at any time by calling method
        <code class="methodname">TxControl.disable</code>
        . Transactions that are currently executing will not be affected. By
        default recovery will be allowed to continue and the transaction system will still be available to manage recovery
        requests from other instances in a distributed environment. (See the Failure Recovery Guide for further
        details). However, if you wish to disable recovery as well as remove any resources it maintains, then you can pass
        <code class="literal">true</code>
        to method
        <code class="methodname">TxControl.disable</code>
        ; the default is to use
        <code class="literal">false</code>
        .
    </p>
    <p>
        If you wish to shut the system down completely then it may also be necessary to terminate the background
        transaction
        reaper (see the Programmers Guide for information about what the reaper does.) In order to do this you may want to
        first prevent the creation of new transactions (if you are not creating transactions with timeouts then this step is
        not necessary) using method
        <code class="methodname">TxControl.disable</code>
        . Then you should call method
        <code class="methodname">TransactionReaper.terminate</code>
        . This method takes a Boolean parameter: if
        <code class="literal">true</code>
        then the method will wait for the normal timeout periods associated with any transactions to
        expire before terminating the transactions; if
        <code class="methodname">false</code>
        then transactions will be forced to
        terminate (rollback or have their outcome set such that they can only ever rollback) immediately.
    </p>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            if you intent to restart the recovery manager later after having terminated it then you MUST use the
            <code class="methodname">TransactionReapear.terminate</code>
            method with asynchronous behavior set to
            <code class="literal">false</code>
            .
        </p>
    </div>
</div>
        <div class="section" title="2.1.3. ObjectStore Management"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1324"/>2.1.3. ObjectStore Management</h3></div></div></div>
    
    <p>
        Within the transaction service installation, the
        object store is updated regularly whenever transactions are created, or when
        <span class="application">Transactional Objects for
            Java
        </span>
        is used. In a failure-free environment, the only object states which should reside within the
        object store are those representing objects created with the
        <span class="application">Transactional Objects for Java</span>
        API.
    </p>
    <p>
        However, if failures occur, transaction logs may remain in the object store until crash recovery facilities have
        resolved the transactions they represent. As such it is very important that the contents of the object store are not
        deleted without due care and attention, as this will make it impossible to resolve in doubt transactions. In
        addition, if multiple users share the same object store it is important that they realize this and do not simply
        delete the contents of the object store assuming it is an exclusive resource.
    </p>
</div>
        <div class="section" title="2.1.4. Narayana Runtime Information"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1330"/>2.1.4. Narayana
        Runtime Information
    </h3></div></div></div>
    
    <p>
        Compile-time configuration information is available via class
        <code class="classname">com.arjuna.common.util.ConfigurationInfo</code>
        . Runtime configuration is embodied in the various
        <code class="classname">
            <em class="replaceable"><code>name</code></em>
            EnvironmentBean
        </code>
        classes where name refers to the
        particular configuration category (see the configuration section of the user guide). These beans have
        corresponding 
        MBean interfaces and may be linked to JMX for remote
        inspection of the configuration if desired.
    </p>
</div>
        <div class="section" title="2.1.5. Failure Recovery Administration"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1336"/>2.1.5. Failure Recovery Administration</h3></div></div></div>
    

    <p>
        The failure recovery subsystem of Narayana
        will ensure that results of a transaction are applied consistently to
        all resources affected by the transaction, even if any of the application processes or the machine hosting them
        crash or lose network connectivity. In the case of machine (system) crash or network failure, the recovery will not
        take place until the system or network are restored, but the original application does not need to be
        restarted. Recovery responsibility is delegated to
        <a class="xref" href="#recovery-manager" title="2.1.5.1. The Recovery Manager">Section 2.1.5.1, “The Recovery Manager”</a>
        . Recovery after failure
        requires that information about the transaction and the resources involved survives the failure and is accessible
        afterward: this information is held in the
        <code class="systemitem">ActionStore</code>
        , which is part of the
        <code class="systemitem">ObjectStore</code>
        .
    </p>
    <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
        <p>
            If the
            <code class="systemitem">ObjectStore</code>
            is destroyed or modified, recovery may not be possible.
        </p>
    </div>
    <p>
        Until the recovery procedures are complete, resources affected by a transaction that was in progress at the time
        of
        the failure may be inaccessible. For database resources, this may be reported as tables or rows held by “in-doubt
        transactions”. For
        <span class="application">TransactionalObjects for Java</span>
        resources, an attempt to activate the
        <code class="systemitem">Transactional Object</code>
        (as when trying to get a lock) will fail.
    </p>

    <div class="section" title="2.1.5.1. The Recovery Manager"><div class="titlepage"><div><div><h4 class="title"><a id="recovery-manager"/>2.1.5.1. The Recovery Manager</h4></div></div></div>
        

        <p>
            The failure recovery subsystem of Narayana
            requires that the stand-alone Recovery Manager process be running for
            each
            <code class="systemitem">ObjectStore</code>
            (typically one for each node on the network that is running Narayana
            applications). The
            <code class="filename">RecoveryManager</code>
            file is located in the arjunacore JAR file within the
            package
            <span class="package">com.arjuna.ats.arjuna.recovery.RecoveryManager</span>
            . To start the Recovery Manager issue the
            following command:
        </p>
        <pre class="screen">
      <span class="command"><strong>java com.arjuna.ats.arjuna.recovery.RecoveryManager</strong></span>
    </pre>
        <p>
            If the
            <em class="parameter"><code>-test</code></em>
            flag is used with the Recovery Manager then it will display a
            <code class="literal">Ready</code>
            message when initialized, i.e.,
        </p>
        <pre class="screen">
      <span class="command"><strong>java com.arjuna.ats.arjuna.recovery.RecoveryManager -test</strong></span>
    </pre>
    </div>

    <div class="section" title="2.1.5.2. Configuring the Recovery Manager"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1361"/>2.1.5.2. Configuring the Recovery Manager</h4></div></div></div>
        
        <p>
            The RecoveryManager reads the properties defined in the
            <code class="filename">jbossts-properties.xml</code>
            file.
        </p>
        <p>
            A default version of
            <code class="filename">jbossts-properties.xml</code>
            is supplied with the distribution. This can
            be used without modification, except possibly the debug tracing fields, as shown in
            <a class="xref" href="#recovery-manager-output" title="2.1.5.3. Output">Section 2.1.5.3, “Output”</a>
            .
        </p>
    </div>

    <div class="section" title="2.1.5.3. Output"><div class="titlepage"><div><div><h4 class="title"><a id="recovery-manager-output"/>2.1.5.3. Output</h4></div></div></div>
        

        <p>
            It is likely that installations will want to have some form of output from the RecoveryManager, to provide a
            record of what recovery activity has taken place. RecoveryManager uses the logging mechanism provided by
            <span class="application">jboss logging</span>
            , which provides a high level interface that
            hides differences that exist between existing logging APIs such Jakarta log4j or JDK logging API.
        </p>
        <p>
            The configuration of
            <span class="application">jboss logging</span>
            depends on the underlying logging framework
            that is used, which is determined by the availability and ordering of alternatives on the classpath. Please
            consult the jboss logging documentation for details. Each log message has an associated
            log Level, that gives the importance and urgency of a log message. The set of possible Log Levels, in order of
            least severity, and highest verbosity, is:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>
                    <code class="literal">TRACE</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">DEBUG</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">INFO</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">WARN</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">ERROR</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">FATAL</code>
                </p>
            </li></ol></div>
        <p>
            Messages describing the start and the periodical behavior made by the RecoveryManager are output using the
            <code class="literal">INFO</code>
            level. If other debug tracing is wanted, the finer debug or trace levels should be set
            appropriately.
        </p>
        <p>
            Setting the normal recovery messages to the
            <code class="literal">INFO</code>
            level allows the RecoveryManager to produce a
            moderate level of reporting. If nothing is going on, it just reports the entry into each module for each periodic
            pass. To disable
            <code class="literal">INFO</code>
            messages produced by the Recovery Manager, the logging level could be set
            to the higher level of
            <code class="literal">ERROR</code>
            , which means that the RecoveryManager will only produce
            <code class="literal">ERROR</code>
            ,
            <code class="literal">WARNING</code>
            , or
            <code class="literal">FATAL</code>
            messages.
        </p>
    </div>

    <div class="section" title="2.1.5.4. Periodic Recovery"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1402"/>2.1.5.4. Periodic Recovery</h4></div></div></div>
        
        <p>
            The RecoveryManager scans the ObjectStore and other locations of information, looking for transactions and
            resources that require, or may require recovery. The scans and recovery processing are performed by recovery
            modules. These recovery modules are instances of classes that implement the
            <code class="interfacename">com.arjuna.ats.arjuna.recovery.RecoveryModule interface</code>
            . Each module has
            responsibility for a particular category of transaction or resource. The set of recovery modules used is
            dynamically loaded, using properties found in the RecoveryManager property file.
        </p>
        <p>
            
            The interface has two methods:
            <code class="methodname">periodicWorkFirstPass</code>
            and
            <code class="methodname">periodicWorkSecondPass</code>
            . At an interval defined by property
            <span class="property">com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod</span>
            , the RecoveryManager calls the first
            pass method on each property, then waits for a brief period, defined by property
            <span class="property">com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod</span>
            . Next, it calls the second pass of each
            module. Typically, in the first pass, the module scans the relevant part of the ObjectStore to find transactions
            or resources that are in-doubt. An in-doubt transaction may be part of the way through the commitment process, for
            instance. On the second pass, if any of the same items are still in-doubt, the original application process
            may
            have crashed, and the item is a candidate for recovery.
        </p>
        <p>
            An attempt by the RecoveryManager to recover a transaction that is still progressing in the original process
            is
            likely to break the consistency. Accordingly, the recovery modules use a mechanism, implemented in the
            <span class="package">com.arjuna.ats.arjuna.recovery.TransactionStatusManager</span>
            package, to check to see if the
            original process is still alive, and if the transaction is still in progress. The RecoveryManager only proceeds
            with recovery if the original process has gone, or, if still alive, the transaction is completed. If a server
            process or machine crashes, but the transaction-initiating process survives, the transaction completes, usually
            generating a warning. Recovery of such a transaction is the responsibility of the RecoveryManager.
        </p>
        <p>
            It is clearly important to set the interval periods appropriately. The total iteration time will be the sum
            of the
            <span class="property">periodicRecoveryPeriod</span>
            and
            <span class="property">recoveryBackoffPeriod</span>
            properties, and the
            length of time it takes to scan the stores and to attempt recovery of any in-doubt transactions found, for all the
            recovery modules. The recovery attempt time may include connection timeouts while trying to communicate with
            processes or machines that have crashed or are inaccessible. There are mechanisms in the recovery system to avoid
            trying to recover the same transaction indefinitely. The total iteration time affects how long a resource will
            remain inaccessible after a failure. –
            <span class="property">periodicRecoveryPeriod</span>
            should be set accordingly. Its
            default is 120 seconds. The
            <span class="property">recoveryBackoffPeriod</span>
            can be comparatively short, and defaults to
            10 seconds. –Its purpose is mainly to reduce the number of transactions that are candidates for recovery and which
            thus require a call to the original process to see if they are still in progress.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                In previous versions of
                <span class="application">Narayana
                </span>
                , there was no contact mechanism, and the back-off
                period needed to be long enough to avoid catching transactions in flight at all. From 3.0, there is no such
                risk.
            </p>
        </div>
        <p>
            Two recovery modules, implementations of the
            <code class="interfacename">com.arjuna.ats.arjuna.recovery.RecoveryModule</code>
            interface, are supplied with
            <span class="application">Narayana
            </span>
            . These modules support various aspects of transaction recovery, including JDBC
            recovery. It is possible for advanced users to create their own recovery modules and register them with the
            Recovery Manager. The recovery modules are registered with the RecoveryManager using
            <code class="methodname">RecoveryEnvironmentBean.recoveryModuleClassNames</code>
            . These will be invoked on each pass of the
            periodic recovery in the sort-order of the property names – it is thus possible to predict the ordering, but a
            failure in an application process might occur while a periodic recovery pass is in progress. The default Recovery
            Extension settings are:
        </p>
        <pre><code class="language-xml">&lt;entry key="RecoveryEnvironmentBean.recoveryModuleClassNames"&gt;
    com.arjuna.ats.internal.arjuna.recovery.AtomicActionRecoveryModule
    com.arjuna.ats.internal.txoj.recovery.TORecoveryModule
    com.arjuna.ats.internal.jta.recovery.arjunacore.XARecoveryModule
&lt;/entry&gt;
</code></pre>

    </div>

    <div class="section" title="2.1.5.5. Expired Entry Removal"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1426"/>2.1.5.5. Expired Entry Removal</h4></div></div></div>
        

        <p>
            The operation of the recovery subsystem cause some entries to be made in the ObjectStore that are not
            removed in
            normal progress. The RecoveryManager has a facility for scanning for these and removing items that are very
            old. Scans and removals are performed by implementations of the
            <code class="interfacename">com.arjuna.ats.arjuna.recovery.ExpiryScanner</code>
            interface. These implementations are
            loaded by giving the class names as the value of a property
            <span class="property">RecoveryEnvironmentBean.expiryScannerClassNames</span>
            . The RecoveryManager calls the
            <code class="methodname">scan()</code>
            method on each loaded Expiry Scanner implementation at an interval determined by the property
            <span class="property">RecoveryEnvironmentBean.expiryScanInterval</span>
            . This value is given in hours, and defaults to
            12hours. An
            <span class="property">expiryScanInterval</span>
            value of zero suppresses any expiry scanning. If the value
            supplied is positive, the first scan is performed when RecoveryManager starts. If the value is negative, the first
            scan is delayed until after the first interval, using the absolute value.
        </p>
        <p>
            The kinds of item that are scanned for expiry are:
        </p>
        <div class="variablelist"><dl><dt><span class="term">TransactionStatusManager items</span></dt><dd>
                    <p>
                        One TransactionStatusManager item is created by every application process that uses
                        <span class="application">Narayana
                        </span>
                        . It contains the information that allows the RecoveryManager to
                        determine if the process that initiated the transaction is still alive, and its status. The expiry time for
                        these items is set by the property
                        <span class="property">com.arjuna.ats.arjuna.recovery.transactionStatusManagerExpiryTime</span>
                        , expressed in
                        hours. The default is 12, and 0 (zero) means never to expire.The expiry time should be greater than the
                        lifetime of any single processes using
                        <span class="application">Narayana
                        </span>
                        .
                    </p>
                </dd></dl></div>
        <p>
            The Expiry Scanner properties for these are:
        </p>
        <pre><code class="language-xml"> &lt;entry key="RecoveryEnvironmentBean.expiryScannerClassNames"&gt;
    com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner
&lt;/entry&gt;
</code></pre>

    </div>

</div>
        <div class="section" title="2.1.6. Errors and Exceptions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1445"/>2.1.6. Errors and Exceptions</h3></div></div></div>
    

    <p>
        This section covers the types and causes of errors and exceptions which may be thrown or reported during a
        transactional application.
    </p>
    <div class="variablelist" title="Errors and Exceptions"><p class="title"><strong>Errors and Exceptions</strong></p><dl><dt><span class="term">
                <code class="literal">NO_MEMORY</code>
            </span></dt><dd>
                <p>
                    The application has run out of memory, and has thrown an
                    <code class="systemitem">OutOfMemoryError</code>
                    exception.
                    <span class="application">Narayana
                    </span>
                    has attempted to do some cleanup, by running the garbage
                    collector, before re-throwing the exception. This is probably a transient problem and retrying the invocation
                    should succeed.
                </p>
            </dd><dt><span class="term">
                <code class="literal">com.arjuna.ats.arjuna.exceptions.FatalError</code>
            </span></dt><dd>
                <p>
                    An error has occurred, and the error is of such severity that that the transaction system must shut
                    down. Prior to this error being thrown the transaction service ensures that all running transactions have
                    rolled back. If an application catches this error, it should tidy up and exit. If further work is attempted,
                    application consistency may be violated.
                </p>
            </dd><dt><span class="term">
                <code class="literal">com.arjuna.ats.arjuna.exceptions.ObjectStoreError</code>
            </span></dt><dd>
                <p>
                    An error occurred while the transaction service attempted to use the object store. Further forward progress is
                    not possible.
                </p>
            </dd></dl></div>
    <p>
        Object store warnings about access problems on states may occur during the normal execution of crash recovery. This
        is the result of multiple concurrent attempts to perform recovery on the same transaction. It can be safely ignored.
    </p>
</div>
        <div class="section" title="2.1.7. Selecting the JTA implementation"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1468"/>2.1.7. Selecting the JTA implementation</h3></div></div></div>
    
    <p>
        Two variants of the JTA implementation are accessible through the same interface. These are:
    </p>
    <div class="informaltable">
        <table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>Purely local JTA</td><td>
                        <p>
                            Only non-distributed JTA transactions are executed. This is the only version available with
                            the Narayana
                            distribution.
                        </p>
                    </td></tr><tr><td>Remote, CORBA-based JTA</td><td>
                        <p>
                            Executes distributed JTA transactions. This functionality is provided by the JTS distribution and requires
                            a supported CORBA ORB.
                            Consult the JTS Installation and Administration Guide for more information.
                        </p>
                    </td></tr></tbody></table>
    </div>
    <p>
        Both of these implementations are fully compatible with the transactional JDBC driver.
    </p>
    <div class="procedure" title="Procedure 2.1. Selecting the local JTA implementation"><a id="d5e1483"/><p class="title"><strong>Procedure 2.1. Selecting the local JTA implementation</strong></p><ol class="procedure" type="1"><li class="step" title="Step 1">
            <p>
                Set the property
                <code class="varname">JTAEnvironmentBean.jtaTMImplementation</code>
                to value
                <code class="literal">com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple</code>
                .
            </p>
        </li><li class="step" title="Step 2">
            <p>
                Set the property
                <code class="varname">JTAEnvironmentBean.jtaUTImplementation</code>
                to value
                <code class="literal">com.arjuna.ats.internal.jta.transaction.arjunacore.UserTransactionImple</code>
                .
            </p>
        </li></ol></div>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            These settings are the default values for the properties, so nothing needs to be changed to use the local
            implementation.
        </p>
    </div>
</div>
    </div>
    <div class="section" title="2.2. Development"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1495"/>2.2. Development</h2></div></div></div>
        
        <div class="section" title="2.2.1. JDBC and Transactions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1497"/>2.2.1. JDBC and Transactions</h3></div></div></div>
    

    <div class="section" title="2.2.1.1. Using the transactional JDBC driver"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1499"/>2.2.1.1. Using the transactional JDBC driver</h4></div></div></div>
        
        <p>
      Narayana
            supports construction of both local and distributed transactional applications which access databases
            using the JDBC APIs. JDBC supports two-phase commit of transactions, and is similar to the XA X/Open
            standard. 
            provides JDBC support in package
            <span class="package">com.arjuna.ats.jdbc</span>.
            A list of the tested
            drivers is available from the 
            website.
        </p>
        <p>
            Only use the transactional JDBC support provided in package
            <span class="package">com.arjuna.ats.jdbc</span>
            when you are
            using 
            outside of an application server, such as WildFly Application Server,
            or another container. Otherwise,
            use the JDBC support provided by your application server or container.
        </p>
        <div class="section" title="2.2.1.1.1. Managing transactions"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1505"/>2.2.1.1.1. Managing transactions</h5></div></div></div>
            
            <p>
        Narayana
                needs the ability to associate work performed on a JDBC connection with a specific
                transaction. Therefore, applications need to use a combination of implicit transaction propagation and indirect
                transaction management. For each JDBC connection, Narayana
                must be able to determine the invoking thread's
                current transaction context.
            </p>
        </div>
        <div class="section" title="2.2.1.1.2. Restrictions"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1508"/>2.2.1.1.2. Restrictions</h5></div></div></div>
            
            <p>
                Nested transactions are not supported by JDBC. If you try to use a JDBC connection within a
                subtransaction,
        Narayana
                throws a suitable exception and no work is allowed on that connection. However, if you need nested
                transactions, and are comfortable with straying from the JDBC standard, you can set property
                <code class="varname">com.arjuna.ats.jta.supportSubtransactions</code>
                property to
                <code class="literal">YES</code>
                .
            </p>
        </div>
    </div>

    <div class="section" title="2.2.1.2. Transactional drivers"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1513"/>2.2.1.2. Transactional drivers</h4></div></div></div>
        
        <p>
            The approach Narayana
            takes for incorporating JDBC connections within transactions is to provide transactional
            JDBC drivers as conduits for all interactions. These drivers intercept all invocations and ensure that they are
            registered with, and driven by, appropriate transactions. The driver
            <code class="classname">com.arjuna.ats.jdbc.TransactionalDriver</code>
            handles all JDBC drivers, implementing the
            <code class="interfacename">java.sql.Driver</code>
            interface. If the database is not transactional, ACID properties
            cannot be guaranteed.
        </p>
        <div class="section" title="2.2.1.2.1. Loading drivers"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1518"/>2.2.1.2.1. Loading drivers</h5></div></div></div>
            
            <div class="example"><a id="d5e1520"/><p class="title"><strong>Example 2.1. Instantiating and using the driver within an application</strong></p><div class="example-contents">
                
                <pre><code class="language-java">TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver(); 
</code></pre>
            </div></div><br class="example-break"/>

            <div class="example"><a id="d5e1523"/><p class="title"><strong>Example 2.2. Registering the drivers with the JDBC driver manager using the Java system properties</strong></p><div class="example-contents">
                
                <pre><code class="language-java">Properties p = System.getProperties(); 

switch (dbType)
{
case MYSQL:
    p.put("jdbc.drivers", "com.mysql.jdbc.Driver"); 
    break;
case PGSQL:
    p.put("jdbc.drivers", "org.postgresql.Driver"); 
    break;
}

System.setProperties(p);
</code></pre>
                <p>
                    The jdbc.drivers property contains a colon-separated list of driver class names, which the JDBC driver manager
                    loads when it is initialized. After the driver is loaded, you can use it to make a connection with a
                    database.
                </p>
            </div></div><br class="example-break"/>
            <div class="example"><a id="d5e1527"/><p class="title"><strong>Example 2.3. 
                    Using the
                    <code class="methodname">Class.forName</code>
                    method
                </strong></p><div class="example-contents">
                
                <p>
                    Calling
                    <code class="methodname">Class.forName()</code>
                    automatically registers the driver with the JDBC driver
                    manager. It is also possible to explicitly create an instance of the JDBC driver.
                </p>
                <pre><code class="language-java">sun.jdbc.odbc.JdbcOdbcDriver drv = new sun.jdbc.odbc.JdbcOdbcDriver();

DriverManager.registerDriver(drv);
</code></pre>
            </div></div><br class="example-break"/>
        </div>
    </div>


    <div class="section" title="2.2.1.3. Connections"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1533"/>2.2.1.3. Connections</h4></div></div></div>
        
        <p>
            Because Narayana
            provides JDBC connectivity via its own JDBC driver, application code can support transactions
            with relatively small code changes. Typically, the application programmer only needs to start and terminate
            transactions.
        </p>
        <div class="section" title="2.2.1.3.1. JDBC"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1536"/>2.2.1.3.1. JDBC</h5></div></div></div>
            
            <p>
                The Narayana
                driver accepts the following properties, all located in class
                <code class="classname">com.arjuna.ats.jdbc.TransactionalDriver</code>
                .
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>username</td><td>
                                <p>
                                    the database username
                                </p>
                            </td></tr><tr><td>password</td><td>
                                <p>
                                    the database password
                                </p>
                            </td></tr><tr><td>createDb</td><td>
                                <p>
                                    creates the database automatically if set to
                                    <code class="literal">true</code>
                                    . Not all JDBC implementations
                                    support this.
                                </p>
                            </td></tr><tr><td>dynamicClass</td><td>
                                <p>
                                    specifies a class to instantiate to connect to the database, instead of using JNDI.
                                </p>
                            </td></tr></tbody></table>
            </div>
        </div>
        <div class="section" title="2.2.1.3.2. XADataSources"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1560"/>2.2.1.3.2. XADataSources</h5></div></div></div>
            
            <p>
                JDBC connections are created from appropriate DataSources. Connections which participate in distributed
                transactions are obtained from XADataSources. When using a JDBC driver, Narayana
                uses the appropriate DataSource
                whenever a connection to the database is made. It then obtains XAResources and registers them with the
                transaction via the JTA interfaces. The transaction service uses these XAResources when the transaction
                terminates in order to drive the database to either commit or roll back the changes made via the JDBC
                connection.
            </p>
            <p>
        Narayana
                JDBC support can obtain XADataSources through the Java Naming and Directory Interface (JNDI) or dynamic
                class instantiation.
            </p>
            <div class="section" title="2.2.1.3.2.1. Java naming and directory interface (JNDI)"><div class="titlepage"><div><div><h6 class="title"><a id="d5e1564"/>2.2.1.3.2.1. Java naming and directory interface (JNDI)</h6></div></div></div>
                
                <p>
                    A JDBC driver can use arbitrary DataSources without having to know specific details about their
                    implementations, by using JNDI. A specific DataSource or XADataSource can be created and registered with an
                    appropriate JNDI implementation, and the application, or JDBC driver, can later bind to and use it. Since JNDI
                    only allows the application to see the DataSource or XADataSource as an instance of the interface (e.g.,
                    javax.sql.XADataSource) rather than as an instance of the implementation class (e.g.,
                    com.mydb.myXADataSource), the application is not tied at build-time to only use a specific
                    implementation.
                </p>
                <p>
                    For the TransactionalDriver class to use a JNDI-registered XADataSource, you need to create the
                    XADataSource instance and store it in an appropriate JNDI implementation. Details of how to do this
                    can be
                    found in the JDBC tutorial available at the Java web site.
                </p>
                <div class="example"><a id="d5e1568"/><p class="title"><strong>Example 2.4. Storing a datasource in a JNDI implementation</strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">XADataSource ds = MyXADataSource();
Hashtable env = new Hashtable();
String initialCtx = PropertyManager.getProperty("Context.INITIAL_CONTEXT_FACTORY");

env.put(Context.INITIAL_CONTEXT_FACTORY, initialCtx);

initialContext ctx = new InitialContext(env);

ctx.bind("jdbc/foo", ds);
 </code></pre>
                    <p>
                        The Context.INITIAL_CONTEXT_FACTORY property is the JNDI way of specifying the type of JNDI
                        implementation to use.
                    </p>
                    <p>
                        The application must pass an appropriate connection URL to the JDBC driver:
                    </p>
                    <pre><code class="language-java">
          Properties dbProps = new Properties();

dbProps.setProperty(TransactionalDriver.userName, "user");
dbProps.setProperty(TransactionalDriver.password, "password");

// the driver uses its own JNDI context info, remember to set it up:
jdbcPropertyManager.propertyManager.setProperty(
                                                "Context.INITIAL_CONTEXT_FACTORY", initialCtx);
jdbcPropertyManager.propertyManager.setProperty(
                                                "Context.PROVIDER_URL", myUrl);

TransactionalDriver arjunaJDBCDriver = new TransactionalDriver();
Connection connection = arjunaJDBCDriver.connect("jdbc:arjuna:jdbc/foo", dbProps);
</code></pre>
                    <p>
                        The JNDI URL must be pre-pended with
                        <code class="literal">jdbc:arjuna:</code>
                        in order for the TransactionalDriver to
                        recognize that the DataSource must participate within transactions and be driven accordingly.
                    </p>
                </div></div><br class="example-break"/>
            </div>
            <div class="section" title="2.2.1.3.2.2. Dynamic class instantiation"><div class="titlepage"><div><div><h6 class="title"><a id="d5e1576"/>2.2.1.3.2.2. Dynamic class instantiation</h6></div></div></div>
                
                <p>
                    If a JNDI implementation is not available. you can specify an implementation of the
                    <code class="interfacename">DynamicClass</code>
                    interface, which is used to get the XADataSource object. This is
                    not recommended, but provides a fallback for environments where use of JNDI is not feasible.
                </p>
                <p>
                    Use the property
                    <code class="varname">TransactionalDriver.dynamicClass</code>
                    to specify the implementation to use. An
                    example is
                    <code class="literal">PropertyFileDynamicClass</code>
                    , a DynamicClass implementation that reads the
                    XADataSource implementation class name and configuration properties from a file, then instantiates and
                    configures it.
                </p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Deprecated class</h2>
                    
                    <p>
                        The oracle_8_1_6 dynamic class is deprecated and should not be used.
                    </p>
                </div>
                <div class="example"><a id="d5e1586"/><p class="title"><strong>Example 2.5. Instantiating a dynamic class</strong></p><div class="example-contents">
                    
                    <p>
                        The application code must specify which dynamic class the TransactionalDriver should instantiate when
                        setting up the connection:
                    </p>
                    <pre><code class="language-java">Properties dbProps = new Properties();

dbProps.setProperty(TransactionalDriver.userName, "user");
dbProps.setProperty(TransactionalDriver.password, "password");
dbProps.setProperty(TransactionalDriver.dynamicClass,
                    "com.arjuna.ats.internal.jdbc.drivers.PropertyFileDynamicClass");

TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
Connection connection = arjunaJDBC2Driver.connect("jdbc:arjuna:/path/to/property/file", dbProperties);
</code></pre>
                </div></div><br class="example-break"/>
            </div>
        </div>
        <div class="section" title="2.2.1.3.3. Using the connection"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1590"/>2.2.1.3.3. Using the connection</h5></div></div></div>
            
            <p>
                Once the connection is established, all operations on the connection are monitored by Narayana.
                you do not need
                to use the transactional connection within transactions. If a transaction is not present when the connection is
                used, then operations are performed directly on the database.
            </p>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
                <p>
                    JDBC does not support subtransactions.
                </p>
            </div>
            <p>
                You can use transaction timeouts to automatically terminate transactions if a connection is not terminated
                within an appropriate period.
            </p>
            <p>
                You can use Narayana
                connections within multiple transactions simultaneously. An example would be different
                threads, with different notions of the current transaction. Narayana
                does connection pooling for each
                transaction within the JDBC connection. Although multiple threads may use the same instance of the JDBC
                connection, internally there may be a separate connection for each transaction. With the exception of method
                <code class="methodname">close</code>
                , all operations performed on the connection at the application level are only
                performed on this transaction-specific connection.
            </p>
            <p>
        Narayana
                automatically registers the JDBC driver connection with the transaction via an appropriate
                resource. When the transaction terminates, this resource either commits or rolls back any changes made to the
                underlying database via appropriate calls on the JDBC driver.
            </p>
            <p>
                Once created, the driver and any connection can be used in the same way as any other JDBC driver or connection.
            </p>
            <div class="example"><a id="d5e1600"/><p class="title"><strong>Example 2.6. Creating and using a connection</strong></p><div class="example-contents">
                
                <pre><code class="language-java">Statement stmt = conn.createStatement();

try
    {
        stmt.executeUpdate("CREATE TABLE test_table (a INTEGER,b INTEGER)");
    }
catch (SQLException e)
    {
        // table already exists
    }

stmt.executeUpdate("INSERT INTO test_table (a, b) VALUES (1,2)");

ResultSet res1 = stmt.executeQuery("SELECT * FROM test_table");        
</code></pre>
            </div></div><br class="example-break"/>
        </div>

        <div class="section" title="2.2.1.3.4. Connection pooling"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1603"/>2.2.1.3.4. Connection pooling</h5></div></div></div>
            
            <p>
                For each user name and password, Narayana
                maintains a single instance of each connection for as long as that
                connection is in use. Subsequent requests for the same connection get a reference to the original connection,
                rather than a new instance. You can try to close the connection, but the connection will only actually be closed
                when all users (including transactions) have either finished with the connection, or issued
                <code class="methodname">close</code>
                calls.
            </p>
        </div>

        <div class="section" title="2.2.1.3.5. Reusing connections"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1607"/>2.2.1.3.5. Reusing connections</h5></div></div></div>
            
            <p>
                Some JDBC drivers allow the reuse of a connection for multiple different transactions once a given
                transaction
                completes. Unfortunately this is not a common feature, and other drivers require a new connection to be
                obtained for each new transaction. By default, the Narayana
                transactional driver always obtains a new
                connection for each new transaction. However, if an existing connection is available and is currently unused,
        Narayana
                can reuse this connection. To turn on this feature, add option
                <code class="varname">reuseconnection=true</code>
                to the JDBC URL. For instance,
                <code class="code">jdbc:arjuna:sequelink://host:port;databaseName=foo;reuseconnection=true</code>
            </p>
        </div>

        <div class="section" title="2.2.1.3.6. Terminating the transaction"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1612"/>2.2.1.3.6. Terminating the transaction</h5></div></div></div>
            
            <p>
                When a transaction with an associated JDBC connection terminates, because of the application or because
                a
                transaction timeout expires, Narayana
                uses the JDBC driver to drive the database to either commit or roll back
                any changes made to it. This happens transparently to the application.
            </p>
        </div>

        <div class="section" title="2.2.1.3.7. AutoCommit"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1615"/>2.2.1.3.7. AutoCommit</h5></div></div></div>
            
            <p>
                If property
                <code class="varname">AutoCommit</code>
                of the interface
                <code class="varname">java.sql.Connection</code>
                is set to
                <code class="literal">true</code>
                for JDBC, the execution of every SQL statement is a separate top-level transaction, and
                it is not possible to group multiple statements to be managed within a single OTS transaction. Therefore,
        Narayana
                disables
                <code class="varname">AutoCommit</code>
                on JDBC connections before they can be used. If
                <code class="varname">AutoCommit</code>
                is later set to
                <code class="literal">true</code>
                by the application, Narayana
                throws the
                <code class="systemitem">java.sql.SQLException</code>
                .
            </p>
        </div>

        <div class="section" title="2.2.1.3.8. Setting isolation levels"><div class="titlepage"><div><div><h5 class="title"><a id="d5e1625"/>2.2.1.3.8. Setting isolation levels</h5></div></div></div>
            
            <p>
                When you use the Narayana
                JDBC driver, you may need to set the underlying transaction isolation level on the XA
                connection. By default, this is set to
                <code class="literal">TRANSACTION_SERIALIZABLE</code>
                , but another value may be
                more appropriate for your application. To change it, set the property
                <code class="varname">com.arjuna.ats.jdbc.isolationLevel</code>
                to the appropriate isolation level in string form. Example
                values are
                <code class="literal">TRANSACTION_READ_COMMITTED</code>
                or
                <code class="literal">TRANSACTION_REPEATABLE_READ</code>
                .
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    Currently, this property applies to all XA connections created in the JVM.
                </p>
            </div>
        </div>
    </div>
</div>
        <div class="section" title="2.2.2. Examples"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1634"/>2.2.2. Examples</h3></div></div></div>
    

    <div class="section" title="2.2.2.1. JDBC example"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1636"/>2.2.2.1. JDBC example</h4></div></div></div>
        

        <div class="example"><a id="d5e1638"/><p class="title"><strong>Example 2.7. JDBC example</strong></p><div class="example-contents">
            
            <p>
                This simplified example assumes that you are using the transactional JDBC driver provided with .
                For
                details about how to configure and use this driver see the previous Chapter.
            </p>
            <pre><code class="language-java">public class JDBCTest
{
    public static void main (String[] args)
    {
        /*
         */

        Connection conn = null;
        Connection conn2 = null;
        Statement stmt = null;        // non-tx statement
        Statement stmtx = null;  // will be a tx-statement
        Properties dbProperties = new Properties();

        try
            {
                System.out.println("\nCreating connection to database: "+url);

                /*
                 * Create conn and conn2 so that they are bound to the JBossTS
                 * transactional JDBC driver. The details of how to do this will
                 * depend on your environment, the database you wish to use and
                 * whether or not you want to use the Direct or JNDI approach. See
                 * the appropriate chapter in the JTA Programmers Guide.
                 */

                stmt = conn.createStatement();  // non-tx statement

                try
                    {
                        stmt.executeUpdate("DROP TABLE test_table");
                        stmt.executeUpdate("DROP TABLE test_table2");
                    }
                catch (Exception e)
                    {
                        // assume not in database.
                    }

                try
                    {
                        stmt.executeUpdate("CREATE TABLE test_table (a INTEGER,b INTEGER)");
                        stmt.executeUpdate("CREATE TABLE test_table2 (a INTEGER,b INTEGER)");
                    }
                catch (Exception e)
                    {
                    }

                try
                    {
                        System.out.println("Starting top-level transaction.");

                        com.arjuna.ats.jta.UserTransaction.userTransaction().begin();

                        stmtx = conn.createStatement(); // will be a tx-statement

                        System.out.println("\nAdding entries to table 1.");

                        stmtx.executeUpdate("INSERT INTO test_table (a, b) VALUES (1,2)");

                        ResultSet res1 = null;

                        System.out.println("\nInspecting table 1.");

                        res1 = stmtx.executeQuery("SELECT * FROM test_table");
                        while (res1.next())
                            {
                                System.out.println("Column 1: "+res1.getInt(1));
                                System.out.println("Column 2: "+res1.getInt(2));
                            }

                        System.out.println("\nAdding entries to table 2.");

                        stmtx.executeUpdate("INSERT INTO test_table2 (a, b) VALUES (3,4)");
                        res1 = stmtx.executeQuery("SELECT * FROM test_table2");
                        System.out.println("\nInspecting table 2.");

                        while (res1.next())
                            {
                                System.out.println("Column 1: "+res1.getInt(1));
                                System.out.println("Column 2: "+res1.getInt(2));
                            }
                        System.out.print("\nNow attempting to rollback changes.");
                        com.arjuna.ats.jta.UserTransaction.userTransaction().rollback();

                        com.arjuna.ats.jta.UserTransaction.userTransaction().begin();
                        stmtx = conn.createStatement();
                        ResultSet res2 = null;

                        System.out.println("\nNow checking state of table 1.");

                        res2 = stmtx.executeQuery("SELECT * FROM test_table");
                        while (res2.next())
                            {
                                System.out.println("Column 1: "+res2.getInt(1));
                                System.out.println("Column 2: "+res2.getInt(2));
                            }

                        System.out.println("\nNow checking state of table 2.");

                        stmtx = conn.createStatement();
                        res2 = stmtx.executeQuery("SELECT * FROM test_table2");
                        while (res2.next())
                            {
                                System.out.println("Column 1: "+res2.getInt(1));
                                System.out.println("Column 2: "+res2.getInt(2));
                            }

                        com.arjuna.ats.jta.UserTransaction.userTransaction().commit(true);
                    }
                catch (Exception ex)
                    {
                        ex.printStackTrace();
                        System.exit(0);
                    }
            }
        catch (Exception sysEx)
            {
                sysEx.printStackTrace();
                System.exit(0);
            }
    }
</code></pre>
        </div></div><br class="example-break"/>
    </div>

    <div class="section" title="2.2.2.2. Failure recovery example with BasicXARecovery"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1642"/>2.2.2.2. Failure recovery example with BasicXARecovery</h4></div></div></div>
        
        <p>
            This class implements the
            <code class="interfacename">XAResourceRecovery</code>
            interface for XAResources. The parameter supplied in
            <code class="varname">setParameters</code>
            can contain arbitrary information necessary to initialize the class once created. In this example, it
            contains the
            name of the property file in which the database connection information is specified, as well as the number of
            connections that this file contains information on. Each item is separated by a semicolon.
        </p>
        <p>
            This is only a small example of the sorts of things an XAResourceRecovery implementer could do. This implementation
            uses a property file that is assumed to contain sufficient information to recreate connections used during the
            normal run of an application so that recovery can be performed on them. Typically, user-names and passwords should
            never be presented in raw text on a production system.
        </p>
        <div class="example"><a id="d5e1648"/><p class="title"><strong>Example 2.8. Database parameter format for the properties file</strong></p><div class="example-contents">
            
            <pre class="screen">
 DB_x_DatabaseURL=
 DB_x_DatabaseUser=
 DB_x_DatabasePassword=
 DB_x_DatabaseDynamicClass=
      </pre>
            <p>
                <em class="replaceable"><code>x</code></em>
                is the number of the connection information.
            </p>
        </div></div><br class="example-break"/>
        <p>
            Some error-handling code is missing from this example, to make it more readable.
        </p>
        <div class="example"><a id="d5e1654"/><p class="title"><strong>Example 2.9. Failure recovery example with BasicXARecovery</strong></p><div class="example-contents">
            
            <pre><code class="language-java">/*
 * Some XAResourceRecovery implementations will do their startup work here,
 * and then do little or nothing in setDetails. Since this one needs to know
 * dynamic class name, the constructor does nothing.
 */

public BasicXARecovery () throws SQLException
{
    numberOfConnections = 1;
    connectionIndex = 0;
    props = null;
}

/**
 * The recovery module will have chopped off this class name already. The
 * parameter should specify a property file from which the url, user name,
 * password, etc. can be read.
 * 
 * @message com.arjuna.ats.internal.jdbc.recovery.initexp An exception
 *          occurred during initialisation.
 */

public boolean initialise (String parameter) throws SQLException
{
    if (parameter == null) 
        return true;

    int breakPosition = parameter.indexOf(BREAKCHARACTER);
    String fileName = parameter;

    if (breakPosition != -1)
        {
            fileName = parameter.substring(0, breakPosition - 1);

            try
                {
                    numberOfConnections = Integer.parseInt(parameter
                                                           .substring(breakPosition + 1));
                }
            catch (NumberFormatException e)
                {
                    return false;
                }
        }

    try
        {
            String uri = com.arjuna.common.util.FileLocator
                .locateFile(fileName);
            jdbcPropertyManager.propertyManager.load(XMLFilePlugin.class
                                                     .getName(), uri);

            props = jdbcPropertyManager.propertyManager.getProperties();
        }
    catch (Exception e)
        {
            return false;
        }

    return true;
}

/**
 * @message com.arjuna.ats.internal.jdbc.recovery.xarec {0} could not find
 *          information for connection!
 */

public synchronized XAResource getXAResource () throws SQLException
{
    JDBC2RecoveryConnection conn = null;

    if (hasMoreResources())
        {
            connectionIndex++;

            conn = getStandardConnection();

            if (conn == null) conn = getJNDIConnection();
        }

    return conn.recoveryConnection().getConnection().getXAResource();
}

public synchronized boolean hasMoreResources ()
{
    if (connectionIndex == numberOfConnections) 
        return false;
    else
        return true;
}

private final JDBC2RecoveryConnection getStandardConnection ()
    throws SQLException
{
    String number = new String("" + connectionIndex);
    String url = new String(dbTag + number + urlTag);
    String password = new String(dbTag + number + passwordTag);
    String user = new String(dbTag + number + userTag);
    String dynamicClass = new String(dbTag + number + dynamicClassTag);

    Properties dbProperties = new Properties();

    String theUser = props.getProperty(user);
    String thePassword = props.getProperty(password);

    if (theUser != null)
        {
            dbProperties.put(TransactionalDriver.userName, theUser);
            dbProperties.put(TransactionalDriver.password, thePassword);

            String dc = props.getProperty(dynamicClass);

            if (dc != null)
                dbProperties.put(TransactionalDriver.dynamicClass, dc);

            return new JDBC2RecoveryConnection(url, dbProperties);
        }
    else
        return null;
}

private final JDBC2RecoveryConnection getJNDIConnection ()
    throws SQLException
{
    String number = new String("" + connectionIndex);
    String url = new String(dbTag + jndiTag + number + urlTag);
    String password = new String(dbTag + jndiTag + number + passwordTag);
    String user = new String(dbTag + jndiTag + number + userTag);

    Properties dbProperties = new Properties();

    String theUser = props.getProperty(user);
    String thePassword = props.getProperty(password);

    if (theUser != null)
        {
            dbProperties.put(TransactionalDriver.userName, theUser);
            dbProperties.put(TransactionalDriver.password, thePassword);

            return new JDBC2RecoveryConnection(url, dbProperties);
        }
    else
        return null;
}

private int numberOfConnections;
private int connectionIndex;
private Properties props;
private static final String dbTag = "DB_";
private static final String urlTag = "_DatabaseURL";
private static final String passwordTag = "_DatabasePassword";
private static final String userTag = "_DatabaseUser";
private static final String dynamicClassTag = "_DatabaseDynamicClass";
private static final String jndiTag = "JNDI_";

/*
 * Example:
 * 
 * DB2_DatabaseURL=jdbc\:arjuna\:sequelink\://qa02\:20001
 * DB2_DatabaseUser=tester2 DB2_DatabasePassword=tester
 * DB2_DatabaseDynamicClass=com.arjuna.ats.internal.jdbc.drivers.sequelink_5_1
 * 
 * DB_JNDI_DatabaseURL=jdbc\:arjuna\:jndi DB_JNDI_DatabaseUser=tester1
 * DB_JNDI_DatabasePassword=tester DB_JNDI_DatabaseName=empay
 * DB_JNDI_Host=qa02 DB_JNDI_Port=20000
 */
private static final char BREAKCHARACTER = ';'; // delimiter for parameters
</code></pre>
            <p>
                You can use the class
                <code class="classname">com.arjuna.ats.internal.jdbc.recovery.JDBC2RecoveryConnection</code>
                to
                create a new connection to the database using the same parameters used to create the initial connection.
            </p>
        </div></div><br class="example-break"/>
    </div>
</div>
        <div class="section" title="2.2.3. Using Narayana in application servers"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1659"/>2.2.3. Using Narayana
        in application servers
    </h3></div></div></div>
    
    <p>
    WildFly Application Server
        is discussed here. Refer to the documentation for your application server for differences.
    </p>
    <div class="section" title="2.2.3.1. Configuration"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1662"/>2.2.3.1. Configuration</h4></div></div></div>
        
        <p>
            When Narayana
            runs embedded in WildFly Application Server,
            the transaction subsystem is configured primarily through the
            <code class="filename">jboss-cli</code>
            configuration tool, which overrides properties read from the default properties
            file mbedded in the
            <code class="filename">.jar</code>
            file.
        </p>
        <div class="table"><a id="d5e1667"/><p class="title"><strong>Table 2.1. Common configuration attributes</strong></p><div class="table-contents">
            
            <table summary="Common configuration attributes" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>default-timeout</td><td>
                            <p>
                                The default transaction timeout to be used for new transactions. Specified as an integer in seconds.
                            </p>
                        </td></tr><tr><td>enable-statistics</td><td>
                            <p>
                                This determines whether or not the transaction service should gather statistical information. This
                                information can then be viewed using the TransactionStatistics MBean. Specified as a Boolean. The
                                default is to not gather this information.
                            </p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>
        <p>
            See the
            <code class="filename">jboss-cli</code>
            tool and the WildFly Application Server
            administration and configuration guide for further
            information.
        </p>
    </div>

    <div class="section" title="2.2.3.2. Logging"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1681"/>2.2.3.2. Logging</h4></div></div></div>
        
        <p>
            To make 
            logging semantically consistent with WildFly Application Server,
            the
            <code class="interfacename">TransactionManagerService</code>
            modifies the level of some log messages, by overriding
            the value of the
            <code class="varname">LoggingEnvironmentBean.loggingFactory</code>
            property in the
            <code class="filename">jbossts-properties.xml</code>
            file. Therefore, the value of this property has no effect on the
            logging behavior when running embedded in WildFly Application Server.
            By forcing use of the
            <code class="systemitem">log4j_releveler</code>
            logger, the
            <code class="interfacename">TransactionManagerService</code>
            changes the level of all
            <code class="literal">INFO</code>
            level messages in the transaction code to
            <code class="literal">DEBUG</code>
            . Therefore, these
            messages do not appear in log files if the filter level is
            <code class="literal">INFO</code>
            . All other log messages behave
            as normal.
        </p>
    </div>

    <div class="section" title="2.2.3.3. The services"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1692"/>2.2.3.3. The services</h4></div></div></div>
        
        <p>
            The
            <code class="interfacename">TransactionManager</code>
            bean provides transaction management services to other
            components in WildFly Application Server.
            There are two different version of this bean and they requires different configuration.
            Use
            <code class="filename">jboss-cli</code>
            to select JTA or JTS mode.
        </p>
    </div>

    <div class="section" title="2.2.3.4. Ensuring transactional context is propagated to the server"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1697"/>2.2.3.4. Ensuring transactional context is propagated to the server</h4></div></div></div>
        
        <p>
            You can coordinate transactions from a coordinator which is not located within the WildFly Application Server,
            such as when using transactions created by an external OTS server. To ensure the transaction context is
            propagated via
            JRMP invocations to the server, the transaction propagation context factory needs to be explicitly set for the
            JRMP invoker proxy. This is done as follows:
        </p>
        <pre><code class="language-java">JRMPInvokerProxy.setTPCFactory( new com.arjuna.ats.internal.jbossatx.jts.PropagationContextManager() );
</code></pre>
    </div>


</div>
    </div>
    <div class="section" title="2.3. Installation"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1701"/>2.3. Installation</h2></div></div></div>
        
        <div class="section" title="2.3.1. Preparing Your System"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1703"/>2.3.1. Preparing Your System</h3></div></div></div>
    
    <div class="procedure" title="Procedure 2.2. Pre-Installation Steps"><a id="d5e1705"/><p class="title"><strong>Procedure 2.2. Pre-Installation Steps</strong></p><p>
            Before installing the Narayana
            software, we recommend the following administrative steps be taken, assuming a default configuration for Narayana.
        </p><ol class="procedure" type="1"><li class="step" title="Install the distribution into the required location.">
            <p class="title"><strong>Install the distribution into the required location.</strong></p>
            <p>
                Typically, the distribution is extracted from a
                <code class="filename">.ZIP</code>
                file.
            </p>
        </li><li class="step" title="Specify the Location for the Object Store">
            <p class="title"><strong>Specify the Location for the Object Store</strong></p>
            <p>
   Narayana
                requires a minimum object store for storing the outcome of transactions in the event of system crashes.
                The location of this should be specified in the properties file using the
                <span class="property">ObjectStoreEnvironmentBean.objectStoreDir</span>
                key or by using environment
                variable:
            </p>
            <pre class="screen"><span class="command"><strong>java –DObjectStoreEnvironmentBean.objectStoreDir =C:\temp foo.</strong></span></pre>
        </li><li class="step" title="Optional: Specify the sub-directory within the Object Store root.">
            <p class="title"><strong>Optional: Specify the sub-directory within the Object Store root.</strong></p>
            <p>
                By default, all object states will be stored within the
                <code class="filename">defaultStore/</code>
                sub-directory of the
                object store root. For instance, if the object store root is
                <code class="filename">/usr/local/Arjuna/TransactionService/ObjectStore</code>
                , the subdirectory
                <code class="filename">/usr/local/Arjuna/TransactionService/ObjectStore/defaultStore/</code>
                is used.
            </p>
            <p>
                To change this subdirectory, set the
                <span class="property">ObjectStoreEnvironmentBean.localOSRoot</span>
                or
                <span class="property">com.arjuna.ats.arjuna.objectstore.localOSRoot</span>
                property variable accordingly.
            </p>
        </li></ol></div>
</div>
        <div class="section" title="2.3.2. Operating System Services"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1727"/>2.3.2. Operating System Services</h3></div></div></div>
    

    <div class="section" title="2.3.2.1. Microsoft Windows Server"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1729"/>2.3.2.1. Microsoft Windows Server</h4></div></div></div>
        
        <p>
            Four scripts, located in the
            <code class="filename">Services\bin\windows</code>
            folder, install and uninstall the recovery manager and transaction server services.
        </p>
        <div class="variablelist" title="Installation Scripts for Microsoft Windows"><p class="title"><strong>Installation Scripts for Microsoft Windows</strong></p><dl><dt><span class="term">Recovery Manager Service</span></dt><dd>
                    <p>
                        <code class="filename">InstallRecoveryManagerService-NT.bat</code>
                    </p>
                </dd><dt><span class="term">Transaction Server</span></dt><dd>
                    <p>
                        <code class="filename">InstallTransactionServiceService-NT.bat</code>
                    </p>
                </dd></dl></div>
        <div class="variablelist" title="Uninstallation Scripts for Microsoft Windows"><p class="title"><strong>Uninstallation Scripts for Microsoft Windows</strong></p><dl><dt><span class="term">Recovery Manager Service</span></dt><dd>
                    <p>
                        <code class="filename">UninstallRecoveryManagerService-NT.bat</code>
                    </p>
                </dd><dt><span class="term">Transaction Server</span></dt><dd>
                    <p>
                        <code class="filename">UninstallTransactionServerService-NT.bat</code>
                    </p>
                </dd></dl></div>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                Each of the scripts requires administrative privileges.
            </p>
        </div>
        <p>
            After running any of the scripts, a status message indicates success or failure.
        </p>

    </div>

    <div class="section" title="2.3.2.2. Linux / UNIX"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1760"/>2.3.2.2. Linux / UNIX</h4></div></div></div>
        

        <div class="procedure" title="Procedure 2.3. Installing Services in Linux / UNIX"><a id="d5e1762"/><p class="title"><strong>Procedure 2.3. Installing Services in Linux / UNIX</strong></p><ol class="procedure" type="1"><li class="step" title="Log into the system with root privileges.">
                <p class="title"><strong>
                    Log into the system with
                    <code class="systemitem">root</code>
                    privileges.
                </strong></p>
                <p>
                    The installer needs these privileges to create files in
                    <code class="filename">/etc</code>
                    .
                </p>
            </li><li class="step" title="Change to JBOSS_HOME /services/installer directory.">
                <p class="title"><strong>
                    Change to
                    <code class="filename">
                        <em class="replaceable"><code>JBOSS_HOME</code></em>
                        /services/installer
                    </code>
                    directory.
                </strong></p>
                <p>
                    <code class="filename">
                        <em class="replaceable"><code>JBOSS_HOME</code></em>
                    </code>
                    refers to the directory where you extracted Narayana.
                </p>
            </li><li class="step" title="Set the JAVA_HOME variable, if necessary.">
                <p class="title"><strong>
                    Set the
                    <code class="varname">JAVA_HOME</code>
                    variable, if necessary.
                </strong></p>
                <p>
                    Set the
                    <code class="varname">JAVA_HOME</code>
                    variable to the
                    <em class="firstterm">base directory</em>
                    of the JVM the service will use. The base directory is the directory above
                    <code class="filename">bin/java</code>
                    .
                </p>
                <ol type="a" class="substeps">
                    <li class="step" title="Step 3.a">
                        <p>
                            Bash:
                            <span class="command"><strong>export JAVA_HOME="/opt/java"</strong></span>
                        </p>
                    </li>
                    <li class="step" title="Step 3.b">
                        <p>
                            CSH:
                            <span class="command"><strong>setenv JAVA_HOME="/opt/java"</strong></span>
                        </p>
                    </li>
                </ol>
            </li><li class="step" title="Run the installer script.">
                <p class="title"><strong>Run the installer script.</strong></p>
                <p>
                    <span class="command"><strong>./install_service.sh</strong></span>
                </p>
            </li><li class="step" title="The start-up and shut-down scripts are installed.">
                <p class="title"><strong>The start-up and shut-down scripts are installed.</strong></p>
                <p>Information similar to the output below is displayed.</p>
                <pre class="screen">
     Adding $JAVA_HOME (/opt/java) to $PATH in
     /opt/arjuna/ats-3.2/services/bin/solaris/recoverymanagerservice.sh
     Adding $JAVA_HOME (/opt/java) to $PATH in
     /opt/arjuna/ats-3.2/services/bin/solaris/transactionserverservice.sh
     Installing shutdown scripts into /etc/rcS.d:
     K01recoverymanagerservice
     K00transactionserverservice
     Installing shutdown scripts into /etc/rc0.d:
     K01recoverymanagerservice
     K00transactionserverservice
     Installing shutdown scripts into /etc/rc1.d:
     K01recoverymanagerservice
     K00transactionserverservice
     Installing shutdown scripts into /etc/rc2.d:
     K01recoverymanagerservice
     K00transactionserverservice
     Installing startup scripts into /etc/rc3.d:
     S98recoverymanagerservice
     S99transactionserverservice
   </pre>
                <p>
                    The start-up and shut-down scripts are installed for each run-level. Depending on your specific operating system, you
                    may need to explicitly enable the services for automatic start-up.
                </p>
            </li></ol></div>

        <div class="procedure" title="Procedure 2.4. Uninstalling Services in Linux / UNIX"><a id="d5e1799"/><p class="title"><strong>Procedure 2.4. Uninstalling Services in Linux / UNIX</strong></p><ol class="procedure" type="1"><li class="step" title="Log into the system with root privileges.">
                <p class="title"><strong>
                    Log into the system with
                    <code class="systemitem">root</code>
                    privileges.
                </strong></p>
                <p>
                    The installer needs these privileges to delete files in
                    <code class="filename">/etc</code>
                    .
                </p>
            </li><li class="step" title="Change to JBOSS_HOME /services/installer directory.">
                <p class="title"><strong>
                    Change to
                    <code class="filename">
                        <em class="replaceable"><code>JBOSS_HOME</code></em>
                        /services/installer
                    </code>
                    directory.
                </strong></p>
                <p>
                    <code class="filename">
                        <em class="replaceable"><code>JBOSS_HOME</code></em>
                    </code>
                    refers to the directory where you extracted Narayana.
                </p>
            </li><li class="step" title="Run the installation script with the -u option.">
                <p class="title"><strong>
                    Run the installation script with the
                    <code class="option">-u</code>
                    option.
                </strong></p>
                <p>
                    <span class="command"><strong>./install_services.sh -u</strong></span>
                </p>
            </li><li class="step" title="The start-up and shut-down scripts are removed.">
                <p class="title"><strong>The start-up and shut-down scripts are removed.</strong></p>
                <p>
                    Messages like the ones below indicate that the start-up and shut-down scripts have been removed successfully.
                </p>
                <pre class="screen">
     Removing startup scripts from /etc/rc3.d:
     S98recoverymanagerservice
     S99transactionserverservice
     Removing shutdown scripts from /etc/rcS.d:
     K01recoverymanagerservice
     K00transactionserverservice
     Removing shutdown scripts from /etc/rc0.d:
     K01recoverymanagerservice
     K00transactionserverservice
     Removing shutdown scripts from /etc/rc1.d:
     K01recoverymanagerservice
     K00transactionserverservice
     Removing shutdown scripts from /etc/rc2.d:
     K01recoverymanagerservice
     K00transactionserverservice
   </pre>
            </li></ol></div>
    </div>
</div>
        <div class="section" title="2.3.3. Logging"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1822"/>2.3.3. Logging</h3></div></div></div>
    
    <p>
        The recovery manager and the transaction server services produce log files which are located in the
        <code class="filename">services/logs/</code>
        directory. Two log files are created per service.
    </p>
    <div class="variablelist"><dl><dt><span class="term">
                <code class="filename">
                    <em class="replaceable"><code>service-name</code></em>
                    -service.log
                </code>
            </span></dt><dd>
                <p>
                    Contains information regarding whether the service is stopped, started, restarted, or in another state.
                </p>
            </dd><dt><span class="term">
                <code class="filename">
                    <em class="replaceable"><code>service-name</code></em>
                    .log
                </code>
            </span></dt><dd>
                <p>
                    Contains information logged from the actual service.
                </p>
            </dd></dl></div>
    <p>
        To configure what information is logged in these files, edit the appropriate LOG4J configuration files located
        in
        <code class="filename">services/config/</code>
        .
    </p>
</div>
        <div class="section" title="2.3.4. Additional JAR Requirements"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1841"/>2.3.4. Additional JAR Requirements</h3></div></div></div>
    
    <p>
        To use all of the facilities available within Narayana,
        you need to add all of the JAR files contained in the
        <code class="filename">lib/</code>
        directory of the distribution to the
        <code class="varname">CLASSPATH</code>
        .
    </p>
</div>
        <div class="section" title="2.3.5. Setting Properties"><div class="titlepage"><div><div><h3 class="title"><a id="chap-JBossJTA_Installation_Guide-Test_Chapter"/>2.3.5. Setting Properties</h3></div></div></div>
    
    <p>
    Narayana
        has been designed to be highly configurable at runtime through
        the use of various property attributes. 
        Although these attributes can be provided at runtime
        on the command line, it may be more convenient to specify them through a
        single properties file or via
        <code class="methodname">setter</code>
        methods on the
        beans. At runtime, Narayana
        looks for the file
        <code class="filename">jbossts-properties.xml</code>
        , in a specific search order.
    </p>
    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            <p>
                A location specified by a system property
                , allowing the normal search path to be overridden.
            </p>
        </li><li class="listitem">
            <p>The directory from which the application was executed.</p>
        </li><li class="listitem">
            <p>The
                home directory of the user that launched Narayana.
            </p>
        </li><li class="listitem">
            <p>
                <code class="varname">java.home</code>
            </p>
        </li><li class="listitem">
            <p>
                The
                <code class="varname">CLASSPATH</code>
                , which normally includes the installation's
                <code class="filename">etc/</code>
                directory.
            </p>
        </li><li class="listitem">
            <p>
                A default set of properties embedded in the
                <code class="filename">JAR</code>
                file.
            </p>
        </li></ol></div>
    <p>
        Where properties are defined in both the system properties by using the
        <em class="parameter"><code>-D</code></em>
        switch, and in the
        properties file, the value from the system property takes precedence. This facilitates overriding individual
        properties easily on the command line.
    </p>
    <p>
        The properties file uses
        <code class="filename">java.uil.Properties</code>
        XML format, for example:
    </p>
    <pre><code class="no-highlight">
    
&lt;entry key="CoordinatorEnvironmentBean.asyncCommit"&gt;NO&lt;/entry&gt;
&lt;entyr key="ObjectStoreEnvironmentBean.objectStoreDir"&gt;/var/ObjectStore&lt;/entry&gt;
     
  </code></pre>
    <p>
        You can override the name of the properties file at runtime by specifying a new file using the
        <code class="varname">com.arjuna.ats.arjuna.common.propertiesFile</code>
        attribute variable.
    </p>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            Unlike earlier releases, there is no longer one properties file name per module. This properties file name
            key is
            now global for all 
            components in the JVM.
        </p>
    </div>
</div>
    </div>
    <div class="section" title="2.4. Quick Start to JTA"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1877"/>2.4. Quick Start to JTA</h2></div></div></div>
    
    <div class="section" title="2.4.1. Introduction"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1879"/>2.4.1. Introduction</h3></div></div></div>
        
        <p>This chapter will briefly cover the key features required to construct a JTA application. It is assumed
            that the reader is familiar with the
            concepts of the JTA.
        </p>
    </div>
    <div class="section" title="2.4.2. Package layout"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1882"/>2.4.2. Package layout</h3></div></div></div>
        
        <p>The key Java packages (and corresponding jar files) for writing basic JTA applications are:</p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>com.arjuna.ats.jts:
                    this package contains the 
                    implementations of the JTS and JTA.
                </p>
            </li><li class="listitem">
                <p>com.arjuna.ats.jta: this package contains local and remote JTA implementation support.</p>
            </li><li class="listitem">
                <p>com.arjuna.ats.jdbc: this package contains transactional JDBC support.</p>
            </li></ul></div>
        <p>All
            of these packages appear in the lib directory of the 
            installation, and should be added to the programmer’s CLASSPATH.
        </p>
        <p>In
            order to fully utilize all of the facilities available within ,
            it will be necessary to add some additional jar files to your
            classpath. See bin/setup-env.sh or bin\setup-env.bat for details.
        </p>
    </div>
    <div class="section" title="2.4.3. Setting properties"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1894"/>2.4.3. Setting properties</h3></div></div></div>
        
        <p>Narayana
            has also been designed to be configurable at runtime through the use of various property attributes. These
            attributes can be
            provided at runtime on command line or specified through a properties file.
        </p>
        <div class="section" title="2.4.3.1. Specifying the object store location"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1897"/>2.4.3.1. Specifying the object store location</h4></div></div></div>
            
            <p>Narayana
                requires an object store in order to persistently record the outcomes of transactions in the event of
                failures. In order to
                specify the location of the object store it is necessary to specify the location when the application is executed; for
                example:
            </p>
            <p>
                </p><pre><code class="language-java">java –DObjectStoreEnvironmentBean.objectStoreDir=/var/tmp/ObjectStore myprogram</code></pre><p>
            </p>
            <p>The default location is a directory under the current execution directory.</p>
            <p>By default, all object states will be stored within the defaultStore subdirectory of the object store
                root, e.g.,
                /usr/local/Arjuna/TransactionService/ObjectStore/defaultStore. However, this subdirectory can be changed by setting the
                ObjectStoreEnvironmentBean.localOSRoot property variable accordingly.
            </p>
        </div>
    </div>
    <div class="section" title="2.4.4. Demarcating Transactions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1904"/>2.4.4. Demarcating Transactions</h3></div></div></div>
        
        <p>The
            Java Transaction API consists of three elements: a high-level application transaction demarcation interface,
            a high-level transaction
            manager interface intended for application server, and a standard Java mapping of the X/Open XA protocol intended for
            transactional resource
            manager. All of the JTA classes and interfaces occur within the jakarta.transaction package, and the corresponding Narayana
            implementations within
            the com.arjuna.ats.jta package.
        </p>
        <div class="section" title="2.4.4.1. UserTransaction"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1907"/>2.4.4.1. UserTransaction</h4></div></div></div>
            
            <p>The UserTransaction interface provides applications with the ability to control transaction
                boundaries. </p>
            <p>In Narayana,
                UserTransaction can be obtained from the static com.arjuna.ats.jta.UserTransaction.userTransaction()
                method. When obtained
                the UserTransaction object can be used to control transactions
            </p>
            <div class="example"><a id="d5e1911"/><p class="title"><strong>Example 2.10. User Transaction Example</strong></p><div class="example-contents">
                
                <pre><code class="language-java"> //get UserTransaction 
UserTransaction utx = com.arjuna.ats.jta.UserTransaction.userTransaction();
// start transaction work..
utx.begin();

// perform transactional work

utx.commit();
 </code></pre>
            </div></div><br class="example-break"/>
        </div>
        <div class="section" title="2.4.4.2. TransactionManager"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1914"/>2.4.4.2. TransactionManager</h4></div></div></div>
            
            <p>The TransactionManager interface allows the application server to control transaction boundaries on
                behalf of the application being
                managed.
            </p>
            <p>In Narayana,
                transaction manager implementations can be obtained from the static
                com.arjuna.ats.jta.TransactionManager.transactionManager() method
            </p>
        </div>
        <div class="section" title="2.4.4.3. The Transaction interface"><div class="titlepage"><div><div><h4 class="title"><a id="d5e1918"/>2.4.4.3. The Transaction interface</h4></div></div></div>
            
            <p>The Transaction interface allows operations to be performed on the transaction associated with the
                target object. Every top-level
                transaction is associated with one Transaction object when the transaction is created. The Transaction object can be used to:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>enlist the transactional resources in use by the application.</p>
                </li><li class="listitem">
                    <p>register for transaction synchronization call backs.</p>
                </li><li class="listitem">
                    <p>commit or rollback the transaction.</p>
                </li><li class="listitem">
                    <p>obtain the status of the transaction.</p>
                </li></ul></div>
            <p>A Transaction object can be obtained using the TransactionManager by invoking the method
                getTransaction() method.</p>
            <p>
                </p><pre><code class="language-java">Transaction txObj = TransactionManager.getTransaction();</code></pre><p>
            </p>
        </div>
    </div>
    <div class="section" title="2.4.5. Local vs Distributed JTA implementations"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1933"/>2.4.5. Local vs Distributed JTA implementations</h3></div></div></div>
        
        <p>In order to ensure interoperability between JTA applications, it is recommended to rely on the JTS/OTS
            specification to ensure transaction
            propagation among transaction managers.
        </p>
        <p>In order to select the local JTA implementation it is necessary to perform the following steps:</p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>make sure the property JTAEnvironmentBean.jtaTMImplementation is set to
                    com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple.
                </p>
            </li><li class="listitem">
                <p>make sure the property JTAEnvironmentBean.jtaUTImplementation is set to
                    com.arjuna.ats.internal.jta.transaction.arjunacore.UserTransactionImple.
                </p>
            </li></ul></div>
        <p>In order to select the distributed JTA implementation it is necessary to perform the following steps:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>make sure the property JTAEnvironmentBean.jtaTMImplementation is set to
                    com.arjuna.ats.internal.jta.transaction.jts.TransactionManagerImple.
                </p>
            </li><li class="listitem">
                <p>make sure the property JTAEnvironmentBean.jtaUTImplementation is set to
                    com.arjuna.ats.internal.jta.transaction.jts.UserTransactionImple.
                </p>
            </li></ul></div>
    </div>
    <div class="section" title="2.4.6. JDBC and Transactions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1948"/>2.4.6. JDBC and Transactions</h3></div></div></div>
        
        <p>
            JTS supports the construction of both local and distributed transactional applications which access
            databases using the JDBC APIs.
            JDBC supports two-phase commit of transactions, and is similar to the XA X/Open standard. The JDBC support is found in
            the com.arjuna.ats.jdbc
            package.
        </p>
        <p>The ArjunaJTS approach to incorporating JDBC connections within transactions is to provide transactional
            JDBC drivers through which all
            interactions occur. These drivers intercept all invocations and ensure that they are registered with, and driven by, appropriate
            transactions.
            (There is a single type of transactional driver through which any JDBC driver can be driven. This driver is
            com.arjuna.ats.jdbc.TransactionalDriver, which implements the java.sql.Driver interface.)
        </p>
        <p>Once
            the connection has been established (for example, using the java.sql.DriverManager.getConnection method),
            all operations on the
            connection will be monitored by Narayana.
            Once created, the driver and any connection can be used in the same way as any other JDBC driver or
            connection.
        </p>
        <p>Narayana
            connections can be used within multiple different transactions simultaneously, i.e., different threads, with
            different notions of
            the current transaction, may use the same JDBC connection. Narayana
            does connection pooling for each transaction within the JDBC connection. So,
            although multiple threads may use the same instance of the JDBC connection, internally this may be using a different
            connection instance per
            transaction. With the exception of close, all operations performed on the connection at the application level will only be
            performed on this
            transaction-specific connection.
        </p>
        <p>Narayana
            will automatically register the JDBC driver connection with the transaction via an appropriate resource.
            When the transaction
            terminates, this resource will be responsible for either committing or rolling back any changes made to the underlying database
            via appropriate
            calls on the JDBC driver.
        </p>
    </div>
    <div class="section" title="2.4.7. Configurable options"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1955"/>2.4.7. Configurable options</h3></div></div></div>
        
        <p>The following table shows some of the configuration features, with default values shown in italics. For
            more detailed information, the
            relevant section numbers are provided. You should look at the various Programmers Guides for more options.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>You need to prefix certain properties in this table with the string
                com.arjuna.ats.internal.jta.transaction. The prefix has been removed
                for formatting reasons, and has been replaced by ...
            </p>
        </div>
        <div class="informaltable">
            <table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Configuration Name</th><th>Possible Values</th></tr></thead><tbody><tr><td>
                            <p>com.arjuna.ats.jta.supportSubtransactions</p>
                        </td><td>
                            <p>
                                <span class="emphasis"><em>YES</em></span>
                                NO
                            </p>
                        </td></tr><tr><td>
                            <p>com.arjuna.ats.jta.jtaTMImplementation</p>
                        </td><td>
                            <p>...arjunacore.TransactionManagerImple</p>
                            <p>...jts.TransactionManagerImple
                            </p>
                        </td></tr><tr><td>
                            <p>com.arjuna.ats.jta.jtaUTImplementation</p>
                        </td><td>
                            <p>...arjunacore.UserTransactionImple</p>
                            <p>...jts.UserTransactionImple</p>
                        </td></tr><tr><td>
                            <p>com.arjuna.ats.jta.xaBackoffPeriod</p>
                        </td><td>
                            <p>Time in seconds.</p>
                        </td></tr><tr><td>
                            <p>com.arjuna.ats.jdbc.isolationLevel</p>
                        </td><td>
                            <p>Any supported JDBC isolation level.</p>
                        </td></tr></tbody></table>
        </div>
    </div>
</div>
</div>
    <div class="chapter" title="Chapter 3. JTS"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1995"/>Chapter 3. JTS</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d5e1997">3.1. Administration</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1999">3.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e2015">3.1.2. Starting and Stopping the Transaction Manager</a></span></dt><dt><span class="section"><a href="#d5e2035">3.1.3. OTS and Jakarta EE Transaction Service Management</a></span></dt><dt><span class="section"><a href="#d5e2176">3.1.4. Failure Recovery Administration</a></span></dt><dt><span class="section"><a href="#d5e2285">3.1.5. ORB-specific Configurations</a></span></dt><dt><span class="section"><a href="#d5e2323">3.1.6. Initializing 
        Applications
    </a></span></dt></dl></dd><dt><span class="section"><a href="#d5e2331">3.2. Development</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2333">3.2.1. Transaction Processing Overview</a></span></dt><dt><span class="section"><a href="#d5e2448">3.2.2. 
        Basics
    </a></span></dt><dt><span class="section"><a href="#d5e2612">3.2.3. Introduction to the OTS</a></span></dt><dt><span class="section"><a href="#d5e3706">3.2.4. Constructing an OTS application</a></span></dt><dt><span class="section"><a href="#d5e3924">3.2.5. 
        interfaces for extending the OTS
    </a></span></dt><dt><span class="section"><a href="#d5e4129">3.2.6. Example</a></span></dt><dt><span class="section"><a href="#d5e4273">3.2.7. Trail map</a></span></dt><dt><span class="section"><a href="#d5e6201">3.2.8. Failure Recovery</a></span></dt><dt><span class="section"><a href="#d5e6425">3.2.9. JTA and JTS</a></span></dt><dt><span class="section"><a href="#d5e6443">3.2.10. ORB-specific configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e6450">3.3. ORB Portability</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6452">3.3.1. ORB Portability Introduction</a></span></dt><dt><span class="section"><a href="#d5e6458">3.3.2. ORB Portability API</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e6661">3.4. Quick Start to JTS/OTS</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6663">3.4.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e6666">3.4.2. Package layout</a></span></dt><dt><span class="section"><a href="#d5e6684">3.4.3. Setting properties</a></span></dt><dt><span class="section"><a href="#d5e6701">3.4.4. Starting and terminating the ORB and BOA/POA</a></span></dt><dt><span class="section"><a href="#d5e6715">3.4.5. Specifying the object store location</a></span></dt><dt><span class="section"><a href="#d5e6722">3.4.6. Implicit transaction propagation and interposition</a></span></dt><dt><span class="section"><a href="#d5e6752">3.4.7. Obtaining Current</a></span></dt><dt><span class="section"><a href="#d5e6755">3.4.8. Transaction termination</a></span></dt><dt><span class="section"><a href="#d5e6759">3.4.9. Transaction factory</a></span></dt><dt><span class="section"><a href="#d5e6772">3.4.10. Recovery manager</a></span></dt></dl></dd></dl></div>
    
    <div class="section" title="3.1. Administration"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1997"/>3.1. Administration</h2></div></div></div>
        
        <div class="section" title="3.1.1. Introduction"><div class="titlepage"><div><div><h3 class="title"><a id="d5e1999"/>3.1.1. Introduction</h3></div></div></div>
    
    <p>
        Since the release of 
        4.1, the Web Services Transaction product has been merged into .
    
        is thus a single product that is compliant with all of the major distributed transaction
        standards and specifications.
    </p>
    <p>
        Knowledge of Web Services is not required to administer a 
        installation that only uses the
        CORBA/J2EE component, nor is knowledge of CORBA required to use the Web Services component. This, administrative
        tasks are separated when they touch only one component or the other.
    </p>
    <p>
        Apart from ensuring that the run-time system is executing normally, there is little continuous administration
        needed
        for the Narayana
        software. Refer to
        <a class="xref" href="#important_points_for_administrators" title="Important Points for Administrators">Important Points for Administrators</a>
        for some specific
        concerns.
    </p>
    <div class="itemizedlist" title="Important Points for Administrators"><a id="important_points_for_administrators"/><p class="title"><strong>Important Points for Administrators</strong></p><ul class="itemizedlist"><li class="listitem">
            <p>
                The present implementation of the Narayana
                system provides no security or protection for data. The objects
                stored in the Narayana
                object store are (typically) owned by the user who ran the application that created
                them. The Object Store and Object Manager facilities make no attempt to enforce even the limited form of
                protection that Unix/Windows provides. There is no checking of user or group IDs on access to objects for either
                reading or writing.
            </p>
        </li><li class="listitem">
            <p>
                Persistent objects created in the Object Store never go away unless the StateManager.destroy method is invoked
                on the object or some application program explicitly deletes them. This means that the Object Store gradually
                accumulates garbage (especially during application development and testing phases). At present we have
                no
                automated garbage collection facility. Further, we have not addressed the problem of dangling references. That
                is, a persistent object, A, may have stored a Uid for another persistent object, B, in its passive
                representation on disk. There is nothing to prevent an application from deleting B even though A still contains
                a reference to it. When A is next activated and attempts to access B, a run-time error will occur.
            </p>
        </li><li class="listitem">
            <p>
                There is presently no support for version control of objects or database reconfiguration in the event of
                class
                structure changes. This is a complex research area that we have not addressed. At present, if you change the
                definition of a class of persistent objects, you are entirely responsible for ensuring that existing instances
                of the object in the Object Store are converted to the new representation. The Narayana
                software can neither
                detect nor correct references to old object state by new operation versions or vice versa.
            </p>
        </li><li class="listitem">
            <p>
                Object store management is critically important to the transaction service.
            </p>
        </li></ul></div>
</div>
        <div class="section" title="3.1.2. Starting and Stopping the Transaction Manager"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2015"/>3.1.2. Starting and Stopping the Transaction Manager</h3></div></div></div>
    
    <p>
        By default the transaction manager starts up in an active state such that new transactions can be created
        immediately. If you wish to have more control over this it is possible to set the
        <code class="option">CoordinatorEnvironmentBean.startDisabled</code>
        configuration option to
        <code class="literal">YES</code>
        and in
        which case no transactions can be created until the transaction manager is enabled via a call to method
        <code class="methodname">TxControl.enable</code>
        ).
    </p>
    <p>
        It is possible to stop the creation of new transactions at any time by calling method
        <code class="methodname">TxControl.disable</code>
        . Transactions that are currently executing will not be affected. By
        default recovery will be allowed to continue and the transaction system will still be available to manage recovery
        requests from other instances in a distributed environment. (See the Failure Recovery Guide for further
        details). However, if you wish to disable recovery as well as remove any resources it maintains, then you can pass
        <code class="literal">true</code>
        to method
        <code class="methodname">TxControl.disable</code>
        ; the default is to use
        <code class="literal">false</code>
        .
    </p>
    <p>
        If you wish to shut the system down completely then it may also be necessary to terminate the background
        transaction
        reaper (see the Programmers Guide for information about what the reaper does.) In order to do this you may want to
        first prevent the creation of new transactions (if you are not creating transactions with timeouts then this step is
        not necessary) using method
        <code class="methodname">TxControl.disable</code>
        . Then you should call method
        <code class="methodname">TransactionReaper.terminate</code>
        . This method takes a Boolean parameter: if
        <code class="literal">true</code>
        then the method will wait for the normal timeout periods associated with any transactions to
        expire before terminating the transactions; if
        <code class="methodname">false</code>
        then transactions will be forced to
        terminate (rollback or have their outcome set such that they can only ever rollback) immediately.
    </p>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            if you intent to restart the recovery manager later after having terminated it then you MUST use the
            <code class="methodname">TransactionReapear.terminate</code>
            method with asynchronous behavior set to
            <code class="literal">false</code>
            .
        </p>
    </div>
</div>
        <div class="section" title="3.1.3. OTS and Jakarta EE Transaction Service Management"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2035"/>3.1.3. OTS and Jakarta EE Transaction Service Management</h3></div></div></div>
    

    <div class="section" title="3.1.3.1. Starting the run-time system"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2037"/>3.1.3.1. Starting the run-time system</h4></div></div></div>
        
        <p>
            The 
            run-time support consists of run-time packages and the OTS transaction manager server. By default,
      
            does not use a separate transaction manager server. Instead, transaction managers are co-located with each
            application process to improve performance and improve application fault-tolerance by reducing application
            dependency on other services.
        </p>
        <p>
            When running applications which require a separate transaction manager, set the
            <code class="varname">JTSEnvironmentBean.transactionManager</code>
            environment variable to value
            <code class="literal">YES</code>
            . The system locates the
            transaction manager server in a manner specific to the ORB being used. This method may be any of:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    Being registered with a name server.
                </p>
            </li><li class="listitem">
                <p>
                    Being added to the ORB’s initial references.
                </p>
            </li><li class="listitem">
                <p>
                    Via a 
                    specific references file.
                </p>
            </li><li class="listitem">
                <p>
                    By the ORB’s specific location mechanism (if applicable).
                </p>
            </li></ul></div>
        <p>
            You override the default registration mechanism by using the
            <code class="varname">OrbPortabilityEnvironmentBean.resolveService</code>
            environment variable, which takes the following
            values:
        </p>
        <div class="table"><a id="d5e2054"/><p class="title"><strong>Table 3.1. 
                Possible values of
                <code class="varname">OrbPortabilityEnvironmentBean.resolveService</code>
            </strong></p><div class="table-contents">
            
            <table summary="&#xA;                Possible values of&#xA;                OrbPortabilityEnvironmentBean.resolveService&#xA;            " border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>CONFIGURATION_FILE</td><td>
                            <p>
                                This is the default, and causes the system to use the
                                <code class="filename">CosServices.cfg</code>
                                file.
                            </p>
                        </td></tr><tr><td>NAME_SERVICE</td><td>
                            <p>
                
                                attempts to use a name service to register the transaction factory. If this is not
                                supported, an
                                exception is thrown.
                            </p>
                        </td></tr><tr><td>BIND_CONNECT</td><td>
                            <p>
                
                                uses the ORB-specific bind mechanism. If this is not supported, an exception is thrown.
                            </p>
                        </td></tr><tr><td>RESOLVE_INITIAL_REFERENCES</td><td>
                            <p>
                
                                attempts to register the transaction service with the ORB's initial service references.
                                If the
                                ORB does not support this, an exception is thrown, and another option must be used.
                            </p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>

        <div class="section" title="3.1.3.1.1. OTS configuration file"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2076"/>3.1.3.1.1. OTS configuration file</h5></div></div></div>
            
            <p>
                Similar to the
                <code class="systemitem">resolve_initial_references</code>, 
                supports an initial reference file
                where references for specific services can be stored and used at runtime. The file,
                <code class="filename">CosServices.cfg</code>
                , consists of two columns: the service name (in the case of the OTS server
                TransactionService), and the IOR, separated by a single space.
                <code class="filename">CosServices.cfg</code>
                is located
                at runtime by the following
                <code class="varname">OrbPortabilityEnvironmentBean</code>
                properties:
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
                                <code class="varname">initialReferencesRoot</code>
                            </td><td>
                                <p>
                                    The directory where the file is located, defaulting to the current working directory.
                                </p>
                            </td></tr><tr><td>
                                <code class="varname">initialReferencesFile</code>
                            </td><td>
                                <p>
                                    The name of the configuration file itself,
                                    <code class="literal">CosServices.cfg</code>
                                    by default.
                                </p>
                            </td></tr></tbody></table>
            </div>
            <p>
                The OTS server automatically registers itself in the
                <code class="filename">CosServices.cfg</code>
                file if the
                <code class="varname">OrbPortabilityEnvironmentBean</code>
                option is used, creating the file if necessary. Stale
                information is also automatically removed. Machines sharing the same transaction server should have access to
                this file, or a copy of it locally.
            </p>
            <div class="example"><a id="d5e2100"/><p class="title"><strong>Example 3.1. Example ORB reference file settings</strong></p><div class="example-contents">
                
                <pre class="screen">
          <code class="varname">OrbPortabilityEnvironmentBean.initialReferencesFile</code>=<code class="literal">myFile</code>
          <code class="varname">OrbPortabilityEnvironmentBean.initialReferencesRoot</code>=<code class="literal">/tmp</code>
        </pre>
            </div></div><br class="example-break"/>
        </div>


        <div class="section" title="3.1.3.1.2. Name service"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2107"/>3.1.3.1.2. Name service</h5></div></div></div>
            
            <p>
                If your ORB supports a name service, and 
                is configured to use it, the transaction manager is registered
                with it automatically. There is no further work required.
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    This option is not used for JacORB
                </p>
            </div>
        </div>


        <div class="section" title="3.1.3.1.3. resolve_initial_references"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2112"/>3.1.3.1.3. resolve_initial_references</h5></div></div></div>
            
            <p>
                Currently this option is only supported for JacORB.
            </p>
        </div>

        <div class="section" title="3.1.3.1.4. Resolution services supported per ORB"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2115"/>3.1.3.1.4. Resolution services supported per ORB</h5></div></div></div>
            
            <div class="informaltable">
                <table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Resolution Mechanism</th><th>ORB</th></tr></thead><tbody><tr><td>OTS configuration file</td><td>All available ORBs</td></tr><tr><td>Name Service</td><td>JacORB</td></tr><tr><td>resolve_initial_references</td><td>JacORB</td></tr></tbody></table>
            </div>
        </div>
    </div>

    <div class="section" title="3.1.3.2. XA Specific management"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2133"/>3.1.3.2. XA Specific management</h4></div></div></div>
        
        <p>
            Each XA Xid that 
            creates must have a unique node identifier encoded within it. 
            only recovers
            transactions and states that match a specified node identifier. Provide the node identifier with the
            <code class="varname">CoreEnvironmentBean.nodeIdentifier</code>
            property. This value must be unique across your 
            instances. If you do not provide a value, 
            generates one and reports the value via the logging
            infrastructure.
        </p>
        <p>
            When running XA recovery, you need to specify which types of Xid 
            can recover. Use the
            <code class="varname">JTAEnvironmentBean.xaRecoveryNodes</code>
            property to provide one or more values, in a space-separated
            list.
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
            <p>
                A value of ‘*’ forces 
                to recover, and possibly rollback, all transactions, regardless of their node
                identifier. Use this value with extreme caution.
            </p>
        </div>
    </div>

    <div class="section" title="3.1.3.3. Selecting the JTA implementation"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2141"/>3.1.3.3. Selecting the JTA implementation</h4></div></div></div>
        
        <p>
            Two variants of the JTA implementation are now provided and accessible through the same interface. These are:
        </p>
        <div class="variablelist"><dl><dt><span class="term">Purely local JTA</span></dt><dd>
                    <p>
                        Only non-distributed JTA transactions can be executed. This is the only version available with
                        the Narayana
                        product.
                    </p>
                </dd><dt><span class="term">Remote, CORBA-based JTA</span></dt><dd>
                    <p>
                        Distributed JTA transactions can be executed. This version is only available with the $PARENT_PRODUCT product and
                        requires a supported CORBA ORB.
                    </p>
                </dd></dl></div>
        <p>
            Both of these implementations are fully compatible with the transactional JDBC driver provided with .
        </p>
        <div class="procedure" title="Procedure 3.1. Selecting the local JTA implementation"><a id="d5e2154"/><p class="title"><strong>Procedure 3.1. Selecting the local JTA implementation</strong></p><ol class="procedure" type="1"><li class="step" title="Step 1">
                <p>
                    Set the property
                    <code class="varname">JTAEnvironmentBean.jtaTMImplementation</code>
                    to value
                    <code class="literal">com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple</code>
                    .
                </p>
            </li><li class="step" title="Step 2">
                <p>
                    Set the property
                    <code class="varname">JTAEnvironmentBean.jtaUTImplementation</code>
                    to value
                    <code class="literal">com.arjuna.ats.internal.jta.transaction.arjunacore.UserTransactionImple</code>
                    .
                </p>
            </li></ol></div>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                These settings are the default values for the properties and do not need to be specified if the local
                implementation is required.
            </p>
        </div>
        <div class="procedure" title="Procedure 3.2. Selecting the remote JTA implementation"><a id="d5e2166"/><p class="title"><strong>Procedure 3.2. Selecting the remote JTA implementation</strong></p><ol class="procedure" type="1"><li class="step" title="Step 1">
                <p>
                    Set the property
                    <code class="varname">JTAEnvironmentBean.jtaTMImplementation</code>
                    to value
                    <code class="literal">com.arjuna.ats.internal.jta.transaction.jts..TransactionManagerImple</code>
                    .
                </p>
            </li><li class="step" title="Step 2">
                <p>
                    Set the property
                    <code class="varname">JTAEnvironmentBean.jtaUTImplementation</code>
                    to value
                    <code class="varname">com.arjuna.ats.internal.jta.transaction.jts.UserTransactionImple</code>
                    .
                </p>
            </li></ol></div>
    </div>
</div>
        <div class="section" title="3.1.4. Failure Recovery Administration"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2176"/>3.1.4. Failure Recovery Administration</h3></div></div></div>
    

    <p>
        The failure recovery subsystem of Narayana
        will ensure that results of a transaction are applied consistently to
        all resources affected by the transaction, even if any of the application processes or the machine hosting them
        crash or lose network connectivity. In the case of machine (system) crash or network failure, the recovery will not
        take place until the system or network are restored, but the original application does not need to be
        restarted. Recovery responsibility is delegated to
        <a class="xref" href="#recovery-manager" title="2.1.5.1. The Recovery Manager">Section 2.1.5.1, “The Recovery Manager”</a>
        . Recovery after failure
        requires that information about the transaction and the resources involved survives the failure and is accessible
        afterward: this information is held in the
        <code class="systemitem">ActionStore</code>
        , which is part of the
        <code class="systemitem">ObjectStore</code>
        .
    </p>
    <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
        <p>
            If the
            <code class="systemitem">ObjectStore</code>
            is destroyed or modified, recovery may not be possible.
        </p>
    </div>
    <p>
        Until the recovery procedures are complete, resources affected by a transaction that was in progress at the time
        of
        the failure may be inaccessible. For database resources, this may be reported as tables or rows held by “in-doubt
        transactions”. For
        <span class="application">TransactionalObjects for Java</span>
        resources, an attempt to activate the
        <code class="systemitem">Transactional Object</code>
        (as when trying to get a lock) will fail.
    </p>

    <div class="section" title="3.1.4.1. The Recovery Manager"><div class="titlepage"><div><div><h4 class="title"><a id="recovery-manager"/>3.1.4.1. The Recovery Manager</h4></div></div></div>
        

        <p>
            The failure recovery subsystem of Narayana
            requires that the stand-alone Recovery Manager process be running for
            each
            <code class="systemitem">ObjectStore</code>
            (typically one for each node on the network that is running Narayana
            applications). The
            <code class="filename">RecoveryManager</code>
            file is located in the Narayana
            JAR file within the
            package
            <span class="package">com.arjuna.ats.arjuna.recovery.RecoveryManager</span>
            . To start the Recovery Manager issue the
            following command:
        </p>
        <pre class="screen">
      <span class="command"><strong>java com.arjuna.ats.arjuna.recovery.RecoveryManager</strong></span>
    </pre>
        <p>
            If the
            <em class="parameter"><code>-test</code></em>
            flag is used with the Recovery Manager then it will display a
            <code class="literal">Ready</code>
            message when initialized, i.e.,
        </p>
        <pre class="screen">
      <span class="command"><strong>java com.arjuna.ats.arjuna.recovery.RecoveryManager -test</strong></span>
    </pre>
    </div>

    <div class="section" title="3.1.4.2. Configuring the Recovery Manager"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2201"/>3.1.4.2. Configuring the Recovery Manager</h4></div></div></div>
        
        <p>
            The RecoveryManager reads the properties defined in the
            <code class="filename">jbossts-properties.xml</code>
            file.
        </p>
        <p>
            A default version of
            <code class="filename">jbossts-properties.xml</code>
            is supplied with the distribution. This can
            be used without modification, except possibly the debug tracing fields, as shown in
            <a class="xref" href="#recovery-manager-output" title="2.1.5.3. Output">Section 2.1.5.3, “Output”</a>
            .
        </p>
    </div>

    <div class="section" title="3.1.4.3. Output"><div class="titlepage"><div><div><h4 class="title"><a id="recovery-manager-output"/>3.1.4.3. Output</h4></div></div></div>
        

        <p>
            It is likely that installations will want to have some form of output from the RecoveryManager, to provide a
            record of what recovery activity has taken place. RecoveryManager uses the logging mechanism provided by
            <span class="application">jboss logging</span>
            , which provides a high level interface that
            hides differences that exist between existing logging APIs such Jakarta log4j or JDK logging API.
        </p>
        <p>
            The configuration of
            <span class="application">jboss logging</span>
            depends on the underlying logging framework
            that is used, which is determined by the availability and ordering of alternatives on the classpath. Please
            consult the jboss logging documentation for details. Each log message has an associated
            log Level, that gives the importance and urgency of a log message. The set of possible Log Levels, in order of
            least severity, and highest verbosity, is:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>
                    <code class="literal">TRACE</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">DEBUG</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">INFO</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">WARN</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">ERROR</code>
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">FATAL</code>
                </p>
            </li></ol></div>
        <p>
            Messages describing the start and the periodical behavior made by the RecoveryManager are output using the
            <code class="literal">INFO</code>
            level. If other debug tracing is wanted, the finer debug or trace levels should be set
            appropriately.
        </p>
        <p>
            Setting the normal recovery messages to the
            <code class="literal">INFO</code>
            level allows the RecoveryManager to produce a
            moderate level of reporting. If nothing is going on, it just reports the entry into each module for each periodic
            pass. To disable
            <code class="literal">INFO</code>
            messages produced by the Recovery Manager, the logging level could be set
            to the higher level of
            <code class="literal">ERROR</code>
            , which means that the RecoveryManager will only produce
            <code class="literal">ERROR</code>
            ,
            <code class="literal">WARNING</code>
            , or
            <code class="literal">FATAL</code>
            messages.
        </p>
    </div>

    <div class="section" title="3.1.4.4. Periodic Recovery"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2242"/>3.1.4.4. Periodic Recovery</h4></div></div></div>
        
        <p>
            The RecoveryManager scans the ObjectStore and other locations of information, looking for transactions and
            resources that require, or may require recovery. The scans and recovery processing are performed by recovery
            modules. These recovery modules are instances of classes that implement the
            <code class="interfacename">com.arjuna.ats.arjuna.recovery.RecoveryModule interface</code>
            . Each module has
            responsibility for a particular category of transaction or resource. The set of recovery modules used is
            dynamically loaded, using properties found in the RecoveryManager property file.
        </p>
        <p>
            The interface has two methods:
            <code class="methodname">periodicWorkFirstPass</code>
            and
            <code class="methodname">periodicWorkSecondPass</code>
            . At an interval
            defined by property
            <span class="property">com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod</span>
            , the RecoveryManager
            calls the first pass method on each property, then waits for a brief period, defined by property
            <span class="property">com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod</span>
            . Next, it calls the second pass of each
            module. Typically, in the first pass, the module scans the relevant part of the ObjectStore to find transactions or
            resources that are in-doubt. An in-doubt transaction may be part of the way through the commitment process,
            for
            instance. On the second pass, if any of the same items are still in-doubt, the original application process may have
            crashed, and the item is a candidate for recovery.
        </p>
        <p>
            An attempt by the RecoveryManager to recover a transaction that is still progressing in the original process
            is
            likely to break the consistency. Accordingly, the recovery modules use a mechanism, implemented in the
            <span class="package">com.arjuna.ats.arjuna.recovery.TransactionStatusManager</span>
            package, to check to see if the
            original process is still alive, and if the transaction is still in progress. The RecoveryManager only proceeds
            with recovery if the original process has gone, or, if still alive, the transaction is completed. If a server
            process or machine crashes, but the transaction-initiating process survives, the transaction completes, usually
            generating a warning. Recovery of such a transaction is the responsibility of the RecoveryManager.
        </p>
        <p>
            It is clearly important to set the interval periods appropriately. The total iteration time will be the sum
            of the
            <span class="property">periodicRecoveryPeriod</span>
            and
            <span class="property">recoveryBackoffPeriod</span>
            properties, and the
            length of time it takes to scan the stores and to attempt recovery of any in-doubt transactions found, for all the
            recovery modules. The recovery attempt time may include connection timeouts while trying to communicate with
            processes or machines that have crashed or are inaccessible. There are mechanisms in the recovery system to avoid
            trying to recover the same transaction indefinitely. The total iteration time affects how long a resource will
            remain inaccessible after a failure. –
            <span class="property">periodicRecoveryPeriod</span>
            should be set accordingly. Its
            default is 120 seconds. The
            <span class="property">recoveryBackoffPeriod</span>
            can be comparatively short, and defaults to
            10 seconds. –Its purpose is mainly to reduce the number of transactions that are candidates for recovery and which
            thus require a call to the original process to see if they are still in progress.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                In previous versions of
                <span class="application">Narayana
                </span>
                , there was no contact mechanism, and the back-off
                period needed to be long enough to avoid catching transactions in flight at all. From 3.0, there is no such
                risk.
            </p>
        </div>
        <p>
            Two recovery modules, implementations of the
            <code class="interfacename">com.arjuna.ats.arjuna.recovery.RecoveryModule</code>
            interface, are supplied with
            <span class="application">Narayana
            </span>
            . These modules support various aspects of transaction recovery, including
            JDBC recovery. It is possible for advanced users to create their own recovery modules and register them with the
            Recovery Manager. The recovery modules are registered with the RecoveryManager using
            <code class="methodname">RecoveryEnvironmentBean.recoveryModuleClassNames</code>
            . These will be invoked on each pass of the
            periodic recovery in the sort-order of the property names – it is thus possible to predict the ordering, but a
            failure in an application process might occur while a periodic recovery pass is in progress. The default Recovery
            Extension settings are:
        </p>
        <pre><code class="language-xml">&lt;entry key="RecoveryEnvironmentBean.recoveryModuleClassNames"&gt;
  com.arjuna.ats.internal.arjuna.recovery.AtomicActionRecoveryModule
  com.arjuna.ats.internal.txoj.recovery.TORecoveryModule
  com.arjuna.ats.internal.jts.recovery.transactions.TopLevelTransactionRecoveryModule
  com.arjuna.ats.internal.jts.recovery.transactions.ServerTransactionRecoveryModule
  com.arjuna.ats.internal.jta.recovery.jts.XARecoveryModule
&lt;/entry&gt;
</code></pre>

    </div>

    <div class="section" title="3.1.4.5. Expired Entry Removal"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2266"/>3.1.4.5. Expired Entry Removal</h4></div></div></div>
        

        <p>
            The operation of the recovery subsystem cause some entries to be made in the ObjectStore that are not
            removed in
            normal progress. The RecoveryManager has a facility for scanning for these and removing items that are very
            old. Scans and removals are performed by implementations of the
            <code class="interfacename">com.arjuna.ats.arjuna.recovery.ExpiryScanner</code>
            interface. These implementations are
            loaded by giving the class names as the value of a property
            <span class="property">RecoveryEnvironmentBean.expiryScannerClassNames</span>
            . The RecoveryManager calls the
            <code class="methodname">scan()</code>
            method on each loaded Expiry Scanner implementation at an interval determined by the property
            <span class="property">RecoveryEnvironmentBean.expiryScanInterval</span>
            . This value is given in hours, and defaults to
            12hours. An
            <span class="property">expiryScanInterval</span>
            value of zero suppresses any expiry scanning. If the value
            supplied is positive, the first scan is performed when RecoveryManager starts. If the value is negative, the first
            scan is delayed until after the first interval, using the absolute value.
        </p>
        <p>
            The kinds of item that are scanned for expiry are:
        </p>
        <div class="variablelist"><dl><dt><span class="term">TransactionStatusManager items</span></dt><dd>
                    <p>
                        One TransactionStatusManager item is created by every application process that uses
                        <span class="application">Narayana
                        </span>
                        . It contains the information that allows the RecoveryManager to
                        determine if the process that initiated the transaction is still alive, and its status. The expiry time for
                        these items is set by the property
                        <span class="property">com.arjuna.ats.arjuna.recovery.transactionStatusManagerExpiryTime</span>
                        , expressed in
                        hours. The default is 12, and 0 (zero) means never to expire.The expiry time should be greater than the
                        lifetime of any single processes using
                        <span class="application">Narayana
                        </span>
                        .
                    </p>
                </dd></dl></div>
        <p>
            The Expiry Scanner properties for these are:
        </p>
        <pre><code class="language-xml"> &lt;entry key="RecoveryEnvironmentBean.expiryScannerClassNames"&gt;
    com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner
&lt;/entry&gt;
</code></pre>

    </div>

</div>
        <div class="section" title="3.1.5. ORB-specific Configurations"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2285"/>3.1.5. ORB-specific Configurations</h3></div></div></div>
    

    <div class="section" title="3.1.5.1. JacORB"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2287"/>3.1.5.1. JacORB</h4></div></div></div>
        
        <p>
            For JacORB to function correctly it needs a valid
            <code class="filename">jacorb.properties</code>
            or
            <code class="filename">.jacorb_properties</code>
            file in one of the following places, in searched order:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>
                    The classpath
                </p>
            </li><li class="listitem">
                <p>
                    The home directory of the user running the 
                    Service. The home directory is retrieved using
                    <code class="methodname">System.getProperty( “user.home” );</code>
                </p>
            </li><li class="listitem">
                <p>
                    The current directory
                </p>
            </li><li class="listitem">
                <p>
                    The
                    <code class="filename">lib/</code>
                    directory of the JDK used to run your application. This is retrieved using
                    <code class="methodname">System.getProperty(“java.home” );</code>
                </p>
            </li></ol></div>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                A template
                <code class="filename">jacorb.properties</code>
                file is located in the JacORB installation directory.
            </p>
        </div>
        <p>
            Within the JacORB properties file there are two important properties which must be tailored to suit your
            application.
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    jacorb.poa.thread_pool_max
                </p>
            </li><li class="listitem">
                <p>
                    jacorb.poa.thread_pool_min
                </p>
            </li></ul></div>
        <p>
            These properties specify the minimum and maximum number of request processing threads that JacORB uses in its
            thread pool. If no threads are available, may block until a thread becomes available.. For more information on
            configuring JacORB, refer to the JacORB documentation.
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
            <p>
                JacORB includes its own implementation of the classes defined in the
                <code class="filename">CosTransactions.idl</code>
                file. Unfortunately these are incompatible with the version shipped with .
                Therefore, the
        
                jar files absolutely must appear in the CLASSPATH before any JacORB jars.
            </p>
        </div>
        <p>
            When running the recovery manager, it should always uses the same well-known port for each machine on which
            it
            runs. Do not use the
            <code class="varname">OAPort</code>
            property provided by JacORB unless the recovery manager has its own
            <code class="filename">jacorb.properties</code>
            file or the property is provided on the command line when starting the
            recovery manager. If the recovery manager and other components of 
            share the same
            <code class="filename">jacorb.properties</code>
            file, use the
            <code class="varname">JTSEnvironmentBean.recoveryManagerPort</code>
            and
            <code class="varname">JTSEnvironmentBean.recoveryManagerAddress</code>
            properties.
        </p>
    </div>
</div>
        <div class="section" title="3.1.6. Initializing Applications"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2323"/>3.1.6. Initializing 
        Applications
    </h3></div></div></div>
    
    <p>
    
        most be initialized correctly before any application object is created. To guarantee this, use the
        <code class="methodname">initORB</code>
        and
        <code class="methodname">create_POA</code>
        methods described in the
        <em class="citetitle">Orb
            Portability Guide
        </em>
        . Consult the Orb Portability Guide if you need to use the underlying
        <code class="methodname">ORB_init</code>
        and
        <code class="methodname">create_POA</code>
        methods provided by the ORB instead of the
    
        methods.
    </p>
</div>
    </div>
    <div class="section" title="3.2. Development"><div class="titlepage"><div><div><h2 class="title"><a id="d5e2331"/>3.2. Development</h2></div></div></div>
        
        <div class="section" title="3.2.1. Transaction Processing Overview"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2333"/>3.2.1. Transaction Processing Overview</h3></div></div></div>
    

    <div class="section" title="3.2.1.1. Defining a transaction"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2335"/>3.2.1.1. Defining a transaction</h4></div></div></div>
        
        <p>
            A transaction is a unit of work that encapsulates multiple database actions such that that either all the
            encapsulated actions fail or all succeed.
        </p>
        <p>
            Transactions ensure data integrity when an application interacts with multiple datasources.
        </p>
        <p title="Practical Example">
            <strong>Practical Example. </strong>
            
                If you subscribe to a newspaper using a credit card, you are using a transactional system. Multiple systems are
                involved, and each of the systems needs the ability to roll back its work, and cause the entire
                transaction to
                roll back if necessary. For instance, if the newspaper's subscription system goes offline halfway through your
                transaction, you don't want your credit card to be charged. If the credit card is over its limit, the
                newspaper
                doesn't want your subscription to go through. In either of these cases, the entire transaction should fail of
                any part of it fails. Neither you as the customer, nor the newspaper, nor the credit card processor, wants an
                unpredictable (indeterminate) outcome to the transaction.
            
        </p>
        <p>
            This ability to roll back an operation if any part of it fails is what 
            is all about. This guide
            assists you in writing transactional applications to protect your data.
        </p>
        <p>
            "Transactions" in this guide refers to atomic transactions, and embody the "all-or-nothing" concept outlined
            above. Transactions are used to guarantee the consistency of data in the presence of failures. Transactions
            fulfill the requirements of ACID: Atomicity, Consistency, Isolation, Durability.
        </p>
        <div class="variablelist" title="ACID Properties"><p class="title"><strong>ACID Properties</strong></p><dl><dt><span class="term">Atomicity</span></dt><dd>
                    <p>
                        The transaction completes successfully (commits) or if it fails (aborts) all of its effects are undone
                        (rolled back).
                    </p>
                </dd><dt><span class="term">Consistency</span></dt><dd>
                    <p>
                        Transactions produce consistent results and preserve application specific invariants.
                    </p>
                </dd><dt><span class="term">Isolation</span></dt><dd>
                    <p>
                        Intermediate states produced while a transaction is executing are not visible to others. Furthermore
                        transactions appear to execute serially, even if they are actually executed concurrently.
                    </p>
                </dd><dt><span class="term">Durability</span></dt><dd>
                    <p>
                        The effects of a committed transaction are never lost (except by a catastrophic failure).
                    </p>
                </dd></dl></div>
        <p>
            A transaction can be terminated in two ways: committed or aborted (rolled back). When a transaction is committed,
            all changes made within it are made durable (forced on to stable storage, e.g., disk). When a transaction is
            aborted, all of the changes are undone. Atomic actions can also be nested; the effects of a nested action are
            provisional upon the commit/abort of the outermost (top-level) atomic action.
        </p>
    </div>
    <div class="section" title="3.2.1.2. Commit protocol"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2363"/>3.2.1.2. Commit protocol</h4></div></div></div>
        
        <p>
            A two-phase commit protocol guarantees that all of the transaction participants either commit or abort any
            changes
            made.
            <a class="xref" href="#img-commit-protocol" title="Figure 3.1. Two-Phase Commit">Figure 3.1, “Two-Phase Commit”</a>
            illustrates the main aspects of the commit protocol.
        </p>
        <div class="procedure" title="Procedure 3.3. Two-phase commit protocol"><a id="d5e2367"/><p class="title"><strong>Procedure 3.3. Two-phase commit protocol</strong></p><ol class="procedure" type="1"><li class="step" title="Step 1">
                <p>
                    During phase 1, the action coordinator, C, attempts to communicate with all of the action participants, A and
                    B, to determine whether they will commit or abort.
                </p>
            </li><li class="step" title="Step 2">
                <p>
                    An abort reply from any participant acts as a veto, causing the entire action to abort.
                </p>
            </li><li class="step" title="Step 3">
                <p>
                    Based upon these (lack of) responses, the coordinator chooses to commit or abort the action.
                </p>
            </li><li class="step" title="Step 4">
                <p>
                    If the action will commit, the coordinator records this decision on stable storage, and the protocol enters
                    phase 2, where the coordinator forces the participants to carry out the decision. The coordinator also informs
                    the participants if the action aborts.
                </p>
            </li><li class="step" title="Step 5">
                <p>
                    When each participant receives the coordinator’s phase-one message, it records sufficient information on
                    stable storage to either commit or abort changes made during the action.
                </p>
            </li><li class="step" title="Step 6">
                <p>
                    After returning the phase-one response, each participant who returned a commit response must remain blocked
                    until it has received the coordinator’s phase-two message.
                </p>
            </li><li class="step" title="Step 7">
                <p>
                    Until they receive this message, these resources are unavailable for use by other actions. If the coordinator
                    fails before delivery of this message, these resources remain blocked. However, if crashed machines eventually
                    recover, crash recovery mechanisms can be employed to unblock the protocol and terminate the action.
                </p>
            </li></ol></div>
        <div class="figure"><a id="img-commit-protocol"/><p class="title"><strong>Figure 3.1. Two-Phase Commit</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-img-2phase.png" alt="Two-Phase Commit" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e2385.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e2385.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>

    </div>

    <div class="section" title="3.2.1.3. Transactional proxies"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2390"/>3.2.1.3. Transactional proxies</h4></div></div></div>
        
        <p>
            The action coordinator maintains a transaction context where resources taking part in the action need to be
            registered. Resources must obey the transaction commit protocol to guarantee ACID properties. Typically, the
            resource provides specific operations which the action can invoke during the commit/abort protocol. However, some
            resources may not be able to be transactional in this way. This may happen if you have legacy code which cannot be
            modified. Transactional proxies allow you to use these anomalous resources within an action.
        </p>
        <p>
            The proxy is registered with, and manipulated by, the action as though it were a transactional resource, and the
            proxy performs implementation specific work to make the resource it represents transactional. The proxy must
            participate within the commit and abort protocols. Because the work of the proxy is performed as part of the
            action, it is guaranteed to be completed or undone despite failures of the action coordinator or action
            participants.
        </p>
    </div>

    <div class="section" title="3.2.1.4. Nested transactions"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2394"/>3.2.1.4. Nested transactions</h4></div></div></div>
        
        <p>
            Given a system that provides transactions for certain operations, you can combine them to form another operation,
            which is also required to be a transaction. The resulting transaction’s effects are a combination of the effects
            of its constituent transactions. This paradigm creates the concept of nested subtransactions, and the resulting
            combined transaction is called the enclosing transaction. The enclosing transaction is sometimes referred to
            as
            the parent of a nested (or child) transaction. It can also be viewed as a hierarchical relationship, with a
            top-level transaction consisting of several subordinate transactions.
        </p>
        <p>
            An important difference exists between nested and top-level transactions.
        </p>
        <p>
            The effect of a nested transaction is provisional upon the commit/roll back of its enclosing transactions. The
            effects are recovered if the enclosing transaction aborts, even if the nested transaction has committed.
        </p>
        <p>
            Subtransactions are a useful mechanism for two reasons:
        </p>
        <div class="variablelist"><dl><dt><span class="term">fault-isolation</span></dt><dd>
                    <p>
                        If a subtransaction rolls back, perhaps because an object it is using fails, the enclosing transaction does
                        not need to roll back.
                    </p>
                </dd><dt><span class="term">modularity</span></dt><dd>
                    <p>
                        If a transaction is already associated with a call when a new transaction begins, the new transaction is
                        nested within it. Therefore, if you know that an object requires transactions, you can them within the
                        object. If the object’s methods are invoked without a client transaction, then the object’s transactions are
                        top-level. Otherwise, they are nested within the scope of the client's transactions. Likewise, a client does
                        not need to know whether an object is transactional. It can begin its own transaction.
                    </p>
                </dd></dl></div>
    </div>

    <div class="section" title="3.2.1.5. The Object Transaction Service (OTS)"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2409"/>3.2.1.5. The Object Transaction Service (OTS)</h4></div></div></div>
        
        <p>
            The CORBA architecture, as defined by the OMG, is a standard which promotes the construction of interoperable
            applications that are based upon the concepts of distributed objects. The architecture principally contains
            the
            following components:
        </p>
        <div class="variablelist"><dl><dt><span class="term">Object Request Broker (ORB)</span></dt><dd>
                    <p>
                        Enables objects to transparently send and receive requests in a distributed, heterogeneous environment. This
                        component is the core of the OMG reference model.
                    </p>
                </dd><dt><span class="term">Object Services</span></dt><dd>
                    <p>
                        A collection of services that support functions for using and implementing objects. Such
                        services are
                        necessary for the construction of any distributed application. The Object Transaction Service (OTS) is the
                        most relevant to Narayana.
                    </p>
                </dd><dt><span class="term">Common Facilities</span></dt><dd>
                    <p>
                        Other useful services that applications may need, but which are not considered to be fundamental. Desktop
                        management and help facilities fit this category.
                    </p>
                </dd></dl></div>
        <p>
            The CORBA architecture allows both implementation and integration of a wide variety of object systems. In
            particular, applications are independent of the location of an object and the language in which an object is
            implemented, unless the interface the object explicitly supports reveals such details. As defined in the OMG
            CORBA
            Services documentation,
            <em class="firstterm">object services</em>
            are defined as a collection of services (interfaces
            and objects) that support the basic functions for using and implementing objects. These services are necessary to
            construct distributed application, and are always independent of an application domain. The standards
            specify
            several core services including naming, event management, persistence, concurrency control and transactions.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                The OTS specification allows, but does not require, nested transactions. 
                is a fully compliant version of
                the OTS version 1.1 draft 5, and support nested transactions.
            </p>
        </div>
        <p>
            The transaction service provides interfaces that allow multiple distributed objects to cooperate in a
            transaction,
            committing or rolling back their changes as a group. However, the OTS does not require all objects to have
            transactional behavior. An object's support of transactions can be none at all, for some operations, or
            fully. Transaction information may be propagated between client and server explicitly, or implicitly. You have
            fine-grained control over an object's support of transactions. If your objects supports partial or complete
            transactional behavior, it needs interfaces derived from interface
            <code class="interfacename">TransactionalObject</code>
            .
        </p>
        <p>
            The Transaction Service specification also distinguishes between recoverable objects and transactional
            objects. Recoverable objects are those that contain the actual state that may be changed by a transaction and must
            therefore be informed when the transaction commits or aborts to ensure the consistency of the state changes. This
            is achieved be registering appropriate objects that support the Resource interface (or the derived
            SubtransactionAwareResource interface) with the current transaction. Recoverable objects are also by
            definition
            transactional objects.
        </p>
        <p>
            In contrast, a simple transactional object does not necessarily need to be recoverable if its state is actually
            implemented using other recoverable objects. A simple transactional object does not need to participate the
            commit
            protocol used to determine the outcome of the transaction since it maintains no state information of its own.
        </p>
        <p>
            The OTS is a protocol engine that guarantees obedience to transactional behavior. It does not directly support all
            of the transaction properties, but relies on some cooperating services:
        </p>
        <div class="informaltable">
            <table border="1"><colgroup><col width="200px"/><col width="240px"/></colgroup><tbody><tr><td>Persistence/Recovery Service</td><td>
                            <p>
                                Supports properties of atomicity and durability.
                            </p>
                        </td></tr><tr><td>Concurrency Control Service</td><td>
                            <p>
                                Supports the isolation properties.
                            </p>
                        </td></tr></tbody></table>
        </div>
        <p>
            You are responsible for using the appropriate services to ensure that transactional objects have the necessary
            ACID properties.
        </p>
    </div>
</div>
        <div class="section" title="3.2.2.  Basics"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2448"/>3.2.2. 
        Basics
    </h3></div></div></div>
    

    <div class="section" title="3.2.2.1. Introduction"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2450"/>3.2.2.1. Introduction</h4></div></div></div>
        
        <p>
      
            is based upon the original Arjuna system developed at the University of Newcastle between 1986 and
            1995. Arjuna predates the OTS specification and includes many features not found in the OTS. 
            is a superset
            of the OTS. Applications written using the standard OTS interfaces are portable across OTS implementations.
        </p>
        <div class="itemizedlist" title="features in terms of OTS specifications"><p class="title"><strong>
                features in terms of OTS specifications
            </strong></p><ul class="itemizedlist"><li class="listitem">
                <p>
                    full draft 5 compliance, with support for Synchronization objects and PropagationContexts.
                </p>
            </li><li class="listitem">
                <p>
                    support for subtransactions.
                </p>
            </li><li class="listitem">
                <p>
                    implicit context propagation where support from the ORB is available.
                </p>
            </li><li class="listitem">
                <p>
                    support for multi-threaded applications.
                </p>
            </li><li class="listitem">
                <p>
                    fully distributed transaction managers, i.e., there is no central transaction manager, and the creator of a
                    top-level transaction is responsible for its termination. Separate transaction manager support is also
                    available, however.
                </p>
            </li><li class="listitem">
                <p>
                    transaction interposition.
                </p>
            </li><li class="listitem">
                <p>
                    X/Open compliance, including checked transactions. This checking can optionally be disabled. Note: checked
                    transactions are disabled by default, i.e., any thread can terminate a transaction.
                </p>
            </li><li class="listitem">
                <p>
                    JDBC support.
                </p>
            </li><li class="listitem">
                <p>
                    Full Jakarta Transactions support.
                </p>
            </li></ul></div>
        <p>
            You can use 
            in three different levels, which correspond to the sections in this chapter, and are each
            explored in their own chapters as well.
        </p>
        <p>
            Because of differences in ORB implementations, 
            uses a separate ORB Portability library which acts as an
            abstraction later. Many of the examples used throughout this manual use this library. Refer to the ORB Portability
            Manual for more details.
        </p>


        <div class="section" title="3.2.2.1.1. Raw OTS"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2475"/>3.2.2.1.1. Raw OTS</h5></div></div></div>
            
            <p>
                The OTS is only a protocol engine for driving registered resources through a two-phase commit protocol.
                You are
                responsible for building and registering the
                <code class="interfacename">Resource</code>
                objects which handle
                persistence and concurrency control, ensuring ACID properties for transactional application objects. You need to
                register
                <code class="interfacename">Resources</code>
                at appropriate times, and ensure that a given
                <code class="interfacename">Resource</code>
                is only registered within a single transaction. Programming at the raw
                OTS level is extremely basic. You as the programmer are responsible for almost everything to do with
                transactions, including managing persistence and concurrency control on behalf of every transactional object.
            </p>

        </div>

        <div class="section" title="3.2.2.1.2. Enhanced OTS functionality"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2481"/>3.2.2.1.2. Enhanced OTS functionality</h5></div></div></div>
            
            <p>
                The OTS implementation of nested transactions is extremely limited, and can lead to the generation of
                heuristic
                results. An example of such a result is when a subtransaction coordinator discovers part of the way through
                committing that some resources cannot commit, but being unable to tell the committed resources to abort. 
                allows nested transactions to execute a full two-phase commit protocol, which removes the possibility
                that some
                resources will comment while others roll back.
            </p>
            <p>
                When resources are registered with a transaction, you have no control over the order in which these
                resources
                are invoked during the commit/abort protocol. For example, if previously registered resources are replaced with
                newly registered resources, resources registered with a subtransaction are merged with the subtraction's
                parent. 
                provides an additional Resource subtype which you this level of control.
            </p>

        </div>

        <div class="section" title="3.2.2.1.3. Advanced API"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2485"/>3.2.2.1.3. Advanced API</h5></div></div></div>
            
            <p>
                The OTS does not provide any
                <code class="interfacename">Resource</code>
                implementations. You are responsible for
                implementing these interfaces. The interfaces defined within the OTS specification are too low-level for most
                application programmers. Therefore, 
                includes
                <span class="application">Transactional Objects for Java
                    (TXOJ)
                </span>
                , which makes use of the raw Common Object Services interfaces but provides a higher-level
                API for building transactional applications and frameworks. This API automates much of the activities concerned
                with participating in an OTS transaction, freeing you to concentrate on application development, rather than
                transactions.
            </p>
            <p>
                The architecture of the system is shown in Figure 2. The API interacts with the concurrency control and
                persistence services, and automatically registers appropriate resources for transactional objects. These
                resources may also use the persistence and concurrency services.
            </p>
            <p>
        
                exploits object-oriented techniques to provide you with a toolkit of Java classes which are inheritable
                by application classes, to obtain transactional properties. These classes form a hierarchy, illustrated
                in
                <a class="xref" href="#jbossts-class-hierarchy" title="Figure 3.2.  class hierarchy">Figure 3.2, “
                    class hierarchy
                ”</a>
                .
            </p>
            <div class="figure"><a id="jbossts-class-hierarchy"/><p class="title"><strong>Figure 3.2. 
                    class hierarchy
                </strong></p><div class="figure-contents">
                
                <div class="mediaobject"><img src="images/jts-jbossts-class-hierarchy.png" alt="class hierarchy" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e2495.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e2495.html" target="longdesc">D</a>]</span></div></div>
            </div></div><br class="figure-break"/>
            <p>
                Your main responsibilities are specifying the scope of transactions and setting appropriate locks within
                objects. 
                guarantees that transactional objects will be registered with, and be driven by, the
                appropriate transactions. Crash recovery mechanisms are invoked automatically in the event of failures. When
                using the provided interfaces, you do not need to create or register
                <code class="classname">Resource</code>
                objects or
                call services controlling persistence or recovery. If a transaction is nested, resources are automatically
                propagated to the transaction’s parent upon commit.
            </p>
            <p>
                The design and implementation goal of 
                was to provide a programming system for constructing
                fault-tolerant distributed applications. Three system properties were considered highly important:
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>Integration of Mechanisms</td><td>
                                <p>
                                    Fault-tolerant distributed systems require a variety of system functions for naming, locating and
                                    invoking operations upon objects, as well as for concurrency control, error detection and recovery
                                    from failures. These mechanisms are integrated in a way that is easy for you to use.
                                </p>
                            </td></tr><tr><td>Flexibility</td><td>
                                <p>
                                    Mechanisms must be flexible, permitting implementation of application-specific enhancements, such as
                                    type-specific concurrency and recovery control, using system defaults.
                                </p>
                            </td></tr><tr><td>Portability</td><td>
                                <p>
                                    You need to be able to run 
                                    on any ORB.
                                </p>
                            </td></tr></tbody></table>
            </div>
            <p>
        
                is implemented in Java and extensively uses the type-inheritance facilities provided by the language to
                provide user-defined objects with characteristics such as persistence and recoverability.
            </p>
        </div>
    </div>


    <div class="section" title="3.2.2.2.  and the OTS implementation"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2521"/>3.2.2.2. 
            and the OTS implementation
        </h4></div></div></div>
        
        <p>
            The OTS specification is written with flexibility in mind, to cope with different application requirements
            for
            transactions. 
            supports all optional parts of the OTS specification. In addition, if the specification
            allows functionality to be implemented in a variety of different ways, 
            supports all possible
            implementations.
        </p>
        <div class="table"><a id="d5e2524"/><p class="title"><strong>Table 3.2. 
                implementation of OTS specifications
            </strong></p><div class="table-contents">
            
            <table summary="&#xA;                implementation of OTS specifications&#xA;            " border="1"><colgroup><col width="220px"/><col width="220px"/></colgroup><thead><tr><th>OTS specification</th><th>
                            default implementation
                        </th></tr></thead><tbody><tr><td>
                            <p>
                                If the transaction service chooses to restrict the availability of the transaction
                                context, then it
                                should raise the
                                <code class="systemitem">Unavailable</code>
                                exception.
                            </p>
                        </td><td>
                            <p>
                
                                does not restrict the availability of the transaction context.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                An implementation of the transaction service need not initialize the transaction context for every
                                request.
                            </p>
                        </td><td>
                            <p>
                
                                only initializes the transaction context if the interface supported by the target object
                                extends
                                the
                                <code class="interfacename">TransactionalObject</code>
                                interface.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                An implementation of the transaction service may restrict the ability for the
                                <code class="classname">Coordinator</code>
                                ,
                                <code class="classname">Terminator</code>
                                , and
                                <code class="classname">Control</code>
                                objects to be transmitted or used in other execution environments to
                                enable it to guarantee transaction integrity.
                            </p>
                        </td><td>
                            <p>
                
                                does not impose restrictions on the propagation of these objects.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                The transaction service may restrict the termination of a transaction to the client that started it.
                            </p>
                        </td><td>
                            <p>
                
                                allows the termination of a transaction by any client that uses the
                                <code class="interfacename">Terminator</code>
                                interface. In addition, 
                                does not impose restrictions
                                when clients use the
                                <code class="interfacename">Current</code>
                                interface.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                A
                                <code class="classname">TransactionFactory</code>
                                is located using the
                                <code class="interfacename">FactoryFinder</code>
                                interface of the life-cycle service.
                            </p>
                        </td><td>
                            <p>
                
                                provides multiple ways in which the
                                <code class="classname">TransactionFactory</code>
                                can be located.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                A transaction service implementation may use the Event Service to report heuristic decisions.
                            </p>
                        </td><td>
                            <p>
                
                                does not use the Event Service to report heuristic decisions.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                An implementation of the transaction service does not need to support nested transactions.
                            </p>
                        </td><td>
                            <p>
                
                                supports nested transactions.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                <code class="classname">Synchronization</code>
                                objects must be called whenever the transaction commits.
                            </p>
                        </td><td>
                            <p>
                
                                allows
                                <code class="classname">Synchronizations</code>
                                to be called no matter what state the transaction
                                terminates with.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                A transaction service implementation is not required to support interposition.
                            </p>
                        </td><td>
                            <p>
                
                                supports various types of interposition.
                            </p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>
    </div>

    <div class="section" title="3.2.2.3. Thread class"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2591"/>3.2.2.3. Thread class</h4></div></div></div>
        
        <p>
      
            is fully multi-threaded and supports the OTS notion of allowing multiple threads to be active within a
            transaction, and for a thread to execute multiple transactions. A thread can only be active within a single
            transaction at a time, however. By default, if a thread is created within the scope of a transaction, the
            new
            thread is not associated with the transaction. If the thread needs to be associated with the transaction, use the
            <code class="methodname">resume</code>
            method of either the
            <code class="classname">AtomicTransaction</code>
            class or the
            <code class="classname">Current</code>
            class.
        </p>
        <p>
            However, if newly created threads need to automatically inherit the transaction context of their parent,
            then they
            should extend the
            <code class="classname">OTS_Thread</code>
            class.
        </p>
        <div class="example"><a id="d5e2599"/><p class="title"><strong>Example 3.2. 
                Extending the
                <code class="classname">OTS_Thread</code>
                class
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">public class OTS_Thread extends Thread
{
    public void terminate ();
    public void run ();

    protected OTS_Thread ();
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            Call the
            <code class="methodname">run</code>
            method of
            <code class="classname">OTS_Thread</code>
            at the start of the application
            thread class's
            <code class="methodname">run</code>
            method. Call
            <code class="methodname">terminate</code>
            before you exit the
            body of the application thread’s
            <code class="methodname">run</code>
            method.
        </p>
    </div>

    <div class="section" title="3.2.2.4. ORB portability issues"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2609"/>3.2.2.4. ORB portability issues</h4></div></div></div>
        
        <p>
            Although the CORBA specification is a standard, it is written so that an ORB can be implemented in multiple
            ways. As such, writing portable client and server code can be difficult. Because 
            has been ported to most
            of the widely available ORBs, it includes a series of ORB Portability classes and macros. If you write your
            application using these classes, it should be mostly portable between different ORBs. These classes are described
            in the separate ORB Portability Manual.
        </p>
    </div>
</div>
        <div class="section" title="3.2.3. Introduction to the OTS"><div class="titlepage"><div><div><h3 class="title"><a id="d5e2612"/>3.2.3. Introduction to the OTS</h3></div></div></div>
    
    <p>
        Basic 
        programming involves using the OTS interfaces provided in the
        <code class="systemitem">CosTransactions</code>
        module, which is specified in
        <code class="filename">CosTransactions.idl</code>
        . This chapter is based on the
        <code class="systemitem">OTS
            Specification1
        </code>,
        specifically with the aspects of OTS that are valuable for developing OTS applications
        using .
        Where relevant, each section describes 
        implementation decisions and runtime choices available
        to you. These choices are also summarized at the end of this chapter. Subsequent chapters illustrate using these
        interfaces to construct transactional applications.
    </p>

    <div class="section" title="3.2.3.1. Defining the OTS"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2618"/>3.2.3.1. Defining the OTS</h4></div></div></div>
        
        <p>
            The raw
            <code class="interfacename">CosTransactions</code>
            interfaces reside in package
            <span class="package">org.omg.CosTransactions</span>.
            The 
            implementations of these interfaces reside in package
            <span class="package">com.arjuna.CosTransactions</span>
            and its sub-packages.
        </p>
        <p>
            You can override many run-time decisions of 
            Java properties specified at run-time. The property names are
            mentioned in the
            <code class="classname">com.arjuna.ats.jts.common.Environment</code>
            class.
        </p>
        <div class="figure"><a id="d5e2626"/><p class="title"><strong>Figure 3.3. OTS architecture</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-ots_architecture.png" alt="OTS architecture" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e2628.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e2628.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>

    </div>

    <div class="section" title="3.2.3.2. Action programming models"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2633"/>3.2.3.2. Action programming models</h4></div></div></div>
        
        <p>
            A client application program can manage a transaction using direct or indirect context management.
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    <em class="firstterm">Indirect context management</em>
                    means that an application uses the pseudo-object
                    <code class="classname">Current</code>
                    , provided by the Transaction Service, to associate the transaction context with
                    the application thread of control.
                </p>
            </li><li class="listitem">
                <p>
                    For
                    <em class="firstterm">direct context management</em>
                    , an application manipulates the
                    <code class="classname">Control</code>
                    object and the other objects associated with the transaction.
                </p>
            </li></ul></div>
        <p>
            An object may require transactions to be either explicitly or implicitly propagated to its operations.
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    <em class="firstterm">Explicit propagation</em>
                    means that an application propagates a transaction context by
                    passing objects defined by the Transaction Service as explicit parameters. Typically the object is the
                    <code class="classname">PropagationContext</code>
                    structure.
                </p>
            </li><li class="listitem">
                <p>
                    <em class="firstterm">Implicit propagation</em>
                    means that requests are implicitly associated with the client’s
                    transaction, by sharing the client's transaction context. The context is transmitted to the objects without
                    direct client intervention. Implicit propagation depends on indirect context management, since it propagates
                    the transaction context associated with the
                    <code class="classname">Current</code>
                    pseudo-object. An object that
                    supports implicit propagation should not receive any Transaction Service object as an explicit parameter.
                </p>
            </li></ul></div>
        <p>
            A client may use one or both forms of context management, and may communicate with objects that use either method
            of transaction propagation. This results in four ways in which client applications may communicate with
            transactional objects:
        </p>
        <div class="variablelist"><dl><dt><span class="term">Direct Context Management/Explicit Propagation</span></dt><dd>
                    <p>
                        The client application directly accesses the
                        <code class="classname">Control</code>
                        object, and the other objects
                        which describe the state of the transaction. To propagate the transaction to an object, the client must
                        include the appropriate Transaction Service object as an explicit parameter of an operation. Typically, the
                        object is the
                        <code class="classname">PropagationContext</code>
                        structure.
                    </p>
                </dd><dt><span class="term">Indirect Context Management/Implicit Propagation</span></dt><dd>
                    <p>
                        The client application uses operations on the
                        <code class="classname">Current</code>
                        pseudo-object to create and
                        control its transactions. When it issues requests on transactional objects, the transaction context
                        associated with the current thread is implicitly propagated to the object.
                    </p>
                </dd><dt><span class="term">Indirect Context Management/Explicit Propagation</span></dt><dd>
                    <p>
                        for an implicit model application to use explicit propagation, it can get access to the Control using the
                        get_control operation on the Current pseudo object. It can then use a Transaction Service object as an
                        explicit parameter to a transactional object; for efficiency reasons this should be the PropagationContext
                        structure, obtained by calling get_txcontext on the appropriate Coordinator reference. This is explicit
                        propagation.
                    </p>
                </dd><dt><span class="term">Direct Context Management/Implicit Propagation</span></dt><dd>
                    <p>
                        A client that accesses the Transaction Service objects directly can use the
                        <code class="methodname">resume</code>
                        pseudo-object operation to set the implicit transaction context associated with its thread. This
                        way, the
                        client can invoke operations of an object that requires implicit propagation of the transaction context.
                    </p>
                </dd></dl></div>
        <p>
            The main difference between direct and indirect context management is the effect on the invoking thread’s
            transaction context. Indirect context management causes the thread’s transaction context to be modified
            automatically by the OTS. For instance, if method
            <code class="methodname">begin</code>
            is called, the thread’s notion of
            the current transaction is modified to the newly-created transaction. When the transaction is terminated, the
            transaction previously associated with the thread, if one existed, is restored as the thread’s context. This
            assumes that subtransactions are supported by the OTS implementation.
        </p>
        <p>
            If you use direct management, no changes to the thread's transaction context are made by the OTS, leaving the
            responsibility to you.
        </p>
    </div>

    <div class="section" title="3.2.3.3. Interfaces"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2680"/>3.2.3.3. Interfaces</h4></div></div></div>
        
        <div class="table"><a id="d5e2682"/><p class="title"><strong>Table 3.3. Interfaces</strong></p><div class="table-contents">
            
            <table summary="Interfaces" border="1"><colgroup><col width="85px"/><col width="75px"/><col width="170px"/><col width="115px"/></colgroup><thead><tr><th>Function</th><th>Used by</th><th>Direct context mgmt</th><th>Indirect context mgmt</th></tr></thead><tbody><tr><td>
                            <p>Create a transaction</p>
                        </td><td>
                            <p>Transaction originator</p>
                        </td><td>
                            <code class="methodname">Factory::create</code>
                            <p>
                                <code class="methodname">Control::get_terminator</code>
                            </p>
                            <p>
                                <code class="methodname">Control::get_coordinator</code>
                            </p>
                        </td><td>
                            <p>begin</p>
                            <p>set_timeout</p>
                        </td></tr><tr><td>Terminate a transaction</td><td>
                            <p>Transaction originator</p>
                            <p>(implicit)</p>
                            <p>All</p>
                            <p>(explicit)</p>
                        </td><td>
                            <p>
                                <code class="methodname">Terminator::commit</code>
                            </p>
                            <p>
                                <code class="methodname">Terminator::rollback</code>
                            </p>
                        </td><td>commit rollback</td></tr><tr><td>Rollback transaction</td><td>Server</td><td>
                            <p>
                                <code class="methodname">Terminator::rollback_only</code>
                            </p>
                        </td><td>
                            <p>
                                <code class="methodname">rollback_only</code>
                            </p>
                        </td></tr><tr><td>Propagation of transaction to server</td><td>Server</td><td>Declaration of method parameter</td><td>
                            <p>
                                <code class="interfacename">TransactionalObject</code>
                            </p>
                        </td></tr><tr><td>Client control of transaction propagation to server</td><td>All</td><td>Request parameters</td><td>
                            <p>
                                <code class="methodname">get_control</code>
                            </p>
                            <p>
                                <code class="methodname">suspend</code>
                            </p>
                            <p>
                                <code class="methodname">resume</code>
                            </p>
                        </td></tr><tr><td>Register with a transaction</td><td>Recoverable Server</td><td>
                            <p>
                                <code class="methodname">Coordinator::register_resource</code>
                            </p>
                        </td><td>N/A</td></tr><tr><td>Miscellaneous</td><td>All</td><td>
                            <p>
                                <code class="methodname">Coordinator::get_status</code>
                            </p>
                            <p>
                                <code class="methodname">Coordinator::get_transaction_name</code>
                            </p>
                            <p>
                                <code class="methodname">Coordinator::is_same_transaction</code>
                            </p>
                            <p>
                                <code class="methodname">Coordinator::hash_transaction</code>
                            </p>
                            <p>
                                <code class="methodname">get_status</code>
                            </p>
                            <p>
                                <code class="methodname">get_transaction_name</code>
                            </p>
                        </td><td>
                            <p>N/A</p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                For clarity, subtransaction operations are not shown
            </p>
        </div>
    </div>

    <div class="section" title="3.2.3.4. Transaction factory"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2777"/>3.2.3.4. Transaction factory</h4></div></div></div>
        
        <p>
            The
            <code class="interfacename">TransactionFactory</code>
            interface allows the transaction originator to begin a
            top-level transaction. Subtransactions must be created using the
            <code class="methodname">begin</code>
            method of
            <code class="classname">Current</code>
            , or the
            <code class="methodname">create_subtransaction</code>
            method of the parent’s
            Coordinator.) Operations on the factory and
            <code class="classname">Coordinator</code>
            to create new transactions use
            direct context management, and therefore do not modify the calling thread’s transaction context.
        </p>
        <p>
            The
            <code class="methodname">create</code>
            operation creates a new top-level transaction and returns its
            <code class="classname">Control</code>
            object, which you can use to manage or control participation in the new
            transaction. Method
            <code class="methodname">create</code>
            takes a parameter that is is an application-specific timeout
            value, in seconds. If the transaction does not complete before this timeout elapses, it is rolled back. If the
            parameter is
            <code class="literal">0</code>
            , no application-specific timeout is established.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                Subtransactions do not have a timeout associated with them.
            </p>
        </div>
        <p>
            The Transaction Service implementation allows the
            <code class="classname">TransactionFactory</code>
            to be a separate
            server from the application, shared by transactions clients, and which manages transactions on their
            behalf. However, the specification also allows the TransactionFactory to be implemented by an object within each
            transactional client. This is the default implementation used by ,
            because it removes the need for a
            separate service to be available in order for transactional applications to execute, and therefore reduces a point
            of failure.
        </p>
        <p>
            If your applications require a separate transaction manager, set the
            <code class="varname">OTS_TRANSACTION_MANAGER</code>
            environment variable to the value
            <code class="literal">YES</code>
            . The system locates the transaction manager server in a
            manner specific to the ORB being used. The server can be located in a number of ways.
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    Registration with a name server.
                </p>
            </li><li class="listitem">
                <p>
                    Addition to the ORB’s initial references, using a 
                    specific references file.
                </p>
            </li><li class="listitem">
                <p>
                    The ORB’s specific location mechanism, if applicable.
                </p>
            </li></ul></div>
        <div class="section" title="3.2.3.4.1. OTS configuration file"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2804"/>3.2.3.4.1. OTS configuration file</h5></div></div></div>
            
            <p>
                Similar to the
                <code class="methodname">resolve_initial_references</code>, 
                supports an initial reference file
                where you can store references for specific services, and use these references at runtime. The file,
                <code class="filename">CosServices.cfg</code>
                , consists of two columns, separated by a single space.
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        The service name, which is
                        <code class="literal">TransactionService</code>
                        in the case of the OTS server.
                    </p>
                </li><li class="listitem">
                    <p>
                        The IOR
                    </p>
                </li></ul></div>
            <p>
                <code class="filename">CosServices.cfg</code>
                is usually located in the
                <code class="filename">etc/</code>
                directory of the
        
                installation. The OTS server automatically registers itself in this file, creating it if necessary, if
                you use the configuration file mechanism. Stale information is also automatically removed. The
                Transaction
                Service locates
                <code class="filename">CosServices.cfg</code>
                at runtime, using the
                <code class="classname">OrbPortabilityEnvironmentBean</code>
                properties
                <code class="varname">initialReferencesRoot</code>
                and
                <code class="varname">InitialReferencesFile</code>
                .
                <code class="varname">initialReferencesRoot</code>
                names a directory, and
                defaults to the current working directory.
                <code class="varname">initialReferencesFile</code>
                refers to a file within the
                <code class="varname">initialReferencesRoot</code>
                , and defaults to the name
                <code class="literal">CosServices.cfg</code>
                .
            </p>
        </div>

        <div class="section" title="3.2.3.4.2. Name service"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2826"/>3.2.3.4.2. Name service</h5></div></div></div>
            
            <p>
                If your ORB supports a name service, and you configure 
                to use it, the transaction manager is
                automatically registered with it.
            </p>

        </div>

        <div class="section" title="3.2.3.4.3. resolve_initial_references"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2829"/>3.2.3.4.3. resolve_initial_references</h5></div></div></div>
            
            <p>
        
                does not support
                <code class="methodname">resolve_initial_references</code>
                .
            </p>

        </div>

        <div class="section" title="3.2.3.4.4. Overriding the default location mechanisms"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2833"/>3.2.3.4.4. Overriding the default location mechanisms</h5></div></div></div>
            
            <p>
                You can override the default location mechanism with the
                <code class="varname">RESOLVE_SERVICE</code>
                property variable,
                which can have any of three possible values.
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>CONFIGURATION_FILE</td><td>
                                <p>
                                    This is the default option, and directs the system to use the
                                    <code class="filename">CosServices.cfg</code>
                                    file.
                                </p>
                            </td></tr><tr><td>NAME_SERVICE</td><td>
                                <p>
                                    tries to use a name service to locate the transaction factory. If the ORB does not
                                    support the name service mechanism, 
                                    throws an exception.
                                </p>
                            </td></tr><tr><td>BIND_CONNECT</td><td>
                                <p>
                                    uses the ORB-specific bind mechanism. If the ORB does not support such a mechanism,
              
                                    throws an exception.
                                </p>
                            </td></tr></tbody></table>
            </div>
            <p>
                If
                <code class="literal">RESOLVE_SERVICE</code>
                is specified when running the transaction factory, the factory registers
                itself with the specified resolution mechanism.
            </p>
        </div>
    </div>

    <div class="section" title="3.2.3.5. Transaction timeouts"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2857"/>3.2.3.5. Transaction timeouts</h4></div></div></div>
        
        <p>
            As of 
            4.5, transaction timeouts are unified across all transaction components and are controlled by
            <span class="application">ArjunaCore</span>
            . Refer to the
            <em class="citetitle">ArjunaCore Development Guide</em>
            for more
            information.
        </p>
    </div>

    <div class="section" title="3.2.3.6. Transaction contexts"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2862"/>3.2.3.6. Transaction contexts</h4></div></div></div>
        
        <p>
            Transaction contexts are fundamental to the OTS architecture. Each thread is associated with a context in one of
            three ways.
        </p>
        <div class="informaltable">
            <table border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>Null</td><td>
                            <p>The thread has no associated transaction.</p>
                        </td></tr><tr><td>A transaction ID</td><td>The thread is associated with a transaction.</td></tr></tbody></table>
        </div>
        <p>
            Contexts may be shared across multiple threads. In the presence of nested transactions, a context remembers
            the
            stack of transactions started within the environment, so that the context of the thread can be restored to the
            state before the nested transaction started, when the nested transaction ends. Threads most commonly use object
            <code class="classname">Current</code>
            to manipulate transactional information, which is represented by
            <code class="classname">Control</code>
            objects.
            <code class="classname">Current</code>
            is the broker between a transaction and
            <code class="classname">Control</code>
            objects.
        </p>
        <p>
            Your application can manage transaction contexts either directly or indirectly. In the direct approach, the
            transaction originator issues a request to a
            <code class="classname">TransactionFactory</code>
            to begin a new top-level
            transaction. The factory returns a
            <code class="classname">Control</code>
            object that enables both a
            <code class="interfacename">Terminator</code>
            interface and a
            <code class="interfacename">Coordinator</code>
            interface.
            <code class="interfacename">Terminator</code>
            ends a
            transaction.
            <code class="interfacename">Coordinator</code>
            associates a thread with a transaction, or begins a nested
            transaction. You need to pass each interface as an explicit parameter in invocations of operations, because
            creating a transaction with them does not change a thread's current context. If you use the factory, and need to
            set the current context for a thread to the context which its control object returns, use the
            <code class="methodname">resume</code>
            method of interface
            <code class="interfacename">Current</code>
            .
        </p>
        <div class="example"><a id="d5e2891"/><p class="title"><strong>Example 3.3. 
                Interfaces
                <code class="interfacename">Terminator</code>
                ,
                <code class="interfacename">Coordinator</code>
                , and
                <code class="interfacename">Control</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">interface Terminator
{
    void commit (in boolean report_heuristics) raises (HeuristicMixed, HeuristicHazard); 
    void rollback ();
};

interface Coordinator
{
    Status get_status ();
    Status get_parent_status ();
    Status get_top_level_status ();

    RecoveryCoordinator register_resource (in Resource r) raises (Inactive);
    Control create_subtransaction () raises (SubtransactionsUnavailable,
                                             Inactive);

    void rollback_only () raises (Inactive);

    ...
};

interface Control
{
    Terminator get_terminator () raises (Unavailable);
    Coordinator get_coordinator () raises (Unavailable);
};

interface TransactionFactory
{
    Control create (in unsigned long time_out);
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            When the factory creates a transaction, you can specify a timeout value in seconds. If the transaction times
            out,
            it is subject to possible roll-back. Set the timeout to
            <code class="literal">0</code>
            to disable application-specific
            timeout.
        </p>
        <p>
            The
            <code class="interfacename">Current</code>
            interface handles implicit context management. Implicit context
            management provides simplified transaction management functionality, and automatically creates nested transactions
            as required. Transactions created using
            <code class="interfacename">Current</code>
            do not alter a thread’s current
            transaction context.
        </p>
        <div class="example"><a id="d5e2902"/><p class="title"><strong>Example 3.4. 
                Interface
                <code class="interfacename">Current</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">interface Current : CORBA::Current
{
    void begin () raises (SubtransactionsUnavailable);
    void commit (in boolean report_heuristics) raises (NoTransaction,
                                                       HeuristicMixed,
                                                       HeuristicHazard); 
    void rollback () raises (NoTransaction);
    void rollback_only () raises (NoTransaction);

    . . .

    Control get_control ();   
    Control suspend ();
    void resume (in Control which) raises (InvalidControl);
};
</code></pre>
        </div></div><br class="example-break"/>

        <div class="section" title="3.2.3.6.1. Nested transactions"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2906"/>3.2.3.6.1. Nested transactions</h5></div></div></div>
            
            <p>
                Subtransactions are a useful mechanism for two reasons:
            </p>
            <div class="variablelist"><dl><dt><span class="term">fault-tolerance</span></dt><dd>
                        <p>
                            If a subtransaction rolls back, the enclosing transaction does not also need to roll back. This preserves
                            as much of the work done so far, as possible.
                        </p>
                    </dd><dt><span class="term">modularity</span></dt><dd>
                        <p>
                            Indirect transaction management does not require special syntax for creating subtransactions. Begin a
                            transaction, and if another transaction is associated with the calling thread, the new transaction is
                            nested within the existing one. If you know that an object requires transactions, you can use them within
                            the object. If the object's methods are invoked without a client transaction, the object's transaction is
                            top-level. Otherwise, it is nested within the client's transaction. A client does not need to know whether
                            an object is transactional.
                        </p>
                    </dd></dl></div>
            <p>
                The outermost transaction of the hierarchy formed by nested transactions is called the top-level
                transaction. The inner components are called subtransactions. Unlike top-level transactions, the commits of
                subtransactions depend upon the commit/rollback of the enclosing transactions. Resources acquired within a
                subtransaction should be inherited by parent transactions when the top-level transaction completes. If a
                subtransaction rolls back, it can release its resources and undo any changes to its inherited resources.
            </p>
            <p>
                In the OTS, subtransactions behave differently from top-level transactions at commit time. Top-level
                transactions undergo a two-phase commit protocol, but nested transactions do not actually perform a commit
                protocol themselves. When a program commits a nested transaction, it only informs registered resources of its
                outcome. If a resource cannot commit, an exception is thrown, and the OTS implementation can ignore the
                exception or roll back the subtransaction. You cannot roll back a subtransaction if any resources have been
                informed that the transaction committed.
            </p>
        </div>

        <div class="section" title="3.2.3.6.2. Transaction propagation"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2920"/>3.2.3.6.2. Transaction propagation</h5></div></div></div>
            
            <p>
                The OTS supports both implicit and explicit propagation of transactional behavior.
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        Implicit propagation means that an operation signature specifies no transactional behavior, and each
                        invocation automatically sends transaction context associated with the calling thread.
                    </p>
                </li><li class="listitem">
                    <p>
                        Explicit propagation means that applications must define their own mechanism for propagating
                        transactions. This has the following features:
                    </p>
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            <p>
                                A client to control if its transaction is propagated with any operation invocation.
                            </p>
                        </li><li class="listitem">
                            <p>
                                A client can invoke operations on both transactional and non-transactional objects within a transaction.
                            </p>
                        </li></ul></div>
                </li></ul></div>
            <p>
                Transaction context management and transaction propagation are different things that may be controlled
                independently of each other. Mixing of direct and indirect context management with implicit and explicit
                transaction propagation is supported. Using implicit propagation requires cooperation from the ORB. The client
                must send current context associated with the thread with any operation invocations, and the server must extract
                them before calling the targeted operation.
            </p>
            <p>
                If you need implicit context propagation, ensure that 
                is correctly initialized before you create
                objects. Both client and server must agree to use implicit propagation. To use implicit context propagation,
                your ORB needs to support filters or interceptors, or the
                <code class="interfacename">CosTSPortability</code>
                interface.
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>Implicit context propagation</td><td>
                                <p>
                                    Property variable
                                    <code class="varname">OTS_CONTEXT_PROP_MODE</code>
                                    set to
                                    <code class="literal">CONTEXT</code>
                                    .
                                </p>
                            </td></tr><tr><td>Interposition</td><td>
                                <p>
                                    Property variable
                                    <code class="varname">OTS_CONTEXT_PROP_MODE</code>
                                    set to
                                    <code class="literal">INTERPOSITION</code>
                                    .
                                </p>
                            </td></tr></tbody></table>
            </div>
            <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
                <p>
                    Interposition is required to use the 
                    Advanced API.
                </p>
            </div>
        </div>

        <div class="section" title="3.2.3.6.3. Examples"><div class="titlepage"><div><div><h5 class="title"><a id="d5e2955"/>3.2.3.6.3. Examples</h5></div></div></div>
            
            <div class="example"><a id="d5e2957"/><p class="title"><strong>Example 3.5. Simple transactional client using direct context management and explicit transaction propagation
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">{
   ...
   org.omg.CosTransactions.Control c;
   org.omg.CosTransactions.Terminator t;
      org.omg.CosTransactions.PropagationContext pgtx;

   c = transFact.create(0);         // create top-level action

      pgtx = c.get_coordinator().get_txcontext();
   ...
   trans_object.operation(arg, pgtx);     // explicit propagation
   ...
   t = c.get_terminator();          // get terminator
   t.commit(false);              // so it can be used to commit
   ...
}
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                The next example rewrites the same program to use indirect context management and implicit propagation. This
                example is considerably simpler, because the application only needs to start and either commit or abort actions.
            </p>
            <div class="example"><a id="d5e2961"/><p class="title"><strong>Example 3.6. Indirect context management and implicit propagation</strong></p><div class="example-contents">
                
                <pre><code class="language-java">{
   ...
   current.begin();           // create new action
   ...
   trans_object2.operation(arg);    // implicit propagation
   ...
   current.commit(false);        // simple commit
   ...
}
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                The last example illustrates the flexibility of OTS by using both direct and indirect context management in
                conjunction with explicit and implicit transaction propagation.
            </p>
            <div class="example"><a id="d5e2965"/><p class="title"><strong>Example 3.7. Direct and direct context management with explicitly and implicit propagation</strong></p><div class="example-contents">
                
                <pre><code class="language-java">{
   ...
   org.omg.CosTransactions.Control c;
   org.omg.CosTransactions.Terminator t;
      org.omg.CosTransactions.PropagationContext pgtx;

   c = transFact.create(0);         // create top-level action
      pgtx = c.get_coordinator().get_txcontext();

   current.resume(c);            // set implicit context
   ...
   trans_object.operation(arg, pgtx);     // explicit propagation
   trans_object2.operation(arg);       // implicit propagation
   ...
   current.rollback();           // oops! rollback
   ...
}
</code></pre>
            </div></div><br class="example-break"/>
        </div>

    </div>

    <div class="section" title="3.2.3.7. Transaction controls"><div class="titlepage"><div><div><h4 class="title"><a id="d5e2968"/>3.2.3.7. Transaction controls</h4></div></div></div>
        
        <p>
            The
            <code class="interfacename">Control</code>
            interface allows a program to explicitly manage or propagate a
            transaction context. An object supporting the
            <code class="interfacename">Control</code>
            interface is associated with
            one specific transaction. The
            <code class="interfacename">Control</code>
            interface supports two operations:
            <code class="methodname">get_terminator</code>
            and
            <code class="methodname">get_coordinator</code>
            .
            <code class="methodname">get_terminator</code>
            returns an instance of the
            <code class="interfacename">Terminator</code>
            interface.
            <code class="methodname">get_coordinator</code>
            returns an instance
            of the
            <code class="interfacename">Coordinator</code>
            interface. Both of these methods throw the
            <code class="systemitem">Unavailable</code>
            exception if the
            <code class="interfacename">Control</code>
            cannot provide the
            requested object. The OTS implementation can restrict the ability to use the Terminator and Coordinator in other
            execution environments or threads. At a minimum, the creator must be able to use them.
        </p>
        <p>
            Obtain the
            <code class="methodname">Control</code>
            object for a transaction when it is created either by using either the
            <code class="methodname">TransactionFactory</code>
            or
            <code class="methodname">create_subtransaction</code>
            methods defined by
            the
            <code class="interfacename">Coordinator</code>
            interface. Obtain a
            <code class="classname">Control</code>
            for the
            transaction associated with the current thread using the
            <code class="methodname">get_control</code>
            or
            <code class="methodname">suspend</code>
            methods defined by the
            <code class="interfacename">Current</code>
            interface.
        </p>

        <div class="section" title="3.2.3.7.1.  specifics"><div class="titlepage"><div><div><h5 class="title"><a id="control-JBossTS-specifics"/>3.2.3.7.1. 
                specifics
            </h5></div></div></div>
            
            <p>
                The transaction creator must be able to use its
                <code class="interfacename">Control</code>
                , but the OTS
                implementation decides whether other threads can use
                <code class="interfacename">Control</code>. 
                places no
                restrictions the users of the
                <code class="interfacename">Control</code>
                .
            </p>
            <p>
                The OTS specification does not provide a means to indicate to the transaction system that information
                and
                objects associated with a given transaction can be purged from the system. In ,
                the
                <code class="interfacename">Current</code>
                interface destroys all information about a transaction when it
                terminates. For that reason, do not use any
                <code class="interfacename">Control</code>
                references to the transaction
                after it commits or rolls back.
            </p>
            <p>
                However, if the transaction is terminated using the Terminator interface, it is up to the programmer to signal
                that the transaction information is no longer required: this can be done using the destroyControl method of the
                OTS class in the com.arjuna.CosTransactions package. Once the program has indicated that the transaction
                information is no longer required, the same restrictions on using Control references apply as described
                above. If destroyControl is not called then transaction information will persist until garbage collected by the
                Java runtime.
            </p>
            <p>
                In ,
                you can propagate
                <code class="interfacename">Coordinators</code>
                and
                <code class="interfacename">Terminators</code>
                between execution environments.
            </p>
        </div>

    </div>

    <div class="section" title="3.2.3.8.  The Terminator interface"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3004"/>3.2.3.8. 
            The
            <code class="interfacename">Terminator</code>
            interface
        </h4></div></div></div>
        
        <p>
            The
            <code class="interfacename">Terminator</code>
            interface supports
            <code class="methodname">commit</code>
            and
            <code class="methodname">rollback</code>
            operations. Typically, the transaction originator uses these operations. Each
            object supporting the Terminator interface is associated with a single transaction. Direct context management via
            the Terminator interface does not change the client thread’s notion of the current transaction.
        </p>
        <p>
            The
            <code class="methodname">commit</code>
            operation attempts to commit the transaction. To successfully commit, the
            transaction must not be marked
            <code class="literal">rollback only</code>
            , and all of its must participants agree to
            commit. Otherwise, the
            <code class="systemitem">TRANSACTION_ROLLEDBACK</code>
            exception is thrown. If the
            <code class="varname">report_heuristics</code>
            parameter is
            <code class="literal">true</code>
            , the Transaction Service reports
            inconsistent results using the
            <code class="systemitem">HeuristicMixed</code>
            and
            <code class="systemitem">HeuristicHazard</code>
            exceptions.
        </p>
        <p>
            When a transaction is committed, the coordinator drives any registered
            <code class="classname">Resources</code>
            using
            their
            <code class="methodname">prepare</code>
            or
            <code class="methodname">commit</code>
            methods. These Resources are responsible
            to ensure that any state changes to recoverable objects are made permanent, to guarantee the ACID properties.
        </p>
        <p>
            When
            <code class="methodname">rollback</code>
            is called, the registered
            <code class="classname">Resources</code>
            need to
            guarantee that all changes to recoverable objects made within the scope of the transaction, and its descendants,
            is undone. All resources locked by the transaction are made available to other transactions, as appropriate to the
            degree of isolation the resources enforce.
        </p>

        <div class="section" title="3.2.3.8.1.  specifics"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3026"/>3.2.3.8.1. 
                specifics
            </h5></div></div></div>
            
            <p>
                See
                <a class="xref" href="#control-JBossTS-specifics" title="3.2.3.7.1.  specifics">Section 3.2.3.7.1, “
                specifics
            ”</a>
                for how long
                <code class="interfacename">Terminator</code>
                references remain valid after a transaction terminates.
            </p>
            <p>
                When a transaction is committing, it must make certain state changes persistent, so that it can recover
                if a
                failure occurs, and continue to commit, or rollback. To guarantee ACID properties, flush these state changes to
                the persistence store implementation before the transaction proceeds to commit. Otherwise, the application may
                assume that the transaction has committed, when the state changes may still volatile storage, and may be lost by
                a subsequent hardware failure. By default, 
                makes sure that such state changes are flushed. However,
                these flushes can impose a significant performance penalty to the application. To prevent transaction state
                flushes, set the
                <code class="varname">TRANSACTION_SYNC</code>
                variable to
                <code class="literal">OFF</code>
                . Obviously, do this at
                your own risk.
            </p>
            <p>
                When a transaction commits, if only a single resource is registered, the transaction manager does not
                need to
                perform the two-phase protocol. A single phase commit is possible, and the outcome of the transaction is
                determined by the resource. In a distributed environment, this optimization represents a significant performance
                improvement. As such, 
                defaults to performing single phase commit in this situation. Override this
                behavior at runtime by setting the
                <code class="varname">COMMIT_ONE_PHASE</code>
                property variable to
                <code class="literal">NO</code>
                .
            </p>
        </div>

    </div>

    <div class="section" title="3.2.3.9.  The Coordinator interface"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3037"/>3.2.3.9. 
            The
            <code class="interfacename">Coordinator</code>
            interface
        </h4></div></div></div>
        
        <p>
            The Coordinator interface is returned by the
            <code class="methodname">get_coordinator</code>
            method of the
            <code class="interfacename">Control</code>
            interface. It supports the operations resources need to participate in a
            transaction. These participants are usually either recoverable objects or agents of recoverable objects, such as
            subordinate coordinators. Each object supporting the
            <code class="interfacename">Coordinator</code>
            interface is
            associated with a single transaction. Direct context management via the Coordinator interface does not change the
            client thread’s notion of the current transaction. You can terminate transaction directly, through the
            <code class="interfacename">Terminator</code>
            interface. In that case, trying to terminate the transaction a second
            time using
            <code class="interfacename">Current</code>
            causes an exception to be thrown for the second termination
            attempt.
        </p>
        <p>
            The operations supported by the Coordinator interface of interest to application programmers are:
        </p>

        <div class="table"><a id="d5e3047"/><p class="title"><strong>Table 3.4. 
                Operations supported by the
                <code class="interfacename">Coordinator</code>
                interface
            </strong></p><div class="table-contents">
            
            <table summary="&#xA;                Operations supported by the&#xA;                Coordinator&#xA;                interface&#xA;            " border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>
                            <p>
                                <code class="methodname">get_status</code>
                            </p>
                            <p>
                                <code class="methodname">get_parent_status</code>
                            </p>
                            <p>
                                <code class="methodname">get_top_level_status</code>
                            </p>
                        </td><td>
                            <p>
                                Return the status of the associated transaction. At any given time a transaction can have one of the
                                following status values representing its progress:
                            </p>
                            <div class="variablelist"><dl><dt><span class="term">StatusActive</span></dt><dd>
                                        <p>
                                            The transaction is currently running, and has not been asked to prepare or marked for rollback.
                                        </p>
                                    </dd><dt><span class="term">StatusMarkedRollback</span></dt><dd>
                                        <p>
                                            The transaction is marked for rollback.
                                        </p>
                                    </dd><dt><span class="term">StatusPrepared</span></dt><dd>
                                        <p>
                                            The transaction has been prepared, which means that all subordinates have
                                            responded
                                            <code class="classname">VoteCommit</code>
                                            .
                                        </p>
                                    </dd><dt><span class="term">StatusCommitted</span></dt><dd>
                                        <p>
                                            The transaction has committed. It is likely that heuristics exist.
                                            Otherwise, the transaction
                                            would have been destroyed and
                                            <code class="classname">StatusNoTransaction</code>
                                            returned.
                                        </p>
                                    </dd><dt><span class="term">StatusRolledBack</span></dt><dd>
                                        <p>
                                            The transaction has rolled back. It is likely that heuristics exist. Otherwise. the transaction
                                            would have been destroyed and StatusNoTransaction returned.
                                        </p>
                                    </dd><dt><span class="term">StatusUnknown</span></dt><dd>
                                        <p>
                                            The Transaction Service cannot determine the current status of the transaction. This is a
                                            transient condition, and a subsequent invocation should return a different status.
                                        </p>
                                    </dd><dt><span class="term">StatusNoTransaction</span></dt><dd>
                                        <p>
                                            No transaction is currently associated with the target object. This occurs after a transaction
                                            completes.
                                        </p>
                                    </dd><dt><span class="term">StatusPreparing</span></dt><dd>
                                        <p>
                                            The transaction is in the process of preparing and the final outcome is not known.
                                        </p>
                                    </dd><dt><span class="term">StatusCommitting</span></dt><dd>
                                        <p>
                                            The transaction is in the process of committing.
                                        </p>
                                    </dd><dt><span class="term">StatusRollingBack</span></dt><dd>
                                        <p>
                                            The transaction is in the process of rolling back.
                                        </p>
                                    </dd></dl></div>
                        </td></tr><tr><td>
                            <p>
                                <code class="methodname">is_same_transaction</code>
                                and others
                            </p>
                        </td><td>
                            <p>
                                You can use these operations for transaction comparison. Resources may use these various operations to
                                guarantee that they are registered only once with a specific transaction.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                <code class="methodname">hash_transaction</code>
                            </p>
                            <p>
                                <code class="methodname">hash_top_level_tran</code>
                            </p>
                        </td><td>
                            <p>
                                Returns a hash code for the specified transaction.
                            </p>
                        </td></tr><tr><td>
                            <p>
                                <code class="methodname">register_resource</code>
                            </p>
                        </td><td>
                            <p>
                                Registers the specified Resource as a participant in the transaction. The
                                <code class="systemitem">Inactive</code>
                                exception is raised if the transaction is already prepared. The
                                <code class="systemitem">TRANSACTION_ROLLEDBACK</code>
                                exception is raised if the transaction is marked
                                <code class="literal">rollback only</code>
                                . If the
                                <code class="classname">Resource</code>
                                is a
                                <code class="classname">SubtransactionAwareResource</code>
                                and the transaction is a subtransaction, this
                                operation registers the resource with this transaction and indirectly with the top-level transaction
                                when the subtransaction’s ancestors commit. Otherwise, the resource is only registered with the current
                                transaction. This operation returns a
                                <code class="classname">RecoveryCoordinator</code>
                                which this
                                <code class="classname">Resource</code>
                                can use during recovery. No ordering of registered Resources is implied
                                by this operation. If
                                <code class="varname">A</code>
                                is registered after
                                <code class="varname">B</code>
                                , the OTS can operate
                                on them in any order when the transaction terminates. Therefore, do not assume such an ordering exists
                                in your implementation.
                            </p>
                        </td></tr><tr><td>register_subtran_aware</td><td>
                            <p>
                                Registers the specified subtransaction-aware resource with the current transaction, so
                                that it know when
                                the subtransaction commits or rolls back. This method cannot register the resource as a participant in
                                the top-level transaction. The
                                <code class="systemitem">NotSubtransaction</code>
                                exception is raised if the
                                current transaction is not a subtransaction. As with
                                <code class="methodname">register_resource</code>
                                , no
                                ordering is implied by this operation.
                            </p>
                        </td></tr><tr><td>register_synchronization</td><td>
                            <p>
                                Registers the
                                <code class="classname">Synchronization</code>
                                object with the transaction so that will be invoked
                                before
                                <code class="methodname">prepare</code>
                                and after the transaction completes. Synchronizations can only
                                be associated with top-level transactions, and the
                                <code class="systemitem">SynchronizationsUnavailable</code>
                                exception is raised if you try to register a Synchronization with a subtransaction. As
                                with
                                <code class="methodname">register_resource</code>
                                , no ordering is implied by this operation.
                            </p>
                        </td></tr><tr><td>rollback_only</td><td>
                            <p>
                                Marks the transaction so that the only possible outcome is for it to rollback. The Inactive exception is
                                raised if the transaction has already been prepared/completed.
                            </p>
                        </td></tr><tr><td>create_subtransaction</td><td>
                            <p>
                                A new subtransaction is created. Its parent is the current transaction. The
                                <code class="systemitem">Inactive</code>
                                exception is raised if the current transaction has already been
                                prepared or completed. If you configure the Transaction Service without subtransaction support, the
                                <code class="systemitem">SubtransactionsUnavailable</code>
                                exception is raised.
                            </p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>

        <div class="section" title="3.2.3.9.1.  specifics"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3160"/>3.2.3.9.1. 
                specifics
            </h5></div></div></div>
            
            <p>
                See
                <a class="xref" href="#control-JBossTS-specifics" title="3.2.3.7.1.  specifics">Section 3.2.3.7.1, “
                specifics
            ”</a>
                to control how long
                <code class="interfacename">Coordinator</code>
                references remain valid after a transaction terminates.
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    To disable subtransactions, set set the
                    <code class="varname">OTS_SUPPORT_SUBTRANSACTIONS</code>
                    property variable to
                    <code class="literal">NO</code>
                    .
                </p>
            </div>
        </div>
    </div>

    <div class="section" title="3.2.3.10. Heuristics"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3169"/>3.2.3.10. Heuristics</h4></div></div></div>
        
        <p>
            The OTS permits individual resources to make heuristic decisions.
            <em class="firstterm">Heuristic</em>
            decisions are
            unilateral decisions made by one or more participants to commit or abort the transaction, without waiting for the
            consensus decision from the transaction service. Use heuristic decisions with care and only in exceptional
            circumstances, because they can lead to a loss of integrity in the system. If a participant makes a heuristic
            decision, an appropriate exception is raised during commit or abort processing.
        </p>
        <div class="table"><a id="d5e3173"/><p class="title"><strong>Table 3.5. Possible heuristic outcomes</strong></p><div class="table-contents">
            
            <table summary="Possible heuristic outcomes" border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>HeuristicRollback</td><td>
                            <p>
                                Raised on an attempt to commit, to indicate that the resource already unilaterally rolled back the
                                transaction.
                            </p>
                        </td></tr><tr><td>HeuristicCommit</td><td>
                            <p>
                                Raised on an attempt to roll back, to indicate that the resource already unilaterally committed the
                                transaction.
                            </p>
                        </td></tr><tr><td>HeuristicMixed</td><td>
                            <p>
                                Indicates that a heuristic decision has been made. Some updates committed while others rolled back.
                            </p>
                        </td></tr><tr><td>HeuristicHazard</td><td>
                            <p>
                                Indicates that a heuristic decision may have been made, and the outcome of some of the updates is
                                unknown. For those updates which are known, they either all committed or all rolled back.
                            </p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>
        <p>
            HeuristicMixed takes priority over HeuristicHazard. Heuristic decisions are only reported back to the
            originator
            if the
            <em class="parameter"><code>report_heuristics</code></em>
            argument is set to
            <code class="literal">true</code>
            when you invoke the
            commit operation.
        </p>

    </div>

    <div class="section" title="3.2.3.11. Current"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3198"/>3.2.3.11. Current</h4></div></div></div>
        
        <p>
            The
            <code class="interfacename">Current</code>
            interface defines operations that allow a client to explicitly manage
            the association between threads and transactions, using indirect context management. It defines operations that
            simplify the use of the Transaction Service.
        </p>
        <div class="table"><a id="d5e3202"/><p class="title"><strong>Table 3.6. 
                Methods of
                <code class="interfacename">Current</code>
            </strong></p><div class="table-contents">
            
            <table summary="&#xA;                Methods of&#xA;                Current&#xA;            " border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>begin</td><td>
                            <p>
                                Creates a new transaction and associates it with the current thread. If the client
                                thread is currently
                                associated with a transaction, and the OTS implementation supported nested transactions, the new
                                transaction becomes a subtransaction of that transaction. Otherwise, the new transaction is a top-level
                                transaction. If the OTS implementation does not support nested transactions, the
                                <code class="systemitem">SubtransactionsUnavailable</code>
                                exception is thrown. The thread’s notion of the
                                current context is modified to be this transaction.
                            </p>
                        </td></tr><tr><td>commit</td><td>
                            <p>
                                Commits the transaction. If the client thread does not have permission to commit the
                                transaction, the
                                standard exception
                                <code class="systemitem">NO_PERMISSION</code>
                                is raised. The effect is the same as
                                performing the
                                <code class="methodname">commit</code>
                                operation on the corresponding
                                <code class="classname">Terminator</code>
                                object. The client thread's transaction context is returned to its
                                state before the
                                <code class="methodname">begin</code>
                                request was initiated.
                            </p>
                        </td></tr><tr><td>rollback</td><td>
                            <p>
                                Rolls back the transaction. If the client thread does not have permission to terminate
                                the transaction,
                                the standard exception
                                <code class="systemitem">NO_PERMISSION</code>
                                is raised. The effect is the same as
                                performing the
                                <code class="methodname">rollback</code>
                                operation on the corresponding
                                <code class="classname">Terminator</code>
                                object. The client thread's transaction context is returned to its
                                state before the
                                <code class="methodname">begin</code>
                                request was initiated.
                            </p>
                        </td></tr><tr><td>rollback_only</td><td>
                            <p>
                                Limits the transaction's outcome to rollback only. If the transaction has already been terminated, or is
                                in the process of terminating, an appropriate exception is thrown.
                            </p>
                        </td></tr><tr><td>get_status</td><td>
                            <p>
                                Returns the status of the current transaction, or exception
                                <code class="systemitem">StatusNoTransaction</code>
                                if no transaction is associated with the thread.
                            </p>
                        </td></tr><tr><td>set_timeout</td><td>
                            <p>
                                Modifies the timeout associated with top-level transactions for subsequent
                                <code class="methodname">begin</code>
                                requests, for this thread only. Subsequent transactions are subject to
                                being rolled back if they do not complete before the specified number of seconds elapses. Default
                                timeout values for transactions without explicitly-set timeouts are implementation-dependent. 
                                uses a value of
                                <code class="literal">0</code>,
                                which results in transactions never timing out. There is no
                                interface in the OTS for obtaining the current timeout associated with a thread. However, 
                                provides additional support for this. See
                                <a class="xref" href="#current-jbossts-specific" title="3.2.3.11.1.  specifics">Section 3.2.3.11.1, “
                specifics
            ”</a>
                                .
                            </p>
                        </td></tr><tr><td>get_control</td><td>
                            <p>
                                Obtains a
                                <code class="classname">Control</code>
                                object representing the current transaction. If the client
                                thread is not associated with a transaction, a null object reference is returned. The operation is not
                                dependent on the state of the transaction. It does not raise the
                                <code class="systemitem">TRANSACTION_ROLLEDBACK</code>
                                exception.
                            </p>
                        </td></tr><tr><td>suspend</td><td>
                            <p>
                                Obtains an object representing a transaction's context. If the client thread is not
                                associated with a
                                transaction, a null object reference is returned. You can pass this object to the
                                <code class="methodname">resume</code>
                                operation to re-establish this context in a thread. The operation is not
                                dependent on the state of the transaction. It does not raise the
                                <code class="systemitem">TRANSACTION_ROLLEDBACK</code>
                                exception. When this call returns, the current thread
                                has no transaction context associated with it.
                            </p>
                        </td></tr><tr><td>resume</td><td>
                            <p>
                                Associates the client thread with a transaction. If the parameter is a null object reference, the
                                client thread becomes associated with no transaction. The thread loses association with any previous
                                transactions.
                            </p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>
        <div class="figure"><a id="d5e3262"/><p class="title"><strong>Figure 3.4. 
                Creation of a top-level transaction using
                <code class="interfacename">Current</code>
            </strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-top_level_transaction_current.png" alt="Creation of a top-level transaction using Current" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3265.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3265.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <div class="figure"><a id="d5e3271"/><p class="title"><strong>Figure 3.5. 
                Creation of a transaction using
                <code class="interfacename">Current</code>
            </strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-subtransaction_current.png" alt="Creation of a transaction using Current" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3274.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3274.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>

        <div class="section" title="3.2.3.11.1.  specifics"><div class="titlepage"><div><div><h5 class="title"><a id="current-jbossts-specific"/>3.2.3.11.1. 
                specifics
            </h5></div></div></div>
            
            <p>
                Ideally, you should Obtain
                <code class="interfacename">Current</code>
                by using the life-cycle service factory
                finder. However, very few ORBs support this. 
                provides method
                <code class="methodname">get_current</code>
                of
                <code class="interfacename">Current</code>
                for this purpose. This class hides any ORB-specific mechanisms required
                for obtaining
                <code class="interfacename">Current</code>
                .
            </p>
            <p>
                If no timeout value is associated with
                <code class="interfacename">Current</code>, 
                associates no timeout
                with the transaction. The current OTS specification does not provide a means whereby the timeout associated with
                transaction creation can be obtained. However, 
                Current supports a get_timeout method.
            </p>
            <p>
                By default, the 
                implementation of
                <code class="interfacename">Current</code>
                does not use a separate
                <code class="classname">TransactionFactory</code>
                server when creating new top-level transactions. Each transactional
                client has a
                <code class="classname">TransactionFactory</code>
                co-located with it. Override this by setting the
                <code class="varname">OTS_TRANSACTION_MANAGER</code>
                variable to
                <code class="literal">YES</code>
                .
            </p>
            <p>
                The transaction factory is located in the
                <code class="filename">bin/</code>
                directory of the 
                distribution. Start
                it by executing the OTS script. 
                <code class="interfacename">Current</code>
                locates the factory
                in a manner specific to the ORB: using the name service, through
                <code class="methodname">resolve_initial_references</code>
                , or via the
                <code class="filename">CosServices.cfg</code>
                file. The
                <code class="filename">CosServices.cfg</code>
                file is similar to
                <code class="methodname">resolve_initial_references</code>,
                and
                is automatically updated when the transaction factory is started on a particular machine. Copy the file to each
        
                instance which needs to share the same transaction factory.
            </p>
            <p>
                If you do not need subtransaction support, set the
                <code class="varname">OTS_SUPPORT_SUBTRANSACTIONS</code>
                property
                variable to
                <code class="literal">NO</code>
                . The
                <code class="methodname">setCheckedAction</code>
                method overrides the
                <code class="interfacename">CheckedAction</code>
                implementation associated with each transaction created by the
                thread.
            </p>
        </div>
    </div>

    <div class="section" title="3.2.3.12. Resource"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3307"/>3.2.3.12. Resource</h4></div></div></div>
        
        <p>
            The Transaction Service uses a two-phase commit protocol to complete a top-level transaction with each registered
            resource.
        </p>
        <div class="example"><a id="d5e3310"/><p class="title"><strong>Example 3.8. Completing a top-level transaction</strong></p><div class="example-contents">
            
            <pre><code class="language-java">interface Resource
{
    Vote prepare ();
    void rollback () raises (HeuristicCommit, HeuristicMixed,
                             HeuristicHazard);
    void commit () raises (NotPrepared, HeuristicRollback,
                           HeuristicMixed, HeuristicHazard);
    void commit_one_phase () raises (HeuristicRollback, HeuristicMixed,
                                    HeuristicHazard);
    void forget ();
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            The
            <code class="interfacename">Resource</code>
            interface defines the operations invoked by the transaction
            service. Each
            <code class="interfacename">Resource</code>
            object is implicitly associated with a single top-level
            transaction. Do not register a
            <code class="interfacename">Resource</code>
            with the same transaction more than
            once. When you tell a
            <code class="interfacename">Resource</code>
            to prepare, commit, or abort, it must do so on
            behalf of a specific transaction. However, the
            <code class="interfacename">Resource</code>
            methods do not specify the
            transaction identity. It is implicit, since a
            <code class="interfacename">Resource</code>
            can only be registered with
            a single transaction.
        </p>
        <p>
            Transactional objects must use the
            <code class="methodname">register_resource</code>
            method to register objects
            supporting the
            <code class="interfacename">Resource</code>
            interface with the current transaction. An object
            supporting the
            <code class="interfacename">Coordinator</code>
            interface is either passed as a parameter in the case of
            explicit propagation, or retrieved using operations on the
            <code class="interfacename">Current</code>
            interface in the
            case of implicit propagation. If the transaction is nested, the
            <code class="interfacename">Resource</code>
            is not
            informed of the subtransaction’s completion, and is registered with its parent upon commit.
        </p>
        <p>
            This example assumes that transactions are only nested two levels deep, for simplicity.
        </p>

        <div class="figure"><a id="d5e3327"/><p class="title"><strong>Figure 3.6. 
                <code class="interfacename">Resource</code>
                and nested transactions
            </strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-resource_nested_transactions.png" alt="Resource and nested transactions" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3330.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3330.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <p>
            Do not register a given
            <code class="interfacename">Resource</code>
            with the same transaction more than once, or it
            will receive multiple termination calls. When a
            <code class="interfacename">Resource</code>
            is directed to prepare,
            commit, or abort, it needs to link these actions to a specific transaction. Because
            <code class="classname">Resource</code>
            methods do not specify the transaction identity, but can only be associated with a
            single transaction, you can infer the identity.
        </p>
        <p>
            A single
            <code class="interfacename">Resource</code>
            or group of
            <code class="interfacename">Resources</code>
            guarantees
            the ACID properties for the recoverable object they represent. A Resource's work depends on the phase of its
            transaction.
        </p>
        <div class="variablelist"><dl><dt><span class="term">prepare</span></dt><dd>
                    <p>
                        If none of the persistent data associated with the resource is modified by the transaction, the
                        Resource can
                        return
                        <code class="systemitem">VoteReadOnly</code>
                        and forget about the transaction. It does not need to know the
                        outcome of the second phase of the commit protocol, since it hasn't made any changes.
                    </p>
                    <p>
                        If the resource can write, or has already written, all the data needed to commit the transaction
                        to stable
                        storage, as well as an indication that it has prepared the transaction, it can return
                        <code class="systemitem">VoteCommit</code>
                        . After receiving this response, the Transaction Service either commits
                        or rolls back. To support recovery, the resource should store the
                        <code class="systemitem">RecoveryCoordinator</code>
                        reference in stable storage.
                    </p>
                    <p>
                        The resource can return
                        <code class="systemitem">VoteRollback</code>
                        under any circumstances. After returning this
                        response, the resource can forget the transaction.
                    </p>
                    <p>
                        The
                        <code class="interfacename">Resource</code>
                        reports inconsistent outcomes using the
                        <code class="systemitem">HeuristicMixed</code>
                        and
                        <code class="systemitem">HeuristicHazard</code>
                        exceptions. One example
                        is that a
                        <code class="interfacename">Resource</code>
                        reports that it can commit and later decides to roll
                        back. Heuristic decisions must be made persistent and remembered by the
                        <code class="interfacename">Resource</code>
                        until the transaction coordinator issues the
                        <code class="methodname">forget</code>
                        method. This method tells the
                        <code class="interfacename">Resource</code>
                        that
                        the heuristic decision has been noted, and possibly resolved.
                    </p>
                </dd><dt><span class="term">rollback</span></dt><dd>
                    <p>
                        The resource should undo any changes made as part of the transaction. Heuristic exceptions can be used to
                        report heuristic decisions related to the resource. If a heuristic exception is raised, the resource must
                        remember this outcome until the forget operation is performed so that it can return the same outcome in case
                        rollback is performed again. Otherwise, the resource can forget the transaction.
                    </p>
                </dd><dt><span class="term">commit</span></dt><dd>
                    <p>
                        If necessary, the resource should commit all changes made as part of this transaction. As with
                        <code class="methodname">rollback</code>
                        , it can raise heuristic exceptions. The
                        <code class="systemitem">NotPrepared</code>
                        exception is raised if the resource has not been prepared.
                    </p>
                </dd><dt><span class="term">commit_one_phase</span></dt><dd>
                    <p>
                        Since there can be only a single resource, the
                        <code class="systemitem">HeuristicHazard</code>
                        exception reports
                        heuristic decisions related to that resource. 
                    </p>
                </dd><dt><span class="term">forget</span></dt><dd>
                    <p>
                        Performed after the resource raises a heuristic exception. After the coordinator determines that
                        the
                        heuristic situation is addressed, it issues
                        <code class="methodname">forget</code>
                        on the resource. The resource
                        can forget all knowledge of the transaction.
                    </p>
                </dd></dl></div>
    </div>

    <div class="section" title="3.2.3.13. SubtransactionAwareResource"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3381"/>3.2.3.13. SubtransactionAwareResource</h4></div></div></div>
        
        <p>
            Recoverable objects that need to participate within a nested transaction may support the
            <code class="interfacename">SubtransactionAwareResource</code>
            interface, a specialization of the
            <code class="interfacename">Resource</code>
            interface.
        </p>

        <div class="example"><a id="d5e3386"/><p class="title"><strong>Example 3.9. 
                Interface
                <code class="interfacename">SubtransactionAwareResource</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">interface SubtransactionAwareResource : Resource
{
    void commit_subtransaction (in Coordinator parent);
    void rollback_subtransaction ();
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            A recoverable object is only informed of the completion of a nested transaction if it registers a
            <code class="interfacename">SubtransactionAwareResource</code>
            . Register the object with either the
            <code class="methodname">register_resource</code>
            of the
            <code class="interfacename">Coordinator</code>
            interface, or the
            <code class="methodname">register_subtran_aware</code>
            method of the
            <code class="interfacename">Current</code>
            interface. A
            recoverable object registers Resources to participate within the completion of top-level transactions, and
            SubtransactionAwareResources keep track of the completion of subtransactions. The
            <code class="methodname">commit_subtransaction</code>
            method uses a reference to the parent transaction to allow
            subtransaction resources to register with these transactions.
        </p>
        <p>
            SubtransactionAwareResources find out about the completion of a transaction after it terminates. They cannot
            affect the outcome of the transaction. Different OTS implementations deal with exceptions raised by
            SubtransactionAwareResources in implementation-specific ways.
        </p>
        <p>
            Use method
            <code class="methodname">register_resource</code>
            or method
            <code class="methodname">register_subtran_aware</code>
            to
            register a SubtransactionAwareResource with a transaction using.
        </p>
        <div class="variablelist"><dl><dt><span class="term">register_resource</span></dt><dd>
                    <p>
                        If the transaction is a subtransaction, the resource is informed of its completion, and automatically
                        registered with the subtransaction’s parent if the parent commits.
                    </p>
                </dd><dt><span class="term">register_subtran_aware</span></dt><dd>
                    <p>
                        If the transaction is not a subtransaction, an exception is thrown. Otherwise, the resource is
                        informed when
                        the subtransaction completes. Unlike
                        <code class="methodname">register_resource</code>
                        , the resource is not
                        propagated to the subtransaction’s parent if the transaction commits. If you need this propagation,
                        re-register using the supplied parent parameter.
                    </p>
                </dd></dl></div>
        <div class="figure"><a id="d5e3411"/><p class="title"><strong>Figure 3.7. 
                Method
                <code class="methodname">register_subtran_aware</code>
            </strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-register_subtran_aware.png" alt="Method register_subtran_aware" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3414.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3414.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <div class="figure"><a id="d5e3420"/><p class="title"><strong>Figure 3.8. 
                Method
                <code class="methodname">register_resource</code>
            </strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-register_resource.png" alt="Method register_resource" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3423.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3423.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <p>
            In either case, the resource cannot affect the outcome of the transaction completion. It can only act on the
            transaction's decision, after the decision is made. However, if the resource cannot respond appropriately,
            it can
            raise an exception. Thee OTS handles these exceptions in an implementation-specific way.
        </p>

        <div class="section" title="3.2.3.13.1.  specifics"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3430"/>3.2.3.13.1. 
                specifics
            </h5></div></div></div>
            
            <p>
                A
                <code class="classname">SubtransactionAwareResource</code>
                which raises an exception to the commitment of a
                transaction may create inconsistencies within the transaction if other
                <code class="classname">SubtransactionAwareResources</code>
                think the transaction committed. To prevent this possibility
                of inconsistency, 
                forces the enclosing transaction to abort if an exception is raised.
            </p>
            <p>
        
                also provides extended subtransaction aware resources to overcome this, and other problems. See Section
                for further details.
            </p>

        </div>

    </div>

    <div class="section" title="3.2.3.14.  The Synchronization interface"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3436"/>3.2.3.14. 
            The
            <code class="interfacename">Synchronization</code>
            interface
        </h4></div></div></div>
        
        <p>
            If an object needs notification before a transaction commits, it can register an object which is an
            implements the
            <code class="interfacename">Synchronization</code>
            interface, using the
            <code class="methodname">register_synchronization</code>
            operation of the
            <code class="interfacename">Coordinator</code>
            interface. Synchronizations flush volatile state data to a recoverable object or database before the
            transaction
            commits. You can only associate Synchronizations with top-level transactions. If you try to associate a
            Synchronization to a nested transaction, an exception is thrown. Each object supporting the
            <code class="interfacename">Synchronization</code>
            interface is associated with a single top-level transaction.
        </p>

        <div class="example"><a id="d5e3444"/><p class="title"><strong>Example 3.10. Synchronization</strong></p><div class="example-contents">
            
            <pre><code class="language-java">interface Synchronization : TransactionalObject
{
   void before_completion ();
   void after_completion (in Status s);
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            The method
            <code class="methodname">before_completion</code>
            is called before the two-phase commit protocol starts, and
            <code class="methodname">after_completion</code>
            is called after the protocol completes. The final status of the
            transaction is given as a parameter to
            <code class="methodname">after_completion</code>
            . If
            <code class="methodname">before_completion</code>
            raises an exception, the transaction rolls back. Any exceptions thrown
            by
            <code class="methodname">after_completion</code>
            do not affect the transaction outcome.
        </p>
        <p>
            The OTS only requires Synchronizations to be invoked if the transaction commits. If it rolls back, registered
            Synchronizations are not informed.
        </p>
        <p>
            Given the previous description of
            <code class="interfacename">Control</code>
            ,
            <code class="interfacename">Resource</code>
            ,
            <code class="interfacename">SubtransactionAwareResource</code>
            , and Synchronization, the following UML relationship
            diagram can be drawn:
        </p>
        <div class="figure"><a id="d5e3458"/><p class="title"><strong>Figure 3.9. Relationship between Control, Resource, SubtransactionAwareResource, and Synchronization</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-interface_relationship.png" alt="Relationship between Control, Resource, SubtransactionAwareResource, and Synchronization" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3460.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3460.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>


        <div class="section" title="3.2.3.14.1.  specifics"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3465"/>3.2.3.14.1. 
                specifics
            </h5></div></div></div>
            
            <p>
                Synchronizations must be called before the top-level transaction commit protocol starts, and after it
                completes. By default, if the transaction is instructed to roll back, the Synchronizations associated
                with the
                transaction is not contacted. To override this, and call Synchronizations regardless of the transaction's
                outcome, set the
                <code class="varname">OTS_SUPPORT_ROLLBACK_SYNC</code>
                property variable to
                <code class="literal">YES</code>
                .
            </p>
            <p>
                If you use distributed transactions and interposition, a local proxy for the top-level transaction
                coordinator
                is created for any recipient of the transaction context. The proxy looks like a
                <code class="classname">Resource</code>
                or
                <code class="classname">SubtransactionAwareResource</code>
                , and registers itself as such with the actual top-level
                transaction coordinator. The local recipient uses it to register
                <code class="classname">Resources</code>
                and
                <code class="classname">Synchronizations</code>
                locally.
            </p>
            <p>
                The local proxy can affect how Synchronizations are invoked during top-level transaction commit. Without
                the
                proxy, all Synchronizations are invoked before any Resource or SubtransactionAwareResource objects are
                processed. However, with interposition, only those Synchronizations registered locally to the transaction
                coordinator are called. Synchronizations registered with remote participants are only called when the interposed
                proxy is invoked. The local proxy may only be invoked after locally-registered Resource or
                SubtransactionAwareResource objects are invoked. With the
                <code class="varname">OTS_SUPPORT_INTERPOSED_SYNCHRONIZATION</code>
                property variable set to
                <code class="literal">YES</code>
                , all
                Synchronizations are invoked before any Resource or SubtransactionAwareResource, no matter where they are
                registered.
            </p>
        </div>
    </div>

    <div class="section" title="3.2.3.15. Transactions and registered resources"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3478"/>3.2.3.15. Transactions and registered resources</h4></div></div></div>
        
        <div class="figure"><a id="d5e3480"/><p class="title"><strong>Figure 3.10. 
                Relationship between a transaction
                <code class="interfacename">Control</code>
                and the resources registered with
                it
            </strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-control_and_resources.png" alt="Relationship between a transaction Control and the resources registered with it" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3483.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3483.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <p>
            In
            <a class="xref" href="#subtransaction-commit" title="Figure 3.11. Subtransaction commit">Figure 3.11, “Subtransaction commit”</a>
            , a subtransaction with both
            <code class="classname">Resource</code>
            and
            <code class="classname">SubtransactionAwareResource</code>
            objects commits. The
            <code class="classname">SubtransactionAwareResources</code>
            were registered using
            <code class="methodname">register_subtran_aware</code>
            . The
            <code class="classname">Resources</code>
            do not know the
            subtransaction terminated, but the
            <code class="classname">SubtransactionAwareResources</code>
            do. Only the
            <code class="classname">Resources</code>
            are automatically propagated to the parent transaction.
        </p>
        <div class="figure"><a id="subtransaction-commit"/><p class="title"><strong>Figure 3.11. Subtransaction commit</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-subtransaction-commit.png" alt="Subtransaction commit" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3500.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3500.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <p>
            <a class="xref" href="#subtransaction-rollback" title="Figure 3.12. Subtransaction rollback">Figure 3.12, “Subtransaction rollback”</a>
            illustrates the impact of a subtransaction rolling back. Any registered
            resources are discarded, and all
            <code class="classname">SubtransactionAwareResources</code>
            are informed of the
            transaction outcome.
        </p>
        <div class="figure"><a id="subtransaction-rollback"/><p class="title"><strong>Figure 3.12. Subtransaction rollback</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-subtransaction-rollback.png" alt="Subtransaction rollback" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3510.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3510.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <p>
            <a class="xref" href="#top-level-commit" title="Figure 3.13. Top-level commit">Figure 3.13, “Top-level commit”</a>
            shows the activity diagram for committing a top-level
            transaction. Subtransactions within the top-level transaction which have also successfully committed propagate
            <code class="classname">SubtransactionAwareResources</code>
            to the top-level transaction. These
            <code class="classname">SubtransactionAwareResources</code>
            then participate within the two-phase commit protocol. Any
            registered
            <code class="classname">Synchronizations</code>
            are contacted before
            <code class="methodname">prepare</code>
            is
            called. Because of indirect context management, when the transaction commits, the transaction service changes the
            invoking thread’s transaction context.
        </p>
        <div class="figure"><a id="top-level-commit"/><p class="title"><strong>Figure 3.13. Top-level commit</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-top-level-commit.png" alt="Top-level commit" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3523.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3523.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
        <div class="figure"><a id="d5e3528"/><p class="title"><strong>Figure 3.14. Top-level rollback</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-top-level-rollback.png" alt="Top-level rollback" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3530.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3530.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>

    </div>

    <div class="section" title="3.2.3.16.  The TransactionalObject interface"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3535"/>3.2.3.16. 
            The
            <code class="interfacename">TransactionalObject</code>
            interface
        </h4></div></div></div>
        
        <p>
            The
            <code class="interfacename">TransactionalObject</code>
            interface indicates to an object that it is
            transactional. By supporting this interface, an object indicates that it wants to associate the transaction
            context associated with the client thread with all operations on its interface. The
            <code class="interfacename">TransactionalObject</code>
            interface defines no operations.
        </p>
        <p>
            OTS specifications do not require an OTS to initialize the transaction context of every request handler. It
            is
            only a requirement if the interface supported by the target object is derived from
            <code class="interfacename">TransactionalObject</code>
            . Otherwise, the initial transaction context of the thread is
            undefined. A transaction service implementation can raise the
            <code class="systemitem">TRANSACTION_REQUIRED</code>
            exception if a
            <code class="classname">TransactionalObject</code>
            is invoked outside the scope of a transaction.
        </p>
        <p>
            In a single-address space application, transaction contexts are implicitly shared between clients and
            objects,
            regardless of whether or not the objects support the
            <code class="interfacename">TransactionalObject</code>
            interface. To preserve distribution transparency, where implicit transaction propagation is supported, you
            can
            direct 
            to always propagate transaction contexts to objects. The default is only to propagate if the object
            is a
            <code class="interfacename">TransactionalObject</code>
            . Set the
            <code class="varname">OTS_ALWAYS_PROPAGATE_CONTEXT</code>
            property variable to
            <code class="literal">NO</code>
            to override this behavior.
        </p>
        <p>
            By default, 
            does not require objects which support the
            <code class="interfacename">TransactionalObject</code>
            interface to invoked within the scope of a transaction. The object determines whether it should be invoked
            within
            a transaction. If so, it must throw the
            <code class="systemitem">TransactionRequired</code>
            exception. Override this
            default by setting the
            <code class="varname">OTS_NEED_TRAN_CONTEXT</code>
            shell environment variable to
            <code class="literal">YES</code>
            .
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
            <p>
                Make sure that the settings for
                <code class="varname">OTS_ALWAYS_PROPAGATE_CONTEXT</code>
                and
                <code class="varname">OTS_NEED_TRAN_CONTEXT</code>
                are identical at the client and the server. If they are not identical
                at both ends, your application may terminate abnormally.
            </p>
        </div>
        
    </div>

    <div class="section" title="3.2.3.17. Interposition"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3559"/>3.2.3.17. Interposition</h4></div></div></div>
        
        <p>
            OTS objects supporting interfaces such as the
            <code class="interfacename">Control</code>
            interface are standard CORBA
            objects. When an interface is passed as a parameter in an operation call to a remote server, only an object
            reference is passed. This ensures that any operations that the remote server performs on the interface are
            correctly performed on the real object. However, this can have substantial penalties for the application, because
            of the overhead of remote invocation. For example, when the server registers a
            <code class="classname">Resource</code>
            with the current transaction, the invocation might be remote to the originator of the transaction.
        </p>
        <p>
            To avoid this overhead, your OTS may support interposition. This permits a server to create a local control object
            which acts as a local coordinator, and fields registration requests that would normally be passed back to
            the
            originator. This coordinator must register itself with the original coordinator, so that it can correctly
            participate in the commit protocol. Interposed coordinators form a tree structure with their parent coordinators.
        </p>
        <p>
            To use interposition, ensure that 
            is correctly initialized before creating objects. Also, the client and
            server must both use interposition. Your ORB must support filters or interceptors, or the
            <code class="interfacename">CosTSPortability</code>
            interface, since interposition requires the use of implicit
            transaction propagation. To use interposition, set the
            <code class="varname">OTS_CONTEXT_PROP_MODE</code>
            property variable
            to
            <code class="literal">INTERPOSITION</code>
            .
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                Interposition is not required if you use the 
                advanced API.
            </p>
        </div>
    </div>

    <div class="section" title="3.2.3.18. RecoveryCoordinator"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3571"/>3.2.3.18. RecoveryCoordinator</h4></div></div></div>
        
        <p>
            A reference to a
            <code class="classname">RecoveryCoordinator</code>
            is returned as a result of successfully calling
            <code class="methodname">register_resource</code>
            on the transaction's
            <code class="classname">Coordinator</code>
            . Each
            <code class="classname">RecoveryCoordinator</code>
            is implicitly associated with a single
            <code class="classname">Resource</code>
            . It can drive the
            <code class="classname">Resource</code>
            through recovery procedures in
            the event of a failure which occurs during the transaction.
        </p>
        <div class="figure"><a id="d5e3580"/><p class="title"><strong>Figure 3.15. 
                <code class="interfacename">Resource</code>
                and
                <code class="interfacename">RecoveryCoordinator</code>
            </strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/jts-resource-and-recoverycoordinator.png" alt="Resource and RecoveryCoordinator" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e3584.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e3584.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
    </div>

    <div class="section" title="3.2.3.19. Checked transaction behavior"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3589"/>3.2.3.19. Checked transaction behavior</h4></div></div></div>
        
        <p>
            The OTS supports both checked and unchecked transaction behavior.
        </p>
        <div class="itemizedlist" title="Integrity constraints of checked transactions"><p class="title"><strong>Integrity constraints of checked transactions</strong></p><ul class="itemizedlist"><li class="listitem">
                <p>
                    A transaction will not commit until all transactional objects involved in the transaction have completed their
                    transactional requests.
                </p>
            </li><li class="listitem">
                <p>
                    Only the transaction originator can commit the transaction
                </p>
            </li></ul></div>
        <p>
            Checked transactional behavior is typical transaction behavior, and is widely implemented. Checked behavior
            requires implicit propagation, because explicit propagation prevents the OTS from tracking which objects are
            involved in the transaction.
        </p>
        <p>
            Unchecked behavior allows you to implement relaxed models of atomicity. Any use of explicit propagation
            implies
            the possibility of unchecked behavior, since you as the programmer are in control of the behavior. Even if you use
            implicit propagation, a server may unilaterally abort or commit the transaction using the
            <code class="interfacename">Current</code>
            interface, causing unchecked behavior.
        </p>
        <p>
            Some OTS implementations enforce checked behavior for the transactions they support, to provide an extra level of
            transaction integrity. The checks ensure that all transactional requests made by the application complete
            their
            processing before the transaction is committed. A checked Transaction Service guarantees that commit fails unless
            all transactional objects involved in the transaction complete the processing of their transactional
            requests. Rolling back the transaction does not require such as check, since all outstanding transactional
            activities will eventually roll back if they are not directed to commit.
        </p>
        <p>
            There are many possible implementations of checking in a Transaction Service. One provides equivalent function to
            that provided by the request and response inter-process communication models defined by X/Open. The X/Open
            Transaction Service model of checking widely implemented. It describes the transaction integrity guarantees
            provided by many existing transaction systems. These transaction systems provide the same level of transaction
            integrity for object-based applications, by providing a Transaction Service interface that implements the X/Open
            checks.
        </p>
        <p>
            In X/Open, completion of the processing of a request means that the object has completed execution of its method
            and replied to the request. The level of transaction integrity provided by a Transaction Service implementing the
            X/Open model provides equivalent function to that provided by the XATMI and TxRPC interfaces defined by X/Open for
            transactional applications. X/Open DTP Transaction Managers are examples of transaction management functions
            that
            implement checked transaction behavior.
        </p>
        <p>
            This implementation of checked behavior depends on implicit transaction propagation. When implicit propagation is
            used, the objects involved in a transaction at any given time form a tree, called the request tree for the
            transaction. The beginner of the transaction is the root of the tree. Requests add nodes to the tree, and replies
            remove the replying node from the tree. Synchronous requests, or the checks described below for deferred
            synchronous requests, ensure that the tree collapses to a single node before commit is issued.
        </p>
        <p>
            If a transaction uses explicit propagation, the Transaction Service has no way to know which objects are or will
            be involved in the transaction. Therefore, the use of explicit propagation is not permitted by a Transaction
            Service implementation that enforces X/Open-style checked behavior.
        </p>
        <p>
            Applications that use synchronous requests exhibit checked behavior. If your application uses deferred
            synchronous
            requests, all clients and objects need to be under the control of a checking Transaction Service. In that case,
            the Transaction Service can enforce checked behavior, by applying a
            <code class="systemitem">reply</code>
            check and a
            <code class="systemitem">committed</code>
            check. The Transaction Service must also apply a
            <code class="systemitem">resume</code>
            check, so that the transaction is only resumed by applications in the correct part
            of the request tree.
        </p>
        <div class="informaltable">
            <table border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>reply check</td><td>
                            <p>
                                Before an object replies to a transactional request, a check is made to ensure that the object has
                                received replies to all the deferred synchronous requests that propagated the transaction in the
                                original request. If this condition is not met, an exception is raised and the transaction is marked as
                                rollback-only. A Transaction Service may check that a reply is issued within the context of the
                                transaction associated with the request.
                            </p>
                        </td></tr><tr><td>commit check</td><td>
                            <p>
                                Before a commit can proceed, a check is made to ensure that the commit request for the transaction is
                                being issued from the same execution environment that created the transaction, and that the client
                                issuing commit has received replies to all the deferred synchronous requests it made that propagated the
                                transaction.
                            </p>
                        </td></tr><tr><td>resume check</td><td>
                            <p>
                                Before a client or object associates a transaction context with its thread of control, a check is made
                                to ensure that this transaction context was previously associated with the execution environment of the
                                thread. This association would exist if the thread either created the transaction or received it in a
                                transactional operation.
                            </p>
                        </td></tr></tbody></table>
        </div>
        <div class="section" title="3.2.3.19.1.  specifics"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3627"/>3.2.3.19.1. 
                specifics
            </h5></div></div></div>
            
            <p>
                Where support from the ORB is available, 
                supports X/Open checked transaction behavior. However, unless
                the
                <code class="varname">OTS_CHECKED_TRANSACTIONS</code>
                property variable is set to
                <code class="literal">YES</code>
                , checked
                transactions are disabled. This is the default setting.
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    Checked transactions are only possible with a co-located transaction manager.
                </p>
            </div>
            <p>
                In a multi-threaded application, multiple threads may be associated with a transaction during its
                lifetime,
                sharing the context. In addition, if one thread terminates a transaction, other threads may still be active
                within it. In a distributed environment, it can be difficult to guarantee that all threads have finished with a
                transaction when it terminates. By default, 
                issues a warning if a thread terminates a transaction when
                other threads are still active within it, but allow the transaction termination to continue. You can choose to
                block the thread which is terminating the transaction until all other threads have disassociated themselves from
                its context, or use other methods to solve the problem. 
                provides the
                <code class="classname">com.arjuna.ats.arjuna.coordinator.CheckedAction</code>
                class, which allows you to override the
                thread and transaction termination policy. Each transaction has an instance of this class associated with it,
                and you can implement the class on a per-transaction basis.
            </p>

            <div class="example"><a id="d5e3636"/><p class="title"><strong>Example 3.11. 
                    <code class="classname">CheckedAction</code>
                    implementation
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java">public class CheckedAction
{
public CheckedAction ();

public synchronized void check (boolean isCommit, Uid actUid,
                                BasicList list);
};
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                When a thread attempts to terminate the transaction and there active threads exist within it, the system
                invokes
                the
                <code class="methodname">check</code>
                method on the transaction’s
                <code class="classname">CheckedAction</code>
                object. The
                parameters to the check method are:
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>isCommit</td><td>
                                <p>
                                    Indicates whether the transaction is in the process of committing or rolling back.
                                </p>
                            </td></tr><tr><td>actUid</td><td>
                                <p>
                                    The transaction identifier.
                                </p>
                            </td></tr><tr><td>list</td><td>
                                <p>
                                    A list of all of the threads currently marked as active within this transaction.
                                </p>
                            </td></tr></tbody></table>
            </div>
            <p>
                When
                <code class="methodname">check</code>
                returns, the transaction termination continues. Obviously the state of the
                transaction at this point may be different from that when check was called.
            </p>
            <p>
                Set the
                <code class="classname">CheckedAction</code>
                instance associated with a given transaction with the
                <code class="methodname">setCheckedAction</code>
                method of
                <code class="interfacename">Current</code>
                .
            </p>
        </div>
    </div>

    <div class="section" title="3.2.3.20. Summary of implementation decisions"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3666"/>3.2.3.20. Summary
            of 
            implementation decisions
        </h4></div></div></div>
        
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    Any execution environment (thread, process) can use a transaction Control.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="interfacename">Control</code>
                    s,
                    <code class="interfacename">Coordinator</code>
                    s, and
                    <code class="interfacename">Terminator</code>
                    s are valid for use for the duration of the transaction if implicit
                    transaction control is used, via
                    <code class="interfacename">Current</code>
                    . If you use explicit control, via the
                    <code class="classname">TransactionFactory</code>
                    and
                    <code class="classname">Terminator</code>
                    , then use the
                    <code class="methodname">destroyControl</code>
                    method of the OTS class in
                    <code class="classname">com.arjuna.CosTransactions</code>
                    to signal when the information can be garbage collected.
                </p>
            </li><li class="listitem">
                <p>
                    You can propagate
                    <span class="interface">Coordinator</span>
                    s and
                    <code class="interfacename">Terminator</code>
                    s between
                    execution environments.
                </p>
            </li><li class="listitem">
                <p>
                    If you try to commit a transaction when there are still active subtransactions within it, 
                    rolls back
                    the parent and the subtransactions.
                </p>
            </li><li class="listitem">
                <p>
          
                    includes full support for nested transactions. However, if a resource raises an exception to the
                    commitment of a subtransaction after other resources have previously been told that the transaction
                    committed,
          
                    forces the enclosing transaction to abort. This guarantees that all resources used within the
                    subtransaction are returned to a consistent state. You can disable support for subtransactions by
                    setting the
                    <code class="varname">OTS_SUPPORT_SUBTRANSACTIONS</code>
                    variable to
                    <code class="literal">NO</code>
                    .
                </p>
            </li><li class="listitem">
                <p>
                    Obtain
                    <code class="interfacename">Current</code>
                    from the
                    <code class="methodname">get_current</code>
                    method of the OTS.
                </p>
            </li><li class="listitem">
                <p>
                    A timeout value of zero seconds is assumed for a transaction if none is specified using
                    <code class="methodname">set_timeout</code>
                    .
                </p>
            </li><li class="listitem">
                <p>
                    by default,
                    <code class="interfacename">Current</code>
                    does not use a separate transaction manager server by
                    default. Override this behavior by setting the
                    <code class="varname">OTS_TRANSACTION_MANAGER</code>
                    environment
                    variable. Location of the transaction manager is ORB-specific.
                </p>
            </li><li class="listitem">
                <p>
                    Checked transactions are disabled by default. To enable them, set the
                    <code class="varname">OTS_CHECKED_TRANSACTIONS</code>
                    property to
                    <code class="literal">YES</code>
                    .
                </p>
            </li></ul></div>
    </div>
</div>
        <div class="section" title="3.2.4. Constructing an OTS application"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3706"/>3.2.4. Constructing an OTS application</h3></div></div></div>
    

    <div class="section" title="3.2.4.1. Important notes for"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3708"/>3.2.4.1. Important
            notes for 
        </h4></div></div></div>
        
        <div class="section" title="3.2.4.1.1. Initialization"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3710"/>3.2.4.1.1. Initialization</h5></div></div></div>
            
            <p>
        
                must be correctly initialized before you create any application object. To guarantee this, use the
                <code class="methodname">initORB</code>
                and
                <code class="methodname">POA</code>
                methods described in the
                <em class="citetitle">Orb
                    Portability Guide
                </em>
                . Consult the
                <em class="citetitle">Orb Portability Guide</em>
                if you need direct use
                of the
                <code class="methodname">ORB_init</code>
                and
                <code class="methodname">create_POA</code>
                methods provided by the
                underlying ORB.
            </p>
        </div>
        <div class="section" title="3.2.4.1.2. Implicit context propagation and interposition"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3719"/>3.2.4.1.2. Implicit context propagation and interposition</h5></div></div></div>
            
            <p>
                If you need implicit context propagation and interposition, initialize 
                correctly before you create any
                objects. You can only use implicit context propagation on an ORB which supports filters and interceptors, or the
                <code class="interfacename">CosTSPortability</code>
                interface. You can set
                <code class="varname">OTS_CONTEXT_PROP_MODE</code>
                to
                <code class="literal">CONTEXT</code>
                or
                <code class="literal">INTERPOSITION</code>,
                depending on which functionality you need. If
                you are using the 
                API, you need to use interposition.
            </p>
        </div>
    </div>

    <div class="section" title="3.2.4.2. Writing applications using the raw OTS interfaces"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3726"/>3.2.4.2. Writing applications using the raw OTS interfaces</h4></div></div></div>
        
        <div class="itemizedlist" title="Steps to participate in an OTS transaction"><p class="title"><strong>Steps to participate in an OTS transaction</strong></p><ul class="itemizedlist"><li class="listitem">
                <p>
                    Create
                    <code class="classname">Resource</code>
                    and
                    <code class="classname">SubtransactionAwareResource</code>
                    objects for each
                    object which will participate within the transaction or subtransaction. These resources manage the
                    persistence, concurrency control, and recovery for the object. The OTS invokes these objects during the
                    prepare, commit, or abort phase of the transaction or subtransaction, and the Resources perform the work of
                    the application.
                </p>
            </li><li class="listitem">
                <p>
                    Register
                    <code class="classname">Resource</code>
                    and
                    <code class="classname">SubtransactionAwareResource</code>
                    objects at the
                    correct time within the transaction, and ensure that the object is only registered once within a given
                    transaction. As part of registration, a
                    <code class="classname">Resource</code>
                    receives a reference to a
                    <code class="classname">RecoveryCoordinator</code>
                    . This reference must be made persistent, so that the transaction
                    can recover in the event of a failure.
                </p>
            </li><li class="listitem">
                <p>
                    Correctly propagate resources such as locks to parent transactions and
                    <code class="classname">SubtransactionAwareResource</code>
                    objects.
                </p>
            </li><li class="listitem">
                <p>
                    Drive the crash recovery for each resource which was participating within the transaction, in the event of a
                    failure.
                </p>
            </li></ul></div>
        <p>
            The OTS does not provide any
            <code class="classname">Resource</code>
            implementations. You need to provide these
            implementations. The interfaces defined within the OTS specification are too low-level for most
            situations. 
            is designed to make use of raw
            <em class="firstterm">Common Object Services (COS)</em>
            interfaces,
            but provides a higher-level API for building transactional applications and framework. This API automates much of
            the work involved with participating in an OTS transaction.
        </p>
    </div>

    <div class="section" title="3.2.4.3. Transaction context management"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3748"/>3.2.4.3. Transaction context management</h4></div></div></div>
        
        <p>
            If you use implicit transaction propagation, ensure that appropriate objects support the
            <code class="interfacename">TransactionalObject</code>
            interface. Otherwise, you need to pass the transaction contexts
            as parameters to the relevant operations.
        </p>

        <div class="section" title="3.2.4.3.1. A transaction originator: indirect and implicit"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3752"/>3.2.4.3.1. A transaction originator: indirect and implicit</h5></div></div></div>
            
            <div class="example"><a id="d5e3754"/><p class="title"><strong>Example 3.12. Indirect and implicit transaction originator</strong></p><div class="example-contents">
                
                <pre><code class="language-java">    ...
    txn_crt.begin();
    // should test the exceptions that might be raised
    ...
    // the client issues requests, some of which involve
    // transactional objects;
    BankAccount1.makeDeposit(deposit);
    ...
</code></pre>
                <p>
                    A transaction originator uses indirect context management and implicit transaction
                    propagation.
                    <code class="classname">txn_crt</code>
                    is a pseudo object supporting the
                    <code class="interfacename">Current</code>
                    interface. The client uses the
                    <code class="methodname">begin</code>
                    operation
                    to start the transaction, which becomes implicitly associated with the originator’s thread of control.
                </p>
                <p>
                    The program commits the transaction associated with the client thread. The
                    <code class="systemitem">report_heuristics</code>
                    argument is set to
                    <code class="literal">false</code>
                    , so the Transaction
                    Service makes no reports about possible heuristic decisions.
                </p>
                <pre><code class="language-java">    ...
    txn_crt.commit(false);
    ...
</code></pre>
            </div></div><br class="example-break"/>
        </div>

        <div class="section" title="3.2.4.3.2. Transaction originator: direct and explicit"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3765"/>3.2.4.3.2. Transaction originator: direct and explicit</h5></div></div></div>
            

            <div class="example"><a id="d5e3767"/><p class="title"><strong>Example 3.13. Direct and explicit transaction originator</strong></p><div class="example-contents">
                
                <pre><code class="language-java">    ...
    org.omg.CosTransactions.Control c;
    org.omg.CosTransactions.Terminator t;
    org.omg.CosTransactions.Coordinator co;
    org.omg.CosTransactions.PropagationContext pgtx;

    c = TFactory.create(0);
    t = c.get_terminator();
    pgtx = c.get_coordinator().get_txcontext();
    ...
</code></pre>
                <p>
                    This transaction originator uses direct context management and explicit transaction propagation. The
                    client
                    uses a factory object supporting the
                    <code class="interfacename">CosTransactions::TransactionFactory</code>
                    interface to create a new transaction, and uses the returned
                    <code class="classname">Control</code>
                    object to retrieve
                    the
                    <code class="classname">Terminator</code>
                    and
                    <code class="classname">Coordinator</code>
                    objects.
                </p>
                <p>
                    The client issues requests, some of which involve transactional objects. This example uses explicit
                    propagation of the context. The
                    <code class="classname">Control</code>
                    object reference is passed as an explicit
                    parameter of the request. It is declared in the OMG IDL of the interface.
                </p>
                <pre><code class="language-java">    ...
    transactional_object.do_operation(arg, pgtx);
</code></pre>
                <p>
                    The transaction originator uses the
                    <code class="classname">Terminator</code>
                    object to commit the transaction. The
                    <code class="systemitem">report_heuristics</code>
                    argument is set to
                    <code class="literal">false</code>
                    , so the Transaction
                    Service makes no reports about possible heuristic decisions.
                </p>
                <pre><code class="language-java">    ...
    t.commit(false);
</code></pre>
            </div></div><br class="example-break"/>
        </div>
    </div>

    <div class="section" title="3.2.4.4. Implementing a transactional client"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3783"/>3.2.4.4. Implementing a transactional client</h4></div></div></div>
        
        <p>
            The
            <code class="methodname">commit</code>
            operation of
            <code class="classname">Current</code>
            or the
            <code class="interfacename">Terminator</code>
            interface takes the
            <span class="type">boolean</span>
            <code class="option">report_heuristics</code>
            parameter. If the
            <code class="option">report_heuristics</code>
            argument is
            <code class="literal">false</code>
            , the commit operation can complete as soon as the
            <code class="classname">Coordinator</code>
            makes the decision to commit or roll back the transaction. The application does not need to wait for the
            <code class="classname">Coordinator</code>
            to complete the commit protocol by informing all the participants of the
            outcome of the transaction. This can significantly reduce the elapsed time for the commit operation, especially
            where participant
            <code class="classname">Resource</code>
            objects are located on remote network nodes. However, no
            heuristic conditions can be reported to the application in this case.
        </p>
        <p>
            Using the
            <code class="option">report_heuristics</code>
            option guarantees that the commit operation does not complete until
            the
            <code class="classname">Coordinator</code>
            completes the commit protocol with all
            <code class="classname">Resource</code>
            objects involved in the transaction. This guarantees that the application is informed of any non-atomic
            outcomes
            of the transaction, through one of the exceptions
            <code class="systemitem">HeuristicMixed</code>
            or
            <code class="systemitem">HeuristicHazard</code>
            . However, it increases the application-perceived elapsed time for the
            commit operation.
        </p>
    </div>

    <div class="section" title="3.2.4.5. Implementing a recoverable server"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3802"/>3.2.4.5. Implementing a recoverable server</h4></div></div></div>
        
        <p>
            A Recoverable Server includes at least one transactional object and one resource object, each of which have
            distinct responsibilities.
        </p>

        <div class="section" title="3.2.4.5.1. Transactional object"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3805"/>3.2.4.5.1. Transactional object</h5></div></div></div>
            
            <p>
                The transactional object implements the transactional object's operations
                and registers a
                <code class="classname">Resource</code>
                object with the
                <code class="classname">Coordinator</code>
                , so that the Recoverable
                Server's resources, including any necessary recovery, can commit.
            </p>
            <p>
                The
                <code class="classname">Resource</code>
                object identifies the involvement of the Recoverable Server in a particular
                transaction. This requires a
                <code class="classname">Resource</code>
                object to only be registered in one transaction at
                a time. Register a different
                <code class="classname">Resource</code>
                object for each transaction in which a recoverable
                server is concurrently involved. A transactional object may receive multiple requests within the scope of a
                single transaction. It only needs to register its involvement in the transaction once. The
                <code class="methodname">is_same_transaction</code>
                operation allows the transactional object to determine if the
                transaction associated with the request is one in which the transactional object is already registered.
            </p>
            <p>
                The
                <code class="classname">hash_transaction</code>
                operations allow the transactional object to reduce the number of
                transaction comparisons it has to make. All
                <code class="classname">Coordinators</code>
                for the same transaction return
                the same hash code. The
                <code class="methodname">is_same_transaction</code>
                operation only needs to be called on
                <code class="classname">Coordinators</code>
                with the same hash code as the
                <code class="classname">Coordinator</code>
                of the
                current request.
            </p>
        </div>

        <div class="section" title="3.2.4.5.2. Resource object"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3821"/>3.2.4.5.2. Resource object</h5></div></div></div>
            
            <p>
                A
                <code class="classname">Resource</code>
                object participates in the completion of the transaction, updates the
                resources of the Recoverable Server in accordance with the transaction outcome, and ensures termination of the
                transaction, including across failures.
            </p>
        </div>

        <div class="section" title="3.2.4.5.3. Reliable servers"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3825"/>3.2.4.5.3. Reliable servers</h5></div></div></div>
            
            <p>
                A
                <em class="firstterm">Reliable Server</em>
                is a special case of a Recoverable Server. A Reliable Server can use
                the same interface as a Recoverable Server to ensure application integrity for objects that do not have
                recoverable state. In the case of a Reliable Server, the transactional object can register a
                <code class="classname">Resource</code>
                object that replies
                <code class="systemitem">VoteReadOnly</code>
                to
                <code class="methodname">prepare</code>
                if its integrity constraints are satisfied. It replies
                <code class="systemitem">VoteRollback</code>
                if it finds a problem. This approach allows the server to apply integrity
                constraints which apply to the transaction as a whole, rather than to individual requests to the server.
            </p>
        </div>

        <div class="section" title="3.2.4.5.4. Examples"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3833"/>3.2.4.5.4. Examples</h5></div></div></div>
            
            <div class="example"><a id="d5e3835"/><p class="title"><strong>Example 3.14. Reliable server</strong></p><div class="example-contents">
                
                <pre><code class="language-java">/* 
  BankAccount1 is an object with internal resources. It inherits from both the TransactionalObject and the Resource interfaces:
*/
interface BankAccount1:
                    CosTransactions::TransactionalObject, CosTransactions::Resource
{
    ...
    void makeDeposit (in float amt);
    ...
};
/* The corresponding Java class is: */
public class BankAccount1
{
public void makeDeposit(float amt);
    ...
};
/*
  Upon entering, the context of the transaction is implicitly associated with the object’s thread. The pseudo object
  supporting the Current interface is used to retrieve the Coordinator object associated with the transaction.
*/
void makeDeposit (float amt)
{
    org.omg.CosTransactions.Control c;
    org.omg.CosTransactions.Coordinator co;
    c = txn_crt.get_control();
    co = c.get_coordinator();
    ...
/*
  Before registering the resource the object should check whether it has already been registered for the same
  transaction. This is done using the hash_transaction and is_same_transaction operations.  that this object registers
  itself as a resource. This imposes the restriction that the object may only be involved in one transaction at a
  time. This is not the recommended way for recoverable objects to participate within transactions, and is only used as an
  example.  If more parallelism is required, separate resource objects should be registered for involvement in the same
  transaction.
*/
    RecoveryCoordinator r;
    r = co.register_resource(this);

    // performs some transactional activity locally
    balance = balance + f;
    num_transactions++;
    ...
    // end of transactional operation
};
</code></pre>
            </div></div><br class="example-break"/>

            <div class="example"><a id="d5e3838"/><p class="title"><strong>Example 3.15. Transactional object</strong></p><div class="example-contents">
                
                <pre><code class="language-java">/*  A BankAccount2 is an object with external resources that inherits from the TransactionalObject interface: */
interface BankAccount2: CosTransactions::TransactionalObject
{
    ...
    void makeDeposit(in float amt);
    ...
};

public class BankAccount2
{
public void makeDeposit(float amt);
    ...
}
/*
Upon entering, the context of the transaction is implicitly associated with the object’s thread. The makeDeposit
operation performs some transactional requests on external, recoverable servers. The objects res1 and res2 are
recoverable objects. The current transaction context is implicitly propagated to these objects.
*/
void makeDeposit(float amt)
{
    balance = res1.get_balance(amt);
    balance = balance + amt;
    res1.set_balance(balance);
    res2.increment_num_transactions();
} // end of transactional operation
</code></pre>
            </div></div><br class="example-break"/>
        </div>
    </div>

    <div class="section" title="3.2.4.6. Failure models"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3841"/>3.2.4.6. Failure models</h4></div></div></div>
        
        <p>
            The Transaction Service provides atomic outcomes for transactions in the presence of application, system or
            communication failures. From the viewpoint of each user object role, two types of failure are relevant:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    A local failure, which affects the object itself.
                </p>
            </li><li class="listitem">
                <p>
                    An external failure, such as failure of another object or failure in the communication with an object.
                </p>
            </li></ul></div>
        <p>
            The transaction originator and transactional server handle these failures in different ways.
        </p>
        <div class="section" title="3.2.4.6.1. Transaction originator"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3850"/>3.2.4.6.1. Transaction originator</h5></div></div></div>
            
            <div class="variablelist"><dl><dt><span class="term">Local failure</span></dt><dd>
                        <p>
                            If a Transaction originator fails before the originator issues
                            <code class="systemitem">commit</code>
                            , the
                            transaction is rolled back. If the originator fails after issuing commit and before the outcome is
                            reported, the transaction can either commit or roll back, depending on timing. In this case, the
                            transaction completes without regard to the failure of the originator.
                        </p>
                    </dd><dt><span class="term">External failure</span></dt><dd>
                        <p>
                            Any external failure which affects the transaction before the originator issues
                            <code class="systemitem">commit</code>
                            causes the transaction to roll back. The standard exception
                            <code class="systemitem">TransactionRolledBack</code>
                            is raised in the originator when it issues
                            <code class="systemitem">commit</code>
                            .
                        </p>
                        <p>
                            If a failure occurs after commit and before the outcome is reported, the client may not be
                            informed of the
                            outcome of the transaction. This depends on the nature of the failure, and the use of the
                            <code class="option">report_heuristics</code>
                            option of
                            <code class="systemitem">commit</code>
                            . For example, the transaction
                            outcome is not reported to the client if communication between the client and the
                            <code class="classname">Coordinator</code>
                            fails.
                        </p>
                        <p>
                            A client can determine the outcome of the transaction by using method
                            <code class="methodname">get_status</code>
                            on the
                            <code class="classname">Coordinator</code>
                            . However, this is not reliable because it may return the status
                            <code class="systemitem">NoTransaction</code>
                            , which is ambiguous. The transaction could have committed and been
                            forgotten, or it could have rolled back and been forgotten.
                        </p>
                        <p>
                            An originator is only guaranteed to know the transaction outcome in one of two ways.
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                <p>
                                    if its implementation includes a
                                    <code class="classname">Resource</code>
                                    object, so that it can participate in
                                    the two-phase commit procedure.
                                </p>
                            </li><li class="listitem">
                                <p>
                                    The originator and
                                    <code class="classname">Coordinator</code>
                                    must be located in the same failure domain.
                                </p>
                            </li></ul></div>
                    </dd></dl></div>
        </div>

        <div class="section" title="3.2.4.6.2. Transactional server"><div class="titlepage"><div><div><h5 class="title"><a id="d5e3881"/>3.2.4.6.2. Transactional server</h5></div></div></div>
            
            <div class="variablelist"><dl><dt><span class="term">Local failure</span></dt><dd>
                        <p>
                            If the Transactional Server fails, optional checks by a Transaction Service implementation
                            may make the
                            transaction to roll back. Without such checks, whether the transaction rolls back depends on whether the
                            commit decision is already made, such as when an unchecked client invokes
                            <code class="systemitem">commit</code>
                            before receiving all replies from servers.
                        </p>
                    </dd><dt><span class="term">External failure</span></dt><dd>
                        <p>
                            Any external failure affecting the transaction during the execution of a Transactional
                            Server causes the
                            transaction to be rolled back. If the failure occurs while the transactional object’s method is executing,
                            the failure has no effect on the execution of this method. The method may terminate normally, returning
                            the reply to its client. Eventually the
                            <code class="systemitem">TransactionRolledBack</code>
                            exception is
                            returned to a client issuing
                            <code class="systemitem">commit</code>
                            .
                        </p>
                    </dd><dt><span class="term">Recoverable server</span></dt><dd>
                        <p>
                            Behavior of a recoverable server when failures occur is determined by the two phase commit
                            protocol
                            between the
                            <code class="classname">Coordinator</code>
                            and the recoverable server’s
                            <code class="classname">Resource</code>
                            object.
                        </p>
                    </dd></dl></div>
        </div>
    </div>

    <div class="section" title="3.2.4.7. Summary"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3901"/>3.2.4.7. Summary</h4></div></div></div>
        
        <p>
            When you develop OTS applications which use the raw OTS interfaces, be aware of the following items:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    Create
                    <code class="classname">Resource</code>
                    and
                    <code class="classname">SubtransactionAwareResource</code>
                    objects for each
                    object which will participate within the transaction or subtransaction. These resources handle the
                    persistence, concurrency control, and recovery for the object. The OTS invokes these objects during the
                    prepare, commit, and abort phases of the transaction or subtransaction, and the
                    <code class="classname">Resources</code>
                    then perform all appropriate work.
                </p>
            </li><li class="listitem">
                <p>
                    Register
                    <code class="classname">Resource</code>
                    and
                    <code class="classname">SubtransactionAwareResource</code>
                    objects at the
                    correct time within the transaction, and ensure that the object is only registered once within a given
                    transaction. As part of registration, a
                    <code class="classname">Resource</code>
                    receives a reference to a
                    <code class="classname">RecoveryCoordinator</code>
                    , which must be made persistent so that recovery can occur in the
                    event of a failure.
                </p>
            </li><li class="listitem">
                <p>
                    For nested transactions, make sure that any propagation of resources, such as locks to parent
                    transactions,
                    are done correctly. You also need to manage propagation of
                    <code class="classname">SubtransactionAwareResource</code>
                    objects to parents.
                </p>
            </li><li class="listitem">
                <p>
                    in the event of failures, drive the crash recovery for each
                    <code class="classname">Resource</code>
                    which participates
                    within the transaction.
                </p>
            </li></ul></div>
        <p>
            The OTS does not provide any
            <code class="classname">Resource</code>
            implementations.
        </p>
    </div>
</div>
        <div class="section" title="3.2.5.  interfaces for extending the OTS"><div class="titlepage"><div><div><h3 class="title"><a id="d5e3924"/>3.2.5. 
        interfaces for extending the OTS
    </h3></div></div></div>
    
    <p>
        This chapter contains a description of the use of the 
        classes you can use to extend the OTS
        interfaces. These advanced interfaces are all written on top of the basic OTS engine described previously, and
        applications which use them run on other OTS implementations, only without the added functionality.
    </p>
    <div class="variablelist" title="Features"><p class="title"><strong>Features</strong></p><dl><dt><span class="term">AtomicTransaction</span></dt><dd>
                <p>
                    Provides a more manageable interface to the OTS transaction than
                    <code class="interfacename">CosTransactions::Current</code>
                    . It automatically keeps track of transaction scope,
                    and allows you to create nested top-level transactions in a more natural manner than the one provided by the
                    OTS.
                </p>
            </dd><dt><span class="term">Advanced subtransaction-Resource classes</span></dt><dd>
                <p>
                    Allow nested transactions to use a two-phase commit protocol. These Resources can also be ordered
                    within
          ,
                    enabling you to control the order in which
                    <code class="classname">Resource</code>
                    s are called during the
                    commit or abort protocol.
                </p>
            </dd><dt><span class="term">Implicit context propagation between client and server</span></dt><dd>
                <p>
                    Where available, 
                    uses implicit context propagation between client and server. Otherwise, 
                    provides an explicit interposition class, which simplifies the work involved in interposition. The 
                    API,
                    <em class="firstterm">Transactional Objects for Java (TXOJ)</em>
                    , requires either explicit or implicit
                    interposition. This is even true in a stand-alone mode when using a separate transaction manager. TXOJ is
                    fully described in the
                    <em class="citetitle">ArjunaCore Development Guide</em>
                    .
                </p>
            </dd></dl></div>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            the extensions to the
            <code class="filename">CosTransactions.idl</code>
            are located in the
            <span class="package">com.arjuna.ArjunaOTS</span>
            package and the
            <code class="filename">ArjunaOTS.idl</code>
            file.
        </p>
    </div>

    <div class="section" title="3.2.5.1. Nested transactions"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3950"/>3.2.5.1. Nested transactions</h4></div></div></div>
        
        <p>
            The OTS implementation of nested transactions is extremely limited, and can lead to the generation of inconsistent
            results. One example is a scenario in which a subtransaction coordinator discovers part of the way through
            committing that a resources cannot commit. It may not be able to tell the committed resources to abort.
        </p>
        <p>
            In most transactional systems which support subtransactions, the subtransaction commit protocol is the same
            as a
            top-level transaction’s. There are two phases, a
            <code class="systemitem">prepare</code>
            phase and a
            <code class="systemitem">commit</code>
            or
            <code class="systemitem">abort</code>
            phase. Using a multi-phase commit protocol
            avoids the above problem of discovering that one resources cannot commit after others have already been told to
            commit. The
            <code class="systemitem">prepare</code>
            phase generates consensus on the commit outcome, and the
            <code class="systemitem">commit</code>
            or
            <code class="systemitem">abort</code>
            phase enforces the outcome.
        </p>
        <p>
      
            supports the strict OTS implementation of subtransactions for those resources derived from
            <code class="interfacename">CosTransactions::SubtransactionAwareResource</code>
            . However, if a resource is derived
            from
            <code class="interfacename">ArjunaOTS::ArjunaSubtranAwareResource</code>
            , it is driven by a two-phase commit
            protocol whenever a nested transaction commits.
        </p>

        <div class="example"><a id="d5e3963"/><p class="title"><strong>Example 3.16. ArjunaSubtranAwareResource</strong></p><div class="example-contents">
            
            <pre><code class="language-java">interface ArjunaSubtranAwareResource : 
    CosTransactions::SubtransactionAwareResource
{
    CosTransactions::Vote prepare_subtransaction ();
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            During the first phase of the commit protocol the
            <code class="methodname">prepare_subtransaction</code>
            method is
            called, and the resource behaves as though it were being driven by a top-level transaction, making any state
            changes provisional upon the second phase of the protocol. Any changes to persistent state must still be
            provisional upon the second phase of the top-level transaction, as well. Based on the votes of all registered
            resources, 
            then calls either
            <code class="methodname">commit_subtransaction</code>
            or
            <code class="methodname">rollback_subtransaction</code>
            .
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                This scheme only works successfully if all resources registered within a given subtransaction are
                instances of
                the
                <code class="interfacename">ArjunaSubtranAwareResource</code>
                interface, and that after a resource tells the
                coordinator it can prepare, it does not change its mind.
            </p>
        </div>

    </div>

    <div class="section" title="3.2.5.2. Extended resources"><div class="titlepage"><div><div><h4 class="title"><a id="d5e3973"/>3.2.5.2. Extended resources</h4></div></div></div>
        
        <p>
            When resources are registered with a transaction, the transaction maintains them within a list, called the
            <em class="firstterm">intentions list</em>.
            At termination time, the transaction uses the intentions list to drive
            each resource appropriately, to commit or abort. However, you have no control over the order in which resources
            are called, or whether previously-registered resources should be replaced with newly registered resources. The
      
            interface
            <code class="interfacename">ArjunaOTS::OTSAbstractRecord</code>
            gives you this level of control.
        </p>

        <div class="example"><a id="d5e3978"/><p class="title"><strong>Example 3.17. OTSAbstractRecord</strong></p><div class="example-contents">
            
            <pre><code class="language-java">interface OTSAbstractRecord : ArjunaSubtranAwareResource
{
    readonly attribute long typeId;
    readonly attribute string uid;

    boolean propagateOnAbort ();
    boolean propagateOnCommit ();

    boolean saveRecord ();
    void merge (in OTSAbstractRecord record);
    void alter (in OTSAbstractRecord record);

    boolean shouldAdd (in OTSAbstractRecord record);
    boolean shouldAlter (in OTSAbstractRecord record);
    boolean shouldMerge (in OTSAbstractRecord record);
    boolean shouldReplace (in OTSAbstractRecord record);
};
</code></pre>
        </div></div><br class="example-break"/>

        <div class="informaltable">
            <table border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>typeId</td><td>
                            <p>
                                returns the record type of the instance. This is one of the values of the enumerated
                                type
                                <span class="type">Record_type</span>
                                .
                            </p>
                        </td></tr><tr><td>uid</td><td>
                            <p>
                                a stringified Uid for this record.
                            </p>
                        </td></tr><tr><td>propagateOnAbort</td><td>
                            <p>
                                by default, instances of
                                <code class="interfacename">OTSAbstractRecord</code>
                                should not be propagated to
                                the parent transaction if the current transaction rolls back. By returning
                                <code class="literal">TRUE</code>
                                , the
                                instance will be propagated.
                            </p>
                        </td></tr><tr><td>propagateOnCommit</td><td>
                            <p>
                                returning
                                <code class="literal">TRUE</code>
                                from this method causes the instance to be propagated to the parent
                                transaction if the current transaction commits. Returning
                                <code class="literal">FALSE</code>
                                disables the
                                propagation.
                            </p>
                        </td></tr><tr><td>saveRecord</td><td>
                            <p>
                                returning
                                <code class="literal">TRUE</code>
                                from this method causes 
                                to try to save sufficient information
                                about the record to persistent state during commit, so that crash recovery mechanisms can replay the
                                transaction termination in the event of a failure. If
                                <code class="literal">FALSE</code>
                                is returned, no
                                information is saved.
                            </p>
                        </td></tr><tr><td>merge</td><td>
                            <p>
                                used when two records need to merge together.
                            </p>
                        </td></tr><tr><td>alter</td><td>
                            <p>
                                used when a record should be altered.
                            </p>
                        </td></tr><tr><td>shouldAdd</td><td>
                            <p>
                                returns
                                <code class="literal">true</code>
                                ii the record should be added to the list,
                                <code class="literal">false</code>
                                if
                                it should be discarded.
                            </p>
                        </td></tr><tr><td>shouldMerge</td><td>
                            <p>
                                returns
                                <code class="literal">true</code>
                                if the two records should be merged into a single record,
                                <code class="literal">false</code>
                                otherwise.
                            </p>
                        </td></tr><tr><td>shouldReplace</td><td>
                            <p>
                                returns
                                <code class="literal">true</code>
                                if the record should replace an existing one,
                                <code class="literal">false</code>
                                otherwise.
                            </p>
                        </td></tr></tbody></table>
        </div>
        <p>
            When inserting a new record into the transaction’s intentions list, 
            uses the following algorithm:
        </p>
        <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                <p>
                    if a record with the same type and uid has already been inserted, then the methods
                    <code class="methodname">shouldAdd</code>
                    , and related methods, are invoked to determine whether this record should
                    also be added.
                </p>
            </li><li class="listitem">
                <p>
                    If no such match occurs, then the record is inserted in the intentions list based on the
                    <code class="systemitem">type</code>
                    field, and ordered according to the uid. All of the records with the same type
                    appear ordered in the intentions list.
                </p>
            </li></ol></div>
        <p>
            <code class="interfacename">OTSAbstractRecord</code>
            is derived from
            <code class="interfacename">ArjunaSubtranAwareResource</code>
            . Therefore, all instances of
            <code class="interfacename">OTSAbstractRecord</code>
            inherit the benefits of this interface.
        </p>
    </div>

    <div class="section" title="3.2.5.3. AtomicTransaction"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4051"/>3.2.5.3. AtomicTransaction</h4></div></div></div>
        
        <p>
            In terms of the OTS,
            <code class="interfacename">AtomicTransaction</code>
            is the preferred interface to the OTS
            protocol engine. It is equivalent to
            <code class="interfacename">CosTransactions::Current</code>
            , but with more
            emphasis on easing application development. For example, if an instance of
            <code class="interfacename">AtomicTransaction</code>
            goes out of scope before it is terminates, the transaction
            automatically rolls back.
            <code class="interfacename">CosTransactions::Current</code>
            cannot provide this
            functionality. When building applications using ,
            use
            <code class="interfacename">AtomicTransaction</code>
            for
            the added benefits it provides. It is located in the
            <span class="package">com.arjuna.ats.jts.extensions.ArjunaOTS</span>
            package.
        </p>

        <div class="example"><a id="d5e4060"/><p class="title"><strong>Example 3.18. AtomicTransaction</strong></p><div class="example-contents">
            
            <pre><code class="language-java">public class AtomicTransaction
{
    public AtomicTransaction ();
    public void begin () throws SystemException, SubtransactionsUnavailable,
                                NoTransaction;
    public void commit (boolean report_heuristics) throws SystemException, 
                                                          NoTransaction, HeuristicMixed,
                                                          HeuristicHazard,TransactionRolledBack;
    public void rollback () throws SystemException, NoTransaction;
    public Control control () throws SystemException, NoTransaction;
    public Status get_status () throws SystemException;
    /* Allow action commit to be supressed */    
    public void rollbackOnly () throws SystemException, NoTransaction;

    public void registerResource (Resource r) throws SystemException, Inactive;
    public void
        registerSubtransactionAwareResource (SubtransactionAwareResource)
        throws SystemException, NotSubtransaction;
    public void
        registerSynchronization(Synchronization s) throws SystemException,
                                                          Inactive;
};
</code></pre>
        </div></div><br class="example-break"/>

        <div class="table"><a id="d5e4063"/><p class="title"><strong>Table 3.7. AtomicTransaction's Methods</strong></p><div class="table-contents">
            
            <table summary="AtomicTransaction's Methods" border="1"><colgroup><col width="150px"/><col width="290px"/></colgroup><tbody><tr><td>begin</td><td>
                            <p>Starts an action</p>
                        </td></tr><tr><td>commit</td><td>
                            <p>Commits an action</p>
                        </td></tr><tr><td>rollback</td><td>
                            <p>Abort an action</p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>
        <p>
            Transaction nesting is determined dynamically. Any transaction started within the scope of another running
            transaction is nested.
        </p>
        <p>
            The
            <code class="classname">TopLevelTransaction</code>
            class, which is derived from
            <code class="interfacename">AtomicTransaction</code>
            , allows creation of nested top-level transactions. Such
            transactions allow non-serializable and potentially non-recoverable side effects to be initiated from within a
            transaction, so use them with caution. You can create nested top-level transactions with a combination of the
            <code class="classname">CosTransactions::TransactionFactory</code>
            and the
            <code class="methodname">suspend</code>
            and
            <code class="methodname">resume</code>
            methods of
            <code class="classname">CosTransactions::Current</code>
            . However, the
            <code class="classname">TopLevelTransaction</code>
            class provides a more user-friendly interface.
        </p>
        <p>
            <code class="classname">AtomicTransaction</code>
            and
            <code class="classname">TopLevelTransaction</code>
            are completely compatible
            with
            <code class="interfacename">CosTransactions::Current</code>
            . You an use the two transaction mechanisms
            interchangeably within the same application or object.
        </p>
        <p>
            <code class="classname">AtomicTransaction</code>
            and
            <code class="classname">TopLevelTransaction</code>
            are similar to
            <code class="interfacename">CosTransactions::Current</code>
            . They both simplify the interface between you and the OTS.
            However, you gain two advantages by using
            <code class="classname">AtomicTransaction</code>
            or
            <code class="classname">TopLevelTransaction</code>
            .
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    The ability to create nested top-level transactions which are automatically associated with the current
                    thread. When the transaction ends, the previous transaction associated with the thread, if any, becomes the
                    thread’s current transaction.
                </p>
            </li><li class="listitem">
                <p>
                    Instances of
                    <code class="classname">AtomicTransaction</code>
                    track scope, and if such an instance goes out of scope
                    before it is terminated, it is automatically aborted, along with its children.
                </p>
            </li></ul></div>
    </div>

    <div class="section" title="3.2.5.4. Context propagation issues"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4106"/>3.2.5.4. Context propagation issues</h4></div></div></div>
        
        <p>
            When using TXOJ in a distributed manner, 
            requires you to use interposition between client and object. This
            requirement also exists if the application is local, but the transaction manager is remote. In the case of
            implicit context propagation, where the application object is derived from
            <code class="interfacename">CosTransactions::TransactionalObject</code>,
            you do not need to do anything
            further. 
            automatically provides interposition. However, where implicit propagation is not supported by the
            ORB, or your application does not use it, you must take additional action to enable interposition.
        </p>
        <p>
            The class
            <code class="classname">com.arjuna.ats.jts.ExplicitInterposition</code>
            allows an application to create a local
            control object which acts as a local coordinator, fielding registration requests that would normally be passed
            back to the originator. This surrogate registers itself with the original coordinator, so that it can correctly
            participate in the commit protocol. The application thread context becomes the surrogate transaction
            hierarchy. Any transaction context currently associated with the thread is lost. The interposition lasts for
            the
            lifetime of the explicit interposition object, at which point the application thread is no longer associated with
            a transaction context. Instead, it is set to
            <code class="literal">null</code>
            .
        </p>
        <p>
            interposition is intended only for those situations where the transactional object and the transaction occur
            within different processes, rather than being co-located. If the transaction is created locally to the client, do
            not use the explicit interposition class. The transaction is implicitly associated with the transactional object
            because it resides within the same process.
        </p>

        <div class="example"><a id="d5e4114"/><p class="title"><strong>Example 3.19. ExplicitInterposition</strong></p><div class="example-contents">
            
            <pre><code class="language-java">public class ExplicitInterposition
{
    public ExplicitInterposition ();

    public void registerTransaction (Control control) throws InterpositionFailed, SystemException;

    public void unregisterTransaction () throws InvalidTransaction,
                                                SystemException;
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            A transaction context can be propagated between client and server in two ways: either as a reference to the
            client’s transaction Control, or explicitly sent by the client. Therefore, there are two ways in which the
            interposed transaction hierarchy can be created and registered. For example, consider the class Example which is
            derived from LockManager and has a method increment:
        </p>

        <div class="example"><a id="d5e4118"/><p class="title"><strong>Example 3.20. ExplicitInterposition Example</strong></p><div class="example-contents">
            
            <pre><code class="language-java">public boolean increment (Control control)
{
    ExplicitInterposition inter = new ExplicitInterposition();

    try
        {
            inter.registerTransaction(control);
        }
    catch (Exception e)
        {
            return false;
        }

    // do real work

    inter.unregisterTransaction();  // should catch exceptions!

    // return value dependant upon outcome
}
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            if the
            <code class="interfacename">Control</code>
            passed to the
            <code class="methodname">register</code>
            operation of
            <code class="classname">ExplicitInterposition</code>
            is
            <code class="literal">null</code>
            , no exception is thrown. The system
            assumes that the client did not send a transaction context to the server. A transaction created within the object
            will thus be a top-level transaction.
        </p>
        <p>
            When the application returns, or when it finishes with the interposed hierarchy, the program should call
            <code class="methodname">unregisterTransaction</code>
            to disassociate the thread of control from the hierarchy. This
            occurs automatically when the
            <code class="classname">ExplicitInterposition</code>
            object is garbage collected. However,
            since this may be after the transaction terminates, 
            assumes the thread is still associated with the
            transaction and issues a warning about trying to terminate a transaction while threads are still active within it.
        </p>
    </div>
</div>
        <div class="section" title="3.2.6. Example"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4129"/>3.2.6. Example</h3></div></div></div>
    
    <p>
        This example illustrates the concepts and the implementation details for a simple client/server example using
        implicit context propagation and indirect context management.
    </p>

    <div class="section" title="3.2.6.1. The basic example"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4132"/>3.2.6.1. The basic example</h4></div></div></div>
        
        <p>
            This example only includes a single unit of work within the scope of the transaction. consequently, only a
            one-phase commit is needed.
        </p>
        <p>
            The client and server processes are both invoked using the
            <code class="option">implicit propagation</code>
            and
            <code class="option">interposition</code>
            command-line options.
        </p>
        <p>
            For the purposes of this worked example, a single method implements the
            <code class="interfacename">DemoInterface</code>
            interface. This method is used in the DemoClient program.
        </p>

        <div class="example"><a id="d5e4140"/><p class="title"><strong>Example 3.21. idl interface</strong></p><div class="example-contents">
            
            <pre><code class="language-java">#include &lt;idl/CosTransactions.idl&gt;
#pragma javaPackage ""


module Demo
{
    exception DemoException {};

    interface DemoInterface : CosTransactions::TransactionalObject
    {
        void work() raises (DemoException);
    };
};
</code></pre>
        </div></div><br class="example-break"/>

        <div class="section" title="3.2.6.1.1. Example implementation of the interface"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4143"/>3.2.6.1.1. Example implementation of the interface</h5></div></div></div>
            
            <p>
                This section deals with the pieces needed to implement the example interface.
            </p>

            <div class="section" title="3.2.6.1.1.1. Resource"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4146"/>3.2.6.1.1.1. Resource</h6></div></div></div>
                
                <p>
                    The example overrides the methods of the
                    <code class="classname">Resource</code>
                    implementation class. The
                    <code class="classname">DemoResource</code>
                    implementation includes the placement of
                    <code class="methodname">System.out.println</code>
                    statements at judicious points, to highlight when a particular
                    method is invoked.
                </p>
                <p>
                    Only a single unit of work is included within the scope of the transaction. Therefore, the
                    <code class="methodname">prepare</code>
                    or
                    <code class="methodname">commit</code>
                    methods should never be invoked, but the
                    <code class="methodname">commit_one_phase</code>
                    method should be invoked.
                </p>

                <div class="example"><a id="d5e4156"/><p class="title"><strong>Example 3.22. DemoResource</strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">1    import org.omg.CosTransactions.*;
2    import org.omg.CORBA .SystemException;
3
4    public class DemoResource extends  org.omg.CosTransactions .ResourcePOA
5    {
6        public Vote prepare() throws HeuristicMixed, HeuristicHazard,
7        SystemException
8        {
9            System.out.println("prepare called");
10
11           return Vote.VoteCommit;
12       }
13
14       public void rollback() throws HeuristicCommit, HeuristicMixed,
15       HeuristicHazard, SystemException
16       {
17           System.out.println("rollback called");
18       }
19
20       public void commit() throws NotPrepared, HeuristicRollback,
21       HeuristicMixed, HeuristicHazard, SystemException
22       {
23           System.out.println("commit called");
24       }
25
26       public void commit_one_phase() throws HeuristicHazard, SystemException
27       {
28           System.out.println("commit_one_phase called");
29       }
30
31       public void forget() throws SystemException
32       {
33           System.out.println("forget called");
34       }
35   }    
</code></pre>
                </div></div><br class="example-break"/>
            </div>

            <div class="section" title="3.2.6.1.1.2. Transactional implementation"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4159"/>3.2.6.1.1.2. Transactional implementation</h6></div></div></div>
                
                <p>
                    At this stage, the
                    <code class="filename">Demo.idl</code>
                    has been processed by the ORB’s idl compiler to generate the
                    necessary client and server package.
                </p>
                <p>
                    Line 14 returns the transactional context for the
                    <code class="classname">Current</code>
                    pseudo object. After
                    obtaining a
                    <code class="classname">Control</code>
                    object, you can derive the Coordinator object (line 16).
                </p>
                <p>
                    Lines 17 and 19 create a resource for the transaction, and then inform the ORB that the resource is ready to
                    receive incoming method invocations.
                </p>
                <p>
                    Line 20 uses the
                    <code class="classname">Coordinator</code>
                    to register a
                    <code class="classname">DemoResource</code>
                    object
                    as a participant in the transaction. When the transaction terminates, the resource receives requests to commit
                    or rollback the updates performed as part of the transaction.
                </p>

                <div class="example"><a id="d5e4170"/><p class="title"><strong>Example 3.23. Transactional implementation</strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">1    import Demo.*;
2    import org.omg.CosTransactions.*;
3    import com.arjuna.ats.jts.*;
4    import com.arjuna.orbportability.*;
5
6    public class DemoImplementation extends Demo.DemoInterfacePOA
7    {
8        public void work() throws DemoException
9        {
10           try
11           {
12
13               Control control = OTSManager.get_current().get_control();
14
15               Coordinator  coordinator = control.get_coordinator();
16               DemoResource resource    = new DemoResource();
17
18               ORBManager.getPOA().objectIsReady(resource);
19               coordinator.register_resource(resource);
20
21           }
22           catch (Exception e)
23           {
24               throw new DemoException();
25           }
26       }
27
28   }          
</code></pre>
                </div></div><br class="example-break"/>
            </div>

            <div class="section" title="3.2.6.1.1.3. Server implementation"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4173"/>3.2.6.1.1.3. Server implementation</h6></div></div></div>
                
                <p>
                    First, you need to to initialize the ORB and the POA. Lines 10 through 14 accomplish these tasks.
                </p>
                <p>
                    The servant class
                    <code class="classname">DemoImplementation</code>
                    contains the implementation code for the
                    <code class="interfacename">DemoInterface</code>
                    interface. The servant services a particular client request. Line
                    16 instantiates a servant object for the subsequent servicing of client requests.
                </p>
                <p>
                    Once a servant is instantiated, connect the servant to the POA, so that it can recognize the invocations on
                    it, and pass the invocations to the correct servant. Line 18 performs this task.
                </p>
                <p>
                    Lines 20 through to 21 registers the service through the default naming mechanism. More information about the
                    options available can be found in the ORB Portability Guide.
                </p>
                <p>
                    If this registration is successful, line 23 outputs a
                    <code class="literal">sanity check</code>
                    message.
                </p>
                <p>
                    Finally, line 25 places the server process into a state where it can begin to accept requests from client
                    processes.
                </p>

                <div class="example"><a id="d5e4184"/><p class="title"><strong>Example 3.24. DemoServer</strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">1    import java.io.*;
2    import com.arjuna.orbportability.*;
3
4    public class DemoServer
5    {
6        public static void main (String[] args)
7        {
8            try
9            {
10               ORB myORB = ORB.getInstance("test").initORB(args, null);
11               RootOA myOA = OA.getRootOA(myORB).myORB.initOA();
12
13               ORBManager.setORB(myORB);
14                   ORBManager.setPOA(myOA);
15
16                   DemoImplementation obj = new DemoImplementation();
17               
18               myOA.objectIsReady(obj);
19               
20               Services serv = new Services(myORB);
21               serv.registerService(myOA.corbaReference(obj), "DemoObjReference", null);
22
23               System.out.println("Object published.");
24
25               myOA.run();
26           }
27           catch (Exception e)
28           {
29               System.err.println(e);
30           }
31       }
32   }
</code></pre>
                </div></div><br class="example-break"/>
                <p>
                    After the server compiles, you can use the command line options defined below to start a server
                    process. By
                    specifying the usage of a filter on the command line, you can override settings in the
                    <code class="filename">TransactionService.properties</code>
                    file.
                </p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                    <p>
                        if you specify the interposition filter, you also imply usage of implicit context propagation.
                    </p>
                </div>
            </div>

            <div class="section" title="3.2.6.1.1.4. Client implementation"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4191"/>3.2.6.1.1.4. Client implementation</h6></div></div></div>
                
                <p>
                    The client, like the server, requires you to first initialize the ORB and the POA. Lines 14 through 18
                    accomplish these tasks.
                </p>
                <p>
                    After a server process is started, you can obtain the object reference through the default
                    publication
                    mechanism used to publish it in the server. This is done in lines 20 and 21. Initially the reference is an
                    instance of
                    <code class="classname">Object</code>
                    . However, to invoke a method on the servant object, you need to
                    narrow this instance to an instance of the
                    <code class="interfacename">DemoInterface</code>
                    interface. This is
                    shown in line 21.
                </p>
                <p>
                    Once we have a reference to this servant object, we can start a transaction (line 23), perform a unit of work
                    (line 25) and commit the transaction (line 27).
                </p>
                <div class="example"><a id="d5e4198"/><p class="title"><strong>Example 3.25. DemoClient</strong></p><div class="example-contents">
                    
                    <pre><code class="language-java">1    import Demo.*;
2    import java.io.*;
3    import com.arjuna.orbportability.*;
4    import com.arjuna.ats.jts.*;
5    import org.omg.CosTransactions.*;
6    import org.omg.*;
7
8    public class DemoClient
9    {
10       public static void main(String[] args)
11       {
12           try
13           {
14               ORB myORB = ORB.getInstance("test").initORB(args, null);
15               RootOA myOA = OA.getRootOA(myORB).myORB.initOA();
16
17               ORBManager.setORB(myORB);
18               ORBManager.setPOA(myOA);
19               
20                   Services serv = new Services(myORB);
21               DemoInterface d = (DemoInterface) DemoInterfaceHelper.narrow(serv.getService("DemoObjReference"));
22               
23               OTS.get_current().begin();
24
25               d.work();
26
27               OTS.get_current().commit(true);
28           }
29           catch (Exception e)
30           {
31               System.err.println(e);
32           }
33       }
34   }
</code></pre>
                </div></div><br class="example-break"/>
            </div>

            <div class="section" title="3.2.6.1.1.5. Sequence diagram"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4201"/>3.2.6.1.1.5. Sequence diagram</h6></div></div></div>
                
                <p>
                    The sequence diagram illustrates the method invocations that occur between the client and server. The
                    following aspects are important:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>
                            You do not need to pass the transactional context as a parameter in method
                            <code class="methodname">work</code>
                            ,
                            since you are using implicit context propagation.
                        </p>
                    </li><li class="listitem">
                        <p>
                            Specifying the use of interposition when the client and server processes are started, by using appropriate
                            filters and interceptors, creates an interposed coordinator that the servant process can use, negating any
                            requirement for cross-process invocations. The interposed coordinator is automatically registered with the
                            root coordinator at the client.
                        </p>
                    </li><li class="listitem">
                        <p>
                            The resource that commits or rolls back modifications made to the transactional object is associated, or
                            registered, with the interposed coordinator.
                        </p>
                    </li><li class="listitem">
                        <p>
                            The
                            <code class="methodname">commit</code>
                            invocation in the client process calls the root coordinator. The root
                            coordinator calls the interposed coordinator, which in turn calls the
                            <code class="methodname">commit_one_phase</code>
                            method for the resource.
                        </p>
                    </li></ul></div>
                <div class="figure"><a id="d5e4216"/><p class="title"><strong>Figure 3.16. Sequence Diagram</strong></p><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/jts-sequence-diagram.png" alt="Sequence Diagram" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e4218.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e4218.html" target="longdesc">D</a>]</span></div></div>
                </div></div><br class="figure-break"/>
            </div>

            <div class="section" title="3.2.6.1.1.6. Interpretation of output"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4223"/>3.2.6.1.1.6. Interpretation of output</h6></div></div></div>
                
                <p>
                    The server process first stringifies the servant instance, and writes the servant IOR to a temporary file. The
                    first line of output is the sanity check that the operation was successful.
                </p>
                <p>
                    In this simplified example, the coordinator object has only a single registered resource.
                    Consequently, it
                    performs a
                    <code class="methodname">commit_one_phase</code>
                    operation on the resource object, instead of performing a
                    <code class="methodname">prepare</code>
                    operation, followed by a
                    <code class="methodname">commit</code>
                    or
                    <code class="methodname">rollback</code>
                    .
                </p>
                <p>
                    The output is identical, regardless of whether implicit context propagation or interposition is used, since
                    interposition is essentially performance aid. Ordinarily, you may need to do a lot of marshaling
                    between a
                    client and server process.
                </p>
                <div class="example"><a id="d5e4232"/><p class="title"><strong>Example 3.26. Server output</strong></p><div class="example-contents">
                    
                    <pre class="screen">
Object reference written to file
commit_one_phase called        
          </pre>
                </div></div><br class="example-break"/>
            </div>
        </div>
    </div>

    <div class="section" title="3.2.6.2. Default settings"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4235"/>3.2.6.2. Default settings</h4></div></div></div>
        
        <p>
            These settings are defaults, and you can override them at run-time by using property variables, or in the
            properties file in the
            <code class="filename">etc/</code>
            directory of the installation.
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    Unless a CORBA object is derived from
                    <code class="interfacename">CosTransactions::TransactionalObject</code>,you
                    do not need to propagate any
                    context. In order to preserve distribution transparency, 
                    defaults to always propagating a
                    transaction context when calling remote objects, regardless of whether they are marked as transactional
                    objects. You can override this by setting the
                    <code class="varname">com.arjuna.ats.jts.alwaysPropagateContext</code>
                    property variable to
                    <code class="literal">NO</code>
                    .
                </p>
            </li><li class="listitem">
                <p>
                    If an object is derived from
                    <code class="interfacename">CosTransactions::TransactionalObject</code>,
                    and no
                    client context is present when an invocation is made, 
                    transmits a null context. Subsequent
                    transactions begun by the object are top-level. If a context is required, then set the
                    <code class="varname">com.arjuna.ats.jts.needTranContext</code>
                    property variable to
                    <code class="literal">YES</code>,
                    in which
                    case 
                    raises the
                    <code class="systemitem">TransactionRequired</code>
                    exception.
                </p>
            </li><li class="listitem">
                <p>
          
                    needs a persistent object store, so that it can record information about transactions in the event
                    of
                    failures. If all transactions complete successfully, this object store has no entries. The default location
                    for this must be set using the
                    <code class="varname">ObjectStoreEnvironmentBean.objectStoreDir</code>
                    variable in the
                    properties file.
                </p>
            </li><li class="listitem">
                <p>
                    If you use a separate transaction manager for
                    <code class="interfacename">Current</code>
                    , its location is obtained
                    from the
                    <code class="filename">CosServices.cfg</code>
                    file.
                    <code class="filename">CosServices.cfg</code>
                    is located at runtime
                    by the
                    <code class="varname">OrbPortabilityEnvironmentBean</code>
                    properties
                    <code class="varname">initialReferencesRoot</code>
                    and
                    <code class="varname">initialReferencesFile</code>
                    . The former is a directory, defaulting to the current working
                    directory. The latter is a file name, relative to the directory. The default value is
                    <code class="literal">CosServices.cfg</code>
                    .
                </p>
            </li><li class="listitem">
                <p>
                    Checked transactions are not enabled by default. This means that threads other than the transaction
                    creator may
                    terminate the transaction, and no check is made to ensure all outstanding requests have finished prior to
                    transaction termination. To override this, set the
                    <code class="varname">JTSEnvironmentBean.checkedTransactions</code>
                    property variable to
                    <code class="literal">YES</code>
                    .
                </p>
            </li><li class="listitem">
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                    <p>
                        As of 
                        4.5, transaction timeouts are unified across all transaction components and are controlled by
                        ArjunaCore. The old JTS configuration property com.arjuna.ats.jts.defaultTimeout still remains
                        but is
                        deprecated.
                    </p>
                </div>
                <p>
                    if a value of
                    <code class="literal">0</code>
                    is specified for the timeout of a top-level transaction, or no timeout is
                    specified, 
                    does not impose any timeout on the transaction. To override this default timeout, set the
                    <code class="varname">CoordinatorEnvironmentBean.defaultTimeout</code>
                    property variable to the required timeout value
                    in seconds.
                </p>
            </li></ul></div>
    </div>
</div>
        <div class="section" title="3.2.7. Trail map"><div class="titlepage"><div><div><h3 class="title"><a id="d5e4273"/>3.2.7. Trail map</h3></div></div></div>
    
    <div class="section" title="3.2.7.1. Introduction"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4275"/>3.2.7.1. Introduction</h4></div></div></div>
        
        <p>
            assures complete, accurate business
            transactions for any Java based applications, including those written for the
            Jakarta EE and EJB frameworks.
        </p>
        <p>
            is a 100% Java implementation of a distributed transaction management system
            based on the Jakarta EE Java Transaction Service (JTS) standard.
            Our implementation of the JTS utilizes the Object Management Group's (OMG) Object
            Transaction Service (OTS) model for transaction interoperability as recommended
            in the Jakarta EE and EJB standards. Although any JTS-compliant product will allow
            Java objects to participate in transactions, one of the key features of 
            is it's 100% Java implementation. This allows 
            to support fully distributed
            transactions that can be coordinated by distributed parties.
            </p><p>
                runs can be run both as an embedded distributed service of an application
                server (e.g. WildFly Application Server),
                affording the user all the added benefits of the
                application server environment such as real-time load balancing, unlimited linear
                scalability and unmatched fault tolerance that allows you to deliver an always-on
                solution to your customers. It is also available as a free-standing Java Transaction
                Service.
            </p><p>
            </p><p>In
                addition to providing full compliance with the latest version of the JTS
                specification, 
                leads the market in providing many advanced features such
                as fully distributed transactions and ORB portability with POA support.
            </p><p>
            </p><p>
                is tested on HP-UX 11i, Red Hat Linux, Windows Server 2003,
                and Sun Solaris 10, using Sun's JDK 5. It should howerver work on any system with JDK 5 or 6.
            </p><p>
            </p><p>The
                Java Transaction API support for 
                comes in two flavours:
            </p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    a purely local implementation, that does not require an ORB, but obviously
                    requires all coordinated resources to reside within the same JVM.
                </li><li class="listitem">
                    a fully distributed implementation.
                </li></ul></div><p>
            </p><p>Key features</p><p>
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    full compliance with the Jakarta Transactions specification:
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Purely local (ORB-less) JTA offers the fastest JTA performance
                        </li><li class="listitem">
                            JDBC support
                        </li><li class="listitem">
                            XA compliance
                        </li><li class="listitem">
                            JDBC drivers for database access with full transaction support
                        </li><li class="listitem">
                            Automatic crash recovery for XAResources
                        </li></ul></div>
                </li><li class="listitem">
                    compliance with the JTS specification and OTS 1.2 specification from the
                    OMG
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Distributed JTA implementation
                        </li><li class="listitem">
                            support for distributed transactions (utilizing two-phase commit)
                        </li><li class="listitem">
                            POA ORB support
                        </li><li class="listitem">
                            interposition
                        </li><li class="listitem">
                            transaction heuristics
                        </li><li class="listitem">
                            distributed transaction manager (co-located with the transaction initiator)
                            or transaction manager server
                        </li><li class="listitem">
                            checked/unchecked transaction behaviour
                        </li><li class="listitem">
                            supports both flat and nested transaction models, with nested-aware
                            resources and resource adapters
                        </li><li class="listitem">
                            independent concurrency control system with support for type-specific
                            concurrency control
                        </li><li class="listitem">
                            support for CosTransaction::Current
                        </li><li class="listitem">
                            direct and indirect transaction management
                        </li><li class="listitem">
                            synchronization interface
                        </li><li class="listitem">
                            explicit and implicit transaction context propagation
                        </li><li class="listitem">
                            automatic crash recovery
                        </li><li class="listitem">
                            multi-thread aware
                        </li></ul></div>
                </li><li class="listitem">
                    transactional objects (TO) for Java
                </li><li class="listitem">
                    ORB independence via the ORB portability layer
                </li></ul></div><p>
        </p>
        <p>
            This trail map will help you get started with running 
            product.
            It is structured as follows:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">1.
                Installation Content: This trail describes the content installed by the 
                distribution
            </li><li class="listitem">2.
                The Sample Application: This trail describes via a set of examples how 
                is used to build transactional applications
            </li><li class="listitem">
                3. Deploying and testing the Sample Application: This trail describes how to deploy and to test the
                sample application
            </li><li class="listitem">
                4. Making the Sample Application Persistent: This trail describes tools allowing to build a persistent
                application
            </li><li class="listitem">5.
                Recovery from Failure: This trail describes via a simple scenario how 
                manages recovery from failure.
            </li><li class="listitem">
                6. Where Next?: This trail indicates where to find additional information
            </li></ul></div>
        <p>
            In addition to the trails listed above, a set of trails giving more explanation on concept around
            transaction processing and standards, and also a quick access to section explaining how to configure 
            are listed in the section "Additional Trails".
        </p>
        <p>
            <span class="emphasis"><em>Note:</em></span>
            When running the local JTS transactions part of the trailmap, you will need to start
            the recovery manager: java com.arjuna.ats.arjuna.recovery.RecoveryManager -test
        </p>
    </div>
    <div class="section" title="3.2.7.2. Overview of the X/Open DTP model"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4325"/>3.2.7.2. Overview of the X/Open DTP model</h4></div></div></div>
        

        The X/Open Distributed Transaction Processing (DTP) model is a distributed
        transaction processing model proposed by the Open Group, a vendor consortium.
        This model is a standard among most of the commercial vendors in transaction
        processing and database domains.
        <p>This model consists of the follwng components (illustrated in Figure 1)</p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                an Application Program (AP), which defines transaction boundaries and specifies
                actions that constitute a transaction
            </li><li class="listitem">
                Resource Managers (RMs) such as databases or file access systems, which
                provide access to resources
            </li><li class="listitem">
                a Transaction Manager (TM), which assigns identifiers to transactions,
                monitors their progress, and takes responsibility for transaction completion
                and for coordinating failure recovery
            </li><li class="listitem">
                Communication Resource Managers (CRMs), which control communication between
                distributed applications within or across TM domains
            </li></ul></div>
        <img src="images/jts-xopen.PNG.png"/>
        <p>Figure 1 - The X/Open DTP model</p>
    </div>
    <div class="section" title="3.2.7.3.  Interface between functional components"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4335"/>3.2.7.3.  Interface between functional components</h4></div></div></div>
        
        There are six interfaces between software components in the X/Open DTP model.
        <div class="itemizedlist"><p>The functions that each RM provides for the TM are called the xa_*()
                functions. For example the TM calls xa_start( ) in each participating
                RM to start an RM-internal transaction as part of a new global transaction.
                Later, the TM may call in sequence xa_end() xa_prepare( ) and xa_commit()
                to coordinate a (successful in this case) two-phase commit protocol.
                The functions that the TM provides for each RM are called the ax_*( ) functions.
                For example an RM calls ax_reg( ) to register dynamically with the TM.
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    the TxRPC interface (see the referenced TxRPC specification)
                </li><li class="listitem">
                    the XATMI interface (see the referenced XATMI specification)
                </li><li class="listitem">
                    the CPI-C interface (see the referenced CPI-C specification).
                </li></ul></div><ul class="itemizedlist"><li class="listitem">
                AP-RM. The AP-RM interfaces give the AP access to resources. X/Open interfaces,
                such as SQL and ISAM provide AP portability. The X/Open DTP model imposes
                few constraints on native RM APIs. The constraints involve only those native
                RM interfaces that define transactions.
            </li><li class="listitem">
                AP-TM. The AP-TM interface (the TX interface) provides the AP with an Application
                Programming Interface (API) by which the AP coordinates global transaction
                management with the TM. For example, when the AP calls tx_begin( ) the
                TM informs the participating RMs of the start of a global transaction.
                After each request is completed, the TM provides a return value to the
                AP reporting back the success or otherwise of the TX call.
            </li><li class="listitem">
                TM-RM. The TM-RM interface (the XA interface) lets the TM structure the
                work of RMs into global transactions and coordinate completion or recovery.
                The XA interface is the bidirectional interface between the TM and RM.
            </li><li class="listitem">
                TM-CRM. The TM-CRM interface (the XA+ interface) supports global transaction
                information flow across TM Domains. In particular TMs can instruct CRMs
                by use of xa_*() function calls to suspend or complete transaction branches,
                and to propagate global transaction commitment protocols to other transaction
                branches. CRMs pass information to TMs in subordinate branches by use of
                ax_*( ) function calls. CRMs also use ax_*( ) function calls to request
                the TM to create subordinate transaction branches, to save and retrieve
                recovery information, and to inform the TM of the start and end of blocking
                conditions.
            </li><li class="listitem">
                AP-CRM. X/Open provides portable APIs for DTP communication between APs
                within a global transaction. The API chosen can significantly influence
                (and may indeed be fundamental to) the whole architecture of the application.
                For this reason, these APIs are frequently referred to in this specification
                and elsewhere as communication paradigms.In practice, each paradigm has
                unique strengths, so X/Open offers the following popular paradigms:
            </li><li class="listitem">
                CRM-OSI TP. This interface (the XAP-TP interface) provides a programming
                interface between a CRM and Open Systems Interconnection Distributed Transaction
                Processing (OSI TP) services. XAP-TP interfaces with the OSI TP Service
                and the Presentation Layer of the seven-layer OSI model. X/Open has defined
                this interface to support portable implementations of application-specific
                OSI services. The use of OSI TP is mandatory for communication between
                heterogeneous TM domains. For details of this interface, see the referenced
                XAP-TP specification and the OSI TP standards.
            </li></ul></div>
        Although the aim of the Open Group was providing portable interfaces, only
        the XA interface appears to be accepted and implemented by a wide
        range of vendors.
        <p>XA is a bidirectional interface between resource managers and transaction
            managers. This interface specifies two sets of functions. The first set,
            called as xa_*() functions are implemented by resource managers for use
            by the transaction manager.
        </p>
        <p>Table 1 - XA Interface of X/Open DTP Model for the transaction manager</p>
        <table id="d5e4351">
            <tr>
                <td>
                    <span class="emphasis"><em>Function</em></span>
                </td>
                <td>
                    <span class="emphasis"><em>Purpose</em></span>
                </td>
            </tr>
            <tr>
                <td>xa_start</td>
                <td>Directs a resource manager to associate the subsequent requests by
                    application programs to a transaction identified by the supplied identifier.
                </td>
            </tr>
            <tr>
                <td>xa_end</td>
                <td>Ends the association of a resource manager with the transaction.</td>
            </tr>
            <tr>
                <td>xa_prepare</td>
                <td>Prepares the resource manager for the commit operation. Issued by the
                    transaction manager in the first phase of the two-phase commit operation.
                </td>
            </tr>
            <tr>
                <td>xa_commit</td>
                <td>Commits the transactional operations. Issued by the transaction manager
                    in the second phase of the two-phase commit operation.
                </td>
            </tr>
            <tr>
                <td>xa_recover</td>
                <td>Retrieves a list of prepared and heuristically committed or heuristically
                    rolled back transactions
                </td>
            </tr>
            <tr>
                <td>xa_forget</td>
                <td>Forgets the heuristic transaction associated with the given transaction
                    identifier
                </td>
            </tr>
        </table>
        <p>The second set of functions, called as ax_*() functions, are implemented
            by the transaction manager for use by resource managers.
        </p>
        <p>Table 2 - XA Interface of X/Open DTP Model for resource managers</p>
        <table id="d5e4377">
            <tr>
                <td>
                    <span class="emphasis"><em>Function</em></span>
                </td>
                <td>
                    <span class="emphasis"><em>Purpose</em></span>
                </td>
            </tr>
            <tr>
                <td>ax_reg()</td>
                <td>Dynamically enlists with the transaction manager.</td>
            </tr>
            <tr>
                <td>ax_unreg()</td>
                <td>Dynamically delists from the transaction manager.</td>
            </tr>
        </table>


    </div>
    <div class="section" title="3.2.7.4. Overview of the Distributed Transaction Processing"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4389"/>3.2.7.4. Overview of the Distributed Transaction Processing</h4></div></div></div>
        
        <p>Transaction management is one of the most crucial requirements for enterprise application development.
            Most of the large enterprise applications
            in the domains of finance, banking and electronic commerce rely on transaction processing for delivering their business
            functionality.
        </p>
        <p>Enterprise applications often require concurrent access to distributed data shared amongst multiple
            components, to perform operations on data. Such
            applications should maintain integrity of data (as defined by the business rules of the application) under the following
            circumstances:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                distributed access to a single resource of data, and
            </li><li class="listitem">
                access to distributed resources from a single application component.
            </li></ul></div>
        <p>In such cases, it may be required that a group of operations on (distributed) resources be treated as one
            unit of work. In a unit of work, all
            the participating operations should either succeed or fail and recover together. This problem is more complicated when
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                a unit of work is implemented across a group of distributed components operating on data from multiple
                resources, and/or
            </li><li class="listitem">
                the participating operations are executed sequentially or in parallel threads requiring coordination
                and/or synchronization.
            </li></ul></div>
        <p>
            In either case, it is required that success or failure of a unit of work be maintained by the application.
            In case of a failure, all the resources should
            bring back the state of the data to the previous state (
            <span class="emphasis"><em>i.e.,</em></span>
            the state prior to the commencement of the unit of work).
        </p>
        <p> From the programmer's perspective a transaction is a scoping mechanism for a collection of actions which
            must complete as a unit. It provides a
            simplified model for exception handling since only two outcomes are possible:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                success - meaning that all actions involved within a transaction are completed
            </li><li class="listitem">
                failure - no actions complete
            </li></ul></div>
        <img src="images/jts-trans_succes_failure.PNG.png"/>
    </div>
    <div class="section" title="3.2.7.5. Example"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4407"/>3.2.7.5. Example</h4></div></div></div>
        
        <p>
            To illustrate the reliability expected by the application let’s consider the funds transfer example which is familiar
            to all of us.
        </p>

        The Money transfer involves two operations: Deposit and Withdrawal

        <p>
            The complexity of implementation doesn't matter; money moves from one place to
            another. For instance, involved accounts may be either located in a same relational table within
            a database or located on different databases.
        </p>
        <p>
            A Simple transfer consists on moving money from savings to checking while a Complex transfer can be performed at the
            end- of- day according
            to a reconciliation between international banks
        </p>
        <img src="images/jts-example_transfer.PNG.pngimages/jts-transaction_components.PNG.png"/>
        <p>The concept of a transaction, and a transaction manager (or a transaction
            processing service) simplifies construction of such enterprise level
            distributed applications while maintaining integrity of data in a unit of
            work.
        </p>
        <p>A transaction is a unit of work that has the following properties: </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <span class="emphasis"><em>Atomicity</em></span>
                – either the whole transaction completes or
                nothing completes - partial completion is not permitted.
            </li><li class="listitem">
                <span class="emphasis"><em>Consistency</em></span>
                – a transaction transforms the system from
                one consistent state to another. In other words, On completion of a
                successful transaction, the data should be in a consistent state. For
                example, in the case of relational databases, a consistent transaction
                should preserve all the integrity constraints defined on the data.
            </li><li class="listitem">
                <span class="emphasis"><em>Isolation:</em></span>
                Each transaction should appear to execute
                independently of other transactions that may be executing concurrently in
                the same environment. The effect of executing a set of transactions serially
                should be the same as that of running them concurrently. This requires two
                things:
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        During the course of a transaction, intermediate (possibly
                        inconsistent) state of the data should not be exposed to all other
                        transactions.
                    </li><li class="listitem">
                        Two concurrent transactions should not be able to operate on the same
                        data. Database management systems usually implement this feature using
                        locking.
                    </li></ul></div>
            </li><li class="listitem">
                <span class="emphasis"><em>Durabiliy:</em></span>
                The effects of a completed transaction should always
                be persistent.
            </li></ul></div>
        <p>
            These properties, called as
            <span class="emphasis"><em>ACID</em></span>
            properties, guarantee that a
            transaction is never incomplete, the data is never inconsistent, concurrent
            transactions are independent, and the effects of a transaction are persistent.
        </p>
        <div class="section" title="3.2.7.5.1. Transactional Concepts"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4429"/>3.2.7.5.1. Transactional Concepts</h5></div></div></div>
            
        </div>
        <div class="section" title="3.2.7.5.2. Transaction Components"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4431"/>3.2.7.5.2. Transaction Components</h5></div></div></div>
            
        </div>
        <p>A collection of actions is said to be transactional if they possess the ACID properties. These properties
            are assumed to be ensured, in the presence of failures; if actions involved within the transaction
            are performed by a Transactional System. A transaction system includes a set of components where each of
            them has a particular role. Main components are described below.
        </p>
        <img src="images/jts-example_transfer.PNG.pngimages/jts-transaction_components.PNG.png"/>
        <div class="section" title="3.2.7.5.3. Application Programs"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4435"/>3.2.7.5.3. Application
                Programs
            </h5></div><div><h5 class="title"><a id="d5e4435"/>3.2.7.5.3. Application
                Programs
            </h5></div><div><h5 class="title"><a id="d5e4435"/>3.2.7.5.3. Application
                Programs
            </h5></div></div></div>
            
            <p>Application Programs are clients for the transactional resources. These
                are the programs with which the application developer implements business
                transactions. With the help of the transaction manager, these components
                create global transactions and operate on the transactional resources with
                in the scope of these transactions. These components are not responsible
                for implementing mechanisms for preserving ACID properties of
                transactions. However, as part of the application logic, these components
                generally make a decision whether to commit or rollback transactions.
            </p>
            <p>Application responsibilities could be summarized as follow:</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Create and demarcate transactions
                </li><li class="listitem">
                    Operate on data via resource managers
                </li></ul></div>
            
            <p>A resource manager is in general a component that manages persistent
                and stable data storage system, and participates in the two phase commit
                and recovery protocols with the transaction manager.
            </p>
            <p>A resource manager is typically a driver that provides two
                sets of interfaces: one set for the application components to get
                connections and operating, and the other set for participating in two
                phase commit and recovery protocols coordinated by a transaction manager.
                This component may also, directly or indirectly, register resources with
                the transaction manager so that the transaction manager can keep track of
                all the resources participating in a transaction. This process is called
                as resource enlistment.
            </p>
            <p>Resource Manager responsibilities could be summarized as follow</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Enlist resources with the transaction manager
                </li><li class="listitem">
                    Participate in two-phase commit and recovery protocol
                </li></ul></div>
            
            <p>The transaction manager is the core component of a transaction
                processing environment. Its main responsibilities are to create
                transactions when requested by application components, allow resource
                enlistment and delistment, and to manage the two-phase commit or recovery
                protocol with the resource managers.
            </p>
            <p>A typical transactional application begins a transaction by issuing a
                request to a transaction manager to initiate a transaction. In response,
                the transaction manager starts a transaction and associates it with the
                calling thread. The transaction manager also establishes a transaction
                context. All application components and/or threads participating in the
                transaction share the transaction context. The thread that initially
                issued the request for beginning the transaction, or, if the transaction
                manager allows, any other thread may eventually terminate the transaction
                by issuing a commit or rollback request.
            </p>
            <p>Before a transaction is terminated, any number of components and/or
                threads may perform transactional operations on any number of
                transactional resources known to the transaction manager. If allowed by
                the transaction manager, a transaction may be suspended or resumed before
                finally completing the transaction.
            </p>
            <p>Once the application issues the commit request, the transaction manager
                prepares all the resources for a commit operation, and based on whether
                all resources are ready for a commit or not, issues a commit or rollback
                request to all the resources.
            </p>
            <p>Resource Manager responsibilities could be summarized as follow:</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Establish and maintain transaction context
                </li><li class="listitem">
                    Maintain association between a transaction and the participating
                    resources.
                </li><li class="listitem">
                    Initiate and conduct two-phase commit and recovery protocol with the
                    resource managers.
                </li><li class="listitem">
                    Make synchronization calls to the application components before
                    beginning and after end of the two-phase commit and recovery process
                </li></ul></div>
            <div class="section" title="3.2.7.5.3.1. Local vs. Distributed Transaction"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4460"/>3.2.7.5.3.1. Local vs. Distributed Transaction</h6></div></div></div>
                
                <p>
                    A transaction that involves only one transactional resource, such a database,
                    is considered as
                    <span class="emphasis"><em>local transaction</em></span>
                    , while a transaction that involves
                    more than one transactional resource that need to be coordinated to reach a
                    consistent state is considered as a
                    <span class="emphasis"><em>distributed transaction.</em></span>
                </p>
                <p>A transaction can be specified by what is known as transaction demarcation.
                    Transaction demarcation enables work done by distributed components to be
                    bound by a global transaction. It is a way of marking groups of operations to
                    constitute a transaction.
                </p>
                <p>The most common approach to demarcation is to mark the thread executing the
                    operations for transaction processing. This is called as programmatic
                    demarcation. The transaction so established can be suspended by unmarking the
                    thread, and be resumed later by explicitly propagating the transaction context
                    from the point of suspension to the point of resumption.
                </p>
                <p>The transaction demarcation ends after a commit or a rollback request to
                    the transaction manager. The commit request directs all the participating
                    resources managers to record the effects of the operations of the transaction
                    permanently. The rollback request makes the resource managers undo the effects
                    of all operations on the transaction.
                </p>
            </div>
            <div class="section" title="3.2.7.5.3.2. Transaction Context and Propagation"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4468"/>3.2.7.5.3.2. Transaction Context and Propagation </h6></div></div></div>
                
                <p>Since multiple application components and resources participate in a
                    transaction, it is necessary for the transaction manager to establish and
                    maintain the state of the transaction as it occurs. This is usually done in
                    the form of transaction context.
                </p>
                <p>Transaction context is an association between the transactional operations
                    on the resources, and the components invoking the operations. During the
                    course of a transaction, all the threads participating in the transaction
                    share the transaction context. Thus the transaction context logically envelops
                    all the operations performed on transactional resources during a transaction.
                    The transaction context is usually maintained transparently by the underlying
                    transaction manager.
                </p>
            </div>
            <div class="section" title="3.2.7.5.3.3. Resource Enlistment"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4472"/>3.2.7.5.3.3. Resource Enlistment</h6></div></div></div>
                
                <p>Resource enlistment is the process by which resource managers inform the
                    transaction manager of their participation in a transaction. This process
                    enables the transaction manager to keep track of all the resources
                    participating in a transaction. The transaction manager uses this information
                    to coordinate transactional work performed by the resource managers and to
                    drive two-phase and recovery protocol. At the end of a transaction (after a
                    commit or rollback) the transaction manager delists the resources.
                </p>
            </div>
            <div class="section" title="3.2.7.5.3.4. Two-Phase Commit"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4475"/>3.2.7.5.3.4. Two-Phase Commit</h6></div></div></div>
                
                <p>This protocol between the transaction manager and all the resources
                    enlisted for a transaction ensures that either all the resource managers
                    commit the transaction or they all abort. In this protocol, when the
                    application requests for committing the transaction, the transaction manager
                    issues a prepare request to all the resource managers involved. Each of these
                    resources may in turn send a reply indicating whether it is ready for commit
                    or not. Only The transaction manager issue a commit request to all the
                    resource managers, only when all the resource managers are ready for a commit.
                    Otherwise, the transaction manager issues a rollback request and the
                    transaction will be rolled back.
                </p>
            </div>
            <div class="section" title="3.2.7.5.3.5. Recovery and Logging"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4478"/>3.2.7.5.3.5. Recovery and Logging</h6></div></div></div>
                
                <p>
                    Basically, the Recovery is the mechanism which preserves the transaction atomicity in presence of failures.
                    The basic technique for implementing transactions in presence of failures is based on the use of logs. That is, a
                    transaction system has to record enough information to ensure that
                    it can be able to return to a previous state in case of failure or to ensure that changes committed by a transaction
                    are properly stored.
                </p>
                <p>
                    In addition to be able to store appropriate information, all participants within a distributed transaction must log
                    similar information which allow
                    them to take a same decision either to set data in their final state or in their initial state.
                </p>
                <p> Two techniques are in general used to ensure transaction's atomicity. A first technique focuses
                    on manipulated data, such the Do/Undo/Redo protocol
                    (considered as a recovery mechanism in a centralized system), which allow a participant to set its data in their final values
                    or to
                    retrieve them in their initial values. A second technique relies on a distributed protocol named the two phases commit,
                    ensuring that all participants involved within a distributed transaction set their data either in
                    their final values or in their initial values.
                    In other words all participants must commit or all must rollback.
                </p>
                <img src="images/jts-recovery_logs.PNG.png"/>
                <p>
                    In addition to failures we refer as centralized such system crashes,
                    communication failures due for instance to network outages or message loss have to be considered during
                    the recovery process of a distributed transaction.
                </p>
                <p>
                    In order to provide an efficient and optimized mechanism to deal with
                    failure, modern transactional systems typically adopt a “presume
                    abort” strategy, which simplifies the transaction management.
                </p>
                <p>
                    The presumed abort strategy can be stated as «when in doubt, abort».
                    With this strategy, when the recovery mechanism has no information
                    about the transaction, it presumes that the transaction has been
                    aborted.
                </p>

                A particularity of the presumed-abort assumption allows a coordinator
                to not log anything before the commit decision and the participants do
                not to log anything before they prepare. Then, any failure which
                occurs before the 2pc starts lead to abort the transaction.
                Furthermore, from a coordinator point of view any communication
                failure detected by a timeout or exception raised on sending prepare
                is considered as a negative vote which leads to abort the transaction.


                So, within a distributed transaction a coordinator or a participant
                may fail in two ways: either it crashes or it times out for a message
                it was expecting. When a coordinator or a participant crashes and
                then restarts, it uses information on stable storage to determine the
                way to perform the recovery. As we will see it the presumed-abort
                strategy enable an optimized behavior for the recovery.
            </div>
            <div class="section" title="3.2.7.5.3.6. Heuristic Decision"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4487"/>3.2.7.5.3.6. Heuristic Decision</h6></div></div></div>
                

                In extremely rare cases, a resource manager may choose not to wait for
                the outcome from the transaction manager. This might occur if the
                communications path was lost and was not likely to be restored for a
                very long time. Typically this
                happens as a result of human intervention and not as an arbitrary
                action of a resource manager.

                In order to release locks and make this transactions data available to
                new transactions, the resource manager makes a
                <span class="emphasis"><em>heuristic decision</em></span>
                ,
                i.e. it guesses the proper transaction outcome. When it does so, it
                must remember its guess until contact with the transaction manager is
                ultimately re-established.

            </div>
        </div>
        <div class="section" title="3.2.7.5.4. Standards"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4490"/>3.2.7.5.4. Standards</h5></div></div></div>
            
            Saying that a distributed transaction can involve several distributed
            participants, means that these participant must be integrated within a
            global transaction manager which has the responsibility to ensure that all
            participants take a common decision to commit or rollback the distributed
            transaction. The key of such integration is the existence of a common
            transactional interface which is understood by all participants,
            transaction manager and resource managers such databases.
            <p>
                The importance of common interfaces between participants, as well as the
                complexity of their implementation, becomes obvious in an open systems
                environment. For this aim various distributed transaction processing
                standards have been developed by international standards organizations.
                Among these organizations, We list three of them which are mainly
                considered in the 
                product:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    The X/Open model and its successful XA interface
                </li><li class="listitem">
                    The OMG with its CORBA infrastructure and the Object
                    Transaction Service and finally
                </li><li class="listitem">
                    The Jakarta Transactions specification process
                </li></ul></div>
            Basically these standards have proposed logical models, which divide
            transaction processing into several functions:
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    those assigned to the application which ties resources together in application- specific operations
                </li><li class="listitem">
                    those assigned to the Resource manager which access physically to data stores
                </li><li class="listitem">
                    functions performed by the Transaction Manager which manages transactions, and finally
                </li><li class="listitem">
                    Communication Resource Managers which allow to exchange information with other transactional
                    domains.
                </li></ul></div>
            <img src="images/jts-standards.PNG.png"/>


        </div>

        <div class="section" title="3.2.7.5.5. Overview of the OMG Object Transaction Service"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4503"/>3.2.7.5.5. Overview of the OMG Object Transaction Service</h5></div></div></div>
            

            Object Transaction Service (OTS) is a distributed transaction processing
            service specified by the Object Management Group (OMG). This specification
            extends the CORBA model and defines a set of interfaces to perform transaction
            processing across multiple CORBA objects.
            <p>OTS is based on the Open Group's DTP model and is designed so that
                it can be implemented using a common kernel for both the OTS and Open Group
                APIs. In addition to the functions defined by DTP, OTS contains enhancements
                specifically designed to support the object environment. Nested transactions
                and explicit propagation are two examples.
            </p>
            <p>The CORBA model also makes some of the functions in DTP unnecessary
                so these have been consciously omitted. Static registration and the communications
                resource manager are unnecessary in the CORBA environment.
            </p>
            <p>A key feature of OTS is its ability to share a common transaction with
                XA compliant resource managers. This permits the incremental addition of
                objects into an environment of existing procedural applications.
            </p>
            <p>
                <img src="images/jts-OTS.PNG.png"/>
            </p>
            <p>Figure 1 - OTS Architecture</p>
            <p>The OTS architecture, shown in Figure 1, consists of the following components:</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <span class="emphasis"><em>Transaction Client:</em></span>
                    A program or object that invokes operations
                    on transactional objects.
                </li><li class="listitem">
                    <span class="emphasis"><em>Transactional Object</em></span>
                    : A CORBA object that encapsulates or refers
                    to persistent data, and whose behavior depends on whether or not its operations
                    are invoked during a transaction.
                </li><li class="listitem">
                    <span class="emphasis"><em>Recoverable Object</em></span>
                    : A transactional object that directly maintains
                    persistent data, and participates in transaction protocols.
                </li><li class="listitem">
                    <span class="emphasis"><em>Transactional Server</em></span>
                    : A collection of one or more transactional
                    objects.
                </li><li class="listitem">
                    <span class="emphasis"><em>Recoverable Server:</em></span>
                    A collection of objects, of which at least one
                    of which is recoverable.
                </li><li class="listitem">
                    <span class="emphasis"><em>Resource Object</em></span>
                    : A resource object is an object in the transaction
                    service that is registered for participation in the two-phase commit and
                    recovery protocol.
                </li></ul></div>
            In addition to the usual transactional semantics, the CORBA OTS provides
            for the following features:
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <span class="emphasis"><em>Nested Transactions</em></span>
                    : This allows an application to create a transaction
                    that is embedded in an existing transaction. In this model, multiple subtransactions
                    can be embedded recursively in a transaction. Subtransactions can be committed
                    or rolled back without committing or rolling back the parent transaction.
                    However, the results of a commit operation are contingent upon the commitment
                    of all the transaction's ancestors. The main advantage of this model is
                    that transactional operations can be controlled at a finer granularity.
                    The application will have an opportunity to correct or compensate for failures
                    at the subtransaction level, without actually attempting to commit the
                    complete parent transaction.
                </li><li class="listitem">
                    <span class="emphasis"><em>Application Synchronization</em></span>
                    : Using the OTS synchronization protocol,
                    certain objects can be registered with the transaction service for notification
                    before the start of and the completion of the two-phase commit process.
                    This enables such application objects to synchronize transient state and
                    data stored in persistent storage.
                </li></ul></div>
        </div>
        <div class="section" title="3.2.7.5.6. Application programming models"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4530"/>3.2.7.5.6. Application programming models</h5></div></div></div>
            
            A client application program may use direct or indirect context management to
            manage a transaction. With indirect context management, an application uses the
            pseudo object called Current, provided by the Transaction Service , to associate
            the transaction context with the application thread of control. In direct context
            management, an application manipulates the Control object and the other objects
            associated with the transaction.
            <p>
                An object may require transactions to be either explicitly or implicitly
                propagated to its operations.
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Explicit propagation means that an application propagates a transaction
                    context by passing objects defined by the Transaction Service as explicit
                    parameters. This should typically be the PropagationContext structure.
                </li><li class="listitem">
                    Implicit propagation means that requests are implicitly associated with
                    the client's transaction; they share the client's transaction context.
                    It is transmitted implicitly to the objects, without direct client intervention.
                    Implicit propagation depends on indirect context management, since it propagates
                    the transaction context associated with the Current pseudo object. An object
                    that supports implicit propagation would not typically expect to receive
                    any Transaction Service object as an explicit parameter.
                </li></ul></div>
            A client may use one or both forms of context management, and may communicate
            with objects that use either method of transaction propagation. (Details
            of how to enable implicit propagation were described in Section Chapter
            0 and Section 0). This results in four ways in which client applications
            may communicate with transactional objects:
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Direct Context Management/Explicit Propagation: the client application
                    directly accesses the Control object, and the other objects which describe
                    the state of the transaction. To propagate the transaction to an object,
                    the client must include the appropriate Transaction Service object as an
                    explicit parameter of an operation; typically this should be the PropagationContext
                    structure.
                </li><li class="listitem">
                    Indirect Context Management/Implicit Propagation: the client application
                    uses operations on the Current pseudo object to create and control its
                    transactions. When it issues requests on transactional objects, the transaction
                    context associated with the current thread is implicitly propagated to
                    the object.
                </li><li class="listitem">
                    Indirect Context Management/Explicit Propagation: for an implicit model
                    application to use explicit propagation, it can get access to the Control
                    using the get_control operation on the Current pseudo object. It can then
                    use a Transaction Service object as an explicit parameter to a transactional
                    object; for efficiency reasons this should be the PropagationContext structure,
                    obtained by calling get_txcontext on the appropriate Coordinator reference.
                    This is explicit propagation.
                </li><li class="listitem">
                    Direct Context Management/Implicit Propagation: a client that accesses
                    the Transaction Service objects directly can use the resume pseudo object
                    operation to set the implicit transaction context associated with its thread.
                    This allows the client to invoke operations of an object that requires
                    implicit propagation of the transaction context.
                </li></ul></div>
        </div>
        <div class="section" title="3.2.7.5.7. Examples"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4541"/>3.2.7.5.7. Examples</h5></div></div></div>
            
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Indirect and Implicit
                    <p>In the code fragments below, a transaction originator uses indirect context
                        management and implicit transaction propagation; txn_crt is an example of
                        an object supporting the Current interface. The client uses the begin operation
                        to start the transaction whichbecomes implicitly associated with the originator's
                        thread of control.
                    </p>

                    <pre><code class="language-java">...
txn_crt.begin();
// should test the exceptions that might be raised
...
// the client issues requests, some of which involve
// transactional objects;
BankAccount.makeDeposit(deposit);
...
txn_crt.commit(false)
</code></pre>

                    <p> The program commits the transaction associated with the client thread.
                        The report_heuristics argument is set to false so no report will be made
                        by the Transaction Service about possible heuristic decisions.
                    </p>
                </li><li class="listitem">
                    Direct and Explicit
                    <p>In the following example, a transaction originator uses direct context
                        management and explicit transaction propagation. The client uses a factory
                        object supporting the CosTransactions::TransactionFactory interface to create
                        a new transaction and uses the returned Control object to retrieve the Ter
                        mi nat or and Coordinator objects.
                    </p>

                    <pre><code class="language-java">...
CosTransactions::Control ctrl;
CosTransactions::Terminator ter;
CosTransactions::Coordinator coo;
coo = TFactory.create(0);
ter = ctrl.get_terminator();
...
transactional_object.do_operation(arg, c);
...
t.commit(false);
</code></pre>

                    <p> The client issues requests, some of which involve transactional objects,
                        in this case explicit propagation of the context is used. The Control object
                        reference is passed as an explicit parameter of the request; it is declared
                        in the OMG IDL of the interface. The transaction originator uses the Terminator
                        object to commit the transaction; the report_heuristics argument is set
                        to false: so no report will be made by the Transaction Service about possible
                        heuristic decisions.
                    </p>
                </li></ul></div>
            <p>The main difference between direct and indirect context management is the effect
                on the invoking thread's transaction context. If using indirect (i.e., invoking
                operations through the Current pseudo object), then the thread's transaction
                context will be modified automatically by the OTS, e.g., if begin is called
                then the thread's notion of the current transaction will be modified to the
                newly created transaction; when that is terminated, the transaction previously
                associated with the thread (if any) will be restored as the thread's context
                (assuming subtransactions are supported by the OTS implementation). However,
                if using direct management, no changes to the threads transaction context are
                performed by the OTS: the application programmer assumes responsibility for
                this.
            </p>
        </div>
    </div>
    <div class="section" title="3.2.7.6.  OTS Interfaces"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4553"/>3.2.7.6. 
            OTS Interfaces
        </h4></div></div></div>
        
        Figure 2 describes the principal interfaces in the CORBA OTS specification,
        with their interaction, while the Table 1 below provides more details for
        each interface.
        <p>
            <img src="images/jts-OTS_Interfaces.PNG.png"/>
        </p>
        <p>Figure 2 - OTS interfaces and their interactions</p>
        <p>Table 1 - OTS Interfaces and their role.</p>
        <table id="d5e4559">
            <tr>
                <td align="center">
                    <span class="emphasis"><em>Interface</em></span>
                </td>
                <td align="center">
                    <span class="emphasis"><em>Role and operations</em></span>
                </td>
            </tr>
            <tr>
                <td>Current</td>
                <td>
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Transaction demarcation (
                            <span class="emphasis"><em>begin, commit, rollback, rollback_only, set_time_out</em></span>
                            )
                        </li><li class="listitem">
                            Status of the transaction (
                            <span class="emphasis"><em>get_status</em></span>
                            )
                        </li><li class="listitem">
                            Name of the transaction (g
                            <span class="emphasis"><em>et_transaction_name</em></span>
                            )
                        </li><li class="listitem">
                            Transaction context (
                            <span class="emphasis"><em>get_control</em></span>
                            )
                        </li></ul></div>
                </td>
            </tr>
            <tr>
                <td>TransactionFactory</td>
                <td>
                    Explicit transaction creation
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            create a transaction with its associated cooridinator (
                            <span class="emphasis"><em>create</em></span>
                            )
                        </li><li class="listitem">
                            create an interposed coordinator as a subrodinator in the transaction tree
                            (
                            <span class="emphasis"><em>recreate</em></span>
                            )
                        </li></ul></div>
                </td>
            </tr>
            <tr>
                <td>Control</td>
                <td>
                    Explicit transaction context management
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            access to the transaction coordinator (
                            <span class="emphasis"><em>get_coordinator</em></span>
                            )
                        </li><li class="listitem">
                            access to the transactions terminator (
                            <span class="emphasis"><em>get_terminator</em></span>
                            )
                        </li></ul></div>
                </td>
            </tr>
            <tr>
                <td>Terminator</td>
                <td>Commit (commit) or rollback (rollback) a transaction in a direct transaction
                    management mode
                </td>
            </tr>
            <tr>
                <td>Coordinator</td>
                <td>
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Status of the transaction (
                            <span class="emphasis"><em>get_status, get_parent_status, get_top_level_status</em></span>
                            )
                        </li><li class="listitem">
                            Transaction information (
                            <span class="emphasis"><em>is_same_transaction, is_related_transaction,
                                is_ancestor_transaction, is_descendant_transaction, is_top_level_transaction,
                                hash_transaciton, hash_top_level_transaction, get_transaction_name, get_txcontext
                            </em></span>
                            )
                        </li><li class="listitem">
                            Resource enlistment (
                            <span class="emphasis"><em>register_resource, register_subtrans_aware</em></span>
                            )
                        </li><li class="listitem">
                            Registration of synchronization objects (
                            <span class="emphasis"><em>register_synchronization</em></span>
                            )
                        </li><li class="listitem">
                            Set the transaction for rollback (
                            <span class="emphasis"><em>rollback_only</em></span>
                            )
                        </li><li class="listitem">
                            Create subtransactions (
                            <span class="emphasis"><em>create_subtransaction</em></span>
                            )
                        </li></ul></div>
                </td>
            </tr>
            <tr>
                <td>RecoveryCoordinator</td>
                <td>
                    Allows to coordinate recovery in case of failure (
                    <span class="emphasis"><em>replay_completion</em></span>
                    )
                </td>
            </tr>
            <tr>
                <td>Resource</td>
                <td>
                    Participation in two-phase commit and recovery protocol (
                    <span class="emphasis"><em>prepare,
                        rollback, commit, commit_one_phase, forget
                    </em></span>
                    )
                </td>
            </tr>
            <tr>
                <td>Synchronization</td>
                <td>
                    Application synchronization before beginning and after completion of
                    two-phase commit (
                    <span class="emphasis"><em>before_completion, after_completion</em></span>
                    )
                </td>
            </tr>
            <tr>
                <td>SubtransactionAwareResource</td>
                <td>
                    Commit or rollback a subtransaction (
                    <span class="emphasis"><em>commit_subtransaction, rollback_subtransaction)</em></span>
                </td>
            </tr>
            <tr>
                <td>TransactionalObject</td>
                <td>A marker interface to be implemented by all transactional objects (no
                    operation defined)
                </td>
            </tr>
        </table>


    </div>
    <div class="section" title="3.2.7.7. Managing Transactions in Jakarta EE"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4631"/>3.2.7.7. Managing Transactions in Jakarta EE</h4></div></div></div>
        
        <div class="section" title="3.2.7.7.1.  JTA/JTS Architecture"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4633"/>3.2.7.7.1.  JTA/JTS Architecture</h5></div></div></div>
            
            The Java transaction initiative consists of two specifications: Java Transaction Service (JTS) and Jakarta
            Transactions API (also known as JTA).
            <p>JTS specifies the implementation of a Java transaction manager. This
                transaction manager supports the JTA, using which application servers can
                be built to support transactional Java applications. Internally the JTS
                implements the Java mapping of the OMG OTS specifications.
            </p>
            <p>The JTA specifies an architecture for building transactional
                application servers and defines a set of interfaces for various components
                of this architecture. The components are: the application, resource managers,
                and the application server, as shown in the slide.
            </p>
            <p>The JTS thus provides a new architecture for transactional application
                servers and applications, while complying to the OMG OTS 1.1 interfaces
                internally. This allows the JTA compliant applications to interoperate
                with other OTS 1.1 complaint applications through the standard IIOP.
            </p>
            <p>
                As shown in the Figure 1, in the Java transaction model, the Java application
                components can conduct transactional operations on JTA compliant resources via
                the JTS. The JTS acts as a layer over the OTS. The applications can therefore
                initiate global transactions to include other OTS transaction managers, or participate
                in global transactions initiated by other OTS compliant transaction managers.
            </p>
            <p>
                <img src="images/jts-j2ee_1.PNG.png"/>
            </p>
            <div class="blockquote"><blockquote class="blockquote">
                Figure 1 - The JTA/JTS transaction model
            </blockquote></div>
            <p>The Java Transaction Service is architected around an application server and
                a transaction manager. The architecture is shown in Figure 2.
            </p>
            <p>
                <img src="images/jts-j2ee_2.PNG.png"/>
            </p>
            <div class="blockquote"><blockquote class="blockquote">
                Figure 2 - The JTA/JTS Architecture
            </blockquote></div>
            <p>The JTS architecture consists of the following components:</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <span class="emphasis"><em>Transaction Manager</em></span>
                    : The transaction manager is the core component
                    of this architecture and is provided by an implementation of the JTS. It
                    provides interfaces to create transactions (including transaction demarcation
                    and propagation of transaction context), allows enlistment and delistment
                    of resources, provides interfaces for registering components for application
                    synchronization, implements the synchronization protocol, and initiates
                    and directs the two phase commit and recovery protocol with the resource
                    managers.
                </li><li class="listitem">
                    <span class="emphasis"><em>Application Server</em></span>
                    : One of the key features of the JTS architecture
                    is that it allows an application server to be built on top of the transaction
                    service and the resources. Application developers can develop and deploy
                    application components onto the application server for initiating and managing
                    transactions. The application server can therefore abstract all transactional
                    semantics from the application programs.
                </li><li class="listitem">
                    <span class="emphasis"><em>Application Components</em></span>
                    : These are the clients for the transactional
                    resources and implement business transactions. These are deployed on the
                    application server. Depending on the architecture of the application server,
                    these components can directly or indirectly create transactions and operate
                    on the transactional resources. For example, an Jakarta Enterprise Beans (EJB)
                    server allows declarative transaction demarcation, in which case, the EJB
                    components need not directly implement the transactions. However, a Java
                    implementation of a CORBA OTS, requires the CORBA object to demarcate transactions
                    explicitly.
                </li><li class="listitem">
                    <span class="emphasis"><em>Resource Manager</em></span>
                    : A resource manager is an X/Open XA compliant component
                    that manages a persistent and stable storage system, and participates in
                    the two phase commit and recovery protocol with the transaction manager.
                    The application manager also provides interfaces for the application server
                    and the application components to operate on the data managed by it.
                </li><li class="listitem">
                    <span class="emphasis"><em>Communication Resource Manager</em></span>
                    : This allows the transaction manager
                    to participate in transactions initiated by other transaction managers.
                    However, the JTS specification does not specify any protocol for this communication
                    and assumes that an implementation of the communication resource manager
                    supports the CORBA OTS and GIOP specifications.
                </li></ul></div>
        </div>
        <div class="section" title="3.2.7.7.2. Jakarta Transactions API (formally JTA)"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4658"/>3.2.7.7.2. Jakarta Transactions API (formally JTA)</h5></div></div></div>
            
            The Jakarta Transactions specification may be classified into three categories of interface
            as shown in Figure 3. The Java Transaction API consists of three elements:
            a high-level application transaction demarcation interface, a high-level
            transaction manager interface intended for application server, and a standard
            Java mapping of the X/Open XA protocol intended for transactional resource
            manager.
            <p>
                <img src="images/jts-j2ee_3_API.PNG.png"/>
            </p>
            <div class="blockquote"><blockquote class="blockquote">
                Figure 3 - JTA Interfaces
            </blockquote></div>
            <div class="section" title="3.2.7.7.2.1.  Transaction Manager Interfaces"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4663"/>3.2.7.7.2.1.  Transaction Manager Interfaces</h6></div></div></div>
                
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        jakarta.transaction.Status: Defines the following flags for the status of
                        a transaction:
                    </li></ul></div>
                <table width="89%" border="1" id="d5e4667">
                    <tr bgcolor="#0099CC">
                        <td width="34%">
                            <span class="emphasis"><em>Flag</em></span>
                        </td>
                        <td width="66%">
                            <span class="emphasis"><em>Purpose </em></span>
                        </td>
                    </tr>
                    <tr>
                        <td>STATUS_ACTIVE</td>
                        <td>Transaction is active (started but not prepared)</td>
                    </tr>
                    <tr>
                        <td>STATUS_COMMITTED</td>
                        <td>Transaction is committed</td>
                    </tr>
                    <tr>
                        <td>STATUS_COMMITTING</td>
                        <td>Transaction is in the process of committing.</td>
                    </tr>
                    <tr>
                        <td>STATUS_MARKED_ROLLBACK</td>
                        <td>Transaction is marked for rollback.</td>
                    </tr>
                    <tr>
                        <td>STATUS_NO_TRANSACTION</td>
                        <td>There is no transaction associated with the current Transaction, UserTransaction
                            or TransactionManager objects.
                        </td>
                    </tr>
                    <tr>
                        <td>STATUS_PREPARED</td>
                        <td>Voting phase of the two phase commit is over and the transaction is prepared.</td>
                    </tr>
                    <tr>
                        <td>STATUS_PREPARING</td>
                        <td>Transaction is in the process of preparing.</td>
                    </tr>
                    <tr>
                        <td>STATUS_ROLLEDBACK</td>
                        <td>Outcome of the transaction has been determined as rollback. It is likely
                            that heuristics exists.
                        </td>
                    </tr>
                    <tr>
                        <td>STATUS_ROLLING_BACK</td>
                        <td>Transaction is in the process of rolling back.</td>
                    </tr>
                    <tr>
                        <td>STATUS_UNKNOWN</td>
                        <td>A transaction exists but its current status can not be determined. This
                            is a transient condition
                        </td>
                    </tr>
                </table>
                <div class="blockquote"><blockquote class="blockquote">
                    <p>Table 1: Transaction Status Flags</p>
                </blockquote></div>
                <p>The jakarta.transaction.Transaction, jakarta.transaction.TransactionManager, and
                    jakarta.transaction.UserTransaction
                    interfaces provide a getStatus method that returns one of the above status flags.
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        jakarta.transaction.Transaction:
                        An object of this type is created for each global transaction. This interface
                        provides methods for transaction completion(commit and rollback), resource
                        enlistment (enlistResource) and delistment (delistResource), registration
                        of synchronization objects (registerSynchronization), and query of status
                        of the transaction (getStatus).
                    </li><li class="listitem">
                        jakarta.transaction.TransactionManager:
                        This interface is implemented by the JTS and allows an application server
                        to communicate with the transaction manager to demarcate transactions (begin,
                        commit, rollback), suspending and resuming transactions (suspend and resume),
                        set the transaction for rollback (setRollbackOnly), get the associated
                        Transaction object (getTransaction), set the transaction timeout interval
                        (setTransactionTimeout) and query the status of the transaction (getStatus).
                    </li><li class="listitem">
                        jakarta.transaction.UserTransaction:
                        . This interface provides methods to begin and end transactions (begin,
                        commit, and rollback), set the transaction for rollback (setRollbackOnly),
                        set the transaction timeout interval (setTransactionTimeout), and get the
                        status of the transaction (getStatus). Nested transactions are not supported,
                        and begin throws the NotSupportedException when the calling thread is already
                        associated with a transaction. UserTransaction automatically associates
                        newly created transactions with the invoking thread.
                    </li><li class="listitem">
                        javax.transaction.xa.Xid: This
                        interface is a Java mapping of the X/Open transaction identifier xid structure.
                        The transaction manager uses an object of this type to associate a resource
                        manager with a transaction.
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.7.2.2. Resource Manager Interfaces"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4711"/>3.2.7.7.2.2. Resource Manager Interfaces</h6></div></div></div>
                
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        javax.transaction.xa.XAResource:
                        This is a Java mapping of the X/Open XA interface, and is implemented by
                        resource managers operating with the JTS. This interface provides methods
                        to start (start) and end (end) work on behalf of a specified transaction,
                        to prepare a transaction with the current resource (prepare), to end transactions
                        with the current resource (commit, forget, recover, and rollback), to compare
                        the current resource manager with another resource manager (isSameRM),
                        and to get and set the transaction timeout (getTransactionTimeout, setTransactionTimeout).
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.7.2.3. Application Interfaces"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4715"/>3.2.7.7.2.3. Application Interfaces</h6></div></div></div>
                
                The only interface that an application object could implement is the Synchronization
                interface. The application components may have to implement whatever other
                interfaces are mandated by a given application server.
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        jakarta.transaction.Synchronization:
                        An object intended to participate in a synchronization protocol with the
                        transaction manager should implement this interface. This mechanism is
                        based on the Observer pattern. This interface has two methods - beforeCompletion
                        and afterCompletion to be called before starting and after completing,
                        respectively, the two phase commit operation.
                    </li></ul></div>
            </div>
        </div>
        <div class="section" title="3.2.7.7.3. Jakarta Transactions API - Usage"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4719"/>3.2.7.7.3. Jakarta Transactions API - Usage</h5></div></div></div>
            
            This section describes the usage of the JTA for implementing various transaction
            semantics. The purpose of this section is to provide conceptual guidelines
            only.
            <div class="section" title="3.2.7.7.3.1. Transaction Demarcation"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4721"/>3.2.7.7.3.1. Transaction Demarcation</h6></div></div></div>
                
                The Jakarta Transactions specifies two approaches with which new global transactions can
                be initiated and demarcated.
                <div class="itemizedlist"><p>The application component can then use this object to begin, commit
                        and rollback transactions. In this approach, association between the calling
                        thread and the transaction, and transaction context propagation are handled
                        transparently by the transaction manager.
                    </p><p>Usage:</p><pre><code class="language-java">
// Get a UserTransaction object
// Begin a transaction
userTransaction.begin();
// Transactional operations ...
// End the transaction
userTransaction.commit();
</code></pre><p>Usage</p><pre><code class="language-java">
// Begin a transaction
Transaction t = TransactionManager.begin();
// Transactional operations ...
// End the transaction
TransactionManager.commit();
</code></pre><ul class="itemizedlist"><li class="listitem">
                        Application Program Demarcation: The jakarta.transaction.UserTransaction
                        interface provides methods for application components to begin and end
                        transactions programmatically. The underlying application server should
                        provide a mechanism to obtain a reference to this object. The Jakarta Transactions specification
                        requires that the application servers use the JNDI for storing references
                        to UserTransaction objects and for lookup.
                    </li><li class="listitem">
                        Application Server Controlled Demarcation In this approach, the
                        jakarta.transaction.TransactionManager
                        interface controls transaction demarcation on behalf of the application being
                        managed. The transaction manager also maintains the transaction context and
                        its association with the calling threads implicitly.
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.7.3.2. Resource Enlistment and Delistment"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4731"/>3.2.7.7.3.2. Resource Enlistment and Delistment</h6></div></div></div>
                
                Transactional resources such as database connections are typically managed by
                the application server in conjunction with some resource adapter and optionally
                with connection pooling optimisation. In order for an external transaction manager
                to co-ordinate transactional work performed by the resource managers, the application
                server must enlist and de-list the resources used in the transaction. These resources
                (participants) are enlisted with the transaction so that they can be informed
                when the transaction terminates, e.g., are driven through the two-phase commit
                protocol.
                <p>
                    Jakarta Transactions is much more closely integrated with the XA concept of resources
                    than the arbitrary objects. For each resource in-use by the application,
                    the application server invokes the enlistResource method with an XAResource
                    object which identifies the resource in use.
                </p>
                <p>The enlistment request results in the transaction manager informing
                    the resource manager to start associating the transaction with the work
                    performed through the corresponding resource. The transaction manager is
                    responsible for passing the appropriate flag in its XAResource.start method
                    call to the resource manager.
                </p>
                <p>The delistResource method is used to disassociate the specified resource
                    from the transaction context in the target object. The application server
                    invokes the method with the two parameters: the XAResource object that
                    represents the resource, and a flag to indicate whether the operation is
                    due to the transaction being suspended (TMSUSPEND), a portion of the work
                    has failed (TMFAIL), or a normal resource release by the application (TMSUCCESS).
                </p>
                <p>The de-list request results in the transaction manager informing the
                    resource manager to end the association of the transaction with the target
                    XAResource. The flag value allows the application server to indicate whether
                    it intends to come back to the same resource whereby the resource states
                    must be kept intact. The transaction manager passes the appropriate flag
                    value in its XAResource.end method call to the underlying resource manager.
                </p>
                <p>
                    The application server can enlist and delist resource managers with the transaction
                    manager using the jakarta.transaction.Transaction
                    interface
                </p>
                Usage
                <p>Resource enlistment is in general done by the application server when an application
                    requests it for a connection to a transactional resource.
                </p>
                <pre><code class="language-java">
// ... an implementation of the application server
// Get a reference to the underlying TransactionManager object.
...
// Get the current Transaction object from the TransactionManager.
transaction = transactionManager.getTransaction();
// Get an XAResource object from a transactional resource.
...
// Create a Transaction object.
...
// Enlist the resource
transaction.enlistResource(xaResource);...
// Return the connection to the application.
...
</code></pre>
                <p> Resource delistment is done similarly after the application closes connections to transactional
                    resources.</p>

            </div>
            <div class="section" title="3.2.7.7.3.3.  Application Synchronization with a Transaction"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4741"/>3.2.7.7.3.3. 
                    Application Synchronization with a Transaction
                </h6></div></div></div>
                
                Using the JTS synchronization protocol, certain objects can be registered
                with the transaction manager for notification before the start of and the
                completion of the two-phase commit process. This enables such application
                objects to synchronize transient state and data stored in persistent storage.
                <p>
                    The jakarta.transaction.Transaction
                    interface provides the
                    <span class="emphasis"><em>registerSynchronization</em></span>
                    method to register
                    jakarta.transaction.Synchronization
                    objects with the transaction manager. The transaction manager then uses
                    the synchronization protocol and calls the beforeCompletion and afterCompletion
                    methods before and after the two phase commit process.
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        The
                        <span class="emphasis"><em>beforeCompletion</em></span>
                        method is called prior to the start of the
                        two-phase transaction complete process. This call is executed in the same
                        transaction context of the caller who initiates the TransactionManager.commit
                        or the call is executed with no transaction context if Transaction.commit
                        is used.
                    </li><li class="listitem">
                        The
                        <span class="emphasis"><em>afterCompletion</em></span>
                        method is called after the transaction has completed.
                        The status of the transaction is supplied in the parameter. This method
                        is executed without a transaction context.
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.7.3.4. Further Reading"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4750"/>3.2.7.7.3.4. Further Reading</h6></div></div></div>
                
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        JDBC and Transactions
                    </li><li class="listitem">
                        Jakarta Enterprise Beans and Transactions
                    </li></ul></div>
            </div>
        </div>
    </div>
    <div class="section" title="3.2.7.8. Managing Transactions in EJB"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4755"/>3.2.7.8. Managing Transactions in EJB</h4></div></div></div>
        
        <div class="section" title="3.2.7.8.1. An Application Server Model - The Jakarta Enterprise Beans"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4757"/>3.2.7.8.1. An Application Server Model - The Jakarta Enterprise Beans</h5></div></div></div>
            
            <div class="section" title="3.2.7.8.1.1. EJB Overview"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4759"/>3.2.7.8.1.1. EJB Overview</h6></div></div></div>
                
                Jakarta Enterprise Beans (EJB) is a technology specification
                that specifies a framework for building component-based distributed
                applications. As an application server framework, the EJB servers address
                transaction processing, resource pooling, security, threading, persistence,
                remote access, life cycle etc.
                <p>The EJB framework specifies construction, deployment and invocation
                    of components called as enterprise beans. The EJB specification classifies
                    enterprise beans into two categories: entity beans and session beans. While
                    entity beans abstract persistent domain data, session beans provide for
                    session specific application logic. Both types of beans are maintained
                    by EJB compliant servers in what are called as containers. A container
                    provides the run time environment for an enterprise bean. Figure 4 shows
                    a simplified architecture of transaction management in EJB compliant application
                    servers.
                </p>
                <p>
                    <img src="images/jts-j2ee_5_ejb_model.PNG.png"/>
                </p>
                <p>
                    Figure 4 - EJB and Transactions
                </p>
                <p>
                    An enterprise bean is specified by two interfaces: the home interface and the
                    remote interface. The home interface specifies how a bean can created or found.
                    With the help of this interface, a client or another bean can obtain a reference
                    to a bean residing in a container on an EJB server. The remote interface specifies
                    application specific methods that are relevant to entity or session beans.
                    </p><p>
                        Clients obtain references to home interfaces of enterprise beans via the Java
                        Naming and Directory Interface (JNDI) mechanism. An EJB server should provide
                        a JNDI implementation for any naming and directory server. Using this reference
                        to the home interface, a client can obtain a reference to the remote interface.
                        The client can then access methods specified in the remote interface. The EJB
                        specification specifies the Java Remote Method Invocation (RMI) as the application
                        level protocol for remote method invocation. However, an implementation can
                        use IIOP as the wire-level protocol.
                    </p><p>
                    </p><p>
                        In Figure 5, the client first obtains a reference to the home interface, and
                        then a reference to an instance of Bean A via the home interface. The same procedure
                        is applicable for instance of Bean A to obtain a reference and invoke methods
                        on an instance of Bean B.
                    </p><p>
                </p>
            </div>
            <div class="section" title="3.2.7.8.1.2. EJB Transaction Model"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4768"/>3.2.7.8.1.2. EJB Transaction Model</h6></div></div></div>
                
                The EJB framework does not specify any specific transaction service (such
                as the JTS) or protocol for transaction management. However, the specification
                requires that the jakarta.transaction.UserTransaction interface of the JTS
                be exposed to enterprise beans. This interface is required for programmatic
                transaction demarcation as discussed in the next section.
                <p>
                    The EJB framework allows both programmatic and declarative demarcation of transactions.
                    Declarative demarcation is needed for all enterprise beans deployed on the EJB.
                    In addition, EJB clients can also initiative and end transactions programmatically.
                </p>
                <p>
                    The container performs automatic demarcation depending on the transaction
                    attributes specified at the time of deploying an enterprise bean in a container.
                    The following attributes determine how transactions are created.
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <span class="emphasis"><em>NotSupported</em></span>
                        : The container invokes the bean without a global transaction
                        context.
                    </li><li class="listitem">
                        <span class="emphasis"><em>Required</em></span>
                        : The container invokes the bean within a global transaction
                        context. If the invoking thread already has a transaction context associated,
                        the container invokes the bean in the same context. Otherwise, the container
                        creates a new transaction and invokes the bean within the transaction context.
                    </li><li class="listitem">
                        <span class="emphasis"><em>Supports</em></span>
                        : The bean is transaction-ready. If the client invokes the
                        bean within a transaction, the bean is also invoked within the same transaction.
                        Otherwise, the bean is invoked without a transaction context.
                    </li><li class="listitem">
                        <span class="emphasis"><em>RequiresNew</em></span>
                        : The container invokes the bean within a new transaction
                        irrespective of whether the client is associated with a transaction or
                        not.
                    </li><li class="listitem">
                        <span class="emphasis"><em>Mandatory</em></span>
                        : The container must invoke the bean within a transaction.
                        The caller should always start a transaction before invoking any method
                        on the bean.
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.8.1.3. Transaction Demarcation"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4783"/>3.2.7.8.1.3. Transaction Demarcation</h6></div></div></div>
                
                The EJB framework supports three types of transaction demarcation.
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <span class="emphasis"><em>Declarative Demarcation</em></span>
                        : This is also called as
                        <span class="emphasis"><em>container managed
                            demarcation
                        </em></span>
                        . The container demarcates transactions on behalf of the
                        bean. The Required or RequiresNew attribute is specified in a deployment
                        descriptor at the time of deploying the bean on an EJB server. The bean
                        can use the jakarta.ejb.EJBContext.setRollbackOnly() method to mark the transaction
                        for rollback.
                    </li><li class="listitem">
                        <span class="emphasis"><em>Bean Managed Demarcation</em></span>
                        : This is similar to the client-managed
                        demarcation.
                    </li><li class="listitem">
                        <span class="emphasis"><em>Client Managed Demarcation</em></span>
                        : Java clients can use the jakarta.transaction.UserTransaction
                        interface to demarcate transactions programmatically.
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.8.1.4. Resource Enlistment"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4793"/>3.2.7.8.1.4. Resource Enlistment</h6></div></div></div>
                
                Resource enlistment is automatic with EJB. The EJB containers automatically
                enlists connections to EJB-aware resource managers whenever a bean obtains
                a connection.

            </div>
            <div class="section" title="3.2.7.8.1.5. Application Synchronization"><div class="titlepage"><div><div><h6 class="title"><a id="d5e4795"/>3.2.7.8.1.5. Application Synchronization</h6></div></div></div>
                
                The EJB specification provides the jakarta.ejb.SessionSynchronization interface
                for application synchronization. When implemented by a bean, the container
                calls the afterBegin, beforeCompletion and afterCompletion methods for
                application synchronization during the two-phase commit process.



            </div>
        </div>
    </div>
    <div class="section" title="3.2.7.9. JDBC and Transactions"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4797"/>3.2.7.9. JDBC and Transactions</h4></div></div></div>
        
        <p> Java Data Base Connectivity, provide Java programs with a way to connect to
            and use relational databases. The JDBC API lets you invoke SQL commands from
            Java programming language methods. In simplest terms, JDBC allows to do three
            things
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                Establish a connection with a database
            </li><li class="listitem">
                Send SQL statements
            </li><li class="listitem">
                Process the results
            </li></ul></div>
        <p>The following code fragment gives a simple example of these three steps:</p>
        <pre><code class="language-java">
Connection con = DriverManager.getConnection(
  "jdbc:myDriver:wombat", "myLogin", "myPassword");
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("SELECT a, b, c FROM Table1");
while (rs.next()) {
  int x = rs.getInt("a");
  String s = rs.getString("b");
  float f = rs.getFloat("c");
}
</code></pre>
        <p>Before the version 2.0 of JDBC, only local transactions controlled by the transaction
            manager of the DBMS is possible. To code a JDBC transaction, you invoke the
            commit and rollback methods of the java.sql.Connection interface. The beginning
            of a transaction is implicit. A transaction begins with the first SQL statement
            that follows the most recent commit, rollback, or connect statement. (This rule
            is generally true, but may vary with DBMS vendor.). The following example illustrates
            how transactions are managed by the JDBC API.
        </p>
        <pre><code class="language-java">
public void withdraw (double amount) {
  try {
    //A connection opened with JDBC is an AUTO COMMIT mode meaning
    // that the commitment is automatically performed when the connection
    // is closed
    //setAutoCommit to false disable this feature
    connection.setAutoCommit(false);
    //perform an SQL update to Withdraw money from account
    connection.commit();
  } catch (Exception ex) {
      try {
         connection.rollback();
          throw new Exception("Transaction failed: " +  ex.getMessage());
      } catch (Exception sqx) {
           throw new Exception(...}
      }
  }
}</code></pre>
        <p>From the version 2.0, a JDBC driver can be involved within a distributed transaction
            since it supports the XAResource interface that allows to participate to the
            2PC protocol. An application that need to include more than one database can
            create a JTA transaction. To demarcate a JTA transaction, the application program
            invokes the begin, commit, and rollback methods of the jakarta.transaction.UserTransaction
            interface. The following code, that can be applied to a bean-managed transaction,
            demonstrates the UserTransaction methods. The begin and commit invocations delimit
            the updates to the database. If the updates fail, the code invokes the rollback
            method and throws an Exception.
        </p>
        <pre><code class="language-java">
public void transfer(double amount) {
  UserTransaction ut = context.getUserTransaction();

  try {
     ut.begin();
     // Perform SQL command to debit account 1
     // Perform SQL command to debit account 2
     ut.commit();
   } catch (Exception ex) {
        try {
          ut.rollback();
        } catch (Exception ex1) {
             throw new Exception ("Rollback failed: " + ex1.getMessage());
        }
        throw new Exception ("Transaction failed: " + ex.getMessage());
   }
}
</code></pre>
    </div>
    <div class="section" title="3.2.7.10. Configuring the"><div class="titlepage"><div><div><h4 class="title"><a id="d5e4810"/>3.2.7.10. Configuring
            the 
        </h4></div></div></div>
        
        <p>This
            trail provides information on the way to configure environmental variables
            needed to define the behaviour of transactional applications managed with .
            Basically, the behaviour of the 
            product is configurable through property
            attributes. Although these property attributes may be specified as command line
            arguments, it is more convenient to organise and initialise them through properties
            files.
        </p>
        <div class="section" title="3.2.7.10.1. Properties File"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4813"/>3.2.7.10.1. Properties File</h5></div></div></div>
            
            <p> The properties file named jbossts-properties.xml
                and located under the &lt;ats_installation_directory&gt;/etc
                directory is organised as a collection of property names.
            </p>
            <div class="blockquote"><blockquote class="blockquote">
                <pre><code class="language-java">
&lt;property&gt;
  name="a_name"
  value="a_value"
&lt;/property&gt; </code></pre>
            </blockquote></div>
            <p>Some properties must be specified by the developer while others do not need
                to be defined and can be used with their default values. Basically the properties
                file that does not provide default values to all its properties is the jbossts-properties.xml.
            </p>
            <p>The following table describes some properties in the jbossts-properties.xml, where:</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <span class="emphasis"><em>Name</em></span>
                    : indicates the name of the property
                </li><li class="listitem">
                    <span class="emphasis"><em>Description</em></span>
                    : explain the aim of the property
                </li><li class="listitem">
                    <span class="emphasis"><em>Possible Value</em></span>
                    : indicates possible value the property can have
                </li><li class="listitem">
                    <span class="emphasis"><em>Default</em></span>
                    <span class="emphasis"><em>Value</em></span>
                    : shows the default value, if any,
                    assigned to the property
                </li></ul></div>
            <table id="d5e4830">
                <tr>
                    <td width="38%">
                        <span class="emphasis"><em>Name</em></span>
                    </td>
                    <td width="25%">
                        <span class="emphasis"><em>Description</em></span>
                    </td>
                    <td width="10%">
                        <span class="emphasis"><em>Possible Value</em></span>
                    </td>
                    <td width="27%">
                        <span class="emphasis"><em>Default Value</em></span>
                    </td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.objectstore.localOSRoot</td>
                    <td>By default, all object states will be stored within the "defaultStore"
                        subdirectory of the object store root. However, this subdirectory can be
                        changed by setting the localOSRoot property variable accordingly
                    </td>
                    <td>Directory name</td>
                    <td>defaultStore</td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.objectstore.objectStoreDir</td>
                    <td>Specify the location of the ObjectStore</td>
                    <td>Directory name</td>
                    <td>PutObjectStoreDirHere</td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.common.varDir</td>
                    <td>
                        needs to be able to write temporary files to a well known location
                        during execution. By default this location is var. However, by setting the
                        varDir property variable this can be overridden.
                    </td>
                    <td>Directory name</td>
                    <td>var/tmp</td>
                </tr>
            </table>
        </div>
        <div class="section" title="3.2.7.10.2. ObjectStore management"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4855"/>3.2.7.10.2. ObjectStore management</h5></div></div></div>
            
            The 
            layer requires an object store for transaction management logs. Within
            the transaction service installation, object store is updated regularly whenever
            transactions are created, or when Transactional Objects for Java is used. In a
            failure free environment, the only object states which should reside within the
            object store are those representing objects created with the Transactional Objects
            for Java API. However, if failures occur, transaction logs may remain in the object
            store until crash recovery facilities have resolved the transactions they represent.
            As such it is very important that the contents of the object store are not deleted
            without due care and attention, as this will make it impossible to resolve in
            doubt transactions. In addition, if multiple users share the same object store
            it is important that they realise this and do not simply delete the contents of
            the object store assuming it is an exclusive resource.
            <p>
                The location of the ObjectStore is specified in via the properrty
                com.arjuna.ats.arjuna.objectstore.objectStoreDir
                that can be passed with the java flag "-D". For convenience this property
                is defined in the properties file jbossts-properties.xml, and its value is set
                during the 
                installation. At any time, the location of the ObjectStore
                may be changed.
            </p>
        </div>
        <div class="section" title="3.2.7.10.3. Configuring Output"><div class="titlepage"><div><div><h5 class="title"><a id="d5e4858"/>3.2.7.10.3. Configuring Output</h5></div></div></div>
            
            <p>Sometimes
                it is desirable, mainly in case of debugging, to have some form of
                output during execution to trace internal actions performed. 
                uses the
                logging tracing mechanism provided by the Arjuna Common Logging Framework (CLF)
                version 2.4, which provides a high level interface that hides differences that
                exist between logging APIs such Jakarta log4j, JDK 1.4 logging API or dotnet
                logging API.
            </p>
            <p>With the CLF applications make logging calls on commonLogger objects. These
                commonLogger objects pass log messages to Handler for publication. Both commonLoggers
                and Handlers may use logging Levels to decide if they are interested in a particular
                log message. Each log message has an associated log Level, that gives the importance
                and urgency of a log message. The set of possible Log Levels are DEBUG, INFO,
                WARN, ERROR and FATAL. Defined Levels are ordered according to their integer
                values as follows: DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL. </p>
            <p> The CLF provides an extension to filter logging messages according to finer
                granularity an application may define. That is, when a log message is provided
                to the commonLogger with the DEBUG level, additional conditions can be specified
                to determine if the log message is enabled or not.
            </p>
            <span class="emphasis"><em>Note</em></span>
            : These conditions are applied if and only the DEBUG level is enabled
            and the log request performed by the application specifies debugging granularity.
            <p>
                When enabled, Debugging is filtered conditionally on three variables:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Debugging level: this is where the log request with the DEBUG Level is
                    generated from, e.g., constructors or basic methods.
                </li><li class="listitem">
                    Visibility level: the visibility of the constructor, method, etc. that
                    generates the debugging.
                </li><li class="listitem">
                    Facility code: for instance the package or sub-module within which debugging
                    is generated, e.g., the object store.
                </li></ul></div>
            <p>According
                to these variables the Common Logging Framework defines three interfaces.
                A particular product may implement its own classes according to its own finer
                granularity. 
                uses the default Debugging level and the default Visibility
                level provided by CLF, but it defines its own Facility Code. 
                uses
                the default level assigned to its commonLoggers objects (DEBUG). However, it
                uses the finer debugging features to disable or enable debug messages. Finer
                values used by the 
                are defined below:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Debugging
                    level – 
                    uses the default values defined in the class
                    com.arjuna.common.util.logging.CommonDebugLevel
                </li></ul></div>
            <table width="83%" border="1" id="d5e4872">
                <tr bgcolor="#8BD5FC">
                    <td width="33%">
                        <span class="emphasis"><em>Debug Level</em></span>
                    </td>
                    <td width="24%">
                        <span class="emphasis"><em>Value</em></span>
                    </td>
                    <td width="43%">
                        <span class="emphasis"><em>Description</em></span>
                    </td>
                </tr>
                <tr>
                    <td>NO_DEBUGGING</td>
                    <td>0x0000</td>
                    <td>A commonLogger object assigned with this values discard all debug requests</td>
                </tr>
                <tr>
                    <td>CONSTRUCTORS</td>
                    <td> 0x0001</td>
                    <td>Diagnostics from constructors</td>
                </tr>
                <tr>
                    <td>DESTRUCTORS</td>
                    <td>0x0002</td>
                    <td>Diagnostics from finalizers.</td>
                </tr>
                <tr>
                    <td>CONSTRUCT_AND_DESTRUCT</td>
                    <td>CONSTRUCTORS | DESTRUCTORS</td>
                    <td>Diagnostics from constructors and finalizers</td>
                </tr>
                <tr>
                    <td>FUNCTIONS</td>
                    <td>0x010</td>
                    <td>Diagnostics from functions</td>
                </tr>
                <tr>
                    <td>OPERATORS</td>
                    <td>0x020</td>
                    <td>Diagnostics from operators, such as equals</td>
                </tr>
                <tr>
                    <td>FUNCS_AND_OPS</td>
                    <td>FUNCTIONS | OPERATORS</td>
                    <td>Diagnostics from functions and operations.</td>
                </tr>
                <tr>
                    <td>ALL_NON_TRIVIAL</td>
                    <td>CONSTRUCT_AND_DESTRUCT | FUNCTIONS
                        | OPERATORS
                    </td>
                    <td>Diagnostics from all non-trivial operations</td>
                </tr>
                <tr>
                    <td>TRIVIAL_FUNCS</td>
                    <td>0x0100</td>
                    <td>Diagnostics from trivial functions.</td>
                </tr>
                <tr>
                    <td>TRIVIAL_OPERATORS:</td>
                    <td>0x0200</td>
                    <td>Diagnostics from trivial operations, and operators.</td>
                </tr>
                <tr>
                    <td> ALL_TRIVIAL</td>
                    <td>TRIVIAL_FUNCS | TRIVIAL_OPERATORS</td>
                    <td>Diagnostics from all trivial operations</td>
                </tr>
                <tr>
                    <td>FULL_DEBUGGING</td>
                    <td>0xffff</td>
                    <td>Full diagnostics.</td>
                </tr>
            </table>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Visibility
                    level – 
                    uses the default values defined in the class
                    com.arjuna.common.util.logging.CommonVisibilityLevel
                </li></ul></div>
            <table width="83%" border="1" id="d5e4930">
                <tr bgcolor="#8BD5FC">
                    <td width="33%">
                        <span class="emphasis"><em>Debug Level</em></span>
                    </td>
                    <td width="24%">
                        <span class="emphasis"><em>Value</em></span>
                    </td>
                    <td width="43%">
                        <span class="emphasis"><em>Description</em></span>
                    </td>
                </tr>
                <tr>
                    <td>VIS_NONE</td>
                    <td>0x0000</td>
                    <td>No Diagnostic</td>
                </tr>
                <tr>
                    <td>VIS_PRIVATE</td>
                    <td>0x0001</td>
                    <td>only from private methods.</td>
                </tr>
                <tr>
                    <td>VIS_PROTECTED</td>
                    <td>0x0002</td>
                    <td>only from protected methods.</td>
                </tr>
                <tr>
                    <td>VIS_PUBLIC</td>
                    <td>0x0004</td>
                    <td>only from public methods.</td>
                </tr>
                <tr>
                    <td>VIS_PACKAGE</td>
                    <td>0x0008</td>
                    <td>only from package methods.</td>
                </tr>
                <tr>
                    <td>VIS_ALL</td>
                    <td>0xffff</td>
                    <td>Full Diagnostic</td>
                </tr>
            </table>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Facility
                    Code – 
                    uses the following values
                </li></ul></div>
            <table width="83%" border="1" id="d5e4964">
                <tr bgcolor="#8BD5FC">
                    <td>
                        <span class="emphasis"><em>Facility Code Level </em></span>
                    </td>
                    <td>
                        <span class="emphasis"><em>Value</em></span>
                    </td>
                    <td>
                        <span class="emphasis"><em>Description</em></span>
                    </td>
                </tr>
                <tr>
                    <td>FAC_ATOMIC_ACTION</td>
                    <td>0x00000001</td>
                    <td>atomic action core module</td>
                </tr>
                <tr>
                    <td>FAC_BUFFER_MAN</td>
                    <td>0x00000004</td>
                    <td>state management (buffer) classes</td>
                </tr>
                <tr>
                    <td>FAC_ABSTRACT_REC</td>
                    <td>0x00000008</td>
                    <td>abstract records</td>
                </tr>
                <tr>
                    <td>FAC_OBJECT_STORE</td>
                    <td>0x00000010</td>
                    <td>object store implementations</td>
                </tr>
                <tr>
                    <td> FAC_STATE_MAN</td>
                    <td>0x00000020</td>
                    <td>state management and StateManager)</td>
                </tr>
                <tr>
                    <td>FAC_SHMEM</td>
                    <td>0x00000040 </td>
                    <td>shared memory implementation classes</td>
                </tr>
                <tr>
                    <td>FAC_GENERAL</td>
                    <td>0x00000080</td>
                    <td>general classes</td>
                </tr>
                <tr>
                    <td>FAC_CRASH_RECOVERY</td>
                    <td>0x00000800</td>
                    <td>detailed trace of crash recovery module and classes</td>
                </tr>
                <tr>
                    <td>FAC_THREADING</td>
                    <td>0x00002000</td>
                    <td>threading classes</td>
                </tr>
                <tr>
                    <td>FAC_JDBC</td>
                    <td>0x00008000</td>
                    <td>JDBC 1.0 and 2.0 support</td>
                </tr>
                <tr>
                    <td>FAC_RECOVERY_NORMAL</td>
                    <td>0x00040000</td>
                    <td>normal output for crash recovery manager</td>
                </tr>
            </table>
            <p>To ensure appropriate output, it is necessary to set some of the finer debug
                properties explicitly as follows:
            </p>
            <pre><code class="language-java"> &lt;properties&gt;
   &lt;!-- CLF 2.4 properties --&gt;
   &lt;property
     name="com.arjuna.common.util.logging.DebugLevel"
     value="0x00000000"/&gt;
   &lt;property
     name="com.arjuna.common.util.logging.FacilityLevel"
     value="0xffffffff"/&gt;
   &lt;property
     name="com.arjuna.common.util.logging.VisibilityLevel"
     value="0xffffffff"/&gt;
   &lt;property
     name="com.arjuna.common.util.logger"
     value="log4j"/&gt;
 &lt;/properties&gt;</code></pre>
            <p>By default, debugging messages are not enabled since the DebugLevel is set
                to NO_DEBUGGING (0x00000000).
                You can enable debugging by providing one of the appropriate value listed above
                - for instance with you wish to see all internal actions performed by the RecoveryManager
                to recover transactions from a failure set the DebugLevel to FULL_DEBUGGING
                (0xffffffff) and the FacilityCode
                Level FAC_CRASH_RECOVERY.
            </p>
            <p>
                <span class="emphasis"><em>Note</em></span>
                : To enable finger debug messages, the logging level should
                be set to the DEBUG level as described below.
            </p>
            <p>From the program point of view a same API is used whatever the underlying logging
                mechanism, but from a configuration point of view is that the user is totally
                responsible for the configuration of the underlying logging system. Hence, the
                properties of the underlying log system are configured in a manner specific
                to that log system, e.g., a log4j.properties file in the case that log4j logging
                is used. To set the logging level to the DEBUG value, the log4j.properties file
                can be edited to set that value.
            </p>
            <p>The property com.arjuna.common.util.logger
                allows to select the underlying logging system. Possible value are listed in
                the following table.
            </p>
            <table width="93%" border="1" id="d5e5023">
                <tr bgcolor="#8BD5FC">
                    <td width="14%">
                        <span class="emphasis"><em>Property Value</em></span>
                    </td>
                    <td width="86%">
                        <span class="emphasis"><em>Description</em></span>
                    </td>
                </tr>
                <tr>
                    <td>log4j</td>
                    <td>Log4j logging (log4j classes must be available in the classpath); configuration
                        through the log4j.properties file, which is picked up from the CLASSPATH
                        or given through a System property: log4j.configuration
                    </td>
                </tr>
                <tr>
                    <td>jdk14</td>
                    <td>JDK 1.4 logging API (only supported on JVMs of version 1.4 or higher).
                        Configuration is done through a file logging.properties in the jre/lib directory.
                    </td>
                </tr>
                <tr>
                    <td>simple</td>
                    <td>Selects the simple JDK 1.1 compatible console-based logger provided by
                        Jakarta Commons Logging
                    </td>
                </tr>
                <tr>
                    <td>csf</td>
                    <td>Selects CSF-based logging (CSF embeddor must be available)</td>
                </tr>
                <tr>
                    <td>jakarta</td>
                    <td>Uses the default log system selection algorithm of the Jakarta Commons
                        Logging framework
                    </td>
                </tr>
                <tr>
                    <td>dotnet</td>
                    <td>
                        Selects a .net logging implementation
                        <p>
                            Since a dotnet logger is not currently implemented, this is currently identical
                            to simple. Simple is a purely
                            JDK1.1 console-based log implementation.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>avalon</td>
                    <td>Uses the Avalon Logkit implementation</td>
                </tr>
                <tr>
                    <td>noop</td>
                    <td>Disables all logging </td>
                </tr>
            </table>
        </div>
    </div>
    <div class="section" title="3.2.7.11. ORB Portability"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5054"/>3.2.7.11. ORB Portability</h4></div></div></div>
        
        <div class="section" title="3.2.7.11.1. Introduction"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5056"/>3.2.7.11.1. Introduction</h5></div></div></div>
            
            <p>
                Many ORBs currently in use support different versions of CORBA and/or the Java
                language mapping.
                </p><p>
  
                    only supports the new Portable Object Adapter
                    (POA) architecture described in the CORBA 2.3 specification as a replacement
                    for the Basic Object Adapter (BOA). Unlike the BOA, which was weakly specified
                    and led to a number of different (and often conflicting) implementations, the
                    POA was deliberately designed to reduce the differences between ORB implementations,
                    and thus minimise the amount of re-coding that would need to be done when porting
                    applications from one ORB to another. However, there is still scope for slight
                    differences between ORB implementations, notably in the area of threading. Note,
                    instead of talking about the POA, this manual will consider the Object Adapter
                </p><p>
                (OA).
            </p>
            <p>Because 
                must be able to run on a number of different
                ORBs, we have developed an ORB portability interface which allows entire applications
                to be moved between ORBs with little or no modifications. This portability interface
                is available to the application programmer in the form of several Java classes.
            </p>
        </div>
        <div class="section" title="3.2.7.11.2. The ORB Portability API"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5061"/>3.2.7.11.2. The ORB Portability API</h5></div></div></div>
            
        </div>
        <div class="section" title="3.2.7.11.3. Using the ORB"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5063"/>3.2.7.11.3. Using the ORB </h5></div></div></div>
            
            <p>The ORB class provided in the package com.arjuna.orbportability.ORB shown below
                provides a uniform way of using the ORB. There are methods for obtaining a reference
                to the ORB, and for placing the application into a mode where it listens for
                incoming connections. There are also methods for registering application specific
                classes to be invoked before or after ORB initialisation.
            </p>
            <pre><code class="language-java">
public class ORB
{
   public static ORB getInstance(String uniqueId);
   // given the various parameters,this method initialises the ORB and
   // retains a reference to it within the ORB class.
   public synchronized void initORB () throws SystemException;
   public synchronized void initORB (Applet a, Properties p)
        throws SystemException;
   public synchronized void initORB (String[] s, Properties p)
        throws SystemException;

  //The orb method returns a reference to the ORB.
  //After shutdown is called this reference may be null.
   public synchronized org.omg.CORBA.ORB orb ();
   public synchronized boolean setOrb (org.omg.CORBA.ORB theORB);
   // If supported, this method cleanly shuts down the ORB.
   // Any pre- and post- ORB shutdown classes which
   //have been registered will also be called.
   public synchronized void shutdown ();

  public synchronized boolean addAttribute (Attribute p);
  public synchronized void addPreShutdown (PreShutdown c);
  public synchronized void addPostShutdown (PostShutdown c);

  public synchronized void destroy () throws SystemException;
  //these methods place the ORB into a listening mode,
  //where it waits for incoming invocations.
   public void run ();
   public void run (String name);
};
</code></pre>
            <p>Note, some of the methods are not supported on all ORBs, and in this situation,
                a suitable exception will be thrown. The ORB class is a factory class which
                has no public constructor. To create an instance of an ORB you must call the
                getInstance method passing a unique name as a parameter. If this unique name
                has not been passed in a previous call to getInstance you will be returned a
                new ORB instance. Two invocations of getInstance made with the same unique name,
                within the same JVM, will return the same ORB instance.
            </p>
        </div>
        <div class="section" title="3.2.7.11.4. Using the Object Adapater (OA)"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5068"/>3.2.7.11.4. Using the Object Adapater (OA)</h5></div></div></div>
            
            <p>The OA classes shown below provide a uniform way of using Object Adapters (OA).
                There are methods for obtaining a reference to the OA. There are also methods
                for registering application specific classes to be invoked before or after OA
                initialisation. Note, some of the methods are not supported on all ORBs, and
                in this situation, a suitable exception will be thrown. The OA class is an abstract
                class and provides the basic interface to an Object Adapter. It has two sub-classes
                RootOA and ChildOA, these classes expose the interfaces specific to the root
                Object Adapter and a child Object Adapter respectively. From the RootOA you
                can obtain a reference to the RootOA for a given ORB by using the static method
                getRootOA. To create a ChildOA instance use the createPOA method on the RootOA.
            </p>
            <p>As described below, the OA class and its sub-classes provide most operations
                provided by the POA as specified in the POA specification.
            </p>
            <pre><code class="language-java">
public abstract class OA
{
  public synchronized static RootOA getRootOA(ORB associatedORB);
  public synchronized void initPOA () throws SystemException;
  public synchronized void initPOA (String[] args) throws SystemException;
  public synchronized void initOA () throws SystemException;
  public synchronized void initOA (String[] args) throws SystemException;
  public synchronized ChildOA createPOA (String adapterName,
      PolicyList policies) throws AdapterAlreadyExists, InvalidPolicy;
  public synchronized org.omg.PortableServer.POA rootPoa ();
  public synchronized boolean setPoa (org.omg.PortableServer.POA thePOA);
  public synchronized org.omg.PortableServer.POA poa (String adapterName);
  public synchronized boolean setPoa (String adapterName,
     org.omg.PortableServer.POA thePOA);
  ...
};

public class RootOA extends OA
{
  public synchronized void destroy() throws SystemException;
  public org.omg.CORBA.Object corbaReference (Servant obj);
  public boolean objectIsReady (Servant obj, byte[] id);
  public boolean objectIsReady (Servant obj);
  public boolean shutdownObject (org.omg.CORBA.Object obj);
  public boolean shutdownObject (Servant obj);
};

public class ChildOA extends OA
{
  public synchronized boolean setRootPoa (POA thePOA);
  public synchronized void destroy() throws SystemException;
  public org.omg.CORBA.Object corbaReference (Servant obj);
  public boolean objectIsReady (Servant obj, byte[] id)
      throws SystemException;
  public boolean objectIsReady (Servant obj) throws SystemException;
  public boolean shutdownObject (org.omg.CORBA.Object obj);
  public boolean shutdownObject (Servant obj);
};
</code></pre>
        </div>
        <div class="section" title="3.2.7.11.5. Example"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5073"/>3.2.7.11.5. Example</h5></div></div></div>
            
            <p>The following example illustrates how to use the ORB Portability API to create
            </p>
            <pre><code class="language-java">
import com.arjuna.orbportability.ORB;
import com.arjuna.orbportability.OA;

public static void main(String[] args)
{
    try
    {
     // Create an ORB instance
     ORB orb = ORB.getInstance("orb_test");
     OA oa = OA.getRootOA( orb );  // Get the root POA
     orb.initORB(args, null); // Initialize the ORB
     oa.initOA(args);  // Initialize the OA
     // Do Work
     oa.destroy(); // destroy the OA
     orb.shutdown();  // Shutdown the ORB
    }
    catch(Exception e) {}
};
</code></pre>
        </div>
        <div class="section" title="3.2.7.11.6. Specifying the ORB to use"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5077"/>3.2.7.11.6. Specifying the ORB to use</h5></div></div></div>
            
            <p> If using such a JDK (from its version 1.2.2) in conjunction with another ORB
                it is necessary to tell the JVM which ORB to use. This happens by specifying
                the org.omg.CORBA.ORBClass and
                org.omg.CORBA.ORBSingletonClass properties.
                If used, ORB Portability classes will ensure that these properties are automatically
                set when required, i.e., during ORB initialisation.
            </p>
            <p>The ORB portability library attempts to detect which ORB is in use, it does
                this by looking for the ORB implementation class for each ORB it supports. This
                means that if there are classes for more than one ORB in the classpath the wrong
                ORB can be detected. Therefore it is best to only have one ORB in your classpath.
                If it is necessary to have multiple ORBs in the classpath then the property
                com.arjuna.orbportability.orbImplementation
                must be set to the value specified in the table below.
            </p>
            <table width="75%" border="1" id="d5e5081">
                <tr bgcolor="#8BD5FC">
                    <td width="22%">
                        <span class="emphasis"><em>ORB</em></span>
                    </td>
                    <td width="78%">
                        <span class="emphasis"><em>Property Value</em></span>
                    </td>
                </tr>
                <tr>
                    <td>JacORB v2.0</td>
                    <td>com.arjuna.orbportability.internal.orbspecific.jacorb.orb.implementations.jacorb_2_0</td>
                </tr>
            </table>
            <p>For
                additional details on the features provided by the ORB Portability API
                refer to the documentation provided by the 
                distribution.
            </p>
        </div>
        <div class="section" title="3.2.7.11.7.  Failure Recovery"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5091"/>3.2.7.11.7. 
                Failure Recovery
            </h5></div></div></div>
            
            <p>The
                failure recovery subsystem of 
                will ensure that results of
                a transaction are applied consistently to all resources affected by the
                transaction, even if any of the application processes or the machine hosting
                them crash or lose network connectivity. In the case of machine (system)
                crash or network failure, the recovery will not take place until the system
                or network are restored, but the original application does not need to
                be restarted recovery responsibility is delegated to the Recovery Manager
                process (see below). Recovery after failure requires that information about
                the transaction and the resources involved survives the failure and is
                accessible afterward: this information is held in the ActionStore, which
                is part of the ObjectStore. If the ObjectStore is destroyed or modified,
                recovery may not be possible.
                </p><p>Until the recovery procedures are complete, resources affected by a
                    transaction that was in progress at the time of the failure may be inaccessible.
                    For database resources, this may be reported as tables or rows held by
                    "in-doubt transactions".
                </p><p>
            </p>
        </div>
        <div class="section" title="3.2.7.11.8. The Recovery Manager"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5095"/>3.2.7.11.8. The Recovery Manager</h5></div></div></div>
            
            The Recovery Manager is a daemon process responsible for performing crash
            recovery. Only one Recovery Manager runs per node. The Object Store provides
            persistent data storage for transactions to log data. During normal transaction
            processing each transaction will log persistent data needed for the commit
            phase to the Object Store. On successfully committing a transaction this
            data is removed, however if the transaction fails then this data remains
            within the Object Store.
            <p>The Recovery Manager functions by:</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Periodically scanning the Object Store for transactions that may have failed.
                    Failed transactions are indicated by the presence of log data after a period
                    of time that the transaction would have normally been expected to finish.
                </li><li class="listitem">
                    Checking with the application process which originated the transaction
                    whether the transaction is still in progress or not.
                </li><li class="listitem">
                    Recovering the transaction by re-activating the transaction and then replaying
                    phase two of the commit protocol.
                </li></ul></div>
            To start the Recovery Manager issue the following command:

            <pre><code class="language-java">
java com.arjuna.ats.arjuna.recovery.RecoveryManager
</code></pre>

            If the -test flag is used with the Recovery Manager then it will display a "Ready" message when initialised,
            i.e.,

            <pre><code class="language-java">
java com.arjuna.ats.arjuna.recovery.RecoveryManager -test
</code></pre>

            On initialization the Recovery Manager first loads in configuration information
            via a properties file. This configuration includes a number of recovery
            activators and recovery modules, which are then dynamically loaded.
            <p>Each
                recovery activator, which implements the
                com.arjuna.ats.arjuna.recovery.RecoveryActivator
                interface, is used to instantiate a recovery class related to the underlying
                communication protocol. Indeed, since the version 3.0 of ,
                the
                Recovery Manager is not specifically tied to an Object Request Broker or
                ORB, which is to specify a recovery instance able to manage the OTS recovery
                protocol the new interface RecoveryActivator is provided to identify specific
                transaction protocol. For instance, when used with OTS, the RecoveryActivitor
                has the responsibility to create a RecoveryCoordinator object able to respond
                to the replay_completion operation.
            </p>
            <p>
                All RecoveryActivator instances inherit the same interface. They are loaded via
                the following recovery extension property:
            </p>
            <pre><code class="language-java">
&lt;property
  name="com.arjuna.ats.arjuna.recovery.recoveryActivator_&lt;number&gt;"
  value="RecoveryClass"/&gt; </code></pre>
            <p>For instance the RecoveryActivator provided in the distribution of JTS/OTS, which shall not be
                commented, is as follow : </p>
            <pre><code class="language-java">
&lt;property
  name="com.arjuna.ats.arjuna.recovery.recoveryActivator_1"
  value="com.arjuna.ats.internal.jts.
     orbspecific.recovery.RecoveryEnablement"/&gt; </code></pre>
            Each recovery module, which implements the com.arjuna.ats.arjuna.recovery.RecoveryModule
            interface, is used to recover a different type of transaction/resource,
            however each recovery module inherits the same basic behaviour.
            <p>Recovery consists of two separate passes/phases separated by two timeout
                periods. The first pass examines the object store for potentially failed
                transactions; the second pass performs crash recovery on failed transactions.
                The timeout between the first and second pass is known as the backoff period.
                The timeout between the end of the second pass and the start of the first
                pass is the recovery period. The recovery period is larger than the backoff
                period.
            </p>
            <p>The Recovery Manager invokes the first pass upon each recovery module,
                applies the backoff period timeout, invokes the second pass upon each recovery
                module and finally applies the recovery period timeout before restarting
                the first pass again.
            </p>
            <p>The recovery modules are loaded via the following recovery extension property:</p>
            <pre><code class="language-java">
com.arjuna.ats.arjuna.recovery.recoveryExtension&lt;number&gt;=&lt;RecoveryClass&gt; </code></pre>
            The default RecoveryExtension settings are:

            <pre><code class="language-java">
&lt;property name="com.arjuna.ats.arjuna.recovery.recoveryExtension1"
  value="com.arjuna.ats.internal.
     arjuna.recovery.AtomicActionRecoveryModule"/&gt;
&lt;property name="com.arjuna.ats.arjuna.recovery.recoveryExtension2"
  value="com.arjuna.ats.internal.
     txoj.recovery.TORecoveryModule"/&gt;
&lt;property name="com.arjuna.ats.arjuna.recovery.recoveryExtension3"
  value="com.arjuna.ats.internal.
     jts.recovery.transactions.TopLevelTransactionRecoveryModule"/&gt;
&lt;property  name="com.arjuna.ats.arjuna.recovery.recoveryExtension4"
  value="com.arjuna.ats.internal.
     jts.recovery.transactions.ServerTransactionRecoveryModule"/&gt; </code></pre>
        </div>
        <div class="section" title="3.2.7.11.9. Configuring the Recovery Manager"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5114"/>3.2.7.11.9. Configuring the Recovery Manager</h5></div></div></div>
            
        </div>
        <div class="section" title="3.2.7.11.10. Periodic Recovery"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5116"/>3.2.7.11.10. Periodic Recovery</h5></div></div></div>
            
            The backoff period and recovery period are set using the following properties:

            <pre><code class="language-java">
com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod (default 10 secs)
com.arjuna.ats.arjuna.recovery.periodicRecovery (default 120 secs)
</code></pre>
        </div>
        <div class="section" title="3.2.7.11.11. Expired entry removal"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5119"/>3.2.7.11.11. Expired entry removal</h5></div></div></div>
            
            The operation of the recovery subsystem will cause some entries to be made
            in the ObjectStore that will not be removed in normal progress. The RecoveryManager
            has a facility for scanning for these and removing items that are very
            old. Scans and removals are performed by implementations of the com.arjuna.ats.arjuna.recovery.ExpiryScanner.
            Implementations of this interface are loaded by giving the class name as
            the value of a property whose name begins with ExperyScanner.
            <p>The RecoveryManager calls the scan() method on each loaded ExpiryScanner
                implementation at an interval determined by the property com.arjuna.ats.arjuna.recovery.expiryScanInterval.
                This value is given in hours default is 12. An EXPIRY_SCAN_INTERVAL value
                of zero will suppress any expiry scanning. If the value as supplied is
                positive, the first scan is performed when RecoveryManager starts; if the
                value is negative, the first scan is delayed until after the first interval
                (using the absolute value)
            </p>
            <p>The default ExpiryScanner is:</p>
            <pre><code class="language-java">
&lt;property
  name="com.arjuna.ats.arjuna.recovery.
        expiryScannerTransactionStatusManager"
  value="com.arjuna.ats.internal.arjuna.recovery.
       ExpiredTransactionStatusManagerScanner"/&gt; </code></pre>
            <p>The following table summarize properties used by the Recovery Manager. These
                properties are defined by default the properties file named RecoveryManager-properties.xml.
            </p>
            <table id="d5e5125">
                <tr>
                    <td width="38%">
                        <span class="emphasis"><em>Name</em></span>
                    </td>
                    <td width="34%">
                        <span class="emphasis"><em>Description</em></span>
                    </td>
                    <td width="9%">
                        <span class="emphasis"><em>Possible Value</em></span>
                    </td>
                    <td width="19%">
                        <span class="emphasis"><em>Default Value</em></span>
                    </td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod</td>
                    <td>Interval in seconds between initiating the periodic recovery modules</td>
                    <td>Value in seconds</td>
                    <td>120</td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod</td>
                    <td>Interval in seconds between first and second pass of periodic recovery</td>
                    <td>Value in seconds</td>
                    <td>10</td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.recovery.recoveryExtensionX</td>
                    <td>Indicates a periodic recovery module to use. X is the occurence number
                        of the recovery module among a set of recovery modules. These modules are
                        invoked in sort-order of names
                    </td>
                    <td>The class name of the periodic recovery module </td>
                    <td>
                        provides a set classes given in the RecoveryManager-properties.xml file
                    </td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.recovery.recoveryActivator_X</td>
                    <td>Indicates a recovery activator to use. X is the occurence number of the
                        recovery activator among a set of recovery activators.
                    </td>
                    <td>The class name of the periodic recovery activator</td>
                    <td>
                        provide one class that manages the recovery protocol specified
                        by the OTS specification
                    </td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.recovery.expiryScannerXXX</td>
                    <td>Expiry scanners to use (order of invocation is random). Names must begin
                        with "com.arjuna.ats.arjuna.recovery.expiryScanner"
                    </td>
                    <td>Class name</td>
                    <td>
                        provides one class given in the RecoveryManager-properties.xml file
                    </td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.recovery.expiryScanInterval</td>
                    <td>Interval, in hours, between running the expiry scanners. This can be
                        quite long. The absolute value determines the interval - if the value is
                        negative, the scan will NOT be run until after one interval has elapsed.
                        If positive the first scan will be immediately
                        after startup. Zero will prevent any scanning.
                    </td>
                    <td>Value in hours</td>
                    <td>12 </td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.recovery.transactionStatusManagerExpiryTime</td>
                    <td>Age, in hours, for removal of transaction status manager item. This should
                        be longer than any ts-using process will remain running. Zero = Never removed.
                    </td>
                    <td>Value in Hours</td>
                    <td>12 </td>
                </tr>
                <tr>
                    <td>com.arjuna.ats.arjuna.recovery.transactionStatusManagerPort</td>
                    <td>Use this to fix the port on which the TransactionStatusManager listens</td>
                    <td>Port number (short) </td>
                    <td>use a free port</td>
                </tr>
            </table>


        </div>
    </div>
    <div class="section" title="3.2.7.12. Installation Content"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5175"/>3.2.7.12. Installation Content</h4></div></div></div>
        
        <div class="section" title="3.2.7.12.1. Verifying Installation"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5177"/>3.2.7.12.1. Verifying Installation</h5></div></div></div>
            
            When installed, the binary release of ,
            JTS version, should have the following structure.
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">/bin:
                    this directory contains commands
                    to run the OTS transaction manager server (if required) and the Recovery Manager,
                    and scripts to configure environment variables needed to execute .
                </li><li class="listitem">/docs:
                    this directory contains
                    documentation on the way to installing, administering and programming ArjunaCore,
    
                    JTA and 
                    JTS.
                </li><li class="listitem">/etc:
                    this directory contains appropriate
                    properties files that can be used to configure the behaviour of the .
                </li><li class="listitem">/htdocs:
                    this directory describes
                    all APIs defined by 
                </li><li class="listitem">
                    /idl: this directory contains the
                    CORBA idl files that may be registered with your interface repository prior
                    to running any applications.
                </li><li class="listitem">
                    /jacorb: This directory contains the jacorb distribution.
                </li><li class="listitem">/lib:
                    this directory contains the
                    jar files that contains packages defined by the .
                    These jar files
                    shall be added in the CLASSPATH
                </li><li class="listitem">
                    /services: this directory contains the
                    appropriates scripts, jar and configuration files allowing to start and stop standalone Transaction Service and Recovery
                    Manager
                </li><li class="listitem">
                    /trail_map: contains examples
                    applications
                </li></ul></div>
        </div>
        <div class="section" title="3.2.7.12.2. Testing your installation"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5189"/>3.2.7.12.2. Testing your installation</h5></div></div></div>
            
            <p>To
                ensure that your 
                installation is fully operational, we will run the simple demo.
            </p>
            <p>Please follow these steps before running the transactional applications</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Ensure you have the Ant build system installed. Ant is a Java build tool,
                    similar to make. It is available for free from http://ant.apache.org/ The
                    sample application requires version 1.5.1 or later.
                </li><li class="listitem">The
                    PATH and CLASSPATH environment variables need to be set appropriately
                    to use .
                    To make this easier, we provide a shell
                    script setup_env.sh (and for
                    Windows a batch file setup_env.bat)
                    in the directory &lt;jbossts_install_root&gt;/bin/
                </li><li class="listitem">From
                    a command prompt, cd to the directory containing the build.xml file
                    (&lt;jbossts_install_root&gt;/trail_map)
                    and type 'ant'. This will compile a set of sources files located under &lt;jbossts_install_root&gt;/trail_map/src
                    then create an application .jar file named
                    <span class="emphasis"><em>jbossts-demo.jar</em></span>.
                    under
                    the directory &lt;jbossts_install_root&gt;/trail_map/lib
                </li><li class="listitem">
                    Add the generated jar file to the CLASSPATH environment variable.
                </li><li class="listitem">Ensure
                    that the jacorb is added in your CLASSPATH. Use only the patched version that ships with .
                    <p>
                        <span class="emphasis"><em>Ensure
                            that 
                            jar files appear before jacorb jar files.
                        </em></span>
                    </p>
                </li></ul></div>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Start the server. src/com/arjuna/demo/simple/HelloServer.java"&gt;(HelloServer.java) (
                    <span class="emphasis"><em>Note: The source code for the trailmap is fully documented and can often contain very
                        useful tips and information that may not be reflected elsewhere in the trailmap</em></span>
                    )
                </li></ul></div>
            <div class="blockquote"><blockquote class="blockquote">
                <p>
                    java com.arjuna.demo.simple.HelloServer
                </p>
            </blockquote></div>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Open
                    another command prompt, go to the same /trail_map directory and start
                    the client src/com/arjuna/demo/simple/HelloClient.java"&gt;(HelloClient.java) . Be sure that the environment variable
                    CLASSPATH is set with the
                    same value as explained above.
                </li></ul></div>
            <div class="blockquote"><blockquote class="blockquote">
                <p>
                    java com.arjuna.demo.simple.HelloClient
                </p>
            </blockquote></div>
            <p>In the client window you should see the following lines:</p>
            <pre><code class="language-java">
     Creating a transaction !
     Call the Hello Server !
     Commit transaction
     Done</code></pre>
            <p>In the server, which must be stopped by hand, you should see:</p>
            <pre><code class="language-java">
     Hello - called within a scope of a transaction</code></pre>
        </div>
        <div class="section" title="3.2.7.12.3. Setting properties"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5215"/>3.2.7.12.3. Setting properties</h5></div></div></div>
            

            has been designed to be highly configurable at runtime through the use of various
            property attributes. Although these attributes can be provided at runtime on the
            command line, it is possible (and may be more convenient) to specify them through the
            properties file jbossts-properties.xml located under the /etc directory of the 
            distribution.
            <p>More
                details on the way to configure the behavior of 
                can be found in the section on configuration.
            </p>
        </div>
    </div>
    <div class="section" title="3.2.7.13. Specifying the ORB to use"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5218"/>3.2.7.13. Specifying the ORB to use</h4></div></div></div>
        
        <p>
            JDK releases from 1.2.2 onwards include a minimum ORB implementation from Sun.
            If using such a JDK in conjunction with another ORB it is necessary to tell
            the JVM which ORB to use. This happens by specifying the
            <span class="emphasis"><em>org.omg.CORBA.ORBClass
            </em></span>
            and org.omg.CORBA.ORBSingletonClass properties. In earlier versions of the 
            it was necessary to specify these properties explicitly, either on the command
            line of in the properties file. However, it is no longer a requirement to do
            this, as the ORB Portability classes
            will ensure that these properties are automatically set when required. Of course
            it is still possible to specify these values explicitly (and necessary if not
            using the ORB initialization methods)
        </p>
    </div>
    <div class="section" title="3.2.7.14. Overview of the Distributed Transaction Processing"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5222"/>3.2.7.14. Overview of the Distributed Transaction Processing</h4></div></div></div>
        
        <p>
            Transaction management is one of the most crucial
            requirements for enterprise application development.
            Most of the large enterprise applications in the
            domains of finance, banking and electronic commerce
            rely on transaction processing for delivering their
            business functionality.
        </p>
        <p>
            Enterprise applications often require concurrent
            access to distributed data shared amongst multiple
            components, to perform operations on data. Such
            applications should maintain integrity of data (as
            defined by the business rules of the application)
            under the following circumstances:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                distributed access to a single resource of data,
                and
            </li><li class="listitem">
                access to distributed resources from a single
                application component.
            </li></ul></div>
        <p>
            In such cases, it may be required that a group of
            operations on (distributed) resources be treated as
            one unit of work. In a unit of work, all the
            participating operations should either succeed or
            fail and recover together. This problem is more
            complicated when
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                a unit of work is implemented across a group of
                distributed components operating on data from
                multiple resources, and/or
            </li><li class="listitem">
                the participating operations are executed
                sequentially or in parallel threads requiring
                coordination and/or synchronization.
            </li></ul></div>
        <p>
            In either case, it is required that success or
            failure of a unit of work be maintained by the
            application. In case of a failure, all the resources
            should bring back the state of the data to the
            previous state (
            <span class="emphasis"><em>i.e.,</em></span>
            the state prior to the commencement of the unit of
            work).
        </p>
        <p>
            From the programmer's perspective a transaction is a
            scoping mechanism for a collection of actions which
            must complete as a unit. It provides a simplified
            model for exception handling since only two outcomes
            are possible:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                success - meaning that all actions involved
                within a transaction are completed
            </li><li class="listitem">
                failure - no actions complete
            </li></ul></div>
        <img src="images/jts-trans_succes_failure.PNG.png"/>
    </div>
    <div class="section" title="3.2.7.15. Example"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5240"/>3.2.7.15. Example</h4></div></div></div>
        
        <p>
            To illustrate the reliability expected by the
            application let’s consider the funds transfer
            example which is familiar to all of us.
        </p>
        The Money transfer involves two operations: Deposit and
        Withdrawal
        <p>
            The complexity of implementation doesn't matter;
            money moves from one place to another. For instance,
            involved accounts may be either located in a same
            relational table within a database or located on
            different databases.
        </p>
        <p>
            A Simple transfer consists on moving money from
            savings to checking while a Complex transfer can be
            performed at the end- of- day according to a
            reconciliation between international banks
        </p>
        <img src="images/jts-example_transfer.PNG.png"/>
        <div class="section" title="3.2.7.15.1. What is a Transaction?"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5246"/>3.2.7.15.1. What is a Transaction?</h5></div></div></div>
            
            <p>
                The concept of a transaction, and a transaction
                manager (or a transaction processing service)
                simplifies construction of such enterprise level
                distributed applications while maintaining
                integrity of data in a unit of work.
            </p>
            <p>
                A transaction is a unit of work that has the
                following properties:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <span class="emphasis"><em>Atomicity</em></span>
                    – either the whole transaction completes or
                    nothing completes - partial completion is not
                    permitted.
                </li><li class="listitem">
                    <span class="emphasis"><em>Consistency</em></span>
                    – a transaction transforms the system from one
                    consistent state to another. In other words, On
                    completion of a successful transaction, the data
                    should be in a consistent state. For example, in
                    the case of relational databases, a consistent
                    transaction should preserve all the integrity
                    constraints defined on the data.
                </li><li class="listitem">
                    <span class="emphasis"><em>Isolation:</em></span>
                    Each transaction should appear to execute
                    independently of other transactions that may be
                    executing concurrently in the same environment.
                    The effect of executing a set of transactions
                    serially should be the same as that of running
                    them concurrently. This requires two things:
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            During the course of a transaction,
                            intermediate (possibly inconsistent)
                            state of the data should not be exposed
                            to all other transactions.
                        </li><li class="listitem">
                            Two concurrent transactions should not
                            be able to operate on the same data.
                            Database management systems usually
                            implement this feature using locking.
                        </li></ul></div>
                </li><li class="listitem">
                    <span class="emphasis"><em>Durability:</em></span>
                    The effects of a completed transaction should
                    always be persistent.
                </li></ul></div>
            <p>
                These properties, called as
                <span class="emphasis"><em>ACID</em></span>
                properties, guarantee that a transaction is never
                incomplete, the data is never inconsistent,
                concurrent transactions are independent, and the
                effects of a transaction are persistent.
            </p>
        </div>
        <div class="section" title="3.2.7.15.2. Transactional Concepts"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5264"/>3.2.7.15.2. Transactional Concepts</h5></div></div></div>
            
            <div class="section" title="3.2.7.15.2.1. Transaction Components"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5266"/>3.2.7.15.2.1. Transaction Components</h6></div></div></div>
                
                <p>
                    A collection of actions is said to be transactional
                    if they possess the ACID properties. These
                    properties are assumed to be ensured, in the
                    presence of failures; if actions involved within the
                    transaction are performed by a Transactional System.
                    A transaction system includes a set of components
                    where each of them has a particular role. Main
                    components are described below.
                </p>
                <img src="images/jts-transaction_components.PNG.png"/>
            </div>
            <div class="section" title="3.2.7.15.2.2. Application Programs"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5270"/>3.2.7.15.2.2. Application Programs</h6></div></div></div>
                
                <p>
                    Application Programs are clients for the
                    transactional resources. These are the programs
                    with which the application developer implements
                    business transactions. With the help of the
                    transaction manager, these components create
                    global transactions and operate on the
                    transactional resources with in the scope of
                    these transactions. These components are not
                    responsible for implementing mechanisms for
                    preserving ACID properties of transactions.
                    However, as part of the application logic, these
                    components generally make a decision whether to
                    commit or rollback transactions.
                </p>
                <p>
                    Application responsibilities could be summarized
                    as follow:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Create and demarcate transactions
                    </li><li class="listitem">
                        Operate on data via resource managers
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.15.2.3. Resource Managers"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5277"/>3.2.7.15.2.3. Resource Managers</h6></div></div></div>
                
                <p>
                    A resource manager is in general a component
                    that manages persistent and stable data storage
                    system, and participates in the two phase commit
                    and recovery protocols with the transaction
                    manager.
                </p>
                <p>
                    A resource manager is typically a driver that
                    provides two sets of interfaces: one set for the
                    application components to get connections and
                    operating, and the other set for participating
                    in two phase commit and recovery protocols
                    coordinated by a transaction manager. This
                    component may also, directly or indirectly,
                    register resources with the transaction manager
                    so that the transaction manager can keep track
                    of all the resources participating in a
                    transaction. This process is called as resource
                    enlistment.
                </p>
                <p>
                    Resource Manager responsibilities could be
                    summarized as follow
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Enlist resources with the transaction
                        manager
                    </li><li class="listitem">
                        Participate in two-phase commit and recovery
                        protocol
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.15.2.4. Transaction Manager"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5285"/>3.2.7.15.2.4. Transaction Manager</h6></div></div></div>
                
                <p>
                    The transaction manager is the core component of
                    a transaction processing environment. Its main
                    responsibilities are to create transactions when
                    requested by application components, allow
                    resource enlistment and delistment, and to
                    manage the two-phase commit or recovery protocol
                    with the resource managers.
                </p>
                <p>
                    A typical transactional application begins a
                    transaction by issuing a request to a
                    transaction manager to initiate a transaction.
                    In response, the transaction manager starts a
                    transaction and associates it with the calling
                    thread. The transaction manager also establishes
                    a transaction context. All application
                    components and/or threads participating in the
                    transaction share the transaction context. The
                    thread that initially issued the request for
                    beginning the transaction, or, if the
                    transaction manager allows, any other thread may
                    eventually terminate the transaction by issuing
                    a commit or rollback request.
                </p>
                <p>
                    Before a transaction is terminated, any number
                    of components and/or threads may perform
                    transactional operations on any number of
                    transactional resources known to the transaction
                    manager. If allowed by the transaction manager,
                    a transaction may be suspended or resumed before
                    finally completing the transaction.
                </p>
                <p>
                    Once the application issues the commit request,
                    the transaction manager prepares all the
                    resources for a commit operation, and based on
                    whether all resources are ready for a commit or
                    not, issues a commit or rollback request to all
                    the resources.
                </p>
                <p>
                    Resource Manager responsibilities could be
                    summarized as follow:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Establish and maintain transaction context
                    </li><li class="listitem">
                        Maintain association between a transaction
                        and the participating resources.
                    </li><li class="listitem">
                        Initiate and conduct two-phase commit and
                        recovery protocol with the resource
                        managers.
                    </li><li class="listitem">
                        Make synchronization calls to the
                        application components before beginning and
                        after end of the two-phase commit and
                        recovery process
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.15.2.5. Local vs. Distributed Transaction"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5297"/>3.2.7.15.2.5. Local vs. Distributed Transaction</h6></div></div></div>
                
                <p>
                    A transaction that involves only one transactional
                    resource, such a database, is considered as
                    <span class="emphasis"><em>local transaction</em></span>
                    , while a transaction that involves more than one
                    transactional resource that need to be coordinated
                    to reach a consistent state is considered as a
                    <span class="emphasis"><em>distributed transaction.</em></span>
                </p>
                <p>
                    A transaction can be specified by what is known as
                    transaction demarcation. Transaction demarcation
                    enables work done by distributed components to be
                    bound by a global transaction. It is a way of
                    marking groups of operations to constitute a
                    transaction.
                </p>
                <p>
                    The most common approach to demarcation is to mark
                    the thread executing the operations for transaction
                    processing. This is called as programmatic
                    demarcation. The transaction so established can be
                    suspended by unmarking the thread, and be resumed
                    later by explicitly propagating the transaction
                    context from the point of suspension to the point of
                    resumption.
                </p>
                <p>
                    The transaction demarcation ends after a commit or a
                    rollback request to the transaction manager. The
                    commit request directs all the participating
                    resources managers to record the effects of the
                    operations of the transaction permanently. The
                    rollback request makes the resource managers undo
                    the effects of all operations on the transaction.
                </p>
            </div>
            <div class="section" title="3.2.7.15.2.6. Transaction Context and Propagation"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5305"/>3.2.7.15.2.6. Transaction Context and Propagation</h6></div></div></div>
                
                <p>
                    Since multiple application components and resources
                    participate in a transaction, it is necessary for
                    the transaction manager to establish and maintain
                    the state of the transaction as it occurs. This is
                    usually done in the form of transaction context.
                </p>
                <p>
                    Transaction context is an association between the
                    transactional operations on the resources, and the
                    components invoking the operations. During the
                    course of a transaction, all the threads
                    participating in the transaction share the
                    transaction context. Thus the transaction context
                    logically envelops all the operations performed on
                    transactional resources during a transaction. The
                    transaction context is usually maintained
                    transparently by the underlying transaction manager.
                </p>
            </div>
            <div class="section" title="3.2.7.15.2.7. Resource Enlistment"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5309"/>3.2.7.15.2.7. Resource Enlistment</h6></div></div></div>
                
                <p>
                    Resource enlistment is the process by which resource
                    managers inform the transaction manager of their
                    participation in a transaction. This process enables
                    the transaction manager to keep track of all the
                    resources participating in a transaction. The
                    transaction manager uses this information to
                    coordinate transactional work performed by the
                    resource managers and to drive two-phase and
                    recovery protocol. At the end of a transaction
                    (after a commit or rollback) the transaction manager
                    delists the resources.
                </p>
            </div>
            <div class="section" title="3.2.7.15.2.8.  Two-Phase Commit"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5312"/>3.2.7.15.2.8. 
                    Two-Phase Commit
                </h6></div></div></div>
                
                <p>
                    This protocol between the transaction manager and
                    all the resources enlisted for a transaction ensures
                    that either all the resource managers commit the
                    transaction or they all abort. In this protocol,
                    when the application requests for committing the
                    transaction, the transaction manager issues a
                    prepare request to all the resource managers
                    involved. Each of these resources may in turn send a
                    reply indicating whether it is ready for commit or
                    not. Only The transaction manager issue a commit
                    request to all the resource managers, only when all
                    the resource managers are ready for a commit.
                    Otherwise, the transaction manager issues a rollback
                    request and the transaction will be rolled back.
                </p>
            </div>
            <div class="section" title="3.2.7.15.2.9.  Recovery and Logging"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5315"/>3.2.7.15.2.9. 
                    Recovery and Logging
                </h6></div></div></div>
                
                <p>
                    Basically, the Recovery is the mechanism which
                    preserves the transaction atomicity in presence of
                    failures. The basic technique for implementing
                    transactions in presence of failures is based on the
                    use of logs. That is, a transaction system has to
                    record enough information to ensure that it can be
                    able to return to a previous state in case of
                    failure or to ensure that changes committed by a
                    transaction are properly stored.
                </p>
                <p>
                    In addition to be able to store appropriate
                    information, all participants within a
                    distributed transaction must log similar
                    information which allow them to take a same
                    decision either to set data in their final state
                    or in their initial state.
                </p>
                <p>
                    Two techniques are in general used to ensure
                    transaction's atomicity. A first technique
                    focuses on manipulated data, such the
                    Do/Undo/Redo protocol (considered as a recovery
                    mechanism in a centralized system), which allow
                    a participant to set its data in their final
                    values or to retrieve them in their initial
                    values. A second technique relies on a
                    distributed protocol named the two phases
                    commit, ensuring that all participants involved
                    within a distributed transaction set their data
                    either in their final values or in their initial
                    values. In other words all participants must
                    commit or all must rollback.
                </p>
                <img src="images/jts-recovery_logs.PNG.png"/>
                <p>
                    In addition to failures we refer as centralized
                    such system crashes, communication failures due
                    for instance to network outages or message loss have to be
                    considered during the recovery process of a
                    distributed transaction.
                </p>
                <p>
                    In order to provide an efficient and optimized
                    mechanism to deal with failure, modern
                    transactional systems typically adopt a “presume
                    abort” strategy, which simplifies the
                    transaction management.
                </p>
                <p>
                    The presumed abort strategy can be stated as
                    «when in doubt, abort». With this strategy, when
                    the recovery mechanism has no information about
                    the transaction, it presumes that the
                    transaction has been aborted.
                </p>
                A particularity of the presumed-abort assumption
                allows a coordinator to not log anything before the
                commit decision and the participants do not to log
                anything before they prepare. Then, any failure
                which occurs before the 2pc starts lead to abort the
                transaction. Furthermore, from a coordinator point
                of view any communication failure detected by a
                timeout or exception raised on sending prepare is
                considered as a negative vote which leads to abort
                the transaction. So, within a distributed
                transaction a coordinator or a participant may fail
                in two ways: either it crashes or it times out for a
                message it was expecting. When a coordinator or a
                participant crashes and then restarts, it uses
                information on stable storage to determine the way
                to perform the recovery. As we will see it the
                presumed-abort strategy enable an optimized behavior
                for the recovery.

            </div>
            <div class="section" title="3.2.7.15.2.10. Heuristic Decision"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5324"/>3.2.7.15.2.10. Heuristic Decision</h6></div></div></div>
                
                In extremely rare cases, a resource manager may choose
                not to wait for the outcome from the transaction
                manager. This might occur if the communications path was
                lost and was not likely to be restored for a very long
                time. Typically this happens as a result of human
                intervention and not as an arbitrary action of a
                resource manager. In order to release locks and make
                this transactions data available to new transactions,
                the resource manager makes a
                <span class="emphasis"><em>heuristic decision</em></span>
                , i.e. it guesses the proper transaction outcome. When
                it does so, it must remember its guess until contact
                with the transaction manager is ultimately
                re-established.
            </div>
            <div class="section" title="3.2.7.15.2.11. Standards"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5327"/>3.2.7.15.2.11. Standards</h6></div></div></div>
                
                Saying that a distributed transaction can involve
                several distributed participants, means that these
                participant must be integrated within a global
                transaction manager which has the responsibility to
                ensure that all participants take a common decision to
                commit or rollback the distributed transaction. The key
                of such integration is the existence of a common
                transactional interface which is understood by all
                participants, transaction manager and resource managers
                such databases.
                <p>
                    The importance of common interfaces between
                    participants, as well as the complexity of their
                    implementation, becomes obvious in an open systems
                    environment. For this aim various distributed
                    transaction processing standards have been developed
                    by international standards organizations. Among
                    these organizations, We list three of them which are
                    mainly considered in the 
                    product:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        The
                        X/Open model
                        and its successful XA interface
                    </li><li class="listitem">
                        The OMG with its CORBA infrastructure and the
                        Object Transaction Service
                        and finally
                    </li><li class="listitem">
                        The Java Community Process leaded by Sun with
                        its
                        JTA/JTS specification
                    </li></ul></div>
                Basically these standards have proposed logical models,
                which divide transaction processing into several
                functions:
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        those assigned to the application which ties
                        resources together in application- specific
                        operations
                    </li><li class="listitem">
                        those assigned to the Resource manager which
                        access physically to data stores
                    </li><li class="listitem">
                        functions performed by the Transaction Manager
                        which manages transactions, and finally
                    </li><li class="listitem">
                        Communication Resource Managers which allow to
                        exchange information with other transactional
                        domains.
                    </li></ul></div>
                <img src="images/jts-standards.PNG.png"/>

            </div>
        </div>
    </div>
    <div class="section" title="3.2.7.16.  Overview"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5340"/>3.2.7.16. 
            Overview
        </h4></div></div></div>
        
        <p>
					
            assures
            complete, accurate business transactions for any
            Java based applications, including those written for
            the Jakarta EE and EJB frameworks.
        </p>
        <p>
					
            is a 100% Java implementation of a
            distributed transaction management system based on
            the Jakarta EE Java Transaction Service
            (JTS) standard. Our implementation of the JTS
            utilizes the Object Management Group's (OMG) Object
            Transaction Service (OTS) model for transaction
            interoperability as recommended in the Jakarta EE and EJB
            standards. Although any JTS-compliant product will
            allow Java objects to participate in transactions,
            one of the key features of 
            is it's 100% Java
            implementation. This allows 
            to support fully
            distributed transactions that can be coordinated by
            distributed parties.
        </p>
        <p>
						
            runs can be run both as an embedded
            distributed service of an application server
            (e.g. WildFly Application Server),
            affording the user all the
            added benefits of the application server
            environment such as real-time load balancing,
            unlimited linear scalability and unmatched fault
            tolerance that allows you to deliver an
            always-on solution to your customers. It is also
            available as a free-standing Java Transaction
            Service.
        </p>
        <p>
            In addition to providing full compliance with
            the latest version of the JTS specification, 
            leads the market in providing many advanced
            features such as fully distributed transactions
            and ORB portability with POA support.
        </p>
        <p>
						
            works on a number of operating systems including
            Red Hat linux, Sun Solaris and Microsoft Windows XP.
            It requires a Java 5 or later environment.
        </p>
        <p>
            The Java Transaction API support for 
            comes
            in two flavours:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                a purely local implementation, that does not
                require an ORB, but obviously requires all
                coordinated resources to reside within the
                same JVM.
            </li><li class="listitem">
                a fully distributed implementation.
            </li></ul></div>
        <div class="section" title="3.2.7.16.1. Key features"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5351"/>3.2.7.16.1. Key features</h5></div></div></div>
            
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    full compliant with the Jakarta Transactions 2.0
                    specification:
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Purely local (ORB-less) JTA offers
                            the fastest JTA performance
                        </li><li class="listitem">
                            JDBC 3 support
                        </li><li class="listitem">
                            XA compliance
                        </li><li class="listitem">
                            JDBC drivers for database access
                            with full transaction support
                        </li><li class="listitem">
                            Automatic crash recovery for
                            XAResources
                        </li></ul></div>
                </li><li class="listitem">
                    compliance with the JTS specification and
                    OTS 1.2 specification from the OMG
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Distributed JTA implementation
                        </li><li class="listitem">
                            support for distributed transactions
                            (utilizing two-phase commit)
                        </li><li class="listitem">
                            POA ORB support
                        </li><li class="listitem">
                            interposition
                        </li><li class="listitem">
                            transaction heuristics
                        </li><li class="listitem">
                            distributed transaction manager
                            (co-located with the transaction
                            initiator) or transaction manager
                            server
                        </li><li class="listitem">
                            checked/unchecked transaction
                            behaviour
                        </li><li class="listitem">
                            supports both flat and nested
                            transaction models, with
                            nested-aware resources and resource
                            adapters
                        </li><li class="listitem">
                            independent concurrency control
                            system with support for
                            type-specific concurrency control
                        </li><li class="listitem">
                            support for CosTransaction::Current
                        </li><li class="listitem">
                            direct and indirect transaction
                            management
                        </li><li class="listitem">
                            synchronization interface
                        </li><li class="listitem">
                            explicit and implicit transaction
                            context propagation
                        </li><li class="listitem">
                            automatic crash recovery
                        </li><li class="listitem">
                            multi-thread aware
                        </li></ul></div>
                </li><li class="listitem">
                    transactional objects (TO) for Java
                </li><li class="listitem">
                    ORB independence via the ORB portability
                    layer
                </li></ul></div>
        </div>
    </div>
    <div class="section" title="3.2.7.17. The Sample Application"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5380"/>3.2.7.17. The Sample Application</h4></div></div></div>
        
        <div class="section" title="3.2.7.17.1. The Banking Application"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5382"/>3.2.7.17.1. The Banking Application</h5></div></div></div>
            
            <p>The sample application consists of a banking application that involves a bank able to manage accounts
                on behalf of clients. Clients can obtain information on accounts and perform operations such credit,
                withdraw and transfer money from one account to an other.</p>
            <p>
                <span class="emphasis"><em>
                    <img src="images/jts-banking_application_1.PNG.png"/>
                </em></span>
            </p>
            <p>Figure 1 - The Banking Applications</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    The client application:
                </li></ul></div>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Initializes the banking object.
                </li><li class="listitem">
                    Choose an operation to be performed on the banking object. Possible operations are:
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Create Account: this operation asks the bank to create a new account credit it with the
                            first amount provided in the request. The creation consists:
                            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    to create an Account Object, then
                                </li></ul></div>
                        </li><li class="listitem">
                            Get Balance: this operation invokes the bank to obtain the balance of an account.
                            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    the account is first returned by the bank, then
                                </li><li class="listitem">
                                    the account is asked to return its balance
                                </li></ul></div>
                        </li><li class="listitem">
                            Withdraw: this operation is invoked to withdraw money from an account. If the final balance
                            is negative the withdraw is refused and the associated transaction aborted
                        </li><li class="listitem">
                            Credit: this operation is performed to credit an account
                        </li><li class="listitem">
                            Transfer: This operation is used to transfer money from an account to another. If the
                            transfer leads to get a negative balance of the debited account, the transfer is refused and
                            the associated transaction is aborted.
                        </li><li class="listitem">
                            Exit: This operation terminates the client
                        </li></ul></div>
                </li><li class="listitem">
                    Waits for a response.
                </li></ul></div>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    The Bank Object
                </li></ul></div>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Creates Account Objects using name
                </li><li class="listitem">
                    Maintains the list of created Accounts
                </li><li class="listitem">
                    Returns, when asked, the Account Object requested by the client. If the Account doesn't exist an
                    exception is returned to the client.
                </li></ul></div>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    An Account Object
                </li></ul></div>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Performs operations requested by the client
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            credit,
                        </li><li class="listitem">
                            withdraw (debit), and
                        </li><li class="listitem">
                            return the current balance.
                        </li></ul></div>
                </li></ul></div>
            <p>Each operation provided to the client leads to the creation of a transaction; therefore in order to
                commit or rollback changes made on an account, a resource is associated with the account to participate
                to the transaction commitment protocol. According to the final transaction decision, the resource is
                able to set the Account either to its initial state (in case of rollback) or to the final state (in case
                of commit). From the transactional view, Figure 2 depicts of transactional components.</p>
            <p>
                <img src="images/jts-banking_application_2.PNG.png"/>
            </p>
            <p>Figure 2 - The Banking Application and the transactional Component</p>
        </div>
        <div class="section" title="3.2.7.17.2. Deploying and Testing The Banking Application"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5425"/>3.2.7.17.2. Deploying and Testing The Banking Application</h5></div></div></div>
            
            <p>
                Assuming that the 
                product has
                been installed, this trail provides a set of
                examples that show how to build transactional
                applications. Two types of transactional
                applications are presented, those using the JTA
                interface and those accessing to the JTS (OTS)
                interfaces.
            </p>
            <p>
                Please follow these steps before running the
                transactional applications
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    Ensure you have the Ant build system installed.
                    Ant is a Java build tool, similar to make. It is
                    available for free from http://ant.apache.org/
                    The sample application requires version 1.5.1 or
                    later.
                </li><li class="listitem">
                    The PATH and CLASSPATH environment variables
                    need to be set appropriately to use .
                    To make this easier, we
                    provide a shell script setup_env.sh (and for
                    Windows a batch file setup_env.bat) in the
                    directory

                    &lt;jbossts_install_root&gt;/bin/

                </li><li class="listitem">
                    From a command prompt, cd to the directory
                    containing the build.xml file
                    (&lt;jbossts_install_root&gt;/trail_map) and
                    type 'ant', unless already done in the
                    installation section
                    . This will compile a set of sources files
                    located under
                    &lt;jbossts_install_root&gt;/trail_map/src then
                    create an application .jar file named
                    <span class="emphasis"><em>jbossts-demo.jar</em></span>
                    . under the directory
                    &lt;jbossts_install_root&gt;/trail_map/lib
                </li><li class="listitem">
                    Add the generated jar file to the CLASSPATH
                    environment variable.
                </li><li class="listitem">
                    The demo application is provided in several
                    ways, accessing persistent data or not. When
                    JDBC is used as a mean to access a database,
                    Oracle 9i is used. For this aim the appropriate
                    Oracle libraries (classes12.zip) should be add
                    in the CLASSPATH environment variable.
                </li></ul></div>
            <div class="section" title="3.2.7.17.2.1. Local transaction with JTA"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5436"/>3.2.7.17.2.1. Local transaction with JTA</h6></div></div></div>
                
                To configure 
                for such transaction, edit the
                jbossts-properties.xml file and set the following
                properties to the appropriate values:

                <pre><code class="language-java">
		&lt;property
		name="com.arjuna.ats.jta.jtaTMImplementation"
		value="com.arjuna.ats.internal.jta.transaction.
		arjunacore.TransactionManagerImple"/&gt;
		&lt;property
		name="com.arjuna.ats.jta.jtaUTImplementation"
		value="com.arjuna.ats.internal.jta.transaction.
		arjunacore.UserTransactionImple"/&gt; </code></pre>
            </div>
            <div class="section" title="3.2.7.17.2.2. Distributed transaction with JTA"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5439"/>3.2.7.17.2.2. Distributed transaction with JTA</h6></div></div></div>
                
                While for a distributed transactions case, 
                need
                to be configured as follow:
                <pre><code class="language-java">
		&lt;property
		name="com.arjuna.ats.jta.jtaTMImplementation"
		value="com.arjuna.ats.internal.jta.transaction.
		jts.TransactionManagerImple"/&gt; &lt;property
		name="com.arjuna.ats.jta.jtaUTImplementation"
		value="com.arjuna.ats.internal.jta.transaction.
		jts.UserTransactionImple"/&gt; </code></pre>

                <p>
                    Using JTA to create a distributed transaction need
                    the creation of an ORB instance as done by a JTS
                    application (see JTS versions of the banking
                    application), the difference is in the interface
                    used to demarcate and control transactions.

                </p>
            </div>
            <div class="section" title="3.2.7.17.2.3.  The application programming interfaces used by the Banking Application"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5443"/>3.2.7.17.2.3. 
                    The application programming interfaces used by the
                    Banking Application
                </h6></div></div></div>
                
                <p>
                    To illustrate the programming interfaces
                    possibilities enabled by ,
                    the banking
                    application is provided in several versions: a
                    version that uses the JTA API and a second that uses
                    JTS/OTS interfaces.
                </p>
                <p>
                    This trail focuses to understanding concepts related
                    to the creation of transactions and the behavior of
                    the commitment protocol, while the next trail
                    illustrates the similar application with persistent
                    data.
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Testing the Banking application with JTA
                    </li><li class="listitem">
                        Testing the Banking application with JTS
                    </li></ul></div>
                <div class="section" title="3.2.7.17.2.3.1. Running The Banking application with JTA"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5450"/>3.2.7.17.2.3.1. Running The Banking application with JTA</h6></div></div></div>
                    
                    <div class="section" title="3.2.7.17.2.3.1.1. Configuring"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5452"/>3.2.7.17.2.3.1.1. Configuring 
                        </h6></div></div></div>
                        
                        <p>Program
                            Applications that create transactions using te JTA interface may invoke as well local
                            services as remote
                            services. When a remote invocation need to be performed, the current transactional context need to be propagated
                            to the remote service in order to involve it to the transaction in progress.
                            allows the
                            possibility to provide such feature using the facilities provided by JTS and ORB. More precisely 
                            need to be configured
                            to determine in which type of transaction, local or distributed, the JTA interface is used.
                        </p>
                    </div>
                    <div class="section" title="3.2.7.17.2.3.1.2. Executing the JTA sample"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5455"/>3.2.7.17.2.3.1.2. Executing the JTA sample</h6></div></div></div>
                        
                        The Banking sample using JTA creates local transactions, ensure that JTA is configured for local
                        transactions as explained above.
                        <p>To launch the JTA version of the Banking application,
                            which creates only local transactions, execute the following java program:
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">
java com.arjuna.demo.jta.localbank.BankClient
</code></pre>
                        </blockquote></div>
                        <p>Once one of the program given above is launched the following lines are displayed:</p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">
-------------------------------------------------
  Bank client
-------------------------------------------------
Select an option :
   0. Quit
   1. Create a new account.
   2. Get an account information.
   3. Make a transfer.
   4. Credit an account.
   5. Withdraw from an account

Your choice :
</code></pre>
                        </blockquote></div>
                        <p>After introducing your choice, the appropriate operation is performed by the
                            Bank object, to get the requested account, and by the account to execute the
                            credit or withdraw or to return the current balance. Let's consider the following
                            execution.
                        </p>
                        <p>Enter the number 1 as your choice, then give the name "Foo" as the
                            account name and "1000" as an initial value of the account to create.
                            You should get the following lines:
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">Your choice : 1
- Create a new account -
------------------------
Name : Foo
Initial balance : 1000
Beginning a User transaction to create account
XA_START[]
Attempt to commit the account creation transaction
XA_END[]
XA_COMMIT (ONE_PHASE)[]
</code></pre>
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                The line XA_START indicates that the AccountResource object that implements
                                the XAResource interface and enlisted to participate in the account creation
                                transaction, receives the indication from the Transaction Manager that the
                                transaction has started.
                            </li><li class="listitem">
                                The line XA_END indicates that the calling thread in which the AccountRessource
                                object is associated shall be ended to enable the transaction completion as
                                recommended by the X/Open specification.
                            </li><li class="listitem">
                                Since only one AccountResource then only one XAResource is involved in the
                                account creation transaction, the two phases needed to get a consensus in
                                the 2PC protocol are not mandatory. The one phase commit optimization, indicated
                                by the "XA_COMMIT (ONE_PHASE)", is applied.
                            </li></ul></div>
                        <p>In the same way create a second account with the name "Bar" and the
                            initial balance set to 500.
                        </p>
                        <p>As a choice now, enter "3" to make a transfer (300) from "Foo"
                            to "Bar".
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">Your choice : 3
- Make a transfer -
-------------------
Take money from : Foo
Put money to : Bar
Transfert amount : 300
Beginning a User transaction to get balance
XA_START[]
XA_START[]
XA_END[]
XA_PREPARE[]
XA_END[]
XA_PREPARE[]
XA_COMMIT[]
XA_COMMIT[]
</code></pre>
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                Now two AccountResource objects, then two XAResource objects are enlisted
                                with the transaction. The displayed lines show that the two phases, prepare
                                and commit, are applied.
                            </li></ul></div>
                        <p>Any attempt to manipulate an account that it doesn't exist leads to throw the
                            NotExistingAccount exception and to rollback the transaction in progress. For
                            instance, let's withdraw money from an account FooBar not previously created.
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">Your choice : 5
- Withdraw from an Account -
----------------------------
Give the Account name : FooBar
Amount to withdraw : 200
Beginning a User transaction to
withdraw from an account
The requested account does not exist!
ERROR - jakarta.transaction.RollbackException
</code></pre>
                        </blockquote></div>


                    </div>
                    <div class="section" title="3.2.7.17.2.3.1.3. Building The Banking Application with JTA"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5480"/>3.2.7.17.2.3.1.3. Building The Banking Application with JTA</h6></div></div></div>
                        
                        <p>From
                            an architectural point of view of JTA, the bank client is considered as
                            an application program able to manage transactions via the jakarta.transaction.UserTransaction interface. The
                            following portion of code illustrates how a JTA transaction is
                            started and terminated when the client asks to transfer money from one account to another. This also describes what are 
                            packages that need to be used
                            in order to obtain appropriate objects instances (such UserTransaction).
                        </p>
                        <p>Note: The code below is a simplified view of the BankClient.java program. Only the
                            transfer operation is illustrated; other operations manage transactions in the same way.
                            (see for details the src/com/arjuna/demo/jta/localbank/BankClient.java)
                        </p>
                        <pre><code class="language-java">
package com.arjuna.demo.jta.localbank;
public class BankClient
{
   private Bank _bank;
   // This operation is used to make a transfer
   //from an account to another account
   private void makeTransfer()
   {
     System.out.print("Take money from : ");
     String name_supplier = input();

     System.out.print("Put money to : ");
     String name_consumer = input();

     System.out.print("Transfer amount : ");
     String amount = input();

     float famount = 0;
     try
      {
        famount = new Float( amount ).floatValue();
      }
     catch ( java.lang.Exception ex )
      {
        System.out.println("Invalid float number, abort operation...");
        return;
      }

     try
      {
       //the following instruction asks a specific 
       //class to obtain a UserTransaction instance
       <span class="emphasis"><em>jakarta.transaction.UserTransaction userTran =
                     com.arjuna.ats.jta.UserTransaction.userTransaction()</em></span>;
       System.out.println("Beginning a User transaction to get balance");
       <span class="emphasis"><em>userTran.begin()</em></span>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( famount );
       consumer.credit( famount );

       <span class="emphasis"><em>userTran.commit( )</em></span>;
      }
     catch (Exception e)
      {
       System.err.println("ERROR - "+e);
      }
   }
   ......
}
</code></pre>
                        <p>The Bank object has mainly two operations: creating an account, which is added in the
                            account list,
                            and returning an Account object. No transactional instruction is performed by the Bank object
                        </p>
                        <pre><code class="language-java">
package com.arjuna.demo.jta.localbank;
public class Bank {
   private java.util.Hashtable _accounts;

   public Bank()
   {
     _accounts = new java.util.Hashtable();
   }

   public Account create_account( String name )
   {
     Account acc = new Account(name);
     _accounts.put( name, acc );
      return acc;
   }

   public Account get_account(String name)
   throws NotExistingAccount
   {
     Account acc = ( Account ) _accounts.get( name );
     if ( acc == null )
       throw new NotExistingAccount("The Account requested does not exist");
     return acc;
   }
}
</code></pre>
                        <p>The Account object provides mainly three methods balance,
                            credit and withdraw.
                            However, in order to provide the transactional behaviour, rather than to modify
                            the current account directly (according to credit or withdraw) this task is
                            delegated to an AccountResource object that is able, according to the transaction
                            outcome, to set the account value either to its initial state or its final state.
                        </p>
                        <p>The AccountResource object is in fact an object that implements the
                            javax.transaction.xa.XAResource,
                            then able to participate to the transaction commitment. For this aim, the Account
                            object has to register or enlist the AccountResource object as a participant
                            after having obtaining the reference of the jakarta.transaction.Transaction object
                            via the jakarta.transaction.TransactionManager object
                        </p>
                        <pre><code class="language-java">
package com.arjuna.demo.jta.localbank;

public class Account
{
   float _balance;
   AccountResource accRes = null;

   public Account(String name)
   {
     _name = name;
     _balance = 0;
   }

   public float balance()
   {
     return getXAResource().balance();;
   }

   public void credit( float value )
   {
     getXAResource().credit( value );
   }

   public void debit( float value )
   {
     getXAResource().debit( value );
   }

   public AccountResource getXAResource()
   {

     try
     {
       <span class="emphasis"><em>jakarta.transaction.TransactionManager transactionManager =
         com.arjuna.ats.jta.TransactionManager.transactionManager();
       jakarta.transaction.Transaction currentTrans =
          transactionManager.getTransaction();</em></span>

       if (accRes == null) {
         <span class="emphasis"><em>currentTrans.enlistResource(
            </em></span>accRes = new AccountResource(this, _name)<span class="emphasis"><em> );</em></span>
       }

       currentTrans.delistResource( accRes, XAResource.TMSUCCESS );

     }
     catch (Exception e)
     {
       System.err.println("ERROR - "+e);
     }
     return accRes;
   }
   ...
}
</code></pre>
                        <p>The AccountResource class that implements the javax.transaction.xa.XAResource
                            interface provides similar methods as the Account class (credit, withdraw and
                            balance) but also all methods specified by the javax.transaction.xa.XAResource.
                            The following portion of code describes how the methods prepare,
                            commit and rollback
                            are implemented.
                        </p>
                        <pre><code class="language-java">
public class AccountResource <span class="emphasis"><em>implements XAResource</em></span>
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   <span class="emphasis"><em>public void commit(Xid id, boolean onePhase) throws XAException</em></span>
   {
     //The value of the associated Account object is modified
     _account._balance = _current_balance;
   }

   <span class="emphasis"><em>public int prepare(Xid xid) throws XAException</em></span>
   {
     if ( _initial_balance == _current_balance ) //account not modified
        return (XA_RDONLY);
     if ( _current_balance &lt; 0 )
        throw new XAException(XAException.XA_RBINTEGRITY);
        //If the integrity of the account is corrupted then vote rollback
     return (XA_OK); //return OK
   }
   </code></pre>
                        <pre><code class="language-java"><span class="emphasis"><em>public void rollback(Xid xid) throws XAException</em></span>
   {
     //Nothing is done
   }
   </code></pre>
                        <pre><code class="language-java">   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 }</code></pre>
                    </div>
                    <div class="section" title="3.2.7.17.2.3.1.4. Sample Application Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5504"/>3.2.7.17.2.3.1.4. Sample Application Source Code</h6></div></div></div>
                        
                        <p>Full source code for the banking application with JTA is included to provide
                            you with a starting point for experimentation.
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                src/com/arjuna/demo/jta/localbank/BankClient.java
                            </li><li class="listitem">
                                src/com/arjuna/demo/jta/localbank/Bank.java"&gt;Bank.java
                            </li><li class="listitem">
                                src/com/arjuna/demo/jta/localbank/Account.java"&gt;Account.java
                            </li><li class="listitem">
                                src/com/arjuna/demo/jta/localbank/AccountResource.java
                            </li><li class="listitem">
                                src/com/arjuna/demo/jta/localbank/NotExistingAccount.java"&gt;NotExistingAccount.java
                            </li></ul></div>
                    </div>
                </div>
            </div>
            <div class="section" title="3.2.7.17.2.4. Running The Banking application with JTS"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5513"/>3.2.7.17.2.4. Running The Banking application with JTS</h6></div></div></div>
                
                <p>The
                    JTS version of the Banking application means that the Object Request Broker
                    will be used. The 
                    distribution is provided to work with the bundled JacORB version
                </p>
                <p>To
                    describe the possibilities provided by 
                    to build a transactional
                    application according to the programming models defined by the OTS specification,
                    the Banking Application is programmed in different ways.
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Local transactions: The Bank Client and the Bank server are collocated in
                        the same process.</li><li class="listitem">
                        Distributed Transactions: The Bank Client and the Bank Server and located
                        on different process. To participate within a client's transaction, Account
                        Objects needed to access the transactional context. We describe the two of
                        context propagation.
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                implicit context propagation, and
                            </li><li class="listitem">
                                explicit context propagation.
                            </li></ul></div>
                    </li></ul></div>
                <p>
                    JTS Local Transactions&gt; </p>
                <p>
                    JTS Distributed Transactions
                </p>
                <div class="section" title="3.2.7.17.2.4.1. Running The Banking application with JTS"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5525"/>3.2.7.17.2.4.1. Running The Banking application with JTS</h6></div></div></div>
                    
                    <p>The
                        JTS version of the Banking application means that the Object Request Broker
                        will be used. The 
                        distribution is provided to work with the bundled JacORB version
                    </p>
                    <p>
                        <span class="emphasis"><em>Note</em></span>
                        : Ensure that the jacorb jar files are added in your CLASSPATH
                    </p>
                    <p>To launch the JTS version of the Banking application,
                        execute the following java program
                    </p>
                    <div class="blockquote"><blockquote class="blockquote">
                        <pre><code class="language-java">java com.arjuna.demo.jts.localbank.BankClient</code></pre>
                    </blockquote></div>
                    <p>Once one of the program given above is launched the following lines are displayed:</p>
                    <div class="blockquote"><blockquote class="blockquote">
                        <pre><code class="language-java">
-------------------------------------------------
   Bank client
-------------------------------------------------
Select an option :
   0. Quit
   1. Create a new account.
   2. Get an account information.
   3. Make a transfer.
   4. Credit an account.
   5. Withdraw from an account

Your choice :
</code></pre>
                    </blockquote></div>
                    <p>After introducing your choice, the appropriate operation is performed by the
                        Bank object, to get the requested account, and by the account to execute the
                        credit or withdraw or to return the current balance. Let's consider the following
                        execution.
                    </p>
                    <p>Enter the number 1 as your choice, then give the name "Foo" as the
                        account name and "1000" as an initial value of the account to create.
                        You should get the following lines:
                    </p>
                    <div class="blockquote"><blockquote class="blockquote">
                        <pre><code class="language-java">
Your choice : 1
- Create a new account -
------------------------
Name : Foo
Initial balance : 1000
Beginning a User transaction to create account
[ Connected to 192.168.0.2:4799 from local port 4924 ]
Attempt to commit the account creation transaction
/[ Resource for Foo : Commit one phase ]
</code></pre>
                    </blockquote></div>
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Since only one AccountResource then only one CosTransaction.Resource is
                            involved in the account creation transaction, the two phases needed to get
                            a consensus in the 2PC protocol are not mandatory. The one phase commit optimisation,
                            indicated by the "Commit one phase", is applied.
                        </li></ul></div>
                    <p>In the same way create a second account with the name "Bar" and the
                        initial balance set to 500.
                    </p>
                    <p>As a choice now, enter "3" to make a transfer (300) from "Foo"
                        to "Bar".
                    </p>
                    <div class="blockquote"><blockquote class="blockquote">
                        <pre><code class="language-java">
Your choice : 3
- Make a transfer -
-------------------

Take money from : Foo
Put money to : Bar
Transfer amount : 300
Beginning a User transaction to Transfer money
[ Resource for Foo : Prepare ]
[ Resource for Bar : Prepare ]
[ Resource for Foo : Commit ]
[ Resource for Bar : Commit ]
</code></pre>
                    </blockquote></div>
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Now two AccountResource objects, then two CosTransactions.Resource objects
                            are enlisted with the transaction. The displayed lines show that the two phases,
                            prepare and commit, are applied.
                        </li></ul></div>
                    <p>Any attempt to manipulate an account that it doesn't exist leads to throw the
                        NotExistingAccount exception and to rollback the transaction in progress. For
                        instance, let's withdraw money from an account FooBar not previously created.
                    </p>
                    <div class="blockquote"><blockquote class="blockquote">
                        <pre><code class="language-java">
Your choice : 5
- Withdraw from an Account -
----------------------------
Give the Account name : FooBar
Amount to withdraw : 200
Beginning a User transaction to withdraw from an account
The requested account does not exist!
ERROR - org.omg.CORBA.TRANSACTION_ROLLEDBACK:
minor code: 50001  completed: No
</code></pre>
                    </blockquote></div>
                    <div class="section" title="3.2.7.17.2.4.1.1. Using a stand-alone Transaction Server"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5551"/>3.2.7.17.2.4.1.1. Using a stand-alone Transaction Server</h6></div></div></div>
                        
                        <p>By
                            default 
                            does not use a separate transaction manager server: transaction
                            managers are co-located with each application process to improve performance
                            and improve application fault-tolerance. When running applications which require
                            a separate transaction manager, you must set the com.arjuna.ats.jts.transactionManager
                            property variable, in the "(jbossts_install_dir)/etc/jbossts-properties.xml file, to YES.
                        </p>
                        <p>In a separate window, the stand-alone Transaction Server is launched as follow:</p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">java com.arjuna.ats.jts.TransactionServer [-test]</code></pre>
                        </blockquote></div>
                        <p>The option -test allows to see the message "Ready" when the Transaction Server is started.
                        </p>
                        <p>The Banking application presented above gives the same output.</p>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.2. Running The Banking application with JTS"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5559"/>3.2.7.17.2.4.1.2. Running The Banking application with JTS</h6></div></div></div>
                        
                        <p>The
                            JTS version of the Banking application means that the Object Request Broker
                            will be used. The 
                            distribution is provided to work with the bundled JacORB version
                        </p>
                        <p>
                            <span class="emphasis"><em>Note</em></span>
                            : Ensure that the jacorb jar files are added in your CLASSPATH
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                In a separate window launch the Recovery Manager, as follow.
                            </li></ul></div>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">java com.arjuna.ats.arjuna.recovery.RecoveryManager</code></pre>
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                <span class="emphasis"><em>
                                    Testing the distributed transaction with
                                    <span class="emphasis"><em>Implicit Propagation Context</em></span>
                                </em></span>
                            </li></ul></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                Start the Server
                            </li></ul></div>
                        <div class="blockquote"><blockquote class="blockquote">
                            java com.arjuna.demo.jts.remotebank.BankServer
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                In a separate window, start the client
                            </li></ul></div>
                        <div class="blockquote"><blockquote class="blockquote">
                            java com.arjuna.demo.jts.remotebank.BankClient
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                <span class="emphasis"><em>
                                    Testing the distributed transaction with
                                    <span class="emphasis"><em>Explicit Propagation Context</em></span>
                                </em></span>
                            </li></ul></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                Start the Server
                            </li></ul></div>
                        <div class="blockquote"><blockquote class="blockquote">
                            java com.arjuna.demo.jts.explicitremotebank.BankServer
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                In a separate window, start the client
                            </li></ul></div>
                        <div class="blockquote"><blockquote class="blockquote">
                            java com.arjuna.demo.jts.explicitremotebank.BankClient
                        </blockquote></div>
                        <p>In both cases (implicit and explicit), the Bank Server, which can be stopped by hand,
                            displays the following lines:</p>
                        <div class="blockquote"><blockquote class="blockquote">
                            The bank server is now ready...
                        </blockquote></div>
                        <p>In both cases (implicit and Explicit), the Bank Client window displays the following
                            lines:</p>
                        <div class="blockquote"><blockquote class="blockquote">

                            -------------------------------------------------
                            Bank client
                            -------------------------------------------------

                            Select an option :
                            0. Quit
                            1. Create a new account.
                            2. Get an account information.
                            3. Make a transfer.
                            4. Credit an account.
                            5. Withdraw from an account

                            Your choice :
                        </blockquote></div>
                        <p>After entering your choice, the appropriate operation is performed by the
                            remote Bank object, to get the requested account, and by the account to execute
                            the credit or withdraw or to return the current balance. Let's consider the following execution.
                        </p>
                        <p>Enter the number 1 as your choice, then give the name "Foo" as the
                            account name and "1000" as an initial value of the account to create.
                            You should get in the server window a result that terminates with the following line
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            [ Resource for Foo : Commit one phase ]
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                Since only one AccountResource then only one CosTransaction.Resource is
                                involved in the account creation transaction, the two phases needed to get
                                a consensus in the 2PC protocol are not mandatory. The one phase commit optimisation,
                                indicated by the "Commit one phase", is applied.
                            </li></ul></div>
                        <p>In the same way create a second account with the name "Bar" and the initial balance set to
                            500. </p>
                        <p>As a choice now, enter in the client window "3" to make a transfer
                            (300) from "Foo" to "Bar".
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">

                            Your choice : 3
                            - Make a transfer -
                            -------------------

                            Take money from : Foo
                            Put money to : Bar
                            Transfer amount : 300
                        </blockquote></div>
                        <p> In the Server window you should see a result with the following lines</p>
                        <div class="blockquote"><blockquote class="blockquote">

                            [ Resource for Foo : Prepare ]
                            [ Resource for Bar : Prepare ]
                            [ Resource for Foo : Commit ]
                            [ Resource for Bar : Commit ]
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                Now two AccountResource objects, then two CosTransactions.Resource objects are enlisted
                                with the transaction. The
                                displayed lines show that the two phases, prepare and commit, are applied.
                            </li></ul></div>
                        <p>Any attempt to manipulate an account that it doesn't exist leads to throw the
                            NotExistingAccount exception and to rollback
                            the transaction in progress. For instance, let's withdraw money from an account FooBar not previously created.
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">

                            Your choice : 5
                            - Withdraw from an Account -
                            ----------------------------
                            Amount to withdraw : 200
                            Beginning a User transaction to withdraw from an account
                            The requested account does not exist!
                            ERROR - org.omg.CORBA.TRANSACTION_ROLLEDBACK:
                            minor code: 50001 completed: No
                        </blockquote></div>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.3. Using a stand-alone Transaction Server"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5606"/>3.2.7.17.2.4.1.3. Using a stand-alone Transaction Server</h6></div></div></div>
                        
                        <p>By
                            default 
                            does not use a separate transaction manager server: transaction
                            managers are co-located with each application process to improve performance
                            and improve application fault-tolerance. When running applications which require
                            a separate transaction manager, you must set the com.arjuna.ats.jts.transactionManager
                            property variable, in the jbossts-properties.xml file, to YES.
                        </p>
                        <p>In a separate window, the stand-alone Transaction Server is launched as follow:</p>
                        <div class="blockquote"><blockquote class="blockquote">
                            java com.arjuna.ats.jts.TransactionServer [-test]
                        </blockquote></div>
                        <p>The option -test allows to see the message "Ready" when the Transaction Server is started.
                        </p>
                        <p>The Banking application presented above gives the same output.</p>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.4. Running the example on several machines"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5613"/>3.2.7.17.2.4.1.4. Running the example on several machines</h6></div></div></div>
                        
                        <p>
                            It is possible to run the 
                            Transaction Service and recovery manager processes on a different machine and have clients
                            access these
                            centralized services in a hub-and-spoke style architecture.
                        </p>
                        <p>
                            All that must be done is to provide the clients with enough information to contact the transaction service (such as
                            the ORB's NameService).
                            However, configuring the ORB is beyond the remit of this trailmap and so we shall opt for a simpler mechanism wherby the
                            transaction services
                            IOR is shared by access to a common file.
                        </p>
                        <p>
                            This trailmap stage assumes that the transaction service has been appropriately installed and configured (the
                            setenv.[bat|sh] script has been ran) onto two hosts (for the purpose of explanation we shall
                            refer to these hosts as host1 and host2).
                        </p>
                        <div class="itemizedlist"><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    Start the recovery manager in one command prompt terminal
                                </li></ul></div><div class="blockquote"><blockquote class="blockquote">
                                java com.arjuna.ats.arjuna.recovery.RecoveryManager [-test]
                            </blockquote></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    Start the transaction service in a second command prompt terminal
                                </li></ul></div><div class="blockquote"><blockquote class="blockquote">
                                java com.arjuna.ats.jts.TransactionServer [-test]
                            </blockquote></div><ul class="itemizedlist"><li class="listitem">
                                Start the transaction service and recovery manager on host1
                            </li></ul></div>
                        <div class="itemizedlist"><p>
                                Open a command prompt on host2 and copy the CosServices.cfg file
                                from the &lt;narayana-jts_install_root&gt;/etc directory on host1.</p><p>
                                For example, using the popular scp package, open a shell prompt and issue the following command:
                            </p><div class="blockquote"><blockquote class="blockquote">
                                scp
                                <span class="emphasis"><em>user</em></span>
                                @
                                <span class="emphasis"><em>host1</em></span>:&lt;ats_root&gt;/etc/CosServices.cfg
                                &lt;host2_ats_root&gt;/etc/
                            </blockquote></div><ul class="itemizedlist"><li class="listitem">
                                Share the transaction service IOR on host1 with host2
                            </li></ul></div>
                        <div class="itemizedlist"><p>
                                <span class="emphasis"><em>NOTE:</em></span>
                                <span class="emphasis"><em>See the section above entitled "Using a stand-alone Transaction Server" for
                                    more information on how to configure these application to use a remote transaction
                                    service.</em></span>
                            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    <span class="emphasis"><em>
                                        Testing the distributed transaction with
                                        <span class="emphasis"><em>Implicit Propagation Context</em></span>
                                    </em></span>
                                </li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    Start the Server
                                </li></ul></div><pre><code class="language-java">   java com.arjuna.demo.jts.remotebank.BankServer</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    In a separate window, start the client
                                </li></ul></div><pre><code class="language-java">   java com.arjuna.demo.jts.remotebank.BankClient</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    <span class="emphasis"><em>
                                        Testing the distributed transaction with
                                        <span class="emphasis"><em>Explicit Propagation Context</em></span>
                                    </em></span>
                                </li></ul></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    Start the Server
                                </li></ul></div><pre><code class="language-java">   java com.arjuna.demo.jts.explicitremotebank.BankServer</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                    In a separate window, start the client
                                </li></ul></div><pre><code class="language-java">   java com.arjuna.demo.jts.explicitremotebank.BankClient</code></pre><ul class="itemizedlist"><li class="listitem">
                                Start the Bank Server and Bank Client applications on host2
                            </li></ul></div>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.5. How the Banking Application is build using JTS interfaces"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5658"/>3.2.7.17.2.4.1.5. How the Banking Application is build using JTS interfaces</h6></div></div></div>
                        
                        <p>From an architectural point of view of JTS, the bank client is considered as
                            an application program able to manage transactions either in a direct or indirect
                            management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory
                            and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current
                            interface. Transactions created by the client in the Banking application are
                            done in the indirect mode.
                        </p>
                        <p>
                            The following portion of code illustrates how a JTS transaction is started
                            and terminated when the client asks to transfer money from one account to another.
                            This also describes what are 
                            packages that need to be used in order
                            to obtain appropriate objects instances (such Current).
                        </p>
                        <p>Note: The code below is a simplified view of the BankClient.java program. Only
                            the transfer operation is illustrated; other operations manage transactions
                            in the same way. (see for details the ../src/com/arjuna/demo/jts/localbank/BankClient.java)
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">package com.arjuna.demo.jta.localbank;
<span class="emphasis"><em>import com.arjuna.ats.jts.OTSManager;
import com.arjuna.ats.internal.jts.ORBManager;</em></span>
					</code></pre>
                            <pre><code class="language-java">public class BankClient
{
   private Bank _bank; //Initialised on BankClient initializations
   ....
   // This operation is used to make a transfer from an account to another account
   private void makeTransfer()
   {
     System.out.print("Take money from : ");
     String name_supplier = input();

     System.out.print("Put money to : ");
     String name_consumer = input();

     System.out.print("Transfert amount : ");
     String amount = input();

     float famount = 0;
     try
      {
        famount = new Float( amount ).floatValue();
      }
     catch ( java.lang.Exception ex )
      {
        System.out.println("Invalid float number, abort operation...");
        return;
      }

     try
      {
       //the following instruction asks a specific  class to obtain a Current instance
       <span class="emphasis"><em>Current current = OTSManager.get_current(); </em></span>
       System.out.println("Beginning a User transaction to get balance");
       <span class="emphasis"><em>current.begin()</em></span>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( famount );
       consumer.credit( famount );

       <span class="emphasis"><em>current.commit( )</em></span>;
      }
     catch (Exception e)
      {
       System.err.println("ERROR - "+e);
      }
   }</code></pre>
                            <p>Since JTS is used invocations against an ORB are needed, such ORB and Object
                                Adapter instantiation and initialisation. To ensure a better portability,
                                the ORB Portability API provides a set of
                                methods that can be used as described below.
                            </p>
                            <pre><code class="language-java">public static void main( String [] args )
{  
    try {
     myORB = ORB.getInstance("test");// Create an ORB instance
     myOA = OA.getRootOA(myORB); //Obtain the Root POA
     myORB.initORB(args, null); //Initialise the ORB
     myOA.initOA(); //Initialise the POA

     // The ORBManager is a class provided by  to facilitate the association
     // of the ORB/POA with the transaction service
     ORBManager.setORB(myORB);
     ORBManager.setPOA(myOA);
     ....
   }
   catch(Exception e)
   {
     e.printStackTrace(System.err);
   }
}
</code></pre>
                        </blockquote></div>
                        <p>The Bank object has mainly two operations: creating an account, which is added
                            in the account list, and returning an Account object. No transactional instruction
                            is performed by the Bank object
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">package com.arjuna.demo.jta.localbank;
public class Bank {
   private java.util.Hashtable _accounts;

   public Bank()
   {
     _accounts = new java.util.Hashtable();
   }

   public Account create_account( String name )
   {
     Account acc = new Account(name);
     _accounts.put( name, acc );
      return acc;
   }

   public Account get_account(String name)
   throws NotExistingAccount
   {
     Account acc = ( Account ) _accounts.get( name );
     if ( acc == null )
       throw new NotExistingAccount("The Account requested does not exist");
     return acc;
   }
}</code></pre>
                        </blockquote></div>
                        <p>The Account object provides mainly three methods balance,
                            credit and withdraw.
                            However, in order to provide the transactional behaviour, rather than to modify
                            the current account directly (according to credit or withdraw) this task is
                            delegated to an AccountResource object that is able, according to the transaction
                            outcome, to set the account value either to its initial state or its final state.
                        </p>
                        <p> The AccountResource object is in fact an object that implements the
                            org.omg.CosTransactions.Resource,
                            then able to participate to the transaction commitment. For this aim, the Account
                            object has to register the AccountResource object as a participant, after having
                            obtaining the reference of the org.omg.CosTransactions.Coordinator object ,
                            itself obtained via the org.omg.CosTransactions.Control object
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">package com.arjuna.demo.jta.localbank;


public class Account
{
   float _balance;
   AccountResource accRes = null;

   public Account(String name )
   {
     _name = name;
     _balance = 0;
   }

   public float balance()
   {
     return getResource().balance();;
   }

   public void credit( float value )
   {
     getResource().credit( value );
   }

   public void debit( float value )
   {
     getResource().debit( value );
   }


   public AccountResource getResource()
    {
    try {
    if (accRes == null) {
         accRes = new AccountResource(this, _name) ;
         <span class="emphasis"><em>Resource ref = org.omg.CosTransactions.ResourceHelper.narrow(ORBManager.getPOA().corbaReference(accRes));</em></span>
         // Note above the possibilities provided by the ORBManager to access the POA then to obtain
         // the CORBA reference of the created AccountResource object

         <span class="emphasis"><em>RecoveryCoordinator recoverycoordinator = OTSManager.get_current().get_control().
                                               get_coordinator().register_resource(ref);</em></span>
						
        }
      }
      catch (Exception e)
      {
        System.err.println("ERROR - "+e);
      }

      return accRes;
   }
   ...
}</code></pre>
                        </blockquote></div>
                        <p>To be considered as a org.omg.CosTransactions.Resource, the AccountResource
                            class shall extends the class org.omg.CosTransactions.ResourcePOA generated
                            by the CORBA IDL compiler. The AccountRessource provides similar methods as
                            the Account class (credit, withdraw and balance) with the appropriate methods
                            to participate to the 2PC protocol. The following portion of code describes
                            how the methods prepare, commit
                            and rollback are implemented.
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">public class AccountResource extends org.omg.CosTransactions.ResourcePOA
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   public org.omg.CosTransactions.Vote prepare()
	   throws org.omg.CosTransactions.HeuristicMixed, org.omg.CosTransactions.HeuristicHazard
    {
	  if ( _initial_balance == _current_balance )
       return org.omg.CosTransactions.Vote.VoteReadOnly;
     if ( _current_balance &lt; 0 )
       return org.omg.CosTransactions.Vote.VoteRollback;
     return org.omg.CosTransactions.Vote.VoteCommit;
    }

   public void rollback()
     throws org.omg.CosTransactions.HeuristicCommit, org.omg.CosTransactions.HeuristicMixed,
                            org.omg.CosTransactions.HeuristicHazard
   {
     //Nothing to do
   }

   public void commit()
     throws org.omg.CosTransactions.NotPrepared, org.omg.CosTransactions.HeuristicRollback,
                      org.omg.CosTransactions.HeuristicMixed, org.omg.CosTransactions.HeuristicHazard
   {
      _account._balance = _current_balance;
   }

   public void commit_one_phase()
     throws org.omg.CosTransactions.HeuristicHazard
   {
     _account._balance = _current_balance;
   }

   .....</code></pre>
                            <pre><code class="language-java">   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 </code></pre>
                        </blockquote></div>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.6. Sample Application Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5685"/>3.2.7.17.2.4.1.6. Sample Application Source Code</h6></div></div></div>
                        
                        <p>Full source code for the banking application is included to provide you with
                            a starting point for experimentation.
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                JTS Version
                                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                        src/com/arjuna/demo/jts/localbank/BankClient.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/localbank/Bank.java"&gt;Bank.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/localbank/Account.java"&gt;Account.java
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/localbank/AccountResource.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/localbank/NotExistingAccount.java"&gt;NotExistingAccount.java
                                    </li></ul></div>
                            </li></ul></div>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.7. How the Banking Application is build using JTS interfaces"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5696"/>3.2.7.17.2.4.1.7. How the Banking Application is build using JTS interfaces</h6></div></div></div>
                        
                        <p>The bank client is an application program able to manage transactions either in a direct
                            or indirect
                            management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory
                            and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current
                            interface. Transactions created by the client in the Banking application are
                            done in the indirect mode.
                        </p>
                        <p>Invoking a remote object within a CORBA environment means that the remote object
                            implements a CORBA interface defined in a CORBA idl file. The following Bank.idl
                            describes the interfaces then the possible kind of distributed CORBA objects
                            involved in the banking application. There is no any interface that inherits
                            the CosTransactions::TransactionalObject interface, which means that for any
                            remote invocations the transactional context is normally not propagated. However,
                            since the Account object may have to register Resource objects that participate
                            to transaction completion, a context is needed. In the following Bank.idl file
                            operations defined in the Account interface have explicitly in their signature
                            the CosTransactions::Control argument meaning that it passed explicitly by the
                            caller - in this case the Bank Client program.
                        </p>
                        <pre><code class="language-java">
module arjuna {
   module demo {
     module jts {
      module explicitremotebank {

        interface Account :
        {
          float balance(<span class="emphasis"><em>in CosTransactions::Control ctrl</em></span>);
          void credit( <span class="emphasis"><em>in CosTransactions::Control ctrl</em></span>, in float value );
          void debit( <span class="emphasis"><em>in CosTransactions::Control ctrl</em></span>, in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
   };
   </code></pre>
                        <p>The
                            following portion of code illustrates how a JTS transaction is started
                            and terminated when the client asks to transfer money from one account to another.
                            This also describes what are 
                            packages that need to be used in order
                            to obtain appropriate objects instances (such Current).
                        </p>
                        <p>Note: The code below is a simplified view of the BankClient.java program. Only
                            the transfer operation is illustrated; other operations manage transactions
                            in the same way. (see for details the src/com/arjuna/demo/jts/explicitremotebank/BankClient.java)
                        </p>
                        <pre><code class="language-java">package com.arjuna.demo.jta.remotebank;
<span class="emphasis"><em>import com.arjuna.ats.jts.OTSManager;</em></span>
public class BankClient
{
   private Bank _bank;
   ....
   // This operation is used to make a transfer
   //from an account to another account
   private void makeTransfer()
   {
     //get the name of the supplier(name_supplier) and
     // the consumer(name_consumer)
     // get the amount to transfer (famount)
     ...
     try
      {
       //the following instruction asks a specific
       // class to obtain a Current instance
       <span class="emphasis"><em>Current current = OTSManager.get_current(); </em></span>
       System.out.println("Beginning a User transaction to get balance");
       <span class="emphasis"><em>current.begin()</em></span>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( <span class="emphasis"><em>current.get_control()</em></span>, famount );
       <span class="emphasis"><em>//The Control is explicitly propagated</em></span>
       consumer.credit( <span class="emphasis"><em>current.get_control()</em></span>, famount );
       <span class="emphasis"><em>current.commit( )</em></span>;
      }
     catch (Exception e)
      {
       ...
      }
   }</code></pre>
                        <p>Since JTS is used invocations against an ORB are needed, such ORB and Object
                            Adapter instantiation and initialisation. To ensure a better portability,
                            the ORB Portability API provides a set of
                            methods that can be used as described below.
                        </p>
                        <pre><code class="language-java">public static void main( String [] args )
{
  ....
  <span class="emphasis"><em>myORB = ORB.getInstance("test");// Create an ORB instance
  myORB.initORB(args, null); //Initialise the ORB
  </em></span>
  org.omg.CORBA.Object obj = null;
  try
  {
     //Read the reference string from a file then convert to Object
     ....
      obj = myORB.orb().string_to_object(stringTarget);
  }
  catch ( java.io.IOException ex )
  {
     ...
  }
  Bank bank = BankHelper.narrow(obj);
   ....
}
</code></pre>
                        <p>The Bank object has mainly two operations: creating an account, which is added
                            in the account list, and returning an Account object. No transactional instruction
                            is performed by the Bank object. The following lines decribe the implementation
                            of the Bank CORBA object
                        </p>
                        <pre><code class="language-java">public class BankImpl extends BankPOA {
     public BankImpl(OA oa)
     {
       _accounts = new java.util.Hashtable();
       _oa = oa;
     }

     public Account create_account( String name )
     {
         AccountImpl acc = new AccountImpl(name);
         _accounts.put( name, acc );
          return com.arjuna.demo.jts.remotebank.AccountHelper.
               narrow(_oa.corbaReference(acc));
     }

     public Account get_account(String name)
          throws NotExistingAccount
     {
      AccountImpl acc = ( AccountImpl ) _accounts.get( name );
      if ( acc == null )
       throw new NotExistingAccount("The Account requested does not exist");
      return com.arjuna.demo.jts.remotebank.AccountHelper.
           narrow(_oa.corbaReference(acc));
     }
     private java.util.Hashtable _accounts;// Accounts created by the Bank
     private OA _oa;
}</code></pre>
                        <p>After having defined an implementation of the Bank object, we should now create
                            an instance and make it available for client requests. This is the role of the
                            Bank Server that has the responsibility to create the ORB and the Object Adapater
                            instances, then the Bank CORBA object that has its object reference stored in
                            a file well known by the bank client. The following lines describe how the Bank
                            server is implemented.
                        </p>
                        <pre><code class="language-java">public class BankServer
{
      public static void main( String [] args )
      {
       ORB myORB = null;
       RootOA myOA = null;
       try
       {
       <span class="emphasis"><em> myORB = ORB.getInstance("ServerSide");
        myOA = OA.getRootOA(myORB);
        myORB.initORB(args, null);
        myOA.initOA();</em></span>
        ....
        <span class="emphasis"><em>BankImpl bank = new BankImpl(myOA);</em></span>

        String reference = <span class="emphasis"><em>myORB.orb().
             object_to_string(myOA.corbaReference(bank))</em></span>;
        //Store the Object reference in the file
        ...

        System.out.println("The bank server is now ready...");
        <span class="emphasis"><em>myOA.run();</em></span>
      }
}</code></pre>
                        <p>The Account object provides mainly three methods balance,
                            credit and withdraw.
                            However, in order to provide the transactional behaviour, rather than to modify
                            the current account directly (according to credit or withdraw) this task is
                            delegated to an AccountResource object that is able, according to the transaction
                            outcome, to set the account value either to its initial state or its final state.
                        </p>
                        <p> The AccountResource object is in fact an object that implements the
                            org.omg.CosTransactions.Resource,
                            then able to participate to the transaction commitment. For this aim, the Account
                            object has to register the AccountResource object as a participant, after having
                            obtaining the reference of the org.omg.CosTransactions.Coordinator object ,
                            itself obtained via the org.omg.CosTransactions.Control object
                        </p>
                        <pre><code class="language-java">
package com.arjuna.demo.jta.remotebank;

import org.omg.CosTransactions.*;
import ....

public class AccountImpl extends AccountPOA
{
   float _balance;
   AccountResource accRes = null;

   public Account(String name )
   {
     _name = name;
     _balance = 0;
   }

   public float balance(Control ctrl)
   {
     return getResource(ctrl).balance();;
   }

   public void credit(Control ctrl, float value )
   {
     getResource(ctrl).credit( value );
   }

   public void debit(Control ctrl, float value )
   {
     getResource(ctrl).debit( value );
   }

   public AccountResource getResource(Control control)
   {
      try
      {
         if (accRes == null) {
            accRes = new AccountResource(this, _name) ;
           <span class="emphasis"><em>
           //The invocation on the ORB illustrates the fact that the same
           //ORB instance created by the Bank Server is returned.
           ref = org.omg.CosTransactions.ResourceHelper.
              narrow(OA.getRootOA(ORB.getInstance("ServerSide")).
              corbaReference(accRes));
           RecoveryCoordinator recoverycoordinator =
              control.get_coordinator().register_resource(ref);</em></span>
         }
      }
      catch (Exception e){...}
      return accRes;
       }
   ...
}</code></pre>
                        <p>To be considered as a org.omg.CosTransactions.Resource, the AccountResource
                            class shall extends the class org.omg.CosTransactions.ResourcePOA generated
                            by the CORBA IDL compiler. The AccountRessource provides similar methods as
                            the Account class (credit, withdraw and balance) with the appropriate methods
                            to participate to the 2PC protocol. The following portion of code describes
                            how the methods prepare, commit
                            and rollback are implemented.
                        </p>
                        <pre><code class="language-java">public class AccountResource <span class="emphasis"><em>extends org.omg.CosTransactions.ResourcePOA</em></span>
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   <span class="emphasis"><em>public org.omg.CosTransactions.Vote prepare()</em></span>
	   throws org.omg.CosTransactions.HeuristicMixed,
	   org.omg.CosTransactions.HeuristicHazard
  {
    if ( _initial_balance == _current_balance )
       return org.omg.CosTransactions.Vote.VoteReadOnly;
    if ( _current_balance &lt; 0 )
       return org.omg.CosTransactions.Vote.VoteRollback;
    return org.omg.CosTransactions.Vote.VoteCommit;
  }

   <span class="emphasis"><em>public void rollback()</em></span>
     throws org.omg.CosTransactions.HeuristicCommit,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
     //Nothing to do
   }

   <span class="emphasis"><em>public void commit()</em></span>
     throws org.omg.CosTransactions.NotPrepared,
     org.omg.CosTransactions.HeuristicRollback,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
      _account._balance = _current_balance;
   }

   public void commit_one_phase()
     throws org.omg.CosTransactions.HeuristicHazard
   {
     _account._balance = _current_balance;
   }

   .....</code></pre>
                        <pre><code class="language-java">   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 </code></pre>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.8. Sample Application Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5736"/>3.2.7.17.2.4.1.8. Sample Application Source Code</h6></div></div></div>
                        
                        <p>Full source code for the banking application is included to provide you with
                            a starting point for experimentation.
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                JTS Version
                                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                        src/com/arjuna/demo/jts/explicitremotebank/Bank.idl
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/explicitremotebank/BankClient.java
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/explicitremotebank/BankServer.java
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/explicitremotebank/BankImpl.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/explicitremotebank/AccountImpl.java"&gt;AccountImpl.java
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/explicitremotebank/AccountResource.java
                                    </li></ul></div>
                            </li></ul></div>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.9. How the Banking Application is build using JTS interfaces"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5748"/>3.2.7.17.2.4.1.9. How the Banking Application is build using JTS interfaces</h6></div></div></div>
                        
                        <p>The bank client is an application program able to manage transactions either
                            in a direct or indirect management mode, respectively with the interfaces
                            org.omg.CosTransactions.TransactionFactory
                            and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current
                            interface. Transactions created by the client in the Banking application are
                            done in the indirect mode.
                        </p>
                        <p>Invoking a remote object within a CORBA environment means that the remote object
                            implements a CORBA interface defined in a CORBA idl file. The following Bank.idl
                            describes the interfaces then the possible kind of distributed CORBA objects
                            involved in the banking application. Only the Account interface inherits the
                            CosTransactions::TransactionalObject interface, this means that an Account CORBA
                            object is expected to invoked within a scope of transaction and the transactional
                            context is implicitly propagated.
                        </p>
                        <pre><code class="language-java">
module arjuna {
   module demo {
     module jts {
      module remotebank {

        interface Account : <span class="emphasis"><em>CosTransactions::TransactionalObject</em></span>
        {
          float balance();
          void credit( in float value );
          void debit( in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
   };</code></pre>
                        <p>The
                            following portion of code illustrates how a JTS transaction is started
                            and terminated when the client asks to transfer money from one account to another.
                            This also describes what are 
                            packages that need to be used in order
                            to obtain appropriate standard JTS API objects instances (such Current).
                        </p>
                        <p>Note: The code below is a simplified view of the BankClient.java program. Only
                            the transfer operation is illustrated; other operations manage transactions
                            in the same way. (see for details the src/com/arjuna/demo/jts/localbank/BankClient.java)
                        </p>
                        <pre><code class="language-java">
package com.arjuna.demo.jta.remotebank;
<span class="emphasis"><em>import com.arjuna.ats.jts.OTSManager;
</em></span>
public class BankClient
{
   private Bank _bank;
   ....
   // This operation is used to make a transfer
   // from an account to another account
   private void makeTransfer()
   {
     //get the name of the supplier(name_supplier)
     // and the consumer(name_consumer)
     // get the amount to transfer (famount)
     ...

     try
      {
       //the following instruction asks a
       // specific  class
       // to obtain a Current instance
       <span class="emphasis"><em>Current current = OTSManager.get_current(); </em></span>
       System.out.println("Beginning a User
              transaction to get balance");
       <span class="emphasis"><em>current.begin()</em></span>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( famount );
       consumer.credit( famount );

       <span class="emphasis"><em>current.commit( )</em></span>;
      }
     catch (Exception e)
      {
       ...
      }
   }</code></pre>
                        <p>Since JTS is used invocations against an ORB are needed, such ORB and Object
                            Adapter instantiation and initialisation. To ensure a better portability,
                            the ORB Portability API provides a set of
                            methods that can be used as described below.
                        </p>
                        <pre><code class="language-java">public static void main( String [] args )
{  ....
<span class="emphasis"><em>  myORB = ORB.getInstance("test");
     myORB.initORB(args, null); //Initialise the ORB

     </em></span>org.omg.CORBA.Object obj = null;
     try
      {
        //Read the reference string from
        // a file then convert to Object
        ....
        obj = myORB.orb().string_to_object(stringTarget);
      }
     catch ( java.io.IOException ex )
     {
       ...
     }
     Bank bank = BankHelper.narrow(obj);
    ....
}
</code></pre>
                        <p>The Bank object has mainly two operations: creating an account, which is added
                            in the account list, and returning an Account object. No transactional instruction
                            is performed by the Bank object. The following lines decribe the implementation
                            of the Bank CORBA object
                        </p>
                        <pre><code class="language-java">public class BankImpl extends BankPOA {
     public BankImpl(OA oa)
     {
       _accounts = new java.util.Hashtable();
       _oa = oa;
     }

     public Account create_account( String name )
     {
         AccountImpl acc = new AccountImpl(name);
         _accounts.put( name, acc );
          return com.arjuna.demo.jts.remotebank.AccountHelper.
               narrow(_oa.corbaReference(acc));
     }

     public Account get_account(String name)
          throws NotExistingAccount
     {
        AccountImpl acc = ( AccountImpl ) _accounts.get( name );
        if ( acc == null )
          throw new NotExistingAccount("The Account requested
                      does not exist");
        return com.arjuna.demo.jts.remotebank.AccountHelper.
             narrow(_oa.corbaReference(acc));
     }
     private java.util.Hashtable _accounts;
        // Accounts created by the Bank
     private OA _oa;
}</code></pre>
                        <p>After having defined an implementation of the Bank object, we should now create
                            an instance and make it available for client requests. This is the role of the
                            Bank Server that has the responsibility to create the ORB and the Object Adapater
                            instances, then the Bank CORBA object that has its object reference stored in
                            a file well known by the bank client. The following lines describe how the Bank
                            server is implemented.
                        </p>
                        <pre><code class="language-java">public class BankServer
{
      public static void main( String [] args )
      {
       ORB myORB = null;
       RootOA myOA = null;
       try
       {
       <span class="emphasis"><em> myORB = ORB.getInstance("ServerSide");
        myOA = OA.getRootOA(myORB);
        myORB.initORB(args, null);
        myOA.initOA();</em></span>
        ....
        <span class="emphasis"><em>BankImpl bank = new BankImpl(myOA);</em></span>

        String reference = <span class="emphasis"><em>myORB.orb().
               object_to_string(myOA.corbaReference(bank))</em></span>;
        //Store the Object reference in the file
        ...
        System.out.println("The bank server is now ready...");
        <span class="emphasis"><em>myOA.run();</em></span>
      }
}</code></pre>
                        <p>The Account object provides mainly three methods balance,
                            credit and withdraw.
                            However, in order to provide the transactional behaviour, rather than to modify
                            the current account directly (according to credit or withdraw) this task is
                            delegated to an AccountResource object that is able, according to the transaction
                            outcome, to set the account value either to its initial state or its final state.
                        </p>
                        <p> The AccountResource object is in fact an object that implements the
                            org.omg.CosTransactions.Resource,
                            then able to participate to the transaction commitment. For this aim, the Account
                            object has to register the AccountResource object as a participant, after having
                            obtaining the reference of the org.omg.CosTransactions.Coordinator object ,
                            itself obtained via the org.omg.CosTransactions.Control object
                        </p>
                        <pre><code class="language-java">package com.arjuna.demo.jta.remotebank;
import ....

public class AccountImpl extends AccountPOA
{
   float _balance;
   AccountResource accRes = null;

   public Account(String name )
   {
     _name = name;
     _balance = 0;
   }

   public float balance()
   {
     return getResource().balance();;
   }

   public void credit( float value )
   {
     getResource().credit( value );
   }

   public void debit( float value )
   {
     getResource().debit( value );
   }


   public AccountResource getResource()
   {
     try
     {
      if (accRes == null) {
        accRes = new AccountResource(this, _name) ;
        <span class="emphasis"><em>//The invocation on the ORB illustrates the
        // fact that the same ORB instance created
        // by the Bank Server is returned.
        ref = org.omg.CosTransactions.ResourceHelper.
	     narrow(OA.getRootOA(ORB.getInstance("ServerSide")).
	     corbaReference(accRes));
        RecoveryCoordinator recoverycoordinator = OTSManager.get_current().
	     get_control().get_coordinator().register_resource(ref);
       </em></span>
      }
    }
    catch (Exception e)
    {....}
      return accRes;
   }
   ...
}</code></pre>
                        <p>To be considered as a org.omg.CosTransactions.Resource, the AccountResource
                            class shall extends the class org.omg.CosTransactions.ResourcePOA generated
                            by the CORBA IDL compiler. The AccountResource provides similar methods as
                            the Account class (credit, withdraw and balance) with the appropriate methods
                            to participate to the 2PC protocol. The following portion of code describes
                            how the methods prepare, commit
                            and rollback are implemented.
                        </p>
                        <pre><code class="language-java">
public class AccountResource <span class="emphasis"><em>
      extends org.omg.CosTransactions.ResourcePOA</em></span>
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   <span class="emphasis"><em>public org.omg.CosTransactions.Vote prepare()</em></span>
	   throws org.omg.CosTransactions.HeuristicMixed,
	   org.omg.CosTransactions.HeuristicHazard
	   {
	   	  if ( _initial_balance == _current_balance )
	          return org.omg.CosTransactions.Vote.VoteReadOnly;
	        if ( _current_balance &lt; 0 )
                  return org.omg.CosTransactions.Vote.VoteRollback;
              return org.omg.CosTransactions.Vote.VoteCommit;
          }

   <span class="emphasis"><em>public void rollback()</em></span>
     throws org.omg.CosTransactions.HeuristicCommit,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
     //Nothing to do
   }

   <span class="emphasis"><em>public void commit()</em></span>
     throws org.omg.CosTransactions.NotPrepared,
     org.omg.CosTransactions.HeuristicRollback,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
      _account._balance = _current_balance;
   }

   public void commit_one_phase()
     throws org.omg.CosTransactions.HeuristicHazard
   {
     _account._balance = _current_balance;
   }

   ....
   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 </code></pre>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.10. Sample Application Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5782"/>3.2.7.17.2.4.1.10. Sample Application Source Code</h6></div></div></div>
                        
                        <p>Full source code for the banking application is included to provide you with
                            a starting point for experimentation.
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                JTS Version
                                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">src/com/arjuna/demo/jts/remotebank/Bank.idl"&gt;Bank.idl
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/remotebank/BankClient.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/remotebank/BankServer.java"&gt;BankServer.java
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/remotebank/BankImpl.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/remotebank/AccountImpl.java"&gt;AccountImpl.java
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/remotebank/AccountResource.java
                                    </li></ul></div>
                            </li></ul></div>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.11. How the Banking Application is build using JTS interfaces"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5794"/>3.2.7.17.2.4.1.11. How the Banking Application is build using JTS interfaces</h6></div></div></div>
                        
                        <p>From an architectural point of view of JTS, the bank client is considered as
                            an application program able to manage transactions either in a direct or indirect
                            management mode, respectively with the interfaces org.omg.CosTransactions.TransactionFactory
                            and org.omg.CosTransactions.Terminator or with the org.omg.CosTransactions.Current
                            interface. Transactions created by the client in the Banking application are
                            done in the indirect mode.
                        </p>
                        <p>
                            The following portion of code illustrates how a JTS transaction is started
                            and terminated when the client asks to transfer money from one account to another.
                            This also describes what are 
                            packages that need to be used in order
                            to obtain appropriate objects instances (such Current).
                        </p>
                        <p>Note: The code below is a simplified view of the BankClient.java program. Only
                            the transfer operation is illustrated; other operations manage transactions
                            in the same way. (see for details the src/com/arjuna/demo/jts/localbank/BankClient.java)
                        </p>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">
package com.arjuna.demo.jta.localbank;
<span class="emphasis"><em>import com.arjuna.ats.jts.OTSManager;</em></span>

public class BankClient
{
   private Bank _bank;
    ....
   // This operation is used to make
   //a transfer from an account to another account
   private void makeTransfer()
   {
     System.out.print("Take money from : ");
     String name_supplier = input();

     System.out.print("Put money to : ");
     String name_consumer = input();

     System.out.print("Transfert amount : ");
     String amount = input();

     float famount = 0;
     try
      {
        famount = new Float( amount ).floatValue();
      }
     catch ( java.lang.Exception ex )
      {
        System.out.println("Invalid float number,
                     abort operation...");
        return;
      }

     try
      {
       //the following instruction asks a specific
       //  class to obtain a Current instance
       <span class="emphasis"><em>Current current = OTSManager.get_current(); </em></span>
       System.out.println("Beginning a User
                     transaction to get balance");
       <span class="emphasis"><em>current.begin()</em></span>;

       Account supplier = _bank.get_account( name_supplier );
       Account consumer = _bank.get_account( name_consumer );
       supplier.debit( famount );
       consumer.credit( famount );

       <span class="emphasis"><em>current.commit( )</em></span>;
      }
     catch (Exception e)
      {
       System.err.println("ERROR - "+e);
      }
   }
   </code></pre>
                            <p>Since JTS is used invocations against an ORB are needed, such ORB and Object
                                Adapter instantiation and initialisation. To ensure a better portability,
                                the ORB Portability API provides a set of
                                methods that can be used as described below.
                            </p>
                            <pre><code class="language-java">
public static void main( String [] args )
{
  try
   { <span class="emphasis"><em>
    // Create an ORB instance
    myORB = ORB.getInstance("test");
    //Obtain the Root POA
    myOA = OA.getRootOA(myORB);
    //Initialise the ORB
    myORB.initORB(args, null);
    //Initialise the POA
    myOA.initOA();
     ....
     </em></span>
   }
   catch(Exception e)
   { ....}
}
</code></pre>
                        </blockquote></div>
                        <p>The Bank object has mainly two operations: creating an account, which is added
                            in the account list, and returning an Account object. No transactional instruction
                            is performed by the Bank object
                        </p>
                        <pre><code class="language-java">package com.arjuna.demo.jta.localbank;
public class Bank {
   private java.util.Hashtable _accounts;

   public Bank()
   {
     _accounts = new java.util.Hashtable();
   }

   public Account create_account( String name )
   {
     Account acc = new Account(name);
     _accounts.put( name, acc );
      return acc;
   }

   public Account get_account(String name)
   throws NotExistingAccount
   {
     Account acc = ( Account ) _accounts.get( name );
     if ( acc == null )
       throw new NotExistingAccount("The Account
                      requested does not exist");
     return acc;
   }
}
</code></pre>
                        <p>The Account object provides mainly three methods balance,
                            credit and withdraw.
                            However, in order to provide the transactional behaviour, rather than to modify
                            the current account directly (according to credit or withdraw) this task is
                            delegated to an AccountResource object that is able, according to the transaction
                            outcome, to set the account value either to its initial state or its final state.
                        </p>
                        <p> The AccountResource object is in fact an object that implements the
                            org.omg.CosTransactions.Resource,
                            then able to participate to the transaction commitment. For this aim, the Account
                            object has to register the AccountResource object as a participant, after having
                            obtaining the reference of the org.omg.CosTransactions.Coordinator object ,
                            itself obtained via the org.omg.CosTransactions.Control object
                        </p>
                        <pre><code class="language-java">
package com.arjuna.demo.jta.localbank;

public class Account
{
 float _balance;
 AccountResource accRes = null;

 public Account(String name )
 {
   _name = name;
   _balance = 0;
 }

 public float balance()
 {
   return getResource().balance();;
 }

 public void credit( float value )
 {
   getResource().credit( value );
 }

 public void debit( float value )
 {
   getResource().debit( value );
 }

 public AccountResource getResource()
 {
   try
   {
    if (accRes == null) {
     accRes = new AccountResource(this, _name) ;
     <span class="emphasis"><em>Resource  ref = org.omg.CosTransactions.ResourceHelper.
      narrow(OA.getRootOA(ORB.getInstance("test")).corbaReference(accRes));</em></span>
     <span class="emphasis"><em>RecoveryCoordinator recoverycoordinator = OTSManager.get_current().
      get_control().get_coordinator().register_resource(ref);</em></span>
    }
  }
  catch (Exception e)
   {...}
   return accRes;
 }
  ...
}</code></pre>
                        <p>To be considered as a org.omg.CosTransactions.Resource, the AccountResource
                            class shall extends the class org.omg.CosTransactions.ResourcePOA generated
                            by the CORBA IDL compiler. The AccountRessource provides similar methods as
                            the Account class (credit, withdraw and balance) with the appropriate methods
                            to participate to the 2PC protocol. The following portion of code describes
                            how the methods prepare, commit
                            and rollback are implemented.
                        </p>
                        <pre><code class="language-java">
public class AccountResource extends org.omg.CosTransactions.ResourcePOA
{
   public AccountResource(Account account, String name )
   {
     _name = name;
     _account = account;
     _initial_balance = account._balance;
     _current_balance = _initial_balance;
   }

   public float balance()
   {
     return _current_balance;
   }

   public void credit( float value )
   {
     _current_balance += value;
   }

   public void debit( float value )
   {
     _current_balance -= value;
   }

   public org.omg.CosTransactions.Vote prepare()
	   throws org.omg.CosTransactions.HeuristicMixed,
	   org.omg.CosTransactions.HeuristicHazard
    {
	  if ( _initial_balance == _current_balance )
       return org.omg.CosTransactions.Vote.VoteReadOnly;
     if ( _current_balance &lt; 0 )
       return org.omg.CosTransactions.Vote.VoteRollback;
     return org.omg.CosTransactions.Vote.VoteCommit;
    }

   public void rollback()
     throws org.omg.CosTransactions.HeuristicCommit,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
     //Nothing to do
   }

   public void commit()
     throws org.omg.CosTransactions.NotPrepared,
     org.omg.CosTransactions.HeuristicRollback,
     org.omg.CosTransactions.HeuristicMixed,
     org.omg.CosTransactions.HeuristicHazard
   {
      _account._balance = _current_balance;
   }

   public void commit_one_phase()
     throws org.omg.CosTransactions.HeuristicHazard
   {
     _account._balance = _current_balance;
   }
   .....
   private float _initial_balance;
   private float _current_balance;
   private Account _account;

   }
 </code></pre>
                    </div>
                    <div class="section" title="3.2.7.17.2.4.1.12. Sample Application Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5817"/>3.2.7.17.2.4.1.12. Sample Application Source Code</h6></div></div></div>
                        
                        <p>Full source code for the banking application is included to provide you with
                            a starting point for experimentation.
                        </p>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                JTS Version
                                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                        src/com/arjuna/demo/jts/localbank/BankClient.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/localbank/Bank.java"&gt;Bank.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/localbank/Account.java"&gt;Account.java
                                    </li><li class="listitem">
                                        src/com/arjuna/demo/jts/localbank/AccountResource.java
                                    </li><li class="listitem">src/com/arjuna/demo/jts/localbank/NotExistingAccount.java"&gt;NotExistingAccount.java
                                    </li></ul></div>
                            </li></ul></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="section" title="3.2.7.18. Making the Banking Application Persistent"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5828"/>3.2.7.18. Making the Banking Application Persistent</h4></div></div></div>
        
        <p>
            The way the banking application is built and
            deployed in the previous trail does not it make it
            persistent, in such way that any created account can
            be retrieved later after stopping the bank server or
            if the application crashes; moreover, it does not
            allow concurrent access to accounts without leading
            to inconsistent values.
        </p>
        <p>
            Two ways will be presented in this trail on the way
            to build the banking application as a persistent and
            sharable application:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                Using the 
                Object For Java
                (TXOJ) mechanisms
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Overview of the Transactional Object
                        For Java
                    </li><li class="listitem">
                        Deploying the Banking application
                        with TXOJ mechanisms
                    </li></ul></div>
            </li><li class="listitem">
                Using the JDBC API by considering the banking
                application as a relational database.
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Developing applications with JDBC
                        and 
                    </li><li class="listitem">
                        The banking application as a
                        relational database accessed with
                        JDBC
                    </li></ul></div>
            </li></ul></div>
    </div>
    <div class="section" title="3.2.7.19. What is Transactional Object For Java"><div class="titlepage"><div><div><h4 class="title"><a id="d5e5841"/>3.2.7.19. What is Transactional Object For Java</h4></div></div></div>
        
        <p>ArjunaCore exploits object-oriented techniques to present programmers with
            a toolkit of Java classes from which application classes can inherit to obtain
            desired properties, such as persistence and concurrency control. These classes
            form a hierarchy, part of which is shown below.
        </p>
        <p>
            <img src="images/jts-ArjunaCore_Classes.PNG.png"/>
        </p>
        <p>Figure 1 - ArjunaCore class hierarchy.</p>
        <p>Apart from specifying the scopes of transactions, and setting appropriate locks
            within objects, the application programmer does not have any other responsibilities:
            ArjunaCore and Transactional Objects for Java (TXOJ) guarantee that transactional
            objects will be registered with, and be driven by, the appropriate transactions,
            and crash recovery mechanisms are invoked automatically in the event of failures.
        </p>
        <div class="section" title="3.2.7.19.1. Recovery and Persistency"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5848"/>3.2.7.19.1. Recovery and Persistency</h5></div></div></div>
            
            <p>Making an object persistent and recoverable means that we shall be able to
                store its final state or to retrieve its initial state according to the final
                status of a transaction even in the presence of failures. ArjunaCore provides
                a set of techniques to save to and to retrieve from the Object Store states
                of objects. All objects made persistent with these ArjunaCore mechanisms are
                assigned unique identifiers (instances of the Uid class), when they are created,
                and this is to identify them within the object store. Due to common functionality
                for persistency and recovery required by several applications, objects are stored
                and retrieved from the object store using the same mechanism: the classes OutputObjectState
                and InputObjecState.
            </p>
            <p>At the root of the class hierarchy, given in Figure 1, is the class StateManager.
                This class is responsible for object activation and deactivation and object
                recovery. The simplified signature of the class is:
            </p>
            <div class="blockquote"><blockquote class="blockquote">
                <pre><code class="language-java">public abstract class StateManager
{
   public boolean activate ();
   public boolean deactivate (boolean commit);
   public Uid get_uid (); // object’s identifier.

   // methods to be provided by a derived class
   public boolean restore_state (InputObjectState os);
   public boolean save_state (OutputObjectState os);

   protected StateManager ();
   protected StateManager (Uid id);
};</code></pre>
            </blockquote></div>
            <p> Objects are assumed to be of three possible flavours. They may simply be recoverable,
                in which case StateManager will attempt to generate and maintain appropriate
                recovery information for the object. Such objects have lifetimes that do not
                exceed the application program that creates them. Objects may be recoverable
                and persistent, in which case the lifetime of the object is assumed to be greater
                than that of the creating or accessing application, so that in addition to maintaining
                recovery information StateManager will attempt to automatically load (unload)
                any existing persistent state for the object by calling the activate (deactivate)
                operation at appropriate times. Finally, objects may possess none of these capabilities,
                in which case no recovery information is ever kept nor is object activation/deactivation
                ever automatically attempted.
            </p>
            <p>According to the its activation or deactivation a transactional object for
                Java move from a passive state to an active state and vice-versa. The fundamental
                life cycle of a persistent object in TXOJ is shown in Figure 2.
            </p>
            <p>
                <img src="images/jts-txoj_lifecycle.PNG.png"/>
            </p>
            <p>Figure 2 - The life cycle of a persistent object.</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    The object is initially passive, and is stored in the object store as an
                    instance of the class OutputObjectState.
                </li><li class="listitem">
                    When required by an application the object is automatically activated by
                    reading it from the store using a read_committed operation and is then converted
                    from an InputObjectState instance into a fully-fledged object by the restore_state
                    operation of the object.
                </li><li class="listitem">
                    When the application has finished with the object it is deactivated by
                    converting it back into an OutputObjectState instance using the save_state
                    operation, and is then stored back into the object store as a shadow copy
                    using write_uncommitted. This shadow copy can be committed, overwriting the
                    previous version, using the commit_state operation. The existence of shadow
                    copies is normally hidden from the programmer by the transaction system. Object
                    de-activation normally only occurs when the top-level transaction within which
                    the object was activated commits.
                </li></ul></div>
            <p>While deactivating and activating a transactional object for java, the operations
                save_state and restore_state are respectively invoked. These operations must
                be implemented by the programmer since StateManager cannot detect user level
                state changes. This gives the programmer the ability to decide which parts of
                an object’s state should be made persistent. For example, for a spreadsheet
                it may not be necessary to save all entries if some values can simply be recomputed.
                The save_state implementation for a class Example that has two integer member
                variables called A and B and one String member variable called C could simply
                be:
            </p>
            <pre><code class="language-java">public boolean save_state(OutputObjectState o)
{
   if (!super.save_state(o))
      return false;
   try
   {
     o.packInt(A);
     o.packInt(B);
     o.packString(C));
   }
   catch (Exception e)
   {
     return false;
   }
   return true;
}</code></pre>
            <p>while, the corresponding restore_state implementation allowing to retrieve
                similar values is:
            </p>
            <pre><code class="language-java">public boolean restore_state(InputObjectState o)
{
   if (!super.restore_state(o))
      return false;
   try
   {
     A = o.unpackInt();
     B = o.unpackInt();
     S = o.unpackString());
   }
   catch (Exception e)
   {
     return false;
   }
   return true;
}
</code></pre>
            <p>Classes OutputObjectState and InputObjectState provide respectively operations
                to pack and unpack instances of standard Java data types. In other words for
                a standard Java data type, for instance Long or Short, there are corresponding
                methods to pack and unpack, i.e., packLong or packShort and unpackLong or unpackShort.
            </p>
            <p>
                <span class="emphasis"><em>Note:</em></span>
                it is necessary for all save_state and restore_state
                methods to call super.save_state and super.restore_state. This is to cater for
                improvements in the crash recovery mechanisms.
            </p>
        </div>
        <div class="section" title="3.2.7.19.2. The concurrency controller"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5870"/>3.2.7.19.2. The concurrency controller</h5></div></div></div>
            
            <p> The concurrency controller is implemented by the class LockManager which provides
                sensible default behaviour while allowing the programmer to override it if deemed
                necessary by the particular semantics of the class being programmed. The primary
                programmer interface to the concurrency controller is via the setlock operation.
                By default, the runtime system enforces strict two-phase locking following a
                multiple reader, single writer policy on a per object basis. However, as shown
                in Figure 1, by inheriting from the Lock class it is possible for programmers
                to provide their own lock implementations with different lock conflict rules
                to enable type specific concurrency control.
            </p>
            <p> Lock acquisition is (of necessity) under programmer control, since just as
                StateManager cannot determine if an operation modifies an object, LockManager
                cannot determine if an operation requires a read or write lock. Lock release,
                however, is under control of the system and requires no further intervention
                by the programmer. This ensures that the two-phase property can be correctly
                maintained.
            </p>
            <pre><code class="language-java">public abstract class LockManager extends StateManager
{
   public LockResult setlock (Lock toSet, int retry, int timeout);
};</code></pre>
            <p> The LockManager class is primarily responsible for managing requests to set
                a lock on an object or to release a lock as appropriate. However, since it is
                derived from StateManager, it can also control when some of the inherited facilities
                are invoked. For example, LockManager assumes that the setting of a write lock
                implies that the invoking operation must be about to modify the object. This
                may in turn cause recovery information to be saved if the object is recoverable.
                In a similar fashion, successful lock acquisition causes activate to be invoked.
            </p>
            <p> The code below shows how we may try to obtain a write lock on an object:</p>
            <pre><code class="language-java">public class Example extends LockManager
{
   public boolean foobar ()
   {
     AtomicAction A = new AtomicAction;
     /*
     <span class="emphasis"><em>
     * The ArjunaCore AtomicAction class is here used to create
     * a transaction. Any interface provided by the JTA or
     * JTS interfaces that allow to create transactions can
     * be used in association with the Locking mechanisms
     * described in this trail.</em></span>
     */
     boolean result = false;

     A.begin();
     if (setlock(new Lock(LockMode.WRITE), 0) == Lock.GRANTED)
     {
       /*
       * Do some work, and TXOJ will
       * guarantee ACID properties.
       */
       // automatically aborts if fails
       if (A.commit() == AtomicAction.COMMITTED)
       {
         result = true;
       }
     }
    else
       A.rollback();

    return result;
   }
}
</code></pre>
        </div>
        <div class="section" title="3.2.7.19.3. Further Reading"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5879"/>3.2.7.19.3. Further Reading</h5></div></div></div>
            
            <p>More details on Transactional Object For Java can be found in the ArjunaCore
                Programming Guide.
            </p>
        </div>
        <div class="section" title="3.2.7.19.4. Making the Banking Application Persistent with Transactional Object For Java"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5882"/>3.2.7.19.4. Making the Banking Application Persistent with Transactional Object For Java</h5></div></div></div>
            
            <p>The banking application consists of a Bank object that contains a list of Account
                object, which in turn have a String (name) and a float (the value) as member
                variables. It appears clearly that from the persistent point of view, an Account
                Object need to store its name and its current balance or value, while the Bank
                Object need to store the list of accounts that it manages.
            </p>
            <div class="section" title="3.2.7.19.4.1. Distributed Configuration"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5885"/>3.2.7.19.4.1. Distributed Configuration </h6></div></div></div>
                
                <p>The
                    banking application with Transactional Object for Java (TXOJ) is configured
                    to use JTS interfaces as the API to create the transaction, then an ORB to deploy
                    it. The 
                    distribution is provided to work with the bundled JacORB version
                </p>
                <p>
                    <span class="emphasis"><em>Note</em></span>
                    : Ensure that the jacorb jar files are added in your CLASSPATH
                </p>
            </div>
            <div class="section" title="3.2.7.19.4.2. Delpoy the Application"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5890"/>3.2.7.19.4.2. Delpoy the Application</h6></div></div></div>
                
                <p>- Start the Server</p>
                <div class="blockquote"><blockquote class="blockquote">
                    <pre><code class="language-java">
                        java com.arjuna.demo.jts.txojbank.BankServer
                    </code></pre>
                </blockquote></div>
                <p>- In a separate window, start the client</p>
                <div class="blockquote"><blockquote class="blockquote">
                    <pre><code class="language-java">
                        java com.arjuna.demo.jts.txojbank.BankClient
                    </code></pre>
                </blockquote></div>
                <p>As for the demonstrations presented in the previous trails, the same menu is
                    presented for the client with a set of operations such creating an account,
                    credit/withdraw money to/from an account and making a transfer.
                </p>
                <p>
                    Building the banking application
                    with TXOJ tools
                </p>
            </div>
            <div class="section" title="3.2.7.19.4.3. Building the banking application with TXOJ"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5900"/>3.2.7.19.4.3. Building the banking application with TXOJ</h6></div></div></div>
                
            </div>
            <div class="section" title="3.2.7.19.4.4. The Bank IDL"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5902"/>3.2.7.19.4.4. The Bank IDL</h6></div></div></div>
                
                <p>Since a distributed version has been adopted to present the application with
                    Transactional Object for Java, an IDL file named Bank.idl described below is
                    needed. The difference with the Bank.idl presented in previous trails is the
                    fact that the Bank interface inherits the CosTransactions::TransactionalObject
                    interface. Since we consider now that a Bank object need to modify its list
                    in a transactional, we consider now a Bank object as a CORBA transactional.
                </p>
                <pre><code class="language-java">module arjuna {
   module demo {
     module jts {
      module txojbank {

        interface Account : <span class="emphasis"><em>CosTransactions::TransactionalObject</em></span>
        {
          float balance();
          void credit( in float value );
          void debit( in float value );
        };

        exception NotExistingAccount
        { };

        interface Bank <span class="emphasis"><em>: CosTransactions::TransactionalObject</em></span>
        {
          Account create_account( in string name );
          Account get_account( in string name )
            raises( NotExistingAccount );
        };
       };
      };
     };
   };</code></pre>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        The client program
                        <p>Basically the client program (src/com/arjuna/demo/jts/txojbank/BankClient.java)
                            is equivalent to the one described in the distributed jts version with implicit
                            propagation, the difference is on the package name.
                        </p>
                    </li><li class="listitem">
                        Implementing the Account Interface
                    </li><li class="listitem">
                        Implementing the Bank Interface
                    </li><li class="listitem">
                        Implementing the Bank Server.
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.19.4.5. Implementing the Account interface"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5914"/>3.2.7.19.4.5. Implementing the Account interface</h6></div></div></div>
                
                <p>To take benefit from the persistency and locking mechanism provided by ArjunaCore,
                    a user class can inherit from the appropriate class (StateManager for recovery,
                    and LockManager for recovery and concurrency control). The AccountImpl class
                    that implements the Account interface inherits the LockManager and implements
                    the AccountOperations interface generated by the CORBA IDL compiler. Since multiple
                    inheritance is not allowed in Java, inheriting the AccountPOA class, as made
                    in simple jts remote version, in addition to the LockManager is not possible.
                    That we use in this version a CORBA TIE mechanism to associate a servant to
                    an CORBA object reference.
                </p>
                <p>The Java interface definition of the AccountImpl class is given below:</p>
                <pre><code class="language-java">public class AccountImpl <span class="emphasis"><em><span class="emphasis"><em>extends LockManager</em></span> implements AccountOperations</em></span>
{
  float _balance;
  String _name;
  public AccountImpl(String name );
  public AccountImpl(Uid uid);
  public void finalize ();
  public float balance();
  public void credit( float value );
  public void debit( float value );
  public boolean save_state (OutputObjectState os, int ObjectType);
  public boolean restore_state (InputObjectState os, int ObjectType);
  public String type();
}</code></pre>
                <div class="itemizedlist"><pre><code class="language-java">public void finalize ()
{
  super.terminate();
}
</code></pre><pre><code class="language-java">public String type ()
{
  return "/StateManager/LockManager/BankingAccounts";
}</code></pre><ul class="itemizedlist"><li class="listitem">
                        Constructors and Destructor
                        <p>To use an existing persistent object requires the use of a special constructor
                            that is required to take the Uid of the persistent object; the implementation
                            of such a constructor is given below:
                        </p>

                        <pre><code class="language-java">public AccountImpl(Uid uid)
{
  super(uid);
  // Invoking super will lead to invoke the
  //restore_state method of this AccountImpl class
}</code></pre>
                        <p>There is no particular behaviour applied by the Constructor with the Uid parameter The
                            following constructor is used for a new Account creation.</p>
                        <pre><code class="language-java">
public AccountImpl(String name )
{
  super(ObjectType.ANDPERSISTENT);
  _name = name;
  _balance = 0;
}
</code></pre>

                        <p>The destructor of the queue class is only required to call the terminate operation of
                            LockManager.</p>
                    </li><li class="listitem">
                        save_state, restore_state and type
                        <p>The implementations of save_state and restore_state are relatively simple
                            for this example:
                        </p>

                        <pre><code class="language-java">public boolean save_state (OutputObjectState os, int ObjectType)
{
   if (!super.save_state(os, ObjectType))
      return false;

   try
   {
      os.packString(_name);
      os.packFloat(_balance);
      return true;
   }
   catch (Exception e)
   {
      return false;
   }
}</code></pre>
                        <pre><code class="language-java">public boolean restore_state (InputObjectState os, int ObjectType)
{
   if (!super.restore_state(os, ObjectType))
      return false;

   try
   {
     _name = os.unpackString();
     _balance = os.unpackFloat();
      return true;
   }
   catch (Exception e)
   {
      return false;
   }
} </code></pre>

                        <p>Because the AccountImpl class is derived from the LockManager class, the operation type
                            should be:</p>
                    </li><li class="listitem">
                        account management operations

                        <pre><code class="language-java">public float balance()
{
  float result = 0;
  if (setlock(new Lock(LockMode.READ), 0) == LockResult.GRANTED)
  {
    result = _balance;
  }
  ...

  return result;
}</code></pre>

                        <p> Since the balance operation consists only to get the current balance,
                            acquiring a lock in READ mode is enough. This is not the case of the credit
                            and debit methods that need to modify the current balance, that is a WRITE
                            mode is needed.
                        </p>
                        <pre><code class="language-java">
public void credit( float value )
{
  if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
  {
    _balance += value;
  }
  ...
}

public void debit( float value )
{
  if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
  {
    _balance -= value;
  }
  ...
}</code></pre>
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.19.4.6. Sample Application Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5939"/>3.2.7.19.4.6. Sample Application Source Code</h6></div></div></div>
                
                <p>Full source code for the src/com/arjuna/demo/jts/txojbank/AccountImpl.java"&gt;AccountImpl
                    class is included to provide you with a starting point for experimentation.
                </p>
            </div>
            <div class="section" title="3.2.7.19.4.7. Implementing the Bank interface"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5942"/>3.2.7.19.4.7. Implementing the Bank interface</h6></div></div></div>
                
                <p>To take benefit from the persistency and locking mechanism provided by ArjunaCore,
                    a user class can inherit from the appropriate class (StateManager for recovery,
                    and LockManager for recovery and concurrency control). The BankImpl class that
                    implements the Bank interface inherits the LockManager and implements the BankOperations
                    interface generated by the CORBA IDL compiler. Since multiple inheritance is
                    not allowed in Java, inheriting the BankPOA class, as made in simple jts remote
                    version, in addition to the LockManager is not possible. That we use in this
                    version a CORBA TIE mechanism to associate a servant to an CORBA object reference.
                </p>
                <p>The Java interface definition of the BankImpl class is given below:</p>
                <pre><code class="language-java">public class BankImpl extends LockManager implements BankOperations
{
  public BankImpl(OA oa);
  public BankImpl(Uid uid, OA oa);
  public BankImpl(Uid uid);
  public Account create_account( String name );
  public Account get_account( String name );
  public boolean save_state (OutputObjectState os, int ObjectType);
  public boolean restore_state (InputObjectState os, int ObjectType);
  public String type();

  public static final int ACCOUNT_SIZE = 10;
  // ACCOUNT_SIZE is the maximum number of accounts
  private String [] accounts;
  private int numberOfAccounts;
  private ORB _orb;
  private OA _oa;
  private java.util.Hashtable _accounts; //The list of accounts

}</code></pre>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Constructors and Destructor
                        <p>To use an existing persistent object requires the use of a special constructor
                            that is required to take the Uid of the persistent object; the implementation
                            of such a constructor is given below:
                        </p>

                        <pre><code class="language-java">public BankImpl(Uid uid)
{
  super(uid);
  _accounts = new java.util.Hashtable();
  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}</code></pre>
                        <p>The following constructor is invoked during the first creation of the Bank Object.</p>
                        <pre><code class="language-java">
public BankImpl(OA oa)
{ super(ObjectType.ANDPERSISTENT);
  _accounts = new java.util.Hashtable();
  _oa = oa;
  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}</code></pre>
                        <p>The following constructor is invoked on successive BankServer restart.
                            A bank already exists and should be recreated. Invoking super or the constructor
                            of the inherited class leads to execute the restore_state method, described
                            below, of the BankImpl class to rebuild the list of accounts previously
                            created, if any.
                        </p>
                        <pre><code class="language-java">
public BankImpl(Uid uid, OA oa)
{ super(uid);
  _accounts = new java.util.Hashtable();
  _oa = oa;
  numberOfAccounts = 0;
  accounts = new String[ACCOUNT_SIZE];
}
</code></pre>

                        <p>The destructor of the queue class is only required to call the terminate operation of
                            LockManager.</p>
                    </li></ul></div>
                <div class="blockquote"><blockquote class="blockquote">
                    <pre><code class="language-java">public void finalize ()
{
  super.terminate();
}
</code></pre>
                </blockquote></div>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        account management operations

                        <pre><code class="language-java">public Account create_account( String name )
{
  AccountImpl acc;
  AccountPOA account = null;
  //Attempt to obtain the lock for change
  if (setlock(new Lock(LockMode.WRITE), 0) == LockResult.GRANTED)
   {
     //Check if the maximum number of accounts is not reached
     if (numberOfAccounts &lt; ACCOUNT_SIZE)
     {
     acc = new AccountImpl(name); //Create a new account
     //Use the TIE mechanism to create a CORBA object
      account = new AccountPOATie(acc);
      //Add the account to the list of accounts that
      //facilitate to retrieve accounts
      _accounts.put( name, acc);
       //The Uid of the created account is put in the array
       accounts[numberOfAccounts] = acc.get_uid().toString();
       numberOfAccounts++;
     }
  }
  return com.arjuna.demo.jts.txojbank.
       AccountHelper.narrow(_oa.corbaReference(account));
}

public Account get_account(String name)
  throws NotExistingAccount
{
  // Only the hashtable list is used to retrieve the account
  AccountImpl acc = ( AccountImpl ) _accounts.get( name );
  AccountPOA account = new AccountPOATie(acc);
  if ( acc == null )
     throw new NotExistingAccount("The Account
        requested does not exist");
  return com.arjuna.demo.jts.txojbank.
    AccountHelper.narrow(_oa.corbaReference(account));
}</code></pre>

                    </li></ul></div>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        save_state, restore_state and type

                        <pre><code class="language-java">public boolean save_state (OutputObjectState os, int ObjectType)
{
   if (!super.save_state(os, ObjectType))
     return false;

   try
   {
     os.packInt(numberOfAccounts);
     if (numberOfAccounts &gt; 0)
     {
      // All Uid located in the array will be saved
      for (int i = 0; i &lt; numberOfAccounts; i++)
        os.packString(accounts[i]);
     }
     return true;
   }
   catch (Exception e)
   {
     return false;
   }
}</code></pre>
                        <pre><code class="language-java">public boolean restore_state (InputObjectState os, int ObjectType)
{
   if (!super.restore_state(os, ObjectType))
   {
     return false;
   }
   try
   {
      numberOfAccounts = os.unpackInt();

      if (numberOfAccounts &gt; 0)
      {
        for (int i = 0; i &lt; numberOfAccounts; i++)
        {
          accounts[i] = os.unpackString();
          //each stored Uid is re-used to recreate
          //a stored account object
          AccountImpl acc = new AccountImpl(new Uid(accounts[i]));
          acc.activate();
          //Once recreated the account object
          //is activated and added to the list.
         _accounts.put( acc.getName(), acc);
        }
      }
      return true;
   }
   catch (Exception e)
   {
      return false;
   }
} </code></pre>
                        <pre><code class="language-java">public String type ()
{
   return "/StateManager/LockManager/BankServer";
}</code></pre>

                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.19.4.8. Sample Application Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5966"/>3.2.7.19.4.8. Sample Application Source Code</h6></div></div></div>
                
                <p>Full source code for the src/com/arjuna/demo/jts/txojbank/BankImpl.java"&gt;BankImpl
                    class is included to provide you with a starting point for experimentation.
                </p>
            </div>
            <div class="section" title="3.2.7.19.4.9. Implementing the BankServer"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5969"/>3.2.7.19.4.9. Implementing the BankServer</h6></div></div></div>
                
                <p>The role of the BankServer class is mainly to initialise the ORB and the Object
                    Adapter and to create the default Bank object responsible to create banking
                    accounts.
                </p>
                <p>Globally the BankServer has the following structure.</p>
                <div class="itemizedlist"><div class="blockquote"><blockquote class="blockquote">
                        <pre><code class="language-java">...
myORB = ORB.getInstance("ServerSide");
myOA = OA.getRootOA(myORB);
myORB.initORB(args, null);
myOA.initOA();
...
</code></pre>
                    </blockquote></div><ul class="itemizedlist"><li class="listitem">
                        Initialise the ORB
                        <p>This done using the ORB Portability API</p>
                    </li><li class="listitem">
                        Create the BankImpl object, an instance that implements the Bank interface.
                        Two ways are provided to build such Bank object according to the fact it's
                        the first time we create such object or not. This depends on the existence
                        or not of the file named "
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            </li></ul></div>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">...
java.io.FileInputStream file = new java.io.FileInputStream("UidBankFile");
java.io.InputStreamReader input = new java.io.InputStreamReader(file);
java.io.BufferedReader reader = new java.io.BufferedReader(input);
String stringUid = reader.readLine();
file.close();
_bank = new BankImpl(new Uid(stringUid), myOA);
boolean result =_bank.activate();
...
</code></pre>
                        </blockquote></div>
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                                If the file does not exist, a new BankImpl object is created, then the
                                Uid of the created object is stored in the file named "UidBankFile"
                            </li></ul></div>
                        <div class="blockquote"><blockquote class="blockquote">
                            <pre><code class="language-java">...
_bank = new BankImpl(myOA);
java.io.FileOutputStream file = new java.io.FileOutputStream("UidBankFile");
java.io.PrintStream pfile=new java.io.PrintStream(file);
pfile.println(_bank.get_uid().toString());
file.close();
...</code></pre>
                        </blockquote></div>
                    </li><li class="listitem">
                        Store the CORBA object reference of the BankImpl object in a file in such
                        way the client can retrieve it from that file.
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.19.4.10. Sample Application Source Code"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5988"/>3.2.7.19.4.10. Sample Application Source Code</h6></div></div></div>
                
                <p>Full source code for the src/com/arjuna/demo/jts/txojbank/BankServer.java"&gt;BankServer
                    class is included to provide you with a starting point for experimentation.
                </p>
            </div>
        </div>
        <div class="section" title="3.2.7.19.5. Developing applications with JDBC and JTS"><div class="titlepage"><div><div><h5 class="title"><a id="d5e5991"/>3.2.7.19.5. Developing
                applications with JDBC and 
                JTS
            </h5></div></div></div>
            
            <p>
                JTS supports the construction of both local and distributed transactional
                applications which access databases using the JDBC APIs. JDBC supports
                two-phase commit of transactions, and is similar to the XA X/Open standard.
                The JDBC support is found in the com.arjuna.ats.jdbc package.
            </p>
            <div class="section" title="3.2.7.19.5.1. Transactional Driver"><div class="titlepage"><div><div><h6 class="title"><a id="d5e5994"/>3.2.7.19.5.1. Transactional Driver</h6></div></div></div>
                
                <p>The 
                    JTS approach to incorporating JDBC connections within transactions
                    is to provide transactional JDBC drivers through which all interactions occur.
                    These drivers intercept all invocations and ensure that they are registered
                    with, and driven by, appropriate transactions. There is a single type of transactional
                    driver through which any JDBC driver can be driven; obviously if the database
                    is not transactional then ACID properties cannot be guaranteed. This driver
                    is com.arjuna.ats.jdbc.TransactionalDriver, which implements the java.sql.Driver
                    interface.
                </p>
                <p>The driver may be directly instantiated and used within an application. For
                    example:
                </p>
                <pre><code class="language-java"> TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver(); </code></pre>
                <p>It can be registered with the JDBC driver manager (java.sql.DriverManager)
                    by adding them to the Java system properties. The jdbc.drivers property contains
                    a list of driver class names, separated by colons, that are loaded by the JDBC
                    driver manager when it is initialised, for instance:
                </p>
                <pre><code class="language-java">jdbc.drivers=foo.bar.Driver:mydata.sql.Driver:bar.test.myDriver</code></pre>
                <p> On running an application, it is the DriverManager's responsibility to load
                    all the drivers found in the system property jdbc.drivers. For example, this
                    is where the driver for the Oracle database may be defined. When opening a connection
                    to a database it is the DriverManager' s role to choose the most appropriate
                    driver from the previously loaded drivers.
                </p>
                <p> A program can also explicitly load JDBC drivers at any time. For example,
                    the my.sql.Driver is loaded with the following statement:
                </p>
                <pre><code class="language-java">Class.forName("my.sql.Driver"); </code></pre>
                <p>Calling Class.forName() will automatically register the driver with the JDBC
                    driver manager. It is also possible to explicitly create an instance of the
                    JDBC driver using the registerDriver method of the DriverManager. This is the
                    case for instance for the TransactionalDriver that can be registered as follow:
                </p>
                <pre><code class="language-java">TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
DriverManager.registerDriver(arjunaJDBC2Driver);</code></pre>
                <p> When you have loaded a driver, it is available for making a connection with
                    a DBMS.
                </p>
            </div>
            <div class="section" title="3.2.7.19.5.2. Making Connections"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6007"/>3.2.7.19.5.2. Making Connections</h6></div></div></div>
                
                <p>Once a driver is loaded and ready for a connection to be made, instances of
                    a Connection class can be created using the getConnection method on the DriverManager,
                    as follow:
                </p>
                <pre><code class="language-java">Connection con = DriverManager.getConnection(url, username, password);</code></pre>
                <p>From
                    its version 2.0, the JDBC API has introduced a new way to obtain instances
                    of the Connection class. This is the case of the interfaces DataSource and XADataSource
                    that creates transactional connections. When using a JDBC 2.0 driver, 
                    will use the appropriate DataSource whenever a connection to the database is
                    made. It will then obtain XAResources and register them with the transaction
                    via the JTA interfaces. It is these XAResources which the transaction service
                    will use when the transaction terminates in order to drive the database to either
                    commit or rollback the changes made via the JDBC connection.
                </p>
                <p>
                    There are two ways in which the 
                    JDBC 2.0 support can obtain XADataSources.
                    These will be explained in the following sections. Note, for simplicity we shall
                    assume that the JDBC 2.0 driver is instantiated directly by the application.
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>Java Naming and Directory Interface (JNDI)</p>
                        <p> To get the ArjunaJDBC2Driver class to use a JNDI registered XADataSource
                            it is first necessary to create the XADataSource instance and store it in
                            an appropriate JNDI implementation. Details of how to do this can be found
                            in the JDBC 2.0 tutorial available at JavaSoft. An example is show below:
                        </p>
                        <pre><code class="language-java">XADataSource ds = MyXADataSource();
Hashtable env = new Hashtable();
String initialCtx = PropertyManager.
  getProperty("Context.INITIAL_CONTEXT_FACTORY");
env.put(Context.INITIAL_CONTEXT_FACTORY, initialCtx);
initialContext ctx = new InitialContext(env);
ctx.bind("jdbc/foo", ds);</code></pre>
                        <p> Where the Context.INITIAL_CONTEXT_FACTORY property is the JNDI way of
                            specifying the type of JNDI implementation to use.
                        </p>
                        <p> Then the application must pass an appropriate connection URL to the JDBC
                            2.0 driver:
                        </p>
                        <pre><code class="language-java">Properties dbProps = new Properties();
dbProps.setProperty(TransactionalDriver.userName, "user");
dbProps.setProperty(TransactionalDriver.password, "password");
TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
Connection connection = arjunaJDBC2Driver.
  connect("jdbc:arjuna:jdbc/foo", dbProps);</code></pre>
                        <p> The JNDI URL must be pre-pended with jdbc:arjuna:
                            in order for the ArjunaJDBC2Driver to recognise that the DataSource must
                            participate within transactions and be driven accordingly.
                        </p>
                    </li><li class="listitem">
                        <p>Dynamic class instantiation</p>
                        <p>
                            Many JDBC implementations provide proprietary implementations of XADataSources
                            that provide non-standard extensions to the specification. In order to allow
                            the application to remain isolated from the actual JDBC 2.0 implementation
                            it is using and yet continue to be able to use these extensions, 
                            hides the details of these proprietary implementations using dynamic class
                            instantiation. In addition, the use of JNDI is not required when using this
                            mechanism because the actual implementation of the XADataSource will be
                            directly instantiated, albeit in a manner which will not tie an application
                            or driver to a specific implementation. 
                            therefore has several classes
                            which are for specific JDBC implementations, and these can be selected
                            at runtime by the application setting the dynamicClass property appropriately:
                        </p>
                    </li></ul></div>
                <div class="blockquote"><blockquote class="blockquote">
                    <table width="60%" border="1" id="d5e6026">
                        <tr>
                            <td width="26%">
                                <span class="emphasis"><em>Database Type</em></span>
                            </td>
                            <td width="74%">
                                <span class="emphasis"><em>Property Name</em></span>
                            </td>
                        </tr>
                        <tr>
                            <td>Cloudscape 3.6</td>
                            <td>com.arjuna.ats.internal.jdbc.drivers.cloudscape_3_6</td>
                        </tr>
                        <tr>
                            <td>Sequelink 5.1</td>
                            <td>com.arjuna.ats.internal.jdbc.drivers.sequelink_5_1</td>
                        </tr>
                        <tr>
                            <td>Oracle 8.1.6</td>
                            <td>com.arjuna.ats.internal.jdbc.drivers.oracle_8_1_6</td>
                        </tr>
                        <tr>
                            <td>SQL Server 2000</td>
                            <td>com.arjuna.ats.internal.jdbc.drivers.sqlserver_2_2</td>
                        </tr>
                    </table>
                </blockquote></div>
                <div class="blockquote"><blockquote class="blockquote">
                    <p>The application code must specify which dynamic class the TransactionalDriver
                        should instantiate when setting up the connection:
                    </p>
                </blockquote></div>
                <div class="itemizedlist"><pre><code class="language-java">Properties dbProps = new Properties();
dbProps.setProperty(TransactionalDriver.userName, "user");
dbProps.setProperty(TransactionalDriver.password, "password");
dbProps.setProperty(TransactionalDriver.dynamicClass,
    "com.arjuna.ats.internal.jdbc.drivers.sequelink_5_0");
TransactionalDriver arjunaJDBC2Driver = new TransactionalDriver();
Connection connection = arjunaJDBC2Driver.connect("jdbc:arjuna:
    sequelink://host:port;databaseName=foo",dbProperties);
</code></pre><ul class="itemizedlist"/></div>
                <p>Note on properties used by the com.arjuna.ats.jdbc.TransactionalDriver class</p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <span class="emphasis"><em>userName</em></span>
                        : the user name to use when attempting to connect to the
                        database.
                    </li><li class="listitem">
                        <span class="emphasis"><em>password</em></span>
                        : the password to use when attempting to connect to the
                        database.
                    </li><li class="listitem">
                        <span class="emphasis"><em>createDb</em></span>
                        : if set to true, the driver will attempt to create the
                        database when it connects. This may not be supported by all JDBC 2.0 implementations.
                    </li><li class="listitem">
                        <span class="emphasis"><em>dynamicClass</em></span>
                        : this specifies a class to instantiate to connect
                        to the database, rather than using JNDI.
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.19.5.3. Using the Connection"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6058"/>3.2.7.19.5.3. Using the Connection</h6></div></div></div>
                
                <p>Once
                    the connection has been established (for example, using the java.sql.DriverManager.getConnection
                    method), all operations on the connection will be monitored by .
                    Once
                    created, the driver and any connection can be used in the same way as any other
                    JDBC driver or connection.
                </p>
                <p> 
                    connections can be used within multiple different transactions simultaneously,
                    i.e., different threads, with different notions of the current transaction,
                    may use the same JDBC connection. 
                    does connection pooling for each
                    transaction within the JDBC connection. So, although multiple threads may use
                    the same instance of the JDBC connection, internally this may be using a different
                    connection instance per transaction. With the exception of close, all operations
                    performed on the connection at the application level will only be performed
                    on this transaction-specific connection.
                </p>
                <p> 
                    will automatically register the JDBC driver connection with the transaction
                    via an appropriate resource . When the transaction terminates, this resource
                    will be responsible for either committing or rolling back any changes made to
                    the underlying database via appropriate calls on the JDBC driver.
                </p>
            </div>
            <div class="section" title="3.2.7.19.5.4. Further reading"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6063"/>3.2.7.19.5.4. Further reading</h6></div></div></div>
                
                <p>More
                    details on the way to manage applications using the JDBC API can be found
                    in the 
                    Programming Guide.
                </p>
            </div>
            <div class="section" title="3.2.7.19.5.5. The banking application as a relational database accessed with JDBC"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6066"/>3.2.7.19.5.5. The banking application as a relational database accessed with JDBC</h6></div></div></div>
                
                <p>In regards to the its structure in the previous trails, the banking application
                    described here has been slightly simplified. In this version creating local
                    JTA transactions, accounts managed by a bank object are in fact instances or
                    tuples within a SQL relational table named "accounts". When the Bank
                    object is requested for instance to create an account or to get information
                    on an account, the Bank object performs SQL statement such SQL INSERT or SQL
                    SELECT.
                </p>
            </div>
            <div class="section" title="3.2.7.19.5.6. Deploy the application"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6069"/>3.2.7.19.5.6. Deploy the application</h6></div></div></div>
                
                <p>Executing the demonstration consists to launch the folowing program</p>
                <pre><code class="language-java">java com.arjuna.demo.jta.jdbcbank.BankClient  -host &lt;hostName&gt;
  -port portNumber  -username &lt;userName&gt;  -dbName &lt;DBName&gt;
  -password &lt;password&gt; -clean|-create</code></pre>
                Where:
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        hostName - the name of the machine where is located the database
                    </li><li class="listitem">
                        userName - the user name used to access the database
                    </li><li class="listitem">
                        password - the password used to access to database
                    </li><li class="listitem">
                        DBName - the database name
                    </li><li class="listitem">
                        clean - the existing relational table will be deleted then created
                    </li><li class="listitem">
                        create - a new relational table will be created
                    </li></ul></div>

                <p>
                    <span class="emphasis"><em>Note</em></span>
                    Due to an issue with Oracle, it is possible that an XA exception is thrown when attempting to
                    perform this test (see Release Notes).
                    If an xa error is returned you can use the following property property
                    <span class="emphasis"><em>com.arjuna.ats.jdbc.isolationLevel </em></span>
                    set to
                    <span class="emphasis"><em>TRANSACTION_READ_COMMITTED</em></span>
                    .
                </p>
                <p>This property can be added in previous command as follow:
                </p>
                <pre><code class="language-java">java -Dcom.arjuna.ats.jdbc.isolationLevel=TRANSACTION_READ_COMMITTED
     com.arjuna.demo.jta.jdbcbank.BankClient  -host &lt;hostName&gt;
    -port portNumber  -userName &lt;userName&gt;
    -password &lt;password&gt; -clean|-create</code></pre>



            </div>
            <div class="section" title="3.2.7.19.5.7. How JDBC is used"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6086"/>3.2.7.19.5.7. How JDBC is used</h6></div></div></div>
                
                <p>The following Banking application illustrates some methods that use the JDBC API. In this
                    application, the way
                    to create a jdbc connection is made via an XADataSource obtained with JNDI operations, es explained in the previous
                    trail jdbc introduction
                    The BankClient class instantiates an XADataSource and bind it to a jndi naming in order to be retrieved to create
                    transactional connections.
                    This portion of code illustrates how this made against oracle (tested on version 9i). A similar code could tested
                    against an other database by providng the appropriate XADataSource implementation. Details of the
                    BankClient class
                    can be found in the file src/com/arjuna/demo/jta/jdbcbank/BankClient.java
                </p>
                <pre><code class="language-java">
  package com.arjuna.demo.jta.jdbcbank;

  import javax.naming.*;
  import java.util.Hashtable;
  import oracle.jdbc.xa.client.OracleXADataSource;
  import com.arjuna.ats.jdbc.common.jdbcPropertyManager;

  public class BankClient
  {
   .....
   public static void main(String[] args)
    {
      //Provide the apporopriate information to access the database
      for (int i = 0; i &lt; args.length; i++)
      {
          if (args[i].compareTo("-host") == 0)
              host = args[i + 1]
		  if (args[i].compareTo("-port") == 0)
                port = args[i + 1];
		  if (args[i].compareTo("-username") == 0)
                user = args[i + 1];
          if (args[i].compareTo("-password") == 0)
                password = args[i + 1];
	      if (args[i].compareTo("-dbName") == 0)
                dbName = args[i + 1];
          ....
      }

     try
     {
       // create DataSource
       OracleXADataSource ds = new OracleXADataSource();
       ds.setURL("jdbc:oracle:thin:@"+host+":"+port+":"+dbName);

       // now stick it into JNDI
       Hashtable env = new Hashtable();
       env.put (Context.INITIAL_CONTEXT_FACTORY,
	   "com.sun.jndi.fscontext.RefFSContextFactory");
	    env.put (Context.PROVIDER_URL, "file:/tmp/JNDI");
	    InitialContext ctx = new InitialContext(env);
	    ctx.rebind("jdbc/DB", ds);
     }
	 catch (Exception ex)
	 { }
  	 //Set the jndi information to be user by the Arjuna JDBC Property Manager
	 jdbcPropertyManager.propertyManager.setProperty("Context.INITIAL_CONTEXT_FACTORY",
	   "com.sun.jndi.fscontext.RefFSContextFactory");
	 jdbcPropertyManager.propertyManager.setProperty("Context.PROVIDER_URL",
	   "file:/tmp/JNDI");

	 Bank bank = new Bank();
     BankClient client = new BankClient(bank);

   }
  </code></pre>
                <p>
                    While the BankClient class is responsible to obtain information to access the database, tocreate the XADataSource
                    and bind it to jndi, and also to get order from a user (create_account, debit, transfer, ..), the Bank class is
                    resposnible
                    to create jdbc connections to perform user's requests. The Bank class is illustarted below where. All
                    methods are not illusrated here but have a similar behavior; they could be found in
                    details in the src/com/arjuna/demo/jta/jdbcbank/Bank.java"&gt;Bank.java
                    program. Note that for simplicity, much error checking code has been removed.
                </p>
                <pre><code class="language-java">public Bank()
{
  try
  {
    DriverManager.registerDriver(new TransactionalDriver());
    dbProperties = new Properties();
    dbProperties.put(TransactionalDriver.userName, user);
    dbProperties.put(TransactionalDriver.password, password);
    arjunaJDBC2Driver = new TransactionalDriver(); //
	create_table();
  }
   catch (Exception e)
   {
   e.printStackTrace();
   System.exit(0);
   }

   _accounts = new java.util.Hashtable();
   reuseConnection = true;
   }

   public void create_account( String _name, float _value )
   {
    try
    {
	  Connection conne = arjunaJDBC2Driver.connect("jdbc:arjuna:jdbc/DB", dbProperties);
      Statement stmtx = conne.createStatement(); // tx statement
      stmtx.executeUpdate
        ("INSERT INTO accounts (name, value)
          VALUES ('"+_name+"',"+_value+")");
    }
    catch (SQLException e)
    {
      e.printStackTrace();
    }
   }

  public float get_balance(String _name)
     throws NotExistingAccount
  {
    float theBalance = 0;
    try
    {
	  Connection conne = arjunaJDBC2Driver.connect("jdbc:arjuna:jdbc/DB", dbProperties);
      Statement stmtx = conne.createStatement(); // tx statement
      ResultSet rs = stmtx.executeQuery
         ("SELECT value from accounts
           WHERE name    = '"+_name+"'");
      while (rs.next()) {
        theBalance = rs.getFloat("value");
      }
    }
    catch (SQLException e)
    {
      e.printStackTrace();
      throw new NotExistingAccount("The Account requested does not exist");
    }
    return theBalance;
  }

 ...
}
</code></pre>
            </div>
            <div class="section" title="3.2.7.19.5.8. Note"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6092"/>3.2.7.19.5.8. Note</h6></div></div></div>
                
                <p>Although,
                    this version of the banking application creates JTA local transactions,
                    the way to manipulate JDBC API and the associated 
                    mechanisms in the
                    case of distributed transactions is the same.
                </p>
            </div>
        </div>
    </div>
    <div class="section" title="3.2.7.20. Recovery From Failure Examples"><div class="titlepage"><div><div><h4 class="title"><a id="d5e6095"/>3.2.7.20. Recovery From Failure Examples</h4></div></div></div>
        
        <div class="section" title="3.2.7.20.1. Introduction"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6097"/>3.2.7.20.1. Introduction</h5></div></div></div>
            
            <p>Recovery is the mechanism which preserves the transaction atomicity in presence of failures.
                The basic technique for implementing transactions in presence of failures is based on the use
                of logs. That is, a transaction system has to record enough information to ensure that it can
                be able to return to a previous state in case of failure or to ensure that changes committed by a
                transaction are properly stored.
            </p>
            <p>
				
                ensures that results of a transaction are applied consistently to all resources involved in
                a transaction, even in the presence of failure. To recover from failure, 
                relies on its Recovery
                Manager.
            </p>
            <p>
                Basically, the Recovery Manager is a daemon process that invokes a set of well known Recovery Modules
                periodically in two steps; a first to determine transactions in doubt state and a second step to
                continue
                the completion of those transactions found in the first step. Since different type of resources may be
                involved in a transaction, different type of Recovery Modules may exist. 
                provides several type of
                modules that manage resources according to their position in the transaction tree (root, subordinate, leaf)
                or the nature of the data itself, transactional object for java or XAResource as seen in
                the previous trail.
            </p>
            <p>
                Whatever the nature of the involved resource, recovery is based on information or logs held in the Object Store,
                which contains specific subdirectory holding information according to the nature of the participant.
            </p>
        </div>
        <div class="section" title="3.2.7.20.2. Running the Recovery Manager"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6103"/>3.2.7.20.2. Running the Recovery Manager</h5></div></div></div>
            
            <p>
                <span class="emphasis"><em>This
                    section provides only brief information on running the recovery manager from provided scripts.
                    For complete information on the recovery manager (including how to configure it), see the 
                    recovery information.
                </em></span>
            </p>
            <div class="section" title="3.2.7.20.2.1. Windows"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6107"/>3.2.7.20.2.1. Windows</h6></div></div></div>
                
                <p>
                    To run the Recovery Manager as a Windows service, simply:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Open a command prompt
                    </li><li class="listitem">cd
                        to the directory &lt;jbossts_install_root&gt;\services\bin\windows
                    </li><li class="listitem">
                        Type InstallRecoveryManagerService-NT.bat
                    </li></ul></div>
                <p>
                    Note: This directory also contains the uninstall script which is ran in the same manner.
                </p>
                <p>
                    To launch the Recovery Manager as a Windows process, simply:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Open a command prompt
                    </li><li class="listitem">cd
                        to the directory &lt;jbossts_install_root&gt;\services\bin\windows
                    </li><li class="listitem">
                        Type recoverymanagerservice.bat
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.20.2.2. UNIX"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6120"/>3.2.7.20.2.2. UNIX</h6></div></div></div>
                
                <p>
                    To launch the Recovery Manager on a Linux/UNIX platform, simply:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        Open a command prompt
                    </li><li class="listitem">cd
                        to the directory &lt;jbossts_install_root&gt;\services\bin\[platform]
                    </li><li class="listitem">
                        Type recoverymanagerservice.sh start
                    </li></ul></div>
                <p>
                    Note: To uninstall the recovery manager, rerun the script specifying the stop flag.
                </p>
            </div>
        </div>
        <div class="section" title="3.2.7.20.3. The Recovery Process and XAResources"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6128"/>3.2.7.20.3. The Recovery Process and XAResources</h5></div></div></div>
            
            <p>
                The 
                recovery manager provides support for recovering XAResources whether or not they are Serializable.
                XAResources that
                <span class="emphasis"><em>do</em></span>
                implement the Serializable interface are handled without requiring additional programmer defined
                classes. For those XAResources that need
                to recover but which cannot implement Serializable, it is possible to provide a small class which is used to help
                recover them.
            </p>
            <p>
                This example shows the 
                recovery manager recovering a Serializable XAResource and a non-Serializable XAResource.
            </p>
            <div class="section" title="3.2.7.20.3.1. The demo's components"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6133"/>3.2.7.20.3.1. The demo's components</h6></div></div></div>
                
                The application consists of four classes. Each class is well documented and it is recommended that the
                provided code is inspected to gain
                useful insight into some of the nuances of the recovery process.
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The
                        code of the main class that controls the application
                        (src/com/arjuna/demo/recovery/xaresource/TestXAResourceRecovery.java"&gt;TestRecoveryModule.java),
                        allows
                        the user to specify a number of options: [-waitForRecovery] [-useExternalRecoveryManager]
                    </li><li class="listitem">Programmer-defined
                        support of the Serializable XAResource is only required in the XAResource implementation class
                        src/com/arjuna/demo/recovery/xaresource/ExampleXAResource.java"&gt;ExampleXAResource.java
                    </li><li class="listitem">Programmer-defined
                        support of the non-Serializable XAResource is required both in the XAResource implementation
                        class
                        src/com/arjuna/demo/recovery/xaresource/NonSerializableExampleXAResource.java"&gt;NonSerializableExampleXAResource,
                        and in a class that implements a helper for the 
                        recovery process
                        src/com/arjuna/demo/recovery/xaresource/NonSerializableExampleXAResourceRecovery.java"&gt;NonSerializableExampleXAResourceRecovery.java
                    </li></ul></div>
            </div>
            <div class="section" title="3.2.7.20.3.2. XAResourceRecovery registration"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6139"/>3.2.7.20.3.2. XAResourceRecovery registration</h6></div></div></div>
                
                <p>
                    When recovering from failures, 
                    requires the ability to reconnect to the resource managers
                    that were in use prior to the failures in order to resolve any outstanding transactions.
                    In order to recreate those connections for non-Serializable XAResources it is necessary to
                    provide implementations of the following 
                    interface com.arjuna.ats.jta.recovery.XAResourceRecovery.
                </p>
                <p>
                    To inform the recovery system about each of the XAResourceRecovery instances, it is
                    necessary to specify their class names through property variables in the jbossts-properties.xml file.
                    Any property variable which starts with the name XAResourceRecovery will be assumed to represent
                    one of these instances, and its value should be the class name.
                </p>
                <p>
                    When running XA transaction recovery it is necessary to tell 
                    which types of
                    Xid it can recover. Each Xid that 
                    creates has a unique node
                    identifier encoded within it and 
                    will only recover transactions
                    and states that match a specified node identifier. The node identifier to
                    use should be provided to 
                    via a property that starts with the
                    name com.arjuna.ats.jta.xaRecoveryNode (multiple values may
                    be provided). A value of * will force 
                    to recover (and possibly
                    rollback) all transactions irrespective of their node identifier and should be
                    used with caution.
                </p>
                <p>
                    The recovery module for the non-Serializable XAResource must be deployed in order to provide support
                    to recover the non-Serializable XAResource.
                    If this step was missed out the Serializable XAResource would recover OK but 
                    would have no knowledge of the non-Serializable XAResource
                    and so it could not recover it. To register the non-Serializable XAResource XAResourceRecovery module, add an entry to
                    the jbossts-properties.xml.
                </p>
                <p>
                    Under the element &lt;properties depends="jts" name="jta"&gt;, add:</p>
                <div class="blockquote"><blockquote class="blockquote">
                    &lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery1" value=
                    "com.arjuna.demo.recovery.xaresource.NonSerializableExampleXAResourceRecovery"/&gt;
                    &lt;property name="com.arjuna.ats.jta.xaRecoveryNode" value="*"/&gt;
                </blockquote></div>
                <div class="section" title="3.2.7.20.3.2.1. Configure the recovery manager scan period"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6147"/>3.2.7.20.3.2.1. Configure the recovery manager scan period</h6></div></div></div>
                    
                    <p>
                        By default, the recovery manager is configured to perform a pass over resources to be recovered every two minutes.
                        It will then wait for ten seconds
                        before re-checking the resources. Although the test will run OK with this configuration, it is possible to configure the
                        recovery
                        manager scan times to reduce the time waiting. To configure the intervals, edit the jbossts-properties.xml as follows:
                    </p>
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Edit the property "com.arjuna.ats.arjuna.recovery.periodicRecoveryPeriod"
                            to change the value from 120 to 5.
                        </li><li class="listitem">
                            Edit the property "com.arjuna.ats.arjuna.recovery.recoveryBackoffPeriod"
                            to change the value from 10 to 5.
                        </li></ul></div>
                </div>
                <div class="section" title="3.2.7.20.3.2.2. Specify the transaction manager type to use"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6153"/>3.2.7.20.3.2.2. Specify the transaction manager type to use</h6></div></div></div>
                    
                    <p>
                        The recovery manager will work in the same manner for either the JTA or JTS implementation. By
                        default 
                        is configured to use a JTS transaction manager, in order to configure it to use a JTA
                        transaction manager a change must again be made
                        to the jbossts-properties.xml.
                        <span class="emphasis"><em>See
                            "Testing JTA" for more information on how to configure
                            the 
                            transaction manager to use JTA rather than JTS.
                        </em></span>
                    </p>
                    <p>
                        <span class="emphasis"><em>If you do change the transaction manager type remember to reconfigure the recovery
                            manager as follows:</em></span>
                    </p>
                    <p>
                        If you are using the ArjunaCore (raw JTA) transaction manager implementation comment out the element in
                        jbossts-properties.xml containing the following text:
                    </p>
                    <div class="blockquote"><blockquote class="blockquote">
                        internal.jta.recovery.jts.XARecoveryModule
                    </blockquote></div>
                    <p>
                        If you are using the JTS transaction manager implementation comment out the element in jbossts-properties.xml
                        containing the following text:
                    </p>
                    <div class="blockquote"><blockquote class="blockquote">
                        internal.jta.recovery.arjunacore.XARecoveryModule
                    </blockquote></div>
                </div>
                <div class="section" title="3.2.7.20.3.2.3. Launching the demo"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6163"/>3.2.7.20.3.2.3. Launching the demo</h6></div></div></div>
                    
                    <p>To launch the Test Recovery Module, execute the following java program</p>
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            Open a command prompt
                        </li><li class="listitem">cd
                            to the directory &lt;jbossts_install_root&gt;\trail_map
                        </li><li class="listitem">
                            Type java com.arjuna.demo.recovery.xaresource.TestXAResourceRecovery
                        </li><li class="listitem">
                            View the output noting the crash during commit.
                        </li><li class="listitem">
                            Inspect the current working directory to note that the applications have created several log
                            files which you may like to review.
                        </li><li class="listitem">
                            Type java com.arjuna.demo.recovery.xaresource.TestXAResourceRecovery -waitForRecovery
                        </li><li class="listitem">
                            Wait for the two resources to be recovered and committed.
                        </li><li class="listitem">
                            Re-review the log files from the working directory, if wanted.
                        </li></ul></div>
                    <p>
                        Note: As you can see, the Serializable XAResource does not need it's recover() method called as the transaction manager
                        is aware of all the
                        information about this resource.
                    </p>
                </div>
                <div class="section" title="3.2.7.20.3.2.4. The Recovery Process and AbstractRecords"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6176"/>3.2.7.20.3.2.4. The Recovery Process and AbstractRecords</h6></div></div></div>
                    
                    <p>
                        <span class="emphasis"><em>WARNING:
                            Implementing a RecoveryModule and AbstractRecord is a very advanced feature of the
                            transaction service. It should only
                            be performed by users familiar with the all the concepts used in the 
                            product. Please see the ArjunaCore guide for more
                            information about RecoveryModules and AbstractRecords.
                        </em></span>
                    </p>
                    <p>
                        The following sample gives an overview how the Recovery Manager invokes a module to recover from failure.
                        This basic sample does not aim to present a complete process to recover from failure, but mainly to illustrate
                        the way to implement a recovery module. More details can be found in "Failure Recovery Guide".
                    </p>
                    The application used here consists to create an atomic transaction, to register a participant within
                    the created transaction and finally to terminate it either by commit or abort. A set of arguments
                    are provided:
                    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                            to decide committing or aborting the transaction,
                        </li><li class="listitem">
                            to decide generating a crash during the commitment process.
                        </li></ul></div>
                    <div class="section" title="3.2.7.20.3.2.4.1. The demo's components"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6184"/>3.2.7.20.3.2.4.1. The demo's components</h6></div></div></div>
                        
                        The application consists of three programs
                        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The
                                code of the main class that control the application
                                (src/com/arjuna/demo/recoverymodule/TestRecoveryModule.java"&gt;TestRecoveryModule.java),
                                which consists to give the choice to either commit or abort the transaction and also to
                                generate a crash.
                            </li><li class="listitem">The
                                registered participant
                                (src/com/arjuna/demo/recoverymodule/SimpleRecord.java"&gt;SimpleRecord.java) has the
                                following behaviour:
                                <pre><code class="language-java">
					- During the prepare phase, it writes a simple message - "I'm prepared" - on the disk such
					The message is written in a well known file 
					- During the commit phase, it writes another message - "I'm committed" - in the same file
					used during prepare 
					- If it receives an abort message, it removes from the disk the file used for prepare if any. 
					- if a crash has been decided for the test, then it crashes during the commit phase - the file remains
					with the message "I'm prepared".</code></pre>
                            </li><li class="listitem">A
                                Recovery Module
                                (src/com/arjuna/demo/recoverymodule/SimpleRecoveryModule.java"&gt;SimpleRecoveryModule.java)
                                that consists to read the content of the file used to store the status of the
                                participant,
                                to determine that status and print a message indicating if a recovery action is needed or not.
                            </li></ul></div>
                        Using the provided 
                        Recovery Modules ensures that resources are correctly recovered. This sample illustrates
                        how to define and register its own module. It's the responsibility of the module to re-create the appropriate
                        objects using information retrieved from a log.

                    </div>
                    <div class="section" title="3.2.7.20.3.2.4.2. Recovery Module registration"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6191"/>3.2.7.20.3.2.4.2. Recovery Module registration</h6></div></div></div>
                        
                        The recovery module should now be deployed in order to be called by the Recovery Manager. To do
                        so,
                        we just need to add an entry in the jbossts-properties.xml by adding a new property as follow:
                        <div class="blockquote"><blockquote class="blockquote">
                            &lt;property name="com.arjuna.ats.arjuna.recovery.recoveryExtension&lt;i&gt;"
                            value="com.arjuna.demo.recoverymodule.SimpleRecoveryModule"/&gt;
                        </blockquote></div>
                        Where &lt;i&gt; represent the new occurrence number that follows the last that already exists in
                        the file. Once started, the Recovery Manager will automatically load the added Recovery module.

                    </div>
                    <div class="section" title="3.2.7.20.3.2.4.3. Starting the Recovery Manager"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6194"/>3.2.7.20.3.2.4.3. Starting the Recovery Manager</h6></div></div></div>
                        
                        In a separate window launch the Recovery Manager,
                        as follows:
                        <pre><code class="language-java">java com.arjuna.ats.arjuna.recovery.RecoveryManager -test</code></pre>

                    </div>
                    <div class="section" title="3.2.7.20.3.2.4.4. Launching the demo"><div class="titlepage"><div><div><h6 class="title"><a id="d5e6197"/>3.2.7.20.3.2.4.4. Launching the demo</h6></div></div></div>
                        
                        <p>To launch the Test Recovery Module, execute the following java program</p>
                        <pre><code class="language-java">java com.arjuna.demo.recoverymodule.TestRecoveryModule
		[-commit|-abort] [-crash]</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
        <div class="section" title="3.2.8. Failure Recovery"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6201"/>3.2.8. Failure Recovery</h3></div></div></div>
    
    <p>
        The failure recovery subsystem of 
        ensure that results of a transaction are applied
        consistently to all
        resources affected by the transaction, even if any of the application
        processes or the hardware hosting them crash
        or lose network connectivity. In the case of
        hardware crashes or network failures, the recovery does not take place
        until the system or
        network are restored, but the original application does not need to be restarted. Recovery is
        handled by the Recovery Manager process. For recover to take place, information about the
        transaction and the
        resources involved needs to survive the failure and be accessible afterward.
        This information is held in the
        <code class="classname">ActionStore</code>
        , which is part of the
        <code class="classname">ObjectStore</code>
        . If the
        <code class="classname">ObjectStore</code>
        is destroyed or modified, recovery may not be possible.
    </p>
    <p>
        Until the recovery procedures are complete, resources affected by a transaction which was in
        progress at the time of
        the failure may be inaccessible. Database resources may report this as as
        tables or rows held by
        <span>in-doubt
            transactions
        </span>
        . For TXOJ resources, an attempt to activate the Transactional Object, such as when trying to
        get a lock, fails.
    </p>
    

    <div class="section" title="3.2.8.1. Configuring the failure recovery subsystem for your ORB"><div class="titlepage"><div><div><h4 class="title"><a id="d5e6209"/>3.2.8.1. Configuring the failure recovery subsystem for your ORB</h4></div></div></div>
        
        <p>
            Although some ORB-specific configuration is necessary to configure the ORB sub-system, the
            basic settings are ORB-independent.
            The configuration which applies to 
            is in the
            <code class="filename">RecoveryManager-properties.xml</code>
            file and
            the
            <code class="filename">orportability-properties.xml</code>
            file. Contents of each file are below.
        </p>
        <div class="example"><a id="d5e6214"/><p class="title"><strong>Example 3.27. RecoverManager-properties.xml</strong></p><div class="example-contents">
            
            <pre><code class="language-xml">&lt;entry key="RecoveryEnvironmentBean.recoveryActivatorClassNames"&gt;
  com.arjuna.ats.internal.jts.orbspecific.recovery.RecoveryEnablement
&lt;/entry&gt;
</code></pre>
        </div></div><br class="example-break"/>
        <div class="example"><a id="d5e6217"/><p class="title"><strong>Example 3.28. orportability-properties.xml</strong></p><div class="example-contents">
            
            <pre><code class="language-xml">&lt;entry key="com.arjuna.orbportability.orb.PostInit2"&gt;com.arjuna.ats.internal.jts.recovery.RecoveryInit&lt;/entry&gt;
</code></pre>
        </div></div><br class="example-break"/>
        <p>
            These entries cause instances of the named classes to be loaded. The named classes then load
            the ORB-specific
            classes needed and perform other initialization. This enables failure recovery
            for transactions initiated by or
            involving applications using this property file. The default
            <code class="filename">RecoveryManager-properties.xml</code>
            file and
            <code class="filename">orportability-properties.xml</code>
            with the distribution include these entries.
        </p>
        <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2>
            <p>
                Failure recovery is NOT supported with the JavaIDL ORB that is part of JDK. Failure
                recovery is supported for
                JacOrb only.
            </p>
        </div>
        <p>
            To disable recovery, remove or comment out the
            <code class="literal">RecoveryEnablement</code>
            line in the property file.
        </p>
    </div>

    <div class="section" title="3.2.8.2. JTS specific recovery"><div class="titlepage"><div><div><h4 class="title"><a id="d5e6227"/>3.2.8.2. JTS specific recovery</h4></div></div></div>
        

        <div class="section" title="3.2.8.2.1. XA resource recovery"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6229"/>3.2.8.2.1. XA resource recovery</h5></div></div></div>
            
            <p>
                Recovery of XA resources accessed via JDBC is handled by the
                <code class="classname">XARecoveryModule</code>
                . This
                module includes both
                <span>transaction-initiated</span>
                and
                <span>resource-initiated</span>
                recovery.
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        Transaction-initiated recovery is possible where the particular transaction branch
                        progressed far enough for
                        a
                        <code class="systemitem">JTA_ResourceRecord</code>
                        to be written in the ObjectStore. The record contains the
                        information needed to link the
                        transaction to information known by the rest of 
                        in the database.
                    </p>
                </li><li class="listitem">
                    <p>
                        Resource-initiated recovery is necessary for branches where a failure occurred after the
                        database made a
                        persistent record of the transaction, but before the
                        <code class="systemitem">JTA_ResourceRecord</code>
                        was
                        written. Resource-initiated recovery is also necessary for datasources for which it
                        is impossible to hold
                        information in the
                        <code class="systemitem">JTA_ResourceRecord</code>
                        that allows the recreation in the
                        RecoveryManager of the
                        <code class="classname">XAConnection</code>
                        or
                        <code class="classname">XAResource</code>
                        used in the
                        original application.
                    </p>
                </li></ul></div>
            <p>
                Transaction-initiated recovery is automatic. The
                <code class="classname">XARecoveryModule</code>
                finds the
                <code class="systemitem">JTA_ResourceRecord</code>
                which needs recovery, using the two-pass mechanism described
                above. It then uses the normal
                recovery mechanisms to find the status of the transaction the resource was
                involved in, by
                running
                <code class="methodname">replay_completion</code>
                on the
                <code class="classname">RecoveryCoordinator</code>
                for the transaction branch. Next, it creates or recreates the
                appropriate
                <code class="classname">XAResource</code>
                and issues
                <code class="methodname">commit</code>
                or
                <code class="methodname">rollback</code>
                on it as appropriate. The
                <code class="classname">XAResource</code>
                creation uses the
                same database name, username, password, and other information as the
                application.
            </p>
            <p>
                Resource-initiated recovery must be specifically configured, by supplying the
                <code class="classname">RecoveryManager</code>
                with the appropriate information for it to interrogate all the
                <code class="classname">XADataSources</code>
                accessed by any 
                application. The access to each
                <code class="classname">XADataSource</code>
                is handled by a class that implements the
                <code class="interfacename">com.arjuna.ats.jta.recovery.XAResourceRecovery</code>
                interface. Instances of this class
                are dynamically loaded, as controlled by property
                <code class="varname">JTAEnvironmentBean.xaResourceRecoveryInstances</code>
                .
            </p>
            <p>
                The
                <code class="classname">XARecoveryModule</code>
                uses the
                <code class="classname">XAResourceRecovery</code>
                implementation to
                get an
                <code class="classname">XAResource</code>
                to the target datasource. On each invocation of
                <code class="methodname">periodicWorkSecondPass</code>
                , the recovery module issues an
                <code class="methodname">XAResource.recover</code>
                request. This request returns a list of the transaction identifiers
                that are known to the
                datasource and are in an in-doubt state. The list of these in-doubt Xids is compared
                across
                multiple passes, using
                <code class="methodname">periodicWorkSecondPass-es</code>
                . Any Xid that appears in both
                lists, and for which no
                <code class="systemitem">JTA_ResourceRecord</code>
                is found by the intervening
                transaction-initiated recovery, is assumed to belong to a
                transaction involved in a crash before any
                <code class="systemitem">JTA_Resource_Record</code>
                was written, and a
                <code class="methodname">rollback</code>
                is issued for
                that transaction on the
                <code class="classname">XAResource</code>
                .
            </p>
            <p>
                This double-scan mechanism is used because it is possible the Xid was obtained from the
                datasource just as the
                original application process was about to create the corresponding
                JTA_ResourceRecord. The interval between the
                scans should allow time for the record to be
                written unless the application crashes (and if it does, rollback is
                the right answer).
            </p>
            <p>
                An
                <code class="classname">XAResourceRecovery</code>
                implementation class can contain all the information needed to
                perform recovery to a specific
                datasource. Alternatively, a single class can handle multiple datasources which
                have some
                similar features. The constructor of the implementation class must have an empty parameter
                list,
                because it is loaded dynamically. The interface includes an
                <code class="methodname">initialise</code>
                method, which
                passes in further information as a
                <span class="type">string</span>
                . The content of the string is taken from the property
                value that provides the class name.
                Everything after the first semi-colon is passed as the value of the
                string. The
                <code class="classname">XAResourceRecovery</code>
                implementation class determines how to use the string.
            </p>
            <p>
                An
                <code class="classname">XAResourceRecovery</code>
                implementation class,
                <code class="classname">com.arjuna.ats.internal.jdbc.recovery.BasicXARecovery</code>
                , supports resource-initiated recovery for any XADataSource. For this class, the string
                received in method
                <code class="methodname">initialise</code>
                is assumed to contain the number of connections to recover, and the name of the
                properties
                file containing the dynamic class name, the database username, the database password and the
                database
                connection URL. The following example is for an Oracle 8.1.6 database accessed via
                the Sequelink 5.1 driver:
            </p>
            <pre class="screen">
XAConnectionRecoveryEmpay=com.arjuna.ats.internal.jdbc.recovery.BasicXARecovery;2;OraRecoveryInfo
      </pre>
            <p>
                This implementation is only meant as an example, because it relies upon usernames and
                passwords appearing in
                plain text properties files. You can create your own implementations
                of
                <code class="classname">XAConnectionRecovery</code>
                . See the javadocs and the example
                <span class="package">com.arjuna.ats.internal.jdbc.recovery.BasicXARecovery</span>
                .
            </p>

            <div class="example"><a id="d5e6285"/><p class="title"><strong>Example 3.29. XAConnectionRecovery implementation</strong></p><div class="example-contents">
                
                <pre><code class="language-java">
/*
 * Copyright (C) 2000, 2001,
 *
 * Hewlett-Packard,
 * Arjuna Labs,
 * Newcastle upon Tyne,
 * Tyne and Wear,
 * UK.
 *
 */
package com.arjuna.ats.internal.jdbc.recovery;

import com.arjuna.ats.jdbc.TransactionalDriver;
import com.arjuna.ats.jdbc.common.jdbcPropertyManager;
import com.arjuna.ats.jdbc.logging.jdbcLogger;

import com.arjuna.ats.internal.jdbc.*;
import com.arjuna.ats.jta.recovery.XAConnectionRecovery;
import com.arjuna.ats.arjuna.common.*;
import com.arjuna.common.util.logging.*;

import java.sql.*;
import javax.sql.*;
import jakarta.transaction.*;
import javax.transaction.xa.*;
import java.util.*;

import java.lang.NumberFormatException;

/**
 * This class implements the XAConnectionRecovery interface for XAResources.
 * The parameter supplied in setParameters can contain arbitrary information
 * necessary to initialise the class once created. In this instance it contains
 * the name of the property file in which the db connection information is
 * specified, as well as the number of connections that this file contains
 * information on (separated by ;).
 *
 * IMPORTANT: this is only an *example* of the sorts of things an
 * XAConnectionRecovery implementor could do. This implementation uses
 * a property file which is assumed to contain sufficient information to
 * recreate connections used during the normal run of an application so that
 * we can perform recovery on them. It is not recommended that information such
 * as user name and password appear in such a raw text format as it opens up
 * a potential security hole.
 *
 * The db parameters specified in the property file are assumed to be
 * in the format:
 *
 * DB_x_DatabaseURL=
 * DB_x_DatabaseUser=
 * DB_x_DatabasePassword=
 * DB_x_DatabaseDynamicClass=
 *
 * DB_JNDI_x_DatabaseURL= 
 * DB_JNDI_x_DatabaseUser= 
 * DB_JNDI_x_DatabasePassword= 
 *
 * where x is the number of the connection information.
 *
 * @since JTS 2.1.
 */

public class BasicXARecovery implements XAConnectionRecovery
{    
    /*
     * Some XAConnectionRecovery implementations will do their startup work
     * here, and then do little or nothing in setDetails. Since this one needs
     * to know dynamic class name, the constructor does nothing.
     */
    public BasicXARecovery () throws SQLException
    {
        numberOfConnections = 1;
        connectionIndex = 0;
        props = null;
    }

    /**
     * The recovery module will have chopped off this class name already.
     * The parameter should specify a property file from which the url,
     * user name, password, etc. can be read.
     */

    public boolean initialise (String parameter) throws SQLException
    {
        int breakPosition = parameter.indexOf(BREAKCHARACTER);
        String fileName = parameter;

        if (breakPosition != -1)
            {
                fileName = parameter.substring(0, breakPosition -1);

                try
                    {
                        numberOfConnections = Integer.parseInt(parameter.substring(breakPosition +1));
                    }
                catch (NumberFormatException e)
                    {
                        //Produce a Warning Message
                        return false;
                    }
            }

        PropertyManager.addPropertiesFile(fileName);

        try
            {
                PropertyManager.loadProperties(true);

                props = PropertyManager.getProperties();
            }
        catch (Exception e)
            {
                //Produce a Warning Message 

                return false;
            }  

        return true;
    }    

    public synchronized XAConnection getConnection () throws SQLException
    {
        JDBC2RecoveryConnection conn = null;

        if (hasMoreConnections())
            {
                connectionIndex++;

                conn = getStandardConnection();

                if (conn == null)
                    conn = getJNDIConnection();

                if (conn == null)
                    //Produce a Warning message
                    }

        return conn;
    }

    public synchronized boolean hasMoreConnections ()
    {
        if (connectionIndex == numberOfConnections)
            return false;
        else
            return true;
    }

    private final JDBC2RecoveryConnection getStandardConnection () throws SQLException
    {
        String number = new String(""+connectionIndex);
        String url = new String(dbTag+number+urlTag);
        String password = new String(dbTag+number+passwordTag);
        String user = new String(dbTag+number+userTag);
        String dynamicClass = new String(dbTag+number+dynamicClassTag);
        Properties dbProperties = new Properties();
        String theUser = props.getProperty(user);
        String thePassword = props.getProperty(password);

        if (theUser != null)
            {
                dbProperties.put(ArjunaJDBC2Driver.userName, theUser);
                dbProperties.put(ArjunaJDBC2Driver.password, thePassword);

                String dc = props.getProperty(dynamicClass);

                if (dc != null)
                    dbProperties.put(ArjunaJDBC2Driver.dynamicClass, dc);

                return new JDBC2RecoveryConnection(url, dbProperties);
            }
        else
            return null;
    }

    private final JDBC2RecoveryConnection getJNDIConnection () throws SQLException
    {
        String number = new String(""+connectionIndex);
        String url = new String(dbTag+jndiTag+number+urlTag);
        String password = new String(dbTag+jndiTag+number+passwordTag);
        String user = new String(dbTag+jndiTag+number+userTag);
        Properties dbProperties = new Properties();
        String theUser = props.getProperty(user);
        String thePassword = props.getProperty(password);

        if (theUser != null)
            {
                dbProperties.put(ArjunaJDBC2Driver.userName, theUser);
                dbProperties.put(ArjunaJDBC2Driver.password, thePassword);    
                return new JDBC2RecoveryConnection(url, dbProperties);
            }
        else
            return null;
    }
    private int        numberOfConnections;
    private int        connectionIndex;
    private Properties props;   
    private static final String dbTag = "DB_";
    private static final String urlTag = "_DatabaseURL";
    private static final String passwordTag = "_DatabasePassword";
    private static final String userTag = "_DatabaseUser";
    private static final String dynamicClassTag = "_DatabaseDynamicClass";
    private static final String jndiTag = "JNDI_";

    /*
     * Example:
     *
     * DB2_DatabaseURL=jdbc\:arjuna\:sequelink\://qa02\:20001
     * DB2_DatabaseUser=tester2
     * DB2_DatabasePassword=tester
     * DB2_DatabaseDynamicClass=
     *      com.arjuna.ats.internal.jdbc.drivers.sequelink_5_1 
     *
     * DB_JNDI_DatabaseURL=jdbc\:arjuna\:jndi
     * DB_JNDI_DatabaseUser=tester1
     * DB_JNDI_DatabasePassword=tester
     * DB_JNDI_DatabaseName=empay
     * DB_JNDI_Host=qa02
     * DB_JNDI_Port=20000
     */

    private static final char BREAKCHARACTER = ';';  // delimiter for parameters
}
</code></pre>
            </div></div><br class="example-break"/>
            
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Multiple recovery domains and resource-initiated recovery</h2>
                
                <p>
                    <code class="methodname">XAResource.recover</code>
                    returns the list of all transactions that are in-doubt with in the
                    datasource. If multiple
                    recovery domains are used with a single datasource, resource-initiated recovery sees
                    transactions from other domains. Since it does not have a
                    <code class="systemitem">JTA_ResourceRecord</code>
                    available, it rolls back the transaction in the database, if the Xid appears in successive
                    recover calls. To
                    suppress resource-initiated recovery, do not supply an
                    <code class="varname">XAConnectionRecovery</code>
                    property, or
                    confine it to one recovery domain.
                </p>
            </div>
        </div>

        <div class="section" title="3.2.8.2.2. Recovery behavior"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6294"/>3.2.8.2.2. Recovery behavior</h5></div></div></div>
            
            <p>
                Property
                <code class="varname">OTS_ISSUE_RECOVERY_ROLLBACK</code>
                controls whether the
                <code class="classname">RecoveryManager</code>
                explicitly issues a rollback request when
                <code class="methodname">replay_completion</code>
                asks for the status of a transaction that is unknown. According to
                the
                <code class="systemitem">presume-abort</code>
                mechanism used by OTS and JTS, the transaction can be assumed to have
                rolled back, and this
                is the response that is returned to the
                <code class="classname">Resource</code>
                , including a
                subordinate coordinator, in this case. The
                <code class="classname">Resource</code>
                should then apply that result to the
                underlying resources. However, it is also legitimate for
                the superior to issue a rollback, if
                <code class="varname">OTS_ISSUE_RECOVERY_ROLLBACK</code>
                is set to
                <code class="literal">YES</code>
                .
            </p>
            <p>
                The OTS transaction identification mechanism makes it possible for a transaction coordinator
                to hold a
                <code class="classname">Resource</code>
                reference that will never be usable. This can occur in two cases:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        The process holding the
                        <code class="classname">Resource</code>
                        crashes before receiving the commit or rollback
                        request from the coordinator.
                    </p>
                </li><li class="listitem">
                    <p>
                        The
                        <code class="classname">Resource</code>
                        receives the commit or rollback, and responds. However, the message is
                        lost or the
                        coordinator process has crashed.
                    </p>
                </li></ul></div>
            <p>
                In the first case, the
                <code class="classname">RecoveryManager</code>
                for the
                <code class="classname">Resource</code>
                <code class="classname">ObjectStore</code>
                eventually reconstructs a new
                <code class="classname">Resource</code>
                (with a
                different CORBA object reference (IOR), and issues a
                <code class="methodname">replay_completion</code>
                request
                containing the new
                <code class="classname">Resource</code>
                IOR. The
                <code class="classname">RecoveryManager</code>
                for the
                coordinator substitutes this in place of the original, useless one, and issues
                <code class="methodname">commit</code>
                to the new reconstructed
                <code class="classname">Resource</code>
                . The
                <code class="classname">Resource</code>
                has to have been
                in a commit state, or there would be no transaction intention list. Until
                the
                <code class="methodname">replay_completion</code>
                is received, the
                <code class="classname">RecoveryManager</code>
                tries to send
                <code class="methodname">commit</code>
                to its
                <code class="classname">Resource</code>
                reference.–This will fail with a CORBA
                System Exception. Which exception depends on the ORB
                and other details.
            </p>
            <p>
                In the second case, the
                <code class="classname">Resource</code>
                no longer exists. The
                <code class="classname">RecoveryManager</code>
                at the coordinator will never get through, and will receive System
                Exceptions forever.
            </p>
            <p>
                The
                <code class="classname">RecoveryManager</code>
                cannot distinguish these two cases by any protocol mechanism. There
                is a perceptible cost in
                repeatedly attempting to send the commit to an inaccessible
                <code class="classname">Resource</code>
                . In particular, the timeouts involved will extend the recovery iteration time,
                and thus
                potentially leave resources inaccessible for longer.
            </p>
            <p>
                To avoid this, the
                <code class="classname">RecoveryManager</code>
                only attempts to send
                <code class="methodname">commit</code>
                to a
                <code class="classname">Resource</code>
                a limited number of times. After that, it considers the transaction
                <span>assumed complete</span>
                . It retains the information about the transaction, by changing the object type
                in the
                <code class="classname">ActionStore</code>
                , and if the
                <code class="classname">Resource</code>
                eventually does wake up
                and a
                <code class="methodname">replay_completion</code>
                request is received, the
                <code class="classname">RecoveryManager</code>
                activates the transaction and issues the commit request to the new Resource IOR. The number
                of times the
                <code class="classname">RecoveryManager</code>
                attempts to issue
                <code class="methodname">commit</code>
                as part of the periodic
                recovery is controlled by the property variable
                <code class="varname">COMMITTED_TRANSACTION_RETRY_LIMIT</code>
                , and
                defaults to
                <code class="literal">3</code>
                .
            </p>
        </div>

        <div class="section" title="3.2.8.2.3. Expired entry removal"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6348"/>3.2.8.2.3. Expired entry removal</h5></div></div></div>
            
            <p>
                The operation of the recovery subsystem causes some entries to be made in the
                <code class="classname">ObjectStore</code>
                that are not removed in normal progress. The
                <code class="classname">RecoveryManager</code>
                has a facility for scanning
                for these and removing items that are very old. Scans and
                removals are performed by implementations of the
                <code class="interfacename">&gt;com.arjuna.ats.arjuna.recovery.ExpiryScanner</code>
                . Implementations of this interface
                are loaded by giving the class names as the value of the
                property
                <code class="varname">RecoveryEnvironmentBean.expiryScannerClassNames</code>
                . The
                <code class="classname">RecoveryManager</code>
                calls the
                <code class="methodname">scan</code>
                method on each loaded
                <code class="classname">ExpiryScanner</code>
                implementation at an
                interval determined by the property
                <code class="varname">RecoveryEnvironmentBean.expiryScanInterval</code>
                . This value is
                given in hours, and defaults to
                <code class="literal">12</code>
                . A property value of
                <code class="literal">0</code>
                disables any
                expiry scanning. If the value as supplied is positive, the first scan is
                performed when
                <code class="classname">RecoveryManager</code>
                starts. If the value is negative, the first scan is delayed until after
                the first interval,
                using the absolute value.
            </p>
            <p>
                There are two kinds of item that are scanned for expiry:
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col width="100px"/><col width="350px"/></colgroup><tbody><tr><td>Contact items</td><td>
                                <p>
                                    One contact item is created by every application process that uses .
                                    They
                                    contain the
                                    information that the
                                    <code class="classname">RecoveryManager</code>
                                    uses to determine if the process that
                                    initiated the transaction is still alive, and
                                    what the transaction status is. The expiry time for
                                    these is set by the property
                                    <code class="varname">RecoveryEnvironmentBean.transactionStatusManagerExpiryTime</code>
                                    , which is expressed in
                                    hours. The default is
                                    <code class="literal">12</code>
                                    , and
                                    <code class="literal">0</code>
                                    suppresses the expiration. This
                                    is the interval after which a process that cannot
                                    be contacted is considered to be dead. It should be
                                    long enough to avoid
                                    accidentally removing valid entries due to short-lived transient errors such as
                                    network downtime.
                                </p>
                            </td></tr><tr><td>Assumed complete transactions</td><td>
                                <p>
                                    The expiry time is counted from when the transactions were assumed to be complete.
                                    A
                                    <code class="methodname">replay_completion</code>
                                    request resets the clock. The risk with removing assumed
                                    complete transactions it
                                    that a prolonged communication outage means that a remote
                                    <code class="classname">Resource</code>
                                    cannot connect to the
                                    <code class="classname">RecoveryManager</code>
                                    for the
                                    parent transaction. If the assumed complete transaction entry is expired
                                    before the communications are
                                    recovered, the eventual
                                    <code class="methodname">replay_completion</code>
                                    will find no information and the
                                    <code class="classname">Resource</code>
                                    will be rolled back, although the transaction committed. Consequently,
                                    the expiry
                                    time for assumed complete transactions should be set to a value that exceeds any
                                    anticipated network outage. The parameter is
                                    <code class="varname">ASSUMED_COMPLETE_EXPIRY_TIME</code>
                                    . It is
                                    expressed in hours, with
                                    <code class="literal">240</code>
                                    being the default, and
                                    <code class="literal">0</code>
                                    meaning
                                    never to expire.
                                </p>
                            </td></tr></tbody></table>
            </div>
            <div class="example"><a id="d5e6388"/><p class="title"><strong>Example 3.30. ExpiryScanner properties</strong></p><div class="example-contents">
                
                <pre><code class="language-xml">&lt;entry key="RecoveryEnvironmentBean.expiryScannerClassNames"&gt;
  com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner
  com.arjuna.ats.internal.jts.recovery.contact.ExpiredContactScanner
  com.arjuna.ats.internal.jts.recovery.transactions.ExpiredToplevelScanner
  com.arjuna.ats.internal.jts.recovery.transactions.ExpiredServerScanner
&lt;/entry&gt;
</code></pre>
            </div></div><br class="example-break"/>
            <p>
                There are two
                <code class="classname">ExpiryScannner</code>
                s for the assumed complete transactions, because there are
                different types in the
                ActionStore.
            </p>
        </div>

        <div class="section" title="3.2.8.2.4. Recovery domains"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6393"/>3.2.8.2.4. Recovery domains</h5></div></div></div>
            
            <p>
                A key part of the recovery subsystem is that the
                <code class="classname">RecoveryManager</code>
                hosts the OTS
                <code class="classname">RecoveryCoordinator</code>
                objects that handle recovery for transactions initiated in
                application processes. Information
                passes between the application process and the
                <code class="classname">RecoveryManager</code>
                in one of three ways:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        <code class="classname">RecoveryCoordinator</code>
                        object references (IORs) are created in the application
                        process. They contain information
                        identifying the transaction in the object key. They pass the object key to
                        the
                        <code class="classname">Resource</code>
                        objects, and the
                        <code class="classname">RecoveryManager</code>
                        receives it.
                    </p>
                </li><li class="listitem">
                    <p>
                        The application process and the
                        <code class="classname">RecoveryManager</code>
                        access the same
                        <code class="filename">jbossts-properties.xml</code>
                        , and therefore use the same
                        <code class="classname">ObjectStore</code>
                        .
                    </p>
                </li><li class="listitem">
                    <p>
                        The
                        <code class="classname">RecoveryCoordinator</code>
                        invokes CORBA directly in the application, using information
                        in the contact items.
                        Contact items are kept in the
                        <code class="classname">ObjectStore</code>
                        .
                    </p>
                </li></ul></div>
            <p>
                Multiple recovery domains may useful if you are doing a migration, and separate
                <code class="classname">ObjectStores</code>
                are useful. However, multiple RecoveryManagers can cause problems with XA
                datasources if
                resource-initiated recovery is active on any of them.
            </p>
        </div>
    </div>

    <div class="section" title="3.2.8.3.  Transaction status and replay_comparison"><div class="titlepage"><div><div><h4 class="title"><a id="d5e6416"/>3.2.8.3. 
            Transaction status and
            <code class="methodname">replay_comparison</code>
        </h4></div></div></div>
        
        <p>
            When a transaction successfully commits, the transaction log is removed from the system. The
            log is no longer
            required, since all registered Resources have responded successfully to the
            two-phase commit sequence. However, if
            a
            <code class="classname">Resource</code>
            calls
            <code class="methodname">replay_completion</code>
            on the
            <code class="classname">RecoveryCoordinator</code>
            after the transaction it represents commits, the status returned is
            <code class="classname">StatusRolledback</code>
            . The transaction system does not keep a record of committed transactions,
            and assumes that in
            the absence of a transaction log, the transaction must have rolled back. This is in line with
            the
            <code class="systemitem">presumed abort protocol</code>
            used by the OTS.
        </p>
    </div>
</div>
        <div class="section" title="3.2.9. JTA and JTS"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6425"/>3.2.9. JTA and JTS</h3></div></div></div>
    

    <div class="section" title="3.2.9.1. Distributed JTA"><div class="titlepage"><div><div><h4 class="title"><a id="d5e6427"/>3.2.9.1. Distributed JTA</h4></div></div></div>
        
        <p>
            This guide describes how to use the JTA interfaces for purely local transactions. This is a high-performance
            implementation, but you can only use it to execute transactions within the same process. If you need support
            for
            distributed transactions, the JTA needs to use the JTS. Another advantage of this approach is interoperability
            with other JTS-compliant transaction systems.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                If you use the JTS and JTA interfaces to manage the same transactions, the JTA needs to be configured to be
                aware of the JTS. Otherwise, local transactions will be unaware of their JTS counterparts.
            </p>
        </div>
        <p>
            You need to do this configuration manually, because some applications may be using 
            in a purely local
            manner, or may need to differentiate between transactions managed by JTS and JTA.
        </p>
        <div class="procedure" title="Procedure 3.4. Making the JTA interfaces JTS-aware"><a id="d5e6433"/><p class="title"><strong>Procedure 3.4. Making the JTA interfaces JTS-aware</strong></p><ol class="procedure" type="1"><li class="step" title="Step 1">
                <p>
                    Set
                    <code class="varname">JTAEnvironmentBean.jtaTMImplementation</code>
                    to
                    <code class="literal">com.arjuna.ats.internal.jta.transaction.jts.TransactionManagerImple</code>
                    .
                </p>
            </li><li class="step" title="Step 2">
                <p>
                    Set
                    <code class="varname">JTAEnvironmentBean.jtaUTImplementation</code>
                    to
                    <code class="literal">com.arjuna.ats.internal.jta.transaction.jts.UserTransactionImple</code>
                    .
                </p>
            </li></ol></div>
    </div>
</div>
        <div class="section" title="3.2.10. ORB-specific configuration"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6443"/>3.2.10. ORB-specific configuration</h3></div></div></div>
    

    <div class="section" title="3.2.10.1. JacORB"><div class="titlepage"><div><div><h4 class="title"><a id="d5e6445"/>3.2.10.1. JacORB</h4></div></div></div>
        
        <p>
            Take care to use only the patched version of JacORB shipped with .
            Correct functioning of the transaction
            system, particularly with regard to crash recovery, is unlikely to work with an unpatched JacORB. For each
            deployment of JacORB, ensure that the
            <code class="varname">jacorb.implname</code>
            in the
            <code class="filename">jacorb.properties</code>
            file is unique.
        </p>
    </div>
</div>
    </div>
    <div class="section" title="3.3. ORB Portability"><div class="titlepage"><div><div><h2 class="title"><a id="d5e6450"/>3.3. ORB Portability</h2></div></div></div>
        
        <div class="section" title="3.3.1. ORB Portability Introduction"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6452"/>3.3.1. ORB Portability Introduction</h3></div></div></div>
    
    <p>
        This part of the guide contains information on how to use the ORB Portability Layer.
        Although the CORBA specification is a standard, it is
        written
        in such a way that allows for a wide
        variety of implementations. Unless writing extremely simple applications, differences between
        ORB
        implementations tend to produce code which cannot easily be moved between ORBs. This is
        especially true for server-side code, which suffers from
        the widest variation between ORBs. There
        have also been a number of revisions of the Java language mapping for IDL and for CORBA itself.
        Many ORBs
        currently in use support different versions of CORBA and/or the Java language mapping.
    </p>
    <p>The Narayana
        only supports the new Portable Object Adapter (POA) architecture described in the CORBA 2.3
        specification as a
        replacement for the Basic Object
        Adapter (BOA). Unlike the BOA, which was
        weakly specified and led to a number of different (and often
        conflicting) implementations, the
        POA was
        deliberately designed to reduce the differences between ORB implementations, and thus
        minimize the
        amount of re-coding that would need to be done
        when porting applications from one ORB
        to another. However, there is still scope for slight
        differences between ORB implementations,
        notably in the
        area of threading. Note, instead of talking about the POA, this manual will
        consider the
        Object Adapter (OA).
    </p>
    <p>
        Because the Narayana
        must be able to run on a number of different ORBs, we have developed an ORB portability
        interface which allows entire
        applications to be moved
        between ORBs with little or no
        modifications. This portability interface is available to the application programmer in
        the form
        of several Java
        classes. Note, the classes to be described in this document are located in the
        <code class="literal">com.arjuna.orbportability</code>
        package.
    </p>
</div>
        <div class="section" title="3.3.2. ORB Portability API"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6458"/>3.3.2. ORB Portability API</h3></div></div></div>

    


    <div class="section" title="3.3.2.1. Using the ORB and OA"><div class="titlepage"><div><div><h4 class="title"><a id="d5e6460"/>3.3.2.1. Using the ORB and OA</h4></div></div></div>
        
        <p>
            The
            <code class="literal">ORB</code>
            class shown below provides a uniform way of using the ORB. There are methods for obtaining a
            reference to the ORB, and for placing the
            application into a mode where it listens for incoming
            connections. There are also methods for registering application specific classes to be
            invoked
            before or after ORB initialisation. Note, some of the methods are not supported on all ORBs,
            and in this situation, a suitable exception
            will be thrown. The ORB class is a factory class
            which has no public constructor. To create an instance of an ORB you must call the getInstance
            method passing a unique name as a parameter. If this unique name has not been passed in a
            previous call to getInstance you will be returned a
            new ORB instance. Two invocations of
            getInstance made with the same unique name, within the same JVM, will return the same ORB
            instance.
        </p>
        <div class="example"><a id="d5e6464"/><p class="title"><strong>Example 3.31. 
                <code class="filename">ORB.java</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java"> public class ORB {
	public static ORB getInstance(String uniqueId);

	public synchronized void initORB()
			throws SystemException;

	public synchronized void initORB(Applet a, Properties p)
			throws SystemException;

	public synchronized void initORB(String[] s,
			Properties p) throws SystemException;

	public synchronized org.omg.CORBA.ORB orb();

	public synchronized boolean setOrb(
			org.omg.CORBA.ORB theORB);

	public synchronized void shutdown();

	public synchronized boolean addAttribute(Attribute p);

	public synchronized void addPreShutdown(PreShutdown c);

	public synchronized void addPostShutdown(PostShutdown c);

	public synchronized void destroy()
			throws SystemException;

	public void run();

	public void run(String name);
}
 </code></pre>
        </div></div><br class="example-break"/>
        <p>We shall now describe the various methods of the ORB class.</p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    <code class="literal">initORB</code>
                    : given the various parameters, this method initialises the ORB and retains a reference to
                    it within the ORB class. This method should be
                    used in preference to the raw ORB interface
                    since the
                    <span class="emphasis"><em>
                    </em></span>
                    requires a reference to the ORB. If this method is not used, setOrb must be called prior
                    to using
                    <span class="emphasis"><em>
                    </em></span>
                    .
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">orb</code>
                    : this method returns a reference to the ORB. After shutdown is called this reference may
                    be null.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">shutdown</code>
                    : where supported, this method cleanly shuts down the ORB. Any pre- and post- ORB shutdown
                    classes which have been registered will also be
                    called. See the section titled ORB and OA
                    Initialisation. This method must be called prior to application termination. It is the
                    application
                    programmer’s responsibility to ensure that no objects or threads continue to
                    exist which require access to the ORB. It is ORB implementation
                    dependant as to whether or
                    not outstanding references to the ORB remain useable after this call.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">addAttribute</code>
                    : this method allows the application to register classes with 
                    which will be called either before, or after the ORB
                    has been initialised. See the section
                    titled ORB and OA Initialisation. If the ORB has already been initialised then the
                    attribute object
                    will not be added, and false will be returned.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">run</code>
                    : these methods place the ORB into a listening mode, where it waits for incoming
                    invocations.
                </p>
            </li></ul></div>
        <p>The OA classes shown below provide a uniform way of using Object Adapters (OA). There are
            methods for obtaining a reference to the OA. There
            are also methods for registering application
            specific classes to be invoked before or after OA initialisation. Note, some of the methods
            are not
            supported on all ORBs, and in this situation, a suitable exception will be thrown. The
            OA class is an abstract class and provides the basic
            interface to an Object Adapter. It has two
            sub-classes RootOA and ChildOA, these classes expose the interfaces specific to the root
            Object
            Adapter and a child Object Adapter respectively. From the RootOA you can obtain a
            reference to the RootOA for a given ORB by using the static
            method getRootOA. To create a
            ChildOA instance use the createPOA method on the RootOA.
        </p>
        <div class="example"><a id="d5e6488"/><p class="title"><strong>Example 3.32. 
                <code class="filename">OA.java</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java"> public abstract class OA {
	public synchronized static RootOA getRootOA(
			ORB associatedORB);

	public synchronized void initPOA()
			throws SystemException;

	public synchronized void initPOA(String[] args)
			throws SystemException;

	public synchronized void initOA()
			throws SystemException;

	public synchronized void initOA(String[] args)
			throws SystemException;

	public synchronized ChildOA createPOA(
			String adapterName, PolicyList policies)
			throws AdapterAlreadyExists, InvalidPolicy;

	public synchronized org.omg.PortableServer.POA rootPoa();

	public synchronized boolean setPoa(
			org.omg.PortableServer.POA thePOA);

	public synchronized org.omg.PortableServer.POA poa(
			String adapterName);

	public synchronized boolean setPoa(String adapterName,
			org.omg.PortableServer.POA thePOA);

	public synchronized boolean addAttribute(OAAttribute p);

	public synchronized void addPreShutdown(OAPreShutdown c);

	public synchronized void addPostShutdown(
			OAPostShutdown c);
}

public class RootOA extends OA {
	public synchronized void destroy()
			throws SystemException;

	public org.omg.CORBA.Object corbaReference(Servant obj);

	public boolean objectIsReady(Servant obj, byte[] id);

	public boolean objectIsReady(Servant obj);

	public boolean shutdownObject(org.omg.CORBA.Object obj);

	public boolean shutdownObject(Servant obj);
}

public class ChildOA extends OA {
	public synchronized boolean setRootPoa(POA thePOA);

	public synchronized void destroy()
			throws SystemException;

	public org.omg.CORBA.Object corbaReference(Servant obj);

	public boolean objectIsReady(Servant obj, byte[] id)
			throws SystemException;

	public boolean objectIsReady(Servant obj)
			throws SystemException;

	public boolean shutdownObject(org.omg.CORBA.Object obj);

	public boolean shutdownObject(Servant obj);
}
 </code></pre>
        </div></div><br class="example-break"/>
        <p>We shall now describe the various methods of the OA class.</p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    <code class="literal">initPOA</code>
                    : this method activates the POA, if this method is called on the RootPOA the POA with the
                    name RootPOA will be activated.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">createPOA</code>
                    : if a child POA with the specified name for the current POA has not already been created
                    then this method will create and activate one,
                    otherwise AdapterAlreadyExists will be
                    thrown. This method returns a ChildOA object.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">initOA</code>
                    : this method calls the initPOA method and has been retained for backwards compatibility.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">rootPoa</code>
                    : this method returns a reference to the root POA. After destroy is called on the root POA
                    this reference may be null.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">poa</code>
                    : this method returns a reference to the POA. After destroy is called this reference may
                    be null.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">destroy</code>
                    : this method destroys the current POA, if this method is called on a RootPOA instance
                    then the root POA will be destroyed along with its
                    children.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">shutdown</code>
                    : this method shuts down the POA.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">addAttribute</code>
                    : this method allows the application to register classes with 
                    which will be called either before or after the OA
                    has been initialised. See below. If the
                    OA has already been initialised then the attribute object will not be added, and false
                    will be
                    returned.
                </p>
            </li></ul></div>
        <div class="section" title="3.3.2.1.1. ORB and OA Initialisation"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6518"/>3.3.2.1.1. ORB and OA Initialisation</h5></div></div></div>
            
            <p>
                It is possible to register application specific code with the ORB portability library which
                can be executed either before or after the ORB or
                OA are initialised. Application programs
                can inherit from either
                <code class="literal">com.arjuna.orbportability.orb.Attribute</code>
                or
                <code class="literal">com.arjuna.orbportability.oa.Attribute</code>
                and pass these instances to the addAttribute method of the ORB/OA classes respectively:
            </p>
            <div class="example"><a id="d5e6523"/><p class="title"><strong>Example 3.33. 
                    <code class="filename">Attribute.java</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java"> package com.arjuna.orbportability.orb;
public abstract class Attribute {
	public abstract void initialise(String[] params);

	public boolean postORBInit();
};

package com.arjuna.orbportability.oa;
public abstract class OAAttribute {
	public abstract void initialise(String[] params);

	public boolean postOAInit();
};
 </code></pre>
            </div></div><br class="example-break"/>
            <p>
                By default, the
                <code class="literal">postORBInit/postOAInit</code>
                methods return true, which means that any
                instances of derived classes will be invoked after
                either
                the ORB or OA have been
                initialised. By redefining this to return false, a particular
                instance will be invoked
                before either the ORB or OA
                have been initialised.
            </p>
            <p>When invoked, each registered instance will be provided with the exact String parameters
                passed to the initialise method for the ORB/OA.
            </p>
        </div>
        <div class="section" title="3.3.2.1.2. ORB and OA shutdown"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6530"/>3.3.2.1.2. ORB and OA shutdown</h5></div></div></div>
            
            <p>
                It is possible to register application specific code (via the
                <code class="literal">addPreShutdown/addPostShutdown</code>
                methods) with the ORB portability library which will be
                executed prior to, or after, shutting
                down the ORB. The pre/post interfaces which are to be
                registered have a single work method,
                taking no parameters and returning no results. When
                the ORB and OA are being shut down (using
                <code class="literal">shutdown/destroy</code>
                ), each registered class will have
                its work method invoked.
            </p>
            <div class="example"><a id="d5e6535"/><p class="title"><strong>Example 3.34. 
                    <code class="filename">Shutdown.java</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java"> public abstract class PreShutdown {
	public abstract void work();
}

public abstract class PostShutdown {
	public abstract void work();
}
 </code></pre>
            </div></div><br class="example-break"/>
        </div>
        <div class="section" title="3.3.2.1.3. Specifying the ORB to use"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6539"/>3.3.2.1.3. Specifying the ORB to use</h5></div></div></div>
            
            <p>
                JDK releases from 1.2.2 onwards include a minimum ORB implementation from Sun. If using
                such
                a JDK in conjunction with another ORB it is necessary to tell the JVM which ORB to use.
                This
                happens by specifying the
                <code class="literal">org.omg.CORBA.ORBClass</code>
                and
                <code class="literal">org.omg.CORBA.ORBSingletonClass</code>
                properties. The ORB Portability classes will ensure that these properties are automatically
                set when required, i.e., during ORB initialisation. Of course it is still possible to
                specify these values explicitly (and necessary if not using the ORB initialisation methods).
                Note: if you do not use the ORB Portability classes for ORB initialisation then it will
                still be necessary to set these properties. The ORB portability library attempts to detect
                which ORB is in use, it does this by looking for the ORB implementation class for each ORB
                it supports. This means that if there are classes for more than one ORB in the classpath the
                wrong ORB can be detected. Therefore it is best to only have one ORB in your classpath. If
                it is necessary to have multiple ORBs in the classpath then the property
                <code class="literal">OrbPortabilityEnvironmentBean.orbImplementation</code>
                must be set to the value specified in the
                table below.
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>ORB</th><th>Property Value</th></tr></thead><tbody><tr><td>
                                <p>JacORB v2</p>
                            </td><td>
                                <p>
                                    <code class="literal">com.arjuna.orbportability.internal.orbspecific.jacorb.orb.implementations.jacorb_2_0
                                    </code>
                                </p>
                            </td></tr><tr><td>
                                <p>JDK miniORB</p>
                            </td><td>
                                <p>
                                    <code class="literal">com.arjuna.orbportability.internal.orbspecific.javaidl.orb.implementations.javaidl_1_4
                                    </code>
                                </p>
                            </td></tr></tbody></table>
            </div>
        </div>
        <div class="section" title="3.3.2.1.4. Initialisation code"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6564"/>3.3.2.1.4. Initialisation code</h5></div></div></div>
            
            <p>
                The
                <span class="emphasis"><em>
                </em></span>
                requires specialised code to be instantiated before and
                after the ORB and the OA are
                initialised. This code can be provided at runtime through the
                use of
                OrbPortabilityEnvironmentBean.orbInitializationProperties This mechanism is also
                available to
                programmers who can register arbitrary code which the ORB Portability will
                guarantee to be
                instantiated either before or after ORB/OA initialisation. For each
                application (and each
                execution of the same application) the programmer can simultaneously
                provide multiple Java
                classes which are instantiated before and after the ORB and or OA is
                initialised. There are
                few restrictions on the types and numbers of classes which can be
                passed to an application at
                execution time. All classes which are to be instantiated must
                have a public default
                constructor, i.e., a constructor which takes no parameters. The
                classes can have any name.
                The property names used must follow the format specified below:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        <span class="emphasis"><em>com..orbportability.orb.PreInit</em></span>
                        – this property is used to specify a global
                        pre-initialisation routine which will be run
                        before any ORB is initialised.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>com..orbportability.orb.PostInit</em></span>
                        – this property is used to specify a global
                        post-initialisation routine which will be run
                        after any ORB is initialised.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>com..orbportability.orb.&lt;ORB NAME&gt;.PreInit</em></span>
                        – this property is used to specify a pre-initialisation routine which
                        will be run when an
                        ORB with the given name is initialised.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>com..orbportability.orb.&lt;ORB NAME&gt;.PostInit</em></span>
                        – this property is used to specify a post-initialisation routine
                        which will be run after
                        an ORB with the given name is initialised.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>com..orbportability.oa.PreInit</em></span>
                        – this property is used to specify a global
                        pre-initialisation routine which will be run
                        before any OA is initialised.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>com..orbportability.oa.PostInit</em></span>
                        – this property is used to specify a global
                        post-initialisation routine which will be run
                        after any OA is initialised,
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>com..orbportability.oa.&lt;ORB NAME&gt;.PreInit</em></span>
                        – this property is used to specify a pre-initialisation routine which
                        will be run before
                        an OA with the given name is initialised
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>com..orbportability.oa.&lt;ORB NAME&gt;.PostInit</em></span>
                        – this property is used to specify a pre-initialisation routine which
                        will be run after
                        an OA with the given name is initialised
                    </p>
                </li></ul></div>
            <p>Pre and post initialisation can be arbitrarily combined, for example:</p>
            <p>
                </p><pre><code class="no-highlight">java –DorbPortabilityEnvironmentBean.orbInitializationProperties=”com..orbportability.orb.PreInit=org.foo.AllORBPreInit com..orbportability.orb.MyORB.PostInit=org.foo.MyOrbPostInit com..orbportability.oa.PostInit=orb.foo.AllOAPostInit” org.foo.MyMainClass</code></pre><p>
            </p>
        </div>
        <div class="section" title="3.3.2.1.5. Locating Objects and Services"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6596"/>3.3.2.1.5. Locating Objects and Services</h5></div></div></div>
            
            <p>Locating and binding to distributed objects within CORBA can be ORB specific. For
                example, many ORBs provide implementations of the naming service, whereas some others may
                rely upon proprietary mechanisms. Having to deal with the many possible ways of binding to
                objects can be a difficult task, especially if portable applications are to be constructed.
                ORB Portability provides the Services class in order to provide a more manageable, and
                portable binding mechanism. The implementation of this class takes care of any ORB specific
                locations mechanisms, and provides a single interface to a range of different object
                location implementations.
            </p>
            <div class="example"><a id="d5e6599"/><p class="title"><strong>Example 3.35. 
                    <code class="filename">Services.java</code>
                </strong></p><div class="example-contents">
                
                <pre><code class="language-java"> public class Services {
	/**
	 * The various means used to locate a service.
	 */

	public static final int RESOLVE_INITIAL_REFERENCES = 0;
	public static final int NAME_SERVICE = 1;
	public static final int CONFIGURATION_FILE = 2;
	public static final int FILE = 3;
	public static final int NAMED_CONNECT = 4;
	public static final int BIND_CONNECT = 5;

	public static org.omg.CORBA.Object getService(
			String serviceName, Object[] params,
			int mechanism) throws InvalidName,
			CannotProceed, NotFound, IOException;

	public static org.omg.CORBA.Object getService(
			String serviceName, Object[] params)
			throws InvalidName, CannotProceed, NotFound,
			IOException;

	public static void registerService(
			org.omg.CORBA.Object objRef,
			String serviceName, Object[] params,
			int mechanism) throws InvalidName, IOException,
			CannotProceed, NotFound;

	public static void registerService(
			org.omg.CORBA.Object objRef,
			String serviceName, Object[] params)
			throws InvalidName, IOException, CannotProceed,
			NotFound;
}
 </code></pre>
            </div></div><br class="example-break"/>
            <p>There are currently several different object location and binding mechanisms supported
                by
                Services (not all of which are supported by all ORBs, in which case a suitable exception
                will be thrown):
            </p>
            <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                    <p>
                        <span class="emphasis"><em>RESOLVE_INITIAL_REFERENCES</em></span>
                        : if the ORB supported resolve_initial_references, then Services will attempt to use
                        this to locate the object.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>NAME_SERVICE</em></span>
                        : Services will contact the name service for the object. The name service will be
                        located using
                        <code class="literal">resolve_initial_references</code>
                        .
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>CONFIGURATION_FILE</em></span>
                        : as described in the Using the OTS Manual, the 
                        supports an
                        initial reference file where references for specific services and objects can be stored
                        and used at runtime. The file, CosServices.cfg, consists of two columns: the service
                        name (in the case of the OTS server TransactionService) and the IOR, separated by a
                        single space. CosServices.cfg is located at runtime by the OrbPortabilityEnvironmentBean
                        properties initialReferencesRoot (a directory, defaulting to the current working
                        directory) and initialReferencesFile (a name relative to the directory,'CosServices.cfg'
                        by default).
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>FILE</em></span>
                        : object IORs can be read from, and written to, application specific files. The service
                        name is used as the file name.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>NAMED_CONNECT</em></span>
                        : some ORBs support proprietary location and binding mechanisms.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>BIND_CONNECT</em></span>
                        : some ORBs support the bind operation for locating services.
                    </p>
                </li></ol></div>
            <p>We shall now describe the various methods supported by the Services class:</p>
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        <span class="emphasis"><em>getService</em></span>
                        : given the name of the object or service to be located (serviceName), and the type of
                        mechanism to be used (mechanism), the programmer must also supply location mechanism
                        specific parameters in the form of params. If the name service is being used, then
                        params[0] should be the String kind field.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>getService</em></span>
                        : the second form of this method does not require a location mechanism to be supplied,
                        and will use an ORB specific default. The default for each ORB is shown in Table 2.
                    </p>
                </li><li class="listitem">
                    <p>
                        <span class="emphasis"><em>registerService</em></span>
                        : given the object to be registered, the name it should be registered with, and the
                        mechanism to use to register it, the application programmer must specify location
                        mechanism specific parameters in the form of params. If the name service is being used,
                        then params[0] should be the String kind field.
                    </p>
                </li></ul></div>
        </div>
        <div class="section" title="3.3.2.1.6. ORB location mechanisms"><div class="titlepage"><div><div><h5 class="title"><a id="d5e6635"/>3.3.2.1.6. ORB location mechanisms</h5></div></div></div>
            
            <p>The following table summarises the different location mechanisms that ORB Portability
                supports for each ORB via the Services class:
            </p>
            <div class="informaltable">
                <table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Location Mechanism</th><th>ORB</th></tr></thead><tbody><tr><td>
                                <p>CONFIGURATION_FILE</p>
                            </td><td>
                                <p>All available ORBs</p>
                            </td></tr><tr><td>
                                <p>FILE</p>
                            </td><td>
                                <p>All available ORBs</p>
                            </td></tr><tr><td>
                                <p>BIND_CONNECT</p>
                            </td><td>
                                <p>None</p>
                            </td></tr></tbody></table>
            </div>
            <p>If a location mechanism isn’t specified then the default is the configuration file.
            </p>
        </div>
    </div>
</div>
    </div>
    <div class="section" title="3.4. Quick Start to JTS/OTS"><div class="titlepage"><div><div><h2 class="title"><a id="d5e6661"/>3.4. Quick Start to JTS/OTS</h2></div></div></div>
    
    <div class="section" title="3.4.1. Introduction"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6663"/>3.4.1. Introduction</h3></div></div></div>
        
        <p>This
            chapter will briefly cover the key features required to construct a basic OTS application using the raw OTS
            interfaces defined by the
            OMG
            specification. It is assumed that the reader is familiar with the concepts of the JTS/OTS and has read the relevant ORB specific
            portions of
            the Narayana
            Programmer’s Guide. Further topics and the advanced facilities provided by Narayana
            will be described in subsequent sections of this
            manual; references to chapters in the other manuals of the document set will be given in the
            relevant sections.
        </p>
    </div>
    <div class="section" title="3.4.2. Package layout"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6666"/>3.4.2. Package layout</h3></div></div></div>
        
        <p>The key Java packages (and corresponding jar files) for writing basic OTS applications are:</p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>com.arjuna.orbportability: this package contains the classes which constitute the ORB portability
                    library and other useful utility
                    classes.
                </p>
            </li><li class="listitem">
                <p>org.omg.CosTransactions: this package contains the classes which make up the CosTransactions.idl
                    module.</p>
            </li><li class="listitem">
                <p>com.arjuna.ats.jts:
                    this package contains the Narayana
                    implementations of the JTS and JTA.
                </p>
            </li><li class="listitem">
                <p>com.arjuna.ats.arjuna:
                    this package contains further classes necessary for the Narayana
                    implementation of the JTS.
                </p>
            </li><li class="listitem">
                <p>com.arjuna.ats.jta: this package contains local and remote JTA implementation support.</p>
            </li><li class="listitem">
                <p>com.arjuna.ats.jdbc: this package contains transactional JDBC support.</p>
            </li></ul></div>
        <p>All
            of these packages appear in the lib directory of the Narayana
            installation, and should be added to the programmer’s CLASSPATH.
        </p>
        <p>In
            order to fully utilize all of the facilities available within Narayana,
            it will be necessary to add the some additional jar files to your
            classpath. See bin/setup-env.sh or bin\setup-env.bat for details.
        </p>
    </div>
    <div class="section" title="3.4.3. Setting properties"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6684"/>3.4.3. Setting properties</h3></div></div></div>
        
        <p>Narayana
            has been designed to be highly configurable at runtime through the use of various property attributes, which
            will be described in
            subsequent
            sections. Although these attributes can be provided at runtime on the command line, it is possible (and may be more
            convenient) to
            specify them
            through the single properties file Narayana-properties.xml.
            At runtime Narayana
            looks for its property file in the following order:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>a location specified by a system property, allowing the normal search path to be overridden.
                </p>
            </li><li class="listitem">
                <p>the current working directory, i.e., where the application was executed from.</p>
            </li><li class="listitem">
                <p>the user’s home directory.</p>
            </li><li class="listitem">
                <p>java.home</p>
            </li><li class="listitem">
                <p>the CLASSPATH, which normally includes the installations etc dir</p>
            </li><li class="listitem">
                <p>A default set of properties embedded in the .jar file.</p>
            </li></ul></div>
        <p>Where properties are defined in both the system properties e.g. -Dfoo=bar and in the properties file, the
            value from the system property
            takes precedence. This facilitates overriding individual properties easily on the command line.
        </p>
    </div>
    <div class="section" title="3.4.4. Starting and terminating the ORB and BOA/POA"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6701"/>3.4.4. Starting and terminating the ORB and BOA/POA</h3></div></div></div>
        
        <p>It
            is important that Narayana
            is correctly initialized prior to any application object being created. In order to guarantee this, the
            programmer must use the initORB and
            initBOA/initPOA methods of the ORBInterface class described in the ORB Portability Manual. Using the
            ORB_init and BOA_init/create_POA methods
            provided by the underlying ORB will not be sufficient, and may lead to incorrectly operating
            applications. For example:
        </p>
        <div class="example"><a id="d5e6704"/><p class="title"><strong>Example 3.36. Initialize ORB</strong></p><div class="example-contents">
            
            <pre><code class="language-java"> public static void main (String[] args) {
	ORBInterface.initORB(args, null);
	ORBInterface.initOA();
	//	. . .
}
 </code></pre>
        </div></div><br class="example-break"/>
        <p>The ORBInterface class has operations orb() and boa()/poa()/rootPoa() for returning references to the orb
            and boa/child POA/root POA
            respectively after initialization has been performed. If the ORB being used does not support the BOA (e.g., Sun’s JDK 1.2) then
            boa() does not
            appear in the class definition, and initBOA will do nothing.
        </p>
        <p>In
            addition, it is necessary to use shutdownOA and shutdownORB (in that order) prior to terminating an
            application to allow Narayana
            to
            perform necessary cleanup routines. shutdownOA routine will either shutdown the BOA or the POA depending upon the ORB being
            used.
        </p>
        <div class="example"><a id="d5e6709"/><p class="title"><strong>Example 3.37. Shutdown ORB</strong></p><div class="example-contents">
            
            <pre><code class="language-java"> public static void main (String[] args) {
	// . . .
	ORBInterface.shutdownOA();
	ORBInterface.shutdownORB();
}
 </code></pre>
        </div></div><br class="example-break"/>
        <p>No further CORBA objects should be used once shutdown has been called. It will be necessary to
            re-initialise the BOA/POA and ORB in such an
            event.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                In the rest of this document we shall use the term Object Adapter to mean either the Basic Object Adapter (BOA) or the
                Portable Object
                Adapter (POA). In addition, where possible we shall use the ORB Portability classes which attempt to mask the differences
                between POA and BOA.
            </p>
        </div>
    </div>
    <div class="section" title="3.4.5. Specifying the object store location"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6715"/>3.4.5. Specifying the object store location</h3></div></div></div>
        
        <p>Narayana
            requires an object store in order to persistently record the outcomes of transactions in the event of
            failures. In order to specify
            the location
            of the object store it is necessary to specify the location when the application is executed; for example:
        </p>
        <p>
            </p><pre><code class="language-java">java –DObjectStoreEnvironmentBean.objectStoreDir=/var/tmp/ObjectStore myprogram</code></pre><p>
        </p>
        <p>The default location is a directory under the current execution directory.</p>
        <p>By default, all object states will be stored within the defaultStore subdirectory of the object store
            root, e.g.,
            /usr/local/Arjuna/TransactionService/ObjectStore/defaultStore. However, this subdirectory can be changed by setting the
            ObjectStoreEnvironmentBean.localOSRoot property variable accordingly.
        </p>
    </div>
    <div class="section" title="3.4.6. Implicit transaction propagation and interposition"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6722"/>3.4.6. Implicit transaction propagation and interposition</h3></div></div></div>
        
        <p>Transactions can be created within one domain (e.g., process) and used within another. Therefore,
            information about a transaction (the
            transaction context) needs to be propagated between these domains. This can be accomplished in two ways:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    <span class="emphasis"><em>Explicit propagation</em></span>
                    means that an application propagates a transaction context by passing context objects (instances of
                    the Control interface or the
                    PropagationContext structure) defined by the Transaction Service as explicit parameters. Note, for efficiency reasons it is
                    recommended that
                    the PropagationContext be passed, rather than the Control.
                </p>
            </li><li class="listitem">
                <p>
                    <span class="emphasis"><em>Implicit propagation</em></span>
                    means that requests on objects are implicitly associated with the client’s transaction; they share
                    the client’s transaction context. The
                    context is transmitted implicitly to the objects, without direct client intervention.
                </p>
            </li></ul></div>
        <p>OTS
            objects supporting the Control interface are standard CORBA objects. When the interface is passed as a
            parameter in some operation call
            to a
            remote server only an object reference is passed. This ensures that any operations that the remote object performs on the
            interface (such
            as
            registering resources as participants within the transaction) are performed on the real object. However, this can have
            substantial penalties
            for
            the application if it frequently uses these interfaces due to the overheads of remote invocation. To avoid this overhead Narayana
            supports
            interposition, whereby the server creates a local object which acts as a proxy for the remote transaction and fields all requests
            that
            would
            normally have been passed back to the originator. This surrogate registers itself with the original transaction coordinator
            to enable it to
            correctly participate in the termination of the transaction. Interposed coordinators effectively form a tree structure with
            their parent
            coordinators. This is shown in the figure below.
        </p>
        <div class="figure"><a id="d5e6733"/><p class="title"><strong>Figure 3.17. Interposition relationship</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="extras/interposition.gif" alt="Interposition"/></div>
        </div></div><br class="figure-break"/>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>implicit transaction propagation does not imply interposition will be used at the server, but
                (typically) interposition requires implicit
                propagation.
            </p>
        </div>
        <p>If
            implicit context propagation and interposition are required, then the programmer must ensure that Narayana
            is correctly initialised prior
            to objects being created; obviously it is necessary for both client and server to agree on which, if any, protocol
            (implicit or interposition)
            is being used. Implicit context propagation is only possible on those ORBs which either support filters/interceptors,
            or the CosTSPortability
            interface. Currently this is JacORB and the JDK miniORB. Depending upon which type of functionality is required, the
            programmer must perform the
            following:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>Implicit context propagation:</p>
                <p>set the JTSEnvironmentBean.contextPropMode property variable to CONTEXT.</p>
            </li><li class="listitem">
                <p>Interposition: </p>
                <p>set the JTSEnvironmentBean.contextPropMode property variable to INTERPOSITION.</p>
            </li></ul></div>
        <p>
            If using the Narayana
            advanced API then interposition is
            <span class="emphasis"><em>required</em></span>
            .
        </p>
    </div>
    <div class="section" title="3.4.7. Obtaining Current"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6752"/>3.4.7. Obtaining Current</h3></div></div></div>
        
        <p>The Current pseudo object can be obtained from the com.arjuna.ats.jts.OTSManager class using its
            get_current() method.</p>
    </div>
    <div class="section" title="3.4.8. Transaction termination"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6755"/>3.4.8. Transaction termination</h3></div></div></div>
        
        <p>It
            is implementation dependant as to how long a Control remains able to access a transaction after it
            terminates. In Narayana,
            if using the
            Current interface then all information about a transaction is destroyed when it terminates. Therefore, the programmer should
            not use
            any Control
            references to the transaction after issuing the commit/rollback operations.
        </p>
        <p>However, if the transaction is terminated explicitly using the Terminator interface then information about
            the transaction will be removed
            when all outstanding references to it are destroyed. However, the programmer can signal that the transaction information
            is no longer required
            using the destroyControl method of the OTS class in the com.arjuna.CosTransactions package. Once the program has indicated
            that the transaction
            information is no longer required, the same restrictions to using Control references apply as described above.
        </p>
    </div>
    <div class="section" title="3.4.9. Transaction factory"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6759"/>3.4.9. Transaction factory</h3></div></div></div>
        
        <p>
            By default, Narayana
            does not use a separate transaction manager when creating transactions through the Current interface. Each
            transactional
            client essentially has
            its own transaction manager (TransactionFactory) which is co-located with it. By setting the
            com.arjuna.ats.jts.transactionManager property
            variable to YES this can be overridden at runtime. The transaction factory is located in the bin
            directory of the Narayana
            distribution, and should be started by executing the start-transaction-service script located in
            &lt;ats_root&gt;/bin.
        </p>
        <p>Typically Current locates the factory using the CosServices.cfg file. This file is similar to
            resolve_initial_references, and is
            automatically updated (or created) when the transaction factory is started on a particular machine. This file must be copied to
            the installation
            of all machines which require to share the same transaction factory. CosServices.cfg is located at runtime by the
            OrbPortabilityEnvironmentBean
            properties initialReferencesRoot (a directory, defaulting to the current working directory) and initialReferencesFile (a name
            relative to the
            directory,'CosServices.cfg' by default).
        </p>
        <p>It is possible to override the default location mechanism by using the
            OrbPortabilityEnvironmentBean.resolveService property variable. This
            can have one of the following values:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>CONFIGURATION_FILE: the default, this causes the system to use the CosServices.cfg file.</p>
            </li><li class="listitem">
                <p>NAME_SERVICE: Narayana
                    will attempt to use a name service to locate the transaction factory. If this is not supported, an
                    exception will
                    be thrown.
                </p>
            </li><li class="listitem">
                <p>BIND_CONNECT: Narayana
                    will use the ORB-specific bind mechanism. If this is not supported, an exception will be thrown.
                </p>
            </li></ul></div>
        <p>If OrbPortabilityEnvironmentBean.resolveService is specified when the transaction factory is run, then the
            factory will register itself with
            the specified resolution mechanism.
        </p>
    </div>
    <div class="section" title="3.4.10. Recovery manager"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6772"/>3.4.10. Recovery manager</h3></div></div></div>
        
        <p>
            You will need to start the recovery manager subsystem to ensure that transactions are recovered despite failures. In
            order to do this, you
            should run the start-recovery-manager script in &lt;ats_root&gt;/bin.
        </p>
    </div>
</div>
</div>
    <div class="chapter" title="Chapter 4. XTS"><div class="titlepage"><div><div><h2 class="title"><a id="d5e6775"/>Chapter 4. XTS</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d5e6777">4.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6849">4.1.1. Managing service-Based Processes</a></span></dt><dt><span class="section"><a href="#d5e6860">4.1.2. Servlets</a></span></dt><dt><span class="section"><a href="#d5e6865">4.1.3. SOAP</a></span></dt><dt><span class="section"><a href="#d5e6869">4.1.4. Web Services Description Language (WDSL)</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e6873">4.2. Transactions Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e6935">4.2.1. The Coordinator</a></span></dt><dt><span class="section"><a href="#d5e6941">4.2.2. The Transaction Context</a></span></dt><dt><span class="section"><a href="#d5e6962">4.2.3. Participants</a></span></dt><dt><span class="section"><a href="#d5e6965">4.2.4. ACID Transactions</a></span></dt><dt><span class="section"><a href="#d5e6992">4.2.5. Two Phase Commit</a></span></dt><dt><span class="section"><a href="#d5e7015">4.2.6. The Synchronization Protocol</a></span></dt><dt><span class="section"><a href="#d5e7035">4.2.7. Optimizations to the Protocol</a></span></dt><dt><span class="section"><a href="#d5e7068">4.2.8. Non-Atomic Transactions and Heuristic Outcomes</a></span></dt><dt><span class="section"><a href="#d5e7110">4.2.9. Interposition</a></span></dt><dt><span class="section"><a href="#d5e7136">4.2.10. A New Transaction Protocol</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e7160">4.3. Overview of Protocols Used by XTS</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7198">4.3.1. WS-Coordination</a></span></dt><dt><span class="section"><a href="#d5e7254">4.3.2. WS-Transaction</a></span></dt><dt><span class="section"><a href="#d5e7499">4.3.3. Summary</a></span></dt></dl></dd></dl></div>
    
    <div class="section" title="4.1. Introduction"><div class="titlepage"><div><div><h2 class="title"><a id="d5e6777"/>4.1. Introduction</h2></div></div></div>

    

    <a id="d5e6779" class="indexterm"/>
    <a id="d5e6782" class="indexterm"/>
    <a id="d5e6784" class="indexterm"/>
    <a id="d5e6786" class="indexterm"/>
    <a id="d5e6789" class="indexterm"/>
    <a id="d5e6792" class="indexterm"/>
    <a id="d5e6795" class="indexterm"/>
    <a id="d5e6798" class="indexterm"/>
    <a id="d5e6800" class="indexterm"/>
    <a id="d5e6802" class="indexterm"/>
    <a id="d5e6804" class="indexterm"/>
    <a id="d5e6807" class="indexterm"/>
    <a id="d5e6809" class="indexterm"/>
    <a id="d5e6812" class="indexterm"/>
    <a id="d5e6815" class="indexterm"/>
    <a id="d5e6818" class="indexterm"/>

    <p>
        The
        <em class="firstterm">XML Transaction Service (XTS)</em>
        component of Narayana
        supports the
        coordination of private and public Web Services in a business transaction. Therefore, to understand XTS, you must be
        familiar with Web Services, and also understand something about transactions. This chapter introduces XTS and
        provides a brief overview of the technologies that form the Web Services standard. Additionally, this chapter
        explores some of the fundamentals of transactioning technology and how it can be applied to Web Services. Much of
        the content presented in this chapter is detailed throughout this guide. However, only overview information about
        Web Services is provided. If you are new to creating Web services, please consult your Web Services platform
        documentation.
    </p>
    <p>
    Narayana
        provides the XTS component as a transaction solution for Web Services. Using XTS, business
        partners can coordinate complex business transactions in a controlled and reliable manner. The XTS API supports a
        transactional coordination model based on the
        <em class="firstterm">WS-Coordination</em>
        ,
        <em class="firstterm">WS-Atomic
            Transaction
        </em>
        , and
        <em class="firstterm">WS-Business Activity</em>
        specifications.
    </p>
    <div class="itemizedlist" title="Protocols Included in XTS"><a id="protocol-spec-list"/><p class="title"><strong>Protocols Included in XTS</strong></p><ul class="itemizedlist"><li class="listitem">
            <p>WS-Coordination (WS-C) is a generic coordination framework developed by IBM, Microsoft and BEA.</p>
        </li><li class="listitem">
            <p>WS-Atomic Transaction (WS-AT) and WS-Business Activity (WS-BA) together comprise the WS-Transaction
                (WS-T) transaction protocols that utilize this framework.
            </p>
        </li></ul></div>
    <p>
    Narayana
        implements versions 1.1, and 1.2 of these three specifications. Version
        specifications are available from
        <a class="ulink" href="http://www.oasis-open.org/specs/">http://www.oasis-open.org/specs/</a>
        .
    </p>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            The 1.1, and 1.2 specifications only differ in a small number of details. The rest of this document employs
            version 1.1 of these specifications when providing explanations and example code. On the few occasions where the
            modifications required to adapt these to the 1.1 specifications are not obvious, an explanatory note is
            provided.
        </p>
    </div>

    <p>
        <em class="firstterm">Web Services</em>
        are modular, reusable software components that are created by exposing business
        functionality through a Web service interface. Web Services communicate directly with other Web Services using
        standards-based technologies such as SOAP and HTTP. These standards-based communication technologies enable
        customers, suppliers, and trading partners to access Web Services, independent of hardware operating system, or
        programming environment. The result is a vastly improved collaboration environment as compared to today's EDI and
        <em class="firstterm">business-to-business (B2B)</em>
        solutions; an environment where businesses can expose their
        current and future business applications as Web Services that can be easily discovered and accessed by external
        partners.
    </p>

    <p>
        Web Services, by themselves, are not fault-tolerant. In fact, some of the reasons that the Web Services model is an
        attractive development solution are also the same reasons that service-based applications may have drawbacks.
    </p>
    <div class="itemizedlist" title="Properties of Web Services:"><p class="title"><strong>Properties of Web Services:</strong></p><ul class="itemizedlist"><li class="listitem">
            <p>Application components that are exposed as Web Services may be owned by third parties, which provides
                benefits in terms of cost of maintenance, but drawbacks in terms of having exclusive control over their
                behavior.</p>
        </li><li class="listitem">
            <p>Web Services are usually remotely located, increasing risk of failure due to increased network
                travel for invocations.
            </p>
        </li></ul></div>

    <p>
        Applications that have high dependability requirements need a method of minimizing the effects of errors that
        may
        occur when an application consumes Web Services. One method of safeguarding against such failures is to interact
        with an application’s Web Services within the context of a
        <em class="firstterm">transaction</em>
        . A transaction is a
        unit of work which is completed entirely, or in the case of failures is reversed to some agreed consistent
        state. The goal, in the event of a failure, is normally to appear as if the work had never occurred in the first
        place. With XTS, transactions can span multiple Web Services, meaning that work performed across multiple
        enterprises can be managed with transactional support.
    </p>

    <div class="section" title="4.1.1. Managing service-Based Processes"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6849"/>4.1.1. Managing service-Based Processes</h3></div></div></div>
        
        <p>
            XTS allows you to create transactions that drive complex business processes, spanning multiple Web
            Services. Current Web Services standards do not address the requirements for a high-level coordination of
            services. This is because in today’s Web Services applications, which use single request/receive interactions,
            coordination is typically not a problem. However, for applications that engage multiple services among multiple
            business partners, coordinating and controlling the resulting interactions is essential. This becomes even more
            apparent when you realize that you generally have little in the way of formal guarantees when interacting with
            third-party Web Services.
        </p>
        <p>
            XTS provides the infrastructure for coordinating services during a business process. By organizing processes
            as
            transactions, business partners can collaborate on complex business interactions in a reliable manner, insuring
            the integrity of their data - usually represented by multiple changes to a database – but without the usual
            overheads and drawbacks of directly exposing traditional transaction-processing engines directly onto the
            web.
            <a class="xref" href="#example-application" title="An Evening On the Town">An Evening On the Town</a>
            demonstrates how an application may manage service-based processes as
            transactions:
        </p>
        <p title="An Evening On the Town"><a id="example-application"/>
            <strong>An Evening On the Town. </strong>
            
                The application in question allows a user to plan a social evening. This application is responsible for reserving a
                table at a restaurant, and reserving tickets to a show. Both activities are paid for using a credit
                card. In this
                example, each service represents exposed Web Services provided by different service providers. XTS is used to envelop
                the interactions between the theater and restaurant services into a single (potentially) long-running business
                transaction. The business transaction must insure that seats are reserved both at the restaurant and the
                theater. If
                one event fails the user has the ability to decline both events, thus returning both services back to their original
                state. If both events are successful, the user’s credit card is charged and both seats are booked. As
                you may expect,
                the interaction between the services must be controlled in a reliable manner over a period of time. In addition,
                management must span several third-party services that are remotely deployed.
            
        </p>
        <p>
            Without the backing of a transaction, an undesirable outcome may occur. For example, the user credit card may be
            charged, even if one or both of the bookings fail.
        </p>
        <p>
            <a class="xref" href="#example-application" title="An Evening On the Town">An Evening On the Town</a>
            describes the situations where XTS excels at supporting business processes
            across multiple enterprises. This example is further refined throughout this guide, and appears as a standard
            demonstrator (including source code) with the XTS distribution.
        </p>
    </div>

    <div class="section" title="4.1.2. Servlets"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6860"/>4.1.2. Servlets</h3></div></div></div>
        

        <p>
            The WS-Coordination, WS-Atomic Transaction, and WS-Business Activity protocols are based on one-way
            interactions
            of entities rather than traditional synchronous request/response RPC-style interactions. One group of entities,
            called transaction participants, invoke operations on other entities, such as the transaction coordinator, in
            order to return responses to requests. The programming model is based on peer-to-peer relationships, with the
            result that all services, whether they are participants, coordinators or clients, must have an
            <em class="firstterm">active
                component
            </em>
            that allows them to receive unsolicited messages.
        </p>
        <p>
            In XTS, the active component is achieved through deployment of JaxWS
            endpoints. Each XTS endpoint that is reachable through SOAP/XML is
            published via JaxWS, without developer intervention. The only requirement
            is that transactional client applications and transactional web services
            must reside within a domain capable of hosting JaxWS endpoints, such as an
            application server. WildFly Application Server
            can provide this functionality.
        </p>
    </div>

    <div class="section" title="4.1.3. SOAP"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6865"/>4.1.3. SOAP</h3></div></div></div>
        

        <p>
            SOAP has emerged as the
            <span class="foreignphrase"><em class="foreignphrase">de facto</em></span>
            message format for XML-based communication in the
            Web Services arena. It is a lightweight protocol that allows the user to define the content of a message and to
            provide hints as to how recipients should process that message.
        </p>
    </div>

    <div class="section" title="4.1.4. Web Services Description Language (WDSL)"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6869"/>4.1.4. Web Services Description Language (WDSL)</h3></div></div></div>
        
        <p>
            <em class="firstterm">Web Services Description Language (WSDL)</em>
            is an XML-based language used to define Web
            service interfaces. An application that consumes a Web service parses the service’s WSDL document to discover the
            location of the service, the operations that the service supports, the protocol bindings the service supports
            (SOAP, HTTP, etc), and how to access them. For each operation, WSDL describes the format that the client must
            follow.
        </p>
    </div>

</div>
    <div class="section" title="4.2. Transactions Overview"><div class="titlepage"><div><div><h2 class="title"><a id="d5e6873"/>4.2. Transactions Overview</h2></div></div></div>

    

    <a id="d5e6875" class="indexterm"/>
    <a id="d5e6877" class="indexterm"/>
    <a id="d5e6879" class="indexterm"/>
    <a id="d5e6881" class="indexterm"/>
    <a id="d5e6883" class="indexterm"/>
    <a id="d5e6886" class="indexterm"/>
    <a id="d5e6889" class="indexterm"/>
    <a id="d5e6891" class="indexterm"/>
    <a id="d5e6893" class="indexterm"/>
    <a id="d5e6895" class="indexterm"/>
    <a id="d5e6897" class="indexterm"/>
    <a id="d5e6899" class="indexterm"/>
    <a id="d5e6901" class="indexterm"/>
    <a id="d5e6903" class="indexterm"/>

    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            This chapter deals with the theory of transactional Web Services. If you are familiar with these principles,
            consider this chapter a reference.
        </p>
    </div>
    <p>
        Transactions have emerged as the dominant paradigm for coordinating interactions between parties in a distributed
        system, and in particular to manage applications that require concurrent access to shared data. Much of the XTS
        API is based on contemporary transaction APIs whose familiarity will enhance
        developer productivity and lessen the learning curve. While the following section provides the essential information
        that you should know before starting to use XTS for building transactional Web Services, it should not be treated as
        a definitive reference to all transactional technology.
    </p>
    <p>
        A transaction is a unit of work that encapsulates multiple database actions such that that either all the
        encapsulated actions fail or all succeed.
    </p>
    <p>
        Transactions ensure data integrity when an application interacts with multiple datasources.
    </p>

    <p>
        The main components involved in using and defining transactional Web Services using XTS are illustrated in
        <a class="xref" href="#fig-web-services-transaction" title="Figure 4.1. Components Involved in an XTS Transaction">Figure 4.1, “Components Involved in an XTS Transaction”</a>
        .
    </p>

    <div class="figure"><a id="fig-web-services-transaction"/><p class="title"><strong>Figure 4.1. Components Involved in an XTS Transaction</strong></p><div class="figure-contents">
        
        <div class="mediaobject"><img src="images/xts-fig-web-services-transaction.png" alt="Components Involved in an XTS Transaction" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e6914.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e6914.html" target="longdesc">D</a>]</span></div></div>
    </div></div><br class="figure-break"/>

    <div class="section" title="4.2.1. The Coordinator"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6935"/>4.2.1. The Coordinator</h3></div></div></div>
        
        <p>
            
            Every transaction is associated with a coordinator, which is responsible
            for governing the outcome of the transaction. When a client begins a Web
            Service transaction it posts a
            <code class="systemitem">create</code>
            request to
            a coordination service, which creates the coordinator and returns its
            details to the client. This service may be located in its own container or
            may be colocated with the application client or with one of the
            transactional web services for improved performance. The coordination
            service is typically responsible for managing many transactions in
            parallel, so each coordinator is identified by a unique transaction
            identifier.
        </p>
        <p>
            
            The coordinator is responsible for ensuring that the web services invoked
            by the client arrive at a consistent outcome. When the client asks the
            coordinator to complete the transaction, the coordinator ensures that each
            web service is ready to confirm any provisional changes it has made within
            the scope of the transaction. It then asks them all to make their changes
            permanent. If any of the web services indicates a problem at the
            confirmation stage, the coordinator ensures that all web services reject
            their provisional changes, reverting to the state before the transaction
            started. The coordinator also reverts all changes if the client asks it to
            cancel the transaction.
        </p>
        <p>
            The negotiation between the coordinator and the web services is organized to ensure that all services will make
            their changes permanent, or all of them will revert to the previous state, even if the coordinator or one of the
            web services crashes part of the way through the transaction."
        </p>
    </div>

    <div class="section" title="4.2.2. The Transaction Context"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6941"/>4.2.2. The Transaction Context</h3></div></div></div>
        
        <p>
            In order for a transaction to span a number of services, certain information has to be shared between those
            services, to propagate information about the transaction. This information is known as the
            <em class="firstterm">Context</em>
            . The coordination service hands a context back to the application client when it
            begins a transaction. This context is passed as an extra, hidden parameter whenever the client invokes a
            transactional web service. The XTS implementation saves and propagates this context automatically with only
            minimal involvement required on the part of the client. 
            However, it is still helpful to understand what information is captured in a
            context. This information is listed in the following section.
        </p>

        <div class="variablelist" title="Contents of a Context"><a id="context-contents"/><p class="title"><strong>Contents of a Context</strong></p><dl><dt><span class="term">Transaction Identifier</span></dt><dd>
                    <p>
                        Guarantees global uniqueness for an individual transaction.
                    </p>
                </dd><dt><span class="term">Transaction Coordinator Location</span></dt><dd>
                    <p>
                        The endpoint address participants contact to enroll.
                    </p>
                </dd></dl></div>

        <div class="figure"><a id="d5e6955"/><p class="title"><strong>Figure 4.2. Web Services and Context Flow</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/xts-fig-web-services-context-flow.png" alt="Web Services and Context Flow" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e6957.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e6957.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>
    </div>

    <div class="section" title="4.2.3. Participants"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6962"/>4.2.3. Participants</h3></div></div></div>
        
        <p>
            The coordinator cannot know the details of how every transactional service is implemented. In fact this
            knowledge
            is not even necessary for it to negotiate a transactional outcome. It treats each service taking part in a
            transaction as a participant and communicates with it according to some predefined participant coordination models
            appropriate to the type of transaction. 
            When a web service receives its first service request in some given transaction, it enrolls with the
            coordinator as a participant, specifying the participant model it wishes to follow. The context contains a
            URL for
            the endpoint of the coordination service which handles enrollment requests. So, the term participant merely refers
            a transactional service enrolled in a specific transaction using a specific participant model.
        </p>
    </div>

    <div class="section" title="4.2.4. ACID Transactions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6965"/>4.2.4. ACID Transactions</h3></div></div></div>
        
        <p>
            Traditionally, transaction processing systems support
            <em class="firstterm">ACID</em>
            properties. ACID is an acronym
            for
            <span class="emphasis"><em>A</em></span>
            tomic,
            <span class="emphasis"><em>C</em></span>
            onsistent,
            <span class="emphasis"><em>I</em></span>
            solated, and
            <span class="emphasis"><em>D</em></span>
            urable. A unit of work has traditionally been considered transactional only if the ACID
            properties are maintained, as describe in
            <a class="xref" href="#acid-properties" title="ACID Properties">ACID Properties</a>
            .
        </p>

        <div class="variablelist" title="ACID Properties"><a id="acid-properties"/><p class="title"><strong>ACID Properties</strong></p><dl><dt><span class="term">Atomicity</span></dt><dd>
                    <p>
                        The transaction executes completely, or not at all.
                    </p>
                </dd><dt><span class="term">Consistency</span></dt><dd>
                    <p>
                        The effects of the transaction preserve the internal consistency of an underlying data structure.
                    </p>
                </dd><dt><span class="term">Isolated</span></dt><dd>
                    <p>
                        The transaction runs as if it were running alone, with no other transactions running, and is not visible to other
                        transactions.
                    </p>
                </dd><dt><span class="term">Durable</span></dt><dd>
                    <p>
                        The transaction's results are not lost in the event of a failure.
                    </p>
                </dd></dl></div>
    </div>

    <div class="section" title="4.2.5. Two Phase Commit"><div class="titlepage"><div><div><h3 class="title"><a id="d5e6992"/>4.2.5. Two Phase Commit</h3></div></div></div>
        

        <p>
            The classical two-phase commit approach is the bedrock of Narayana,
            and more generally of Web
            Services transactions. Two-phase commit provides coordination of parties that are involved in a transaction. The
            general flow of a two-phase commit transaction is described in
            <a class="xref" href="#two-phase-commit-overview" title="Figure 4.3. Two-Phase Commit Overview">Figure 4.3, “Two-Phase Commit Overview”</a>
            .
        </p>

        <div class="figure"><a id="two-phase-commit-overview"/><p class="title"><strong>Figure 4.3. Two-Phase Commit Overview</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/xts-fig-two-phase-commit-overview.png" alt="Two-Phase Commit Overview" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e6998.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e6998.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>

        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                During two-phase commit transactions, coordinators and resources keep track of activity in non-volatile data stores
                so that they can recover in the case of a failure.
            </p>
        </div>

    </div>

    <div class="section" title="4.2.6. The Synchronization Protocol"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7015"/>4.2.6. The Synchronization Protocol</h3></div></div></div>
        
        <p>
            Besides the two-phase commit protocol, traditional transaction processing systems employ an additional
            protocol,
            often referred to as the
            <em class="firstterm">synchronization protocol</em>
            . With the original ACID properties,
            Durability is important when state changes need to be available despite failures. Applications interact with a
            persistence store of some kind, such as a database, and this interaction can impose a significant overhead,
            because disk access is much slower to access than main computer memory.
        </p>
        <p>
            One solution to the problem disk access time is to cache the state in main memory and only operate on the
            cache
            for the duration of a transaction. Unfortunately, this solution needs a way to flush the state back to the
            persistent store before the transaction terminates, or risk losing the full ACID properties. This is what the
            synchronization protocol does, with
            <em class="firstterm">Synchronization Participants</em>
            .
        </p>
        <p>
            Synchronizations are informed that a transaction is about to commit. At that point, they can flush cached state,
            which might be used to improve performance of an application, to a durable representation prior to the transaction
            committing. The synchronizations are then informed about when the transaction completes and its completion
            state.
        </p>

        <div class="procedure" title="Procedure 4.1. The &#34;Four Phase Protocol&#34; Created By Synchronizations"><a id="d5e7022"/><p class="title"><strong>Procedure 4.1. The "Four Phase Protocol" Created By Synchronizations</strong></p><p>
                Synchronizations essentially turn the two-phase commit protocol into a four-phase protocol:
            </p><ol class="procedure" type="1"><li class="step" title="Step 1">
                <p class="title"><strong>Step 1</strong></p>
                <p>
                    Before the transaction starts the two-phase commit, all registered Synchronizations are informed. Any failure at
                    this point will cause the transaction to roll back.
                </p>
            </li><li class="step" title="Steps 2 and 3">
                <p class="title"><strong>Steps 2 and 3</strong></p>
                <p>
                    The coordinator then conducts the normal two-phase commit protocol.
                </p>
            </li><li class="step" title="Step 4">
                <p class="title"><strong>Step 4</strong></p>
                <p>
                    Once the transaction has terminated, all registered Synchronizations are informed. However, this is a courtesy
                    invocation because any failures at this stage are ignored: the transaction has terminated so there’s
                    nothing to
                    affect.
                </p>
            </li></ol></div>
        <p>
            The synchronization protocol does not have the same failure requirements as the traditional two-phase commit
            protocol. For example, Synchronization participants do not need the ability to recover in the event of failures,
            because any failure before the two-phase commit protocol completes cause the transaction to roll back, and
            failures after it completes have no effect on the data which the Synchronization participants are responsible for.
        </p>
    </div>

    <div class="section" title="4.2.7. Optimizations to the Protocol"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7035"/>4.2.7. Optimizations to the Protocol</h3></div></div></div>
        
        <p>
            There are several variants to the standard two-phase commit protocol that are worth knowing about, because
            they
            can have an impact on performance and failure recovery.
            <a class="xref" href="#two-phase-variants" title="Table 4.1. Variants to the Two-Phase Commit Protocol">Table 4.1, “Variants to the Two-Phase Commit Protocol”</a>
            gives more
            information about each one.
        </p>
        <div class="table"><a id="two-phase-variants"/><p class="title"><strong>Table 4.1. Variants to the Two-Phase Commit Protocol</strong></p><div class="table-contents">
            
            <table summary="Variants to the Two-Phase Commit Protocol" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                            <p>Variant</p>
                        </th><th>
                            <p>Description</p>
                        </th></tr></thead><tbody><tr><td>
                            <p>Presumed Abort</p>
                        </td><td>
                            <p>
                                If a transaction is going to roll back, the coordinator may record this information
                                locally and tell
                                all enlisted participants. Failure to contact a participant has no effect on the transaction outcome. The
                                coordinator is informing participants only as a courtesy. Once all participants have
                                been contacted, the
                                information about the transaction can be removed. If a subsequent request for the status of the transaction
                                occurs, no information will be available and the requester can assume that the transaction has aborted. This
                                optimization has the benefit that no information about participants need be made
                                persistent until the transaction
                                has progressed to the end of the
                                <code class="systemitem">prepare</code>
                                phase and decided to commit, since any failure
                                prior to this point is assumed to be an abort of the transaction.
                            </p>
                        </td></tr><tr><td>
                            <p>One-Phase</p>
                        </td><td>
                            <p>
                                If only a single participant is involved in the transaction, the coordinator does not
                                need to drive
                                it through the
                                <code class="systemitem">prepare</code>
                                phase. Thus, the participant is told to commit, and the
                                coordinator does not need to record information about the decision, since the outcome of the transaction is the
                                responsibility of the participant.
                            </p>
                        </td></tr><tr><td>
                            <p>Read-Only</p>
                        </td><td>
                            <p>When a participant is asked to prepare, it can indicate to the coordinator that no
                                information or
                                data that it controls has been modified during the transaction. Such a participant does not need to be informed
                                about the outcome of the transaction since the fate of the participant has no affect on
                                the
                                transaction. Therefore, a read-only participant can be omitted from the second phase of the commit
                                protocol.
                            </p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>

        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                The WS-Atomic Transaction protocol does not support the one-phase commit optimization.
            </p>
        </div>
    </div>

    <div class="section" title="4.2.8. Non-Atomic Transactions and Heuristic Outcomes"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7068"/>4.2.8. Non-Atomic Transactions and Heuristic Outcomes</h3></div></div></div>
        
        <p>
            In order to guarantee atomicity, the two-phase commit protocol is
            <em class="firstterm">blocking</em>
            . As a result of
            failures, participants may remain blocked for an indefinite period of time, even if failure recovery mechanisms
            exist. Some applications and participants cannot tolerate this blocking.
        </p>
        <p>
            To break this blocking nature, participants that are past the
            <code class="systemitem">prepare</code>
            phase are allowed
            to make autonomous decisions about whether to commit or rollback. Such a participant must record its decision, so
            that it can complete the original transaction if it eventually gets a request to do so. If the coordinator
            eventually informs the participant of the transaction outcome, and it is the same as the choice the participant
            made, no conflict exists. If the decisions of the participant and coordinator are different, the situation is
            referred to as a non-atomic outcome, and more specifically as a
            <em class="firstterm">heuristic outcome</em>
            .
        </p>
        <p>
            Resolving and reporting heuristic outcomes to the application is usually the domain of complex, manually driven
            system administration tools, because attempting an automatic resolution requires semantic information about the
            nature of participants involved in the transactions.
        </p>
        <p>
            Precisely when a participant makes a heuristic decision depends on the specific implementation. Likewise,
            the
            choice the participant makes about whether to commit or to roll back depends upon the implementation, and possibly
            the application and the environment in which it finds itself. The possible heuristic outcomes are discussed in
            <a class="xref" href="#tbl-heuristic-outcomes" title="Table 4.2. Heuristic Outcomes">Table 4.2, “Heuristic Outcomes”</a>
            .
        </p>

        <div class="table"><a id="tbl-heuristic-outcomes"/><p class="title"><strong>Table 4.2. Heuristic Outcomes</strong></p><div class="table-contents">
            
            <table summary="Heuristic Outcomes" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                            <p>Outcome</p>
                        </th><th>
                            <p>Description</p>
                        </th></tr></thead><tbody><tr><td>
                            <p>Heuristic Rollback</p>
                        </td><td>
                            <p>The commit operation failed because some or all of the participants unilaterally
                                rolled back the
                                transaction.
                            </p>
                        </td></tr><tr><td>
                            <p>Heuristic Commit</p>
                        </td><td>
                            <p>
                                An attempted rollback operation failed because all of the participants unilaterally
                                committed. One
                                situation where this might happen is if the coordinator is able to successfully
                                <code class="systemitem">prepare</code>
                                the transaction, but then decides to roll it back because its transaction log could not
                                be updated. While the
                                coordinator is making its decision, the participants decides to commit.
                            </p>
                        </td></tr><tr><td>
                            <p>Heuristic Mixed</p>
                        </td><td>
                            <p>Some participants committed, while others were rolled back.</p>
                        </td></tr><tr><td>
                            <p>Heuristic Hazard</p>
                        </td><td>
                            <p>The disposition of some of the updates is unknown. For those which are known, they
                                have either all
                                been committed or all rolled back.
                            </p>
                        </td></tr></tbody></table>
        </div></div><br class="table-break"/>

        <p>
            Heuristic decisions should be used with care and only in exceptional circumstances, since the decision may
            possibly differ from that determined by the transaction service. This type of difference can lead to a loss of
            integrity in the system. Try to avoid needing to perform resolution of heuristics, either by working with services
            and participants that do not cause heuristics, or by using a transaction service that provides assistance in the
            resolution process.
        </p>

    </div>

    <div class="section" title="4.2.9. Interposition"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7110"/>4.2.9. Interposition</h3></div></div></div>
        
        <p>
            <em class="firstterm">Interposition</em>
            is a scoping mechanism which allows coordination of a transaction to be
            delegated across a hierarchy of coordinators. See
            <a class="xref" href="#fig-interpositions" title="Figure 4.4. Interpositions">Figure 4.4, “Interpositions”</a>
            for a graphical
            representation of this concept.
        </p>
        <div class="figure"><a id="fig-interpositions"/><p class="title"><strong>Figure 4.4. Interpositions</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/xts-fig-interpositions.png" alt="Interpositions" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7117.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7117.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>

        <p>
            Interposition is particularly useful for Web Services transactions, as a way of limiting the amount of
            network
            traffic required for coordination. For example, if communications between the top-level coordinator and a web
            service are slow because of network traffic or distance, the web service might benefit from executing in a
            subordinate transaction which employs a local coordinator service. In
            <a class="xref" href="#fig-interpositions" title="Figure 4.4. Interpositions">Figure 4.4, “Interpositions”</a>
            ,to
            <code class="systemitem">prepare</code>
            , the top-level coordinator only needs to send one
            <code class="systemitem">prepare</code>
            message to the subordinate coordinator, and receive one
            <code class="systemitem">prepared</code>
            or
            <code class="systemitem">aborted</code>
            reply. The subordinate coordinator forwards
            a
            <code class="systemitem">prepare</code>
            locally to each participant and combines the results to decide whether to send
            a single
            <code class="systemitem">prepared</code>
            or
            <code class="systemitem">aborted</code>
            reply.
        </p>
    </div>

    <div class="section" title="4.2.10. A New Transaction Protocol"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7136"/>4.2.10. A New Transaction Protocol</h3></div></div></div>
        

        <p>
            Many component technologies offer mechanisms for coordinating ACID transactions based on two-phase commit
            semantics. Some of these are CORBA/OTS, JTS/JTA, and MTS/MSDTC. ACID transactions are not suitable for all Web
            Services transactions, as explained in the following section.
        </p>

        <div class="itemizedlist" title="Reasons ACID is Not Suitable for Web Services"><a id="acid-not-suitable"/><p class="title"><strong>Reasons ACID is Not Suitable for Web Services</strong></p><ul class="itemizedlist"><li class="listitem">
                <p>
                    Classic ACID transactions assume that an organization that develops and deploys applications owns the entire
                    infrastructure for the applications. This infrastructure has traditionally taken the form of an
                    Intranet. Ownership
                    implies that transactions operate in a trusted and predictable manner. To assure ACIDity, potentially long-lived
                    locks can be kept on underlying data structures during two-phase commit. Resources can be used for any period of
                    time and released when the transaction is complete.
                </p>
                <p>
                    In Web Services, these assumptions are no longer valid. One obvious reason is that the owners of data exposed
                    through a Web service refuse to allow their data to be locked for extended periods, since allowing such locks
                    invites denial-of-service attacks.
                </p>
            </li><li class="listitem">
                <p>
                    All application infrastructures are generally owned by a single party. Systems using classical ACID transactions
                    normally assume that participants in a transaction will obey the directives of the transaction
                    manager and only
                    infrequently make unilateral decisions which harm other participants in a transaction.
                </p>
                <p>
                    Web Services participating in a transaction can effectively decide to resign from the transaction at any time, and
                    the consumer of the service generally has little in the way of quality of service guarantees to prevent this.
                </p>
            </li></ul></div>

        <div class="section" title="4.2.10.1. Transaction in Loosely Coupled Systems"><div class="titlepage"><div><div><h4 class="title"><a id="d5e7147"/>4.2.10.1. Transaction in Loosely Coupled Systems</h4></div></div></div>
            

            <p>
                Extended transaction models which relax the ACID properties have been proposed over the years. WS-T provides a new
                transaction protocol to implement these concepts for the Web Services architecture. XTS is designed to
                accommodate
                four underlying requirements inherent in any loosely coupled architecture like Web Services. These requirements are
                discussed in the following section.
            </p>
            <div class="itemizedlist" title="Requirements of Web Services"><a id="web-services-requirements"/><p class="title"><strong>Requirements of Web Services</strong></p><ul class="itemizedlist"><li class="listitem">
                    <p>
                        Ability to handle multiple successful outcomes to a transaction, and to involve operations whose effects may not
                        be isolated or durable.
                    </p>
                </li><li class="listitem">
                    <p>
                        Coordination of autonomous parties whose relationships are governed by contracts, rather than the dictates of a
                        central design authority.
                    </p>
                </li><li class="listitem">
                    <p>
                        Discontinuous service, where parties are expected to suffer outages during their lifetimes, and coordinated work
                        must be able to survive such outages.
                    </p>
                </li><li class="listitem">
                    <p>
                        Interoperation using XML over multiple communication protocols. XTS uses SOAP encoding carried over HTTP.
                    </p>
                </li></ul></div>
        </div>
    </div>
</div>
    <div class="section" title="4.3. Overview of Protocols Used by XTS"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7160"/>4.3. Overview of Protocols Used by XTS</h2></div></div></div>

    

    <a id="d5e7162" class="indexterm"/>
    <a id="d5e7165" class="indexterm"/>
    <a id="d5e7168" class="indexterm"/>
    <a id="d5e7170" class="indexterm"/>
    <a id="d5e7172" class="indexterm"/>
    <a id="d5e7174" class="indexterm"/>
    <a id="d5e7177" class="indexterm"/>
    <a id="d5e7179" class="indexterm"/>
    <a id="d5e7181" class="indexterm"/>
    <a id="d5e7183" class="indexterm"/>
    <a id="d5e7185" class="indexterm"/>
    <a id="d5e7188" class="indexterm"/>
    <a id="d5e7191" class="indexterm"/>
    <a id="d5e7193" class="indexterm"/>

    <p>
        This section discusses fundamental concepts associated with the WS-Coordination, WS-Atomic Transaction and
        WS-Business Activity protocols, as defined in each protocol's specification. Foundational information about these
        protocols is important to understanding the remaining material covered in this guide.
    </p>
    
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            If you are familiar with the WS-Coordination, WS-Atomic Transaction, and WS-Business Activity specifications you
            may only need to skim this chapter.
        </p>
    </div>

    <div class="section" title="4.3.1. WS-Coordination"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7198"/>4.3.1. WS-Coordination</h3></div></div></div>
        
        <p>
            In general terms,
            <em class="firstterm">coordination</em>
            is the act of one entity, known as the coordinator,
            disseminating information to a number of participants for some domain-specific reason. This reason could be to
            reach consensus on a decision by a distributed transaction protocol, or to guarantee that all participants obtain
            a specific message, such as in a reliable multicast environment. When parties are being coordinated, information,
            known as the
            <em class="firstterm">coordination context</em>
            , is propagated to tie together operations which are
            logically part of the same coordinated work or activity. This context information may flow with normal application
            messages, or may be an explicit part of a message exchange. It is specific to the type of coordination being
            performed.
        </p>
        <p>
            The fundamental idea underpinning
            <em class="firstterm">WS-Coordination (WS-C)</em>
            is that a coordination
            infrastructure is needed in a Web Services environment. The WS-C specification defines a framework that allows
            different coordination protocols to be plugged in to coordinate work between clients, services, and participants,
            as shown in
            <a class="xref" href="#fig-ws-c-architecture" title="Figure 4.5. WS-C Architecture">Figure 4.5, “WS-C Architecture”</a>
            .
        </p>

        <div class="figure"><a id="fig-ws-c-architecture"/><p class="title"><strong>Figure 4.5. WS-C Architecture</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/xts-fig-ws-c-overview.png" alt="WS-C Architecture" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7208.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7208.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>

        <p>
            Whatever coordination protocol is used, and in whatever domain it is deployed, the same generic requirements are
            present.
        </p>
        <div class="itemizedlist" title="Generic Requirements for WS-C"><a id="list-requirements-for-wsc"/><p class="title"><strong>Generic Requirements for WS-C</strong></p><ul class="itemizedlist"><li class="listitem">
                <p>Instantiation, or activation, of a new coordinator for the specific coordination protocol, for a
                    particular application instance.</p>
            </li><li class="listitem">
                <p>Registration of participants with the coordinator, such that they will receive that coordinator’s
                    protocol messages during (some part of) the application’s lifetime.
                </p>
            </li><li class="listitem">
                <p>Propagation of contextual information between Web Services that comprise the application.</p>
            </li><li class="listitem">
                <p>An entity to drive the coordination protocol through to completion.</p>
            </li></ul></div>

        <p>
            The first three of the points in
            <a class="xref" href="#list-requirements-for-wsc" title="Generic Requirements for WS-C">Generic Requirements for WS-C</a>
            are the direct responsibility of
            WS-C, while the fourth is the responsibility of a third-party entity. The third-party entity is usually the client
            component of the overall application. These four WS-C roles and their relationships are shown in
            <a class="xref" href="#fig-wsc-four-roles" title="Figure 4.6. Four Roles in WS-C">Figure 4.6, “Four Roles in WS-C”</a>
            .
        </p>

        <div class="figure"><a id="fig-wsc-four-roles"/><p class="title"><strong>Figure 4.6. Four Roles in WS-C</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/xts-fig-wsc-four-roles.png" alt="Four Roles in WS-C" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7230.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7230.html" target="longdesc">D</a>]</span></div></div>
        </div></div><br class="figure-break"/>

        <div class="section" title="4.3.1.1. Activation"><div class="titlepage"><div><div><h4 class="title"><a id="d5e7235"/>4.3.1.1. Activation</h4></div></div></div>
            
            <p>
                The WS-C framework exposes an Activation Service which supports the creation of coordinators for
                specific
                coordination protocols and retrieval of associated contexts. Activation services are invoked synchronously using an
                RPC style exchange. So, the service WSDL defines a single port declaring a
                <code class="methodname">CreateCoordinationContext</code>
                operation. This operation takes an input specfying the details of
                the transaction to be created, including the type of coordination required, timeout, and other relevant
                information. It returns an output containing the details of the newly-created transaction context: the transaction
                identifier, coordination type, and registration service URL.
            </p>

            <div class="example"><a id="example-wsc-interfaces"/><p class="title"><strong>Example 4.1. </strong></p><div class="example-contents">
                
                <pre><code class="language-xml">&lt;!-- Activation Service portType Declaration --&gt; 
&lt;wsdl:portType name="ActivationCoordinatorPortType"&gt; 
  &lt;wsdl:operation name="CreateCoordinationContext"&gt; 
    &lt;wsdl:input message="wscoor:CreateCoordinationContext"/&gt; 
    &lt;wsdl:output message="wscoor:CreateCoordinationContextResponse"/&gt; 
  &lt;/wsdl:operation&gt; 
&lt;/wsdl:portType&gt; 
</code></pre>
            </div></div><br class="example-break"/>

        </div> 

        <div class="section" title="4.3.1.2. Registration"><div class="titlepage"><div><div><h4 class="title"><a id="d5e7242"/>4.3.1.2. Registration</h4></div></div></div>
            
            
            <p>
                The context returned by the activation service includes the URL of a Registration Service. When a web service
                receieves a service request accompanied by a transaction context, it contacts the Registration Service to enroll as a
                participant in the transaction. The registration request includes a participant protocol defining the
                role the web
                service wishes to take in the transaction. Depending upon the coordination protocol, more than one choice of
                participant protocol may be available.
            </p>
            <p>
                Like the activation service, the registration service assumes synchronous communication. Thus, the
                service WSDL
                exposes a single port declaring a
                <code class="methodname">Register</code>
                operation. This operation takes an input
                specifying the details of the participant which is to be registered, including the participant protocol type. It
                returns a corresponding output response.
            </p>
            <div class="example"><a id="example-wsc-registration"/><p class="title"><strong>Example 4.2. Registration ServiceWSDL Interface</strong></p><div class="example-contents">
                
                <pre><code class="no-highlight">&lt;!-- Registration Service portType Declaration --&gt; 
&lt;wsdl:portType name="RegistrationCoordinatorPortType"&gt; 
  &lt;wsdl:operation name="Register"&gt; 
    &lt;wsdl:input message="wscoor:Register"/&gt; 
    &lt;wsdl:output message="wscoor:RegisterResponse"/&gt; 
  &lt;/wsdl:operation&gt; 
&lt;/wsdl:portType&gt; 
</code></pre>
            </div></div><br class="example-break"/>

            <p>
                Once a participant is registered with a coordinator through the registration service, it receives coordination
                messages from the coordinator. Typical messages include such things as “prepare to complete” and “complete” messages,
                if a two-phase protocol is used. Where the coordinator’s protocol supports it, participants can also send messages
                back to the coordinator.
            </p>
        </div> 

        <div class="section" title="4.3.1.3. Completion"><div class="titlepage"><div><div><h4 class="title"><a id="d5e7251"/>4.3.1.3. Completion</h4></div></div></div>
            
            <p>
                The role of terminator is generally filled by the client application. At an appropriate point, the client asks the
                coordinator to perform its particular coordination function with any registered participants, to drive
                the protocol
                through to its completion. After completion, the client application may be informed of an outcome for the
                activity. This outcome may take any form along the spectrum from simple success or failure notification, to complex
                structured data detailing the activity’s status.
            </p>
        </div> 
    </div> 

    <div class="section" title="4.3.2. WS-Transaction"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7254"/>4.3.2. WS-Transaction</h3></div></div></div>
        
        <p>
            <em class="firstterm">WS-Transaction (WS-T)</em>
            comprises the pair of transaction coordination protocols,
            <em class="firstterm">WS-Atomic Transaction (WS-AT)</em>
            and
            <em class="firstterm">WS-Business Activity (WS-BA)</em>
            ,
            which utilize the coordination framework provided by
            <em class="firstterm">WS-Coordination (WS-C)</em>
            .
        </p>
        <p>
            <em class="firstterm">WS-Transactions</em>
            was developed to unify existing traditional transaction processing systems,
            allowing them to communicate reliably with one another without changes to the systems' own function.
        </p>

        <div class="section" title="4.3.2.1. WS-Transaction Foundations"><div class="titlepage"><div><div><h4 class="title"><a id="d5e7263"/>4.3.2.1. WS-Transaction Foundations</h4></div></div></div>
            
            <p>
                WS-Transaction is layered upon the WS-Coordination protocol, as shown in
                <a class="xref" href="#wsc-wst-interop" title="Figure 4.7. WS-Coordination, WS-Transaction, and WS-Business Activity">Figure 4.7, “WS-Coordination, WS-Transaction, and WS-Business Activity”</a>
                .
            </p>

            <div class="figure"><a id="wsc-wst-interop"/><p class="title"><strong>Figure 4.7. WS-Coordination, WS-Transaction, and WS-Business Activity</strong></p><div class="figure-contents">
                
                <div class="mediaobject"><img src="images/xts-fig-wsc-wst-interop.png" alt="WS-Coordination, WS-Transaction, and WS-Business Activity" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7269.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7269.html" target="longdesc">D</a>]</span></div></div>
            </div></div><br class="figure-break"/>

            <p>
                WS-C provides a generic framework for specific coordination protocols, like WS-Transaction, used in a modular
                fashion. WS-C provides only context management, allowing contexts to be created and activities to be registered with
                those contexts. WS-Transaction leverages the context management framework provided by WS-C in two ways.
            </p>
            <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                    <p>
                        It extends the WS-C context to create a transaction context.
                    </p>
                </li><li class="listitem">
                    <p>
                        It augments the activation and registration services with a number of additional services (Completion,
                        Volatile2PC, Durable2PC, BusinessAgreementWithParticipantCompletion, and
                        BusinessAgreementWithCoordinatorCompletion) and two protocol message sets (one for each of the transaction models
                        supported in WS-Transaction), to build a fully-fledged transaction coordinator on top of the WS-C protocol
                        infrastructure.
                    </p>
                </li><li class="listitem">
                    <p>
                        An important aspect of WS-Transaction that differs from traditional transaction protocols is that a synchronous
                        request/response model is not assumed. Sequences of one way messages are used to implement
                        communications between
                        the client/participant and the coordination services appropriate to the transaction's coordination and
                        participant protocols. This is significant because it means that the client and participant containers must
                        deploy XTS service endpoints to receive messages from the coordinator service.
                    </p>
                    <p>
                        This requirement is visible in the details of the
                        <code class="methodname">Register</code>
                        and
                        <code class="methodname">RegisterResponse</code>
                        messages declared in the Registration Service WSDL in
                        <a class="xref" href="#example-wsc-registration" title="Example 4.2. Registration ServiceWSDL Interface">Example 4.2, “Registration ServiceWSDL Interface”</a>
                        . The
                        <code class="methodname">Register</code>
                        message contains the URL of an
                        endpoint in the client or web service container. This URL is used when a WS-Transaction coordination service
                        wishes to dispatch a message to the client or web service. Similarly, the
                        <code class="methodname">RegisterResponse</code>
                        message contains a URL iendtifying an endpoint for the
                        protocol-specific WS-Transaction coordination service for which the client/web service is registered, allowing
                        messages to be addressed to the transaction coordinator.
                    </p>
                </li></ol></div>
        </div> 

        <div class="section" title="4.3.2.2. WS-Transaction Architecture"><div class="titlepage"><div><div><h4 class="title"><a id="d5e7288"/>4.3.2.2. WS-Transaction Architecture</h4></div></div></div>
            

            <p>
                WS-Transaction distinguishes the transaction-aware web service in its role executing business-logic,
                from the web
                service acting as a participant in the transaction, communicating with and responding to its transaction
                coordinator. Transaction-aware web services deal with application clients using business-level protocols, while the
                participant handles the underlying WS-Transaction protocols, as shown in
                <a class="xref" href="#ws-trans-global-view" title="Figure 4.8. WS-Transaction Global View">Figure 4.8, “WS-Transaction Global View”</a>
                .
            </p>

            <div class="figure"><a id="ws-trans-global-view"/><p class="title"><strong>Figure 4.8. WS-Transaction Global View</strong></p><div class="figure-contents">
                
                <div class="mediaobject"><img src="images/xts-ws-trans-global-view.png" alt="WS-Transaction Global View" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7294.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7294.html" target="longdesc">D</a>]</span></div></div>
            </div></div><br class="figure-break"/>

            <p>
                A transaction-aware web service encapsulates the business logic or work that needs to be conducted within the scope
                of a transaction. This work cannot be confirmed by the application unless the transaction also commits.
                Thus, control
                is ultimately removed from the application and given to the transaction.
            </p>
            <p>
                The participant is the entity that, under the dictates of the transaction coordinator, controls the
                outcome of the
                work performed by the transaction-aware Web service. In
                <a class="xref" href="#ws-trans-global-view" title="Figure 4.8. WS-Transaction Global View">Figure 4.8, “WS-Transaction Global View”</a>
                , each web service is
                shown with one associated participant that manages the transaction protocol messages on behalf of its web
                service.
                <a class="xref" href="#ws-trans-services-participants" title="Figure 4.9. WS-Transaction Web Services and Participants">Figure 4.9, “WS-Transaction Web Services and Participants”</a>
                , however, shows a close-up view of a single web service,
                and a client application with their associated participants.
            </p>
            <div class="figure"><a id="ws-trans-services-participants"/><p class="title"><strong>Figure 4.9. WS-Transaction Web Services and Participants</strong></p><div class="figure-contents">
                
                <div class="mediaobject"><img src="images/xts-fig-ws-trans-services-participants.png" alt="WS-Transaction Web Services and Participants" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7305.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7305.html" target="longdesc">D</a>]</span></div></div>
            </div></div><br class="figure-break"/>
            <p>
                The transaction-aware web service employs a back end database accessed via a JDBC driver, which sends SQL statements
                to the database for processing. However, those statements should only commit if the enclosing web service transaction
                does. For this to work, the web service must employ transaction bridging. Transaction bridging registers
                a
                participant with the coordinator for the web service transaction and creates a matching XA transaction within which
                it can invoke the driver to make tentative changes to the database. The web service ensures that service requests
                associated with a specific web service transaction are executed in the scope of the corresponding XA
                transaction,
                grouping changes common to a given transaction while isolating changes belonging to different transactions. The
                participant responds to prepare, commit, or rollback requests associated from the web service transaction coordinator
                by forwarding the same operations to the underlying XA transaction coordinator, ensuring that the local outcome in
                the database corresponds with the global outcome of the web service transaction as a whole.
            </p>
            <p>
                Things are less complex for the client. Through its API, the client application registers a participant with the
                transaction, and uses this participant to control termination of the transaction.
            </p>
        </div> 

        <div class="section" title="4.3.2.3. WS-Transaction Models"><div class="titlepage"><div><div><h4 class="title"><a id="d5e7312"/>4.3.2.3. WS-Transaction Models</h4></div></div></div>
            
            <p>
                It has been established that traditional transaction models are not appropriate for Web Services. No one specific
                protocol is likely to be sufficient, given the wide range of situations where Web service transactions
                are likely to
                be used. The WS-Transaction specification proposes two distinct models, where each supports the semantics of a
                particular kind of B2B interaction.
            </p>

            <p>
                The following discussion presents the interactions between the client, web service and the transaction
                coordinator in
                great detail for expository purposes only. Most of this activity happens automatically behind the scenes. The actual
                APIs used to initiate and complete a transaction and to register a participant and drive it through the commit or
                abort process are described in
                <a class="xref" href="#">???</a>
                .
            </p>


            <div class="section" title="4.3.2.3.1. Atomic Transactions"><div class="titlepage"><div><div><h5 class="title"><a id="d5e7317"/>4.3.2.3.1. Atomic Transactions</h5></div></div></div>
                
                <p>
                    An
                    <em class="firstterm">atomic transaction (AT)</em>
                    is similar to traditional ACID transactions, and is designed to
                    support short-duration interactions where ACID semantics are appropriate. Within the scope of an AT, web services
                    typically
                    employ bridging to allow them to access XA resources, such as databases and message queues, under the control of
                    the web service transaction. When the transaction terminates, the participant propagates the outcome decision of
                    the AT to the XA resources, and the appropriate commit or rollback actions are taken by each.
                </p>
                <p>
                    All services and associated participants are expected to provide ACID semantics, and it is expected that any use of
                    atomic transactions occurs in environments and situations where ACID is appropriate. Usually, this
                    environment is a
                    trusted domain, over short durations.
                </p>
                <div class="procedure" title="Procedure 4.2. Atomic Transaction Process"><a id="d5e7322"/><p class="title"><strong>Procedure 4.2. Atomic Transaction Process</strong></p><ol class="procedure" type="1"><li class="step" title="Step 1">
                        <p>
                            To begin an atomic transaction, the client application first locates a WS-C Activation Coordinator web service
                            that supports WS-Transaction.
                        </p>
                    </li><li class="step" title="Step 2">
                        <p>
                            The client sends a WS-C
                            <code class="systemitem">CreateCoordinationContext</code>
                            message to the service, specifying
                            <a class="ulink" href="http://schemas.xmlsoap.org/ws/2004/10/wsat">http://schemas.xmlsoap.org/ws/2004/10/wsat</a>
                            as its coordination type.
                        </p>
                    </li><li class="step" title="Step 3">
                        <p>
                            The client receives an appropriate WS-Transaction context from the activation service.
                        </p>
                    </li><li class="step" title="Step 4">
                        <p>
                            The response to the
                            <code class="systemitem">CreateCoordinationContext</code>
                            message, the transaction context, has
                            its
                            <code class="systemitem">CoordinationType</code>
                            element set to the WS-Atomic Transaction namespace,
                            <a class="ulink" href="http://schemas.xmlsoap.org/ws/2004/10/wsat">http://schemas.xmlsoap.org/ws/2004/10/wsat</a>
                            . It also contains a reference to the atomic transaction
                            coordinator endpoint, the WS-C Registration Service, where participants can be enlisted.
                        </p>
                    </li><li class="step" title="Step 5">
                        <p>
                            The client normally proceeds to invoke Web Services and complete the transaction, either
                            committing all the
                            changes made by the web services, or rolling them back. In order to be able to drive this completion activity,
                            the client must register itself as a participant for the
                            <code class="systemitem">Completion</code>
                            protocol, by
                            sending a
                            <code class="systemitem">Register</code>
                            message to the Registration Service whose endpoint was returned in
                            the Coordination Context.
                        </p>
                    </li><li class="step" title="Step 6">
                        <p>
                            Once registered for Completion, the client application then interacts with Web Services to accomplish its
                            business-level work. With each invocation of a business Web service, the client inserts the
                            transaction context
                            into a SOAP header block, such that each invocation is implicitly scoped by the transaction. The toolkits that
                            support WS-Atomic Transaction-aware Web Services provide facilities to correlate contexts
                            found in SOAP header
                            blocks with back-end operations. This ensures that modifications made by the Web service are done within the
                            scope of the same transaction as the client and subject to commit or rollback by the transaction coordinator.
                        </p>
                    </li><li class="step" title="Step 7">
                        <p>
                            Once all the necessary application-level work is complete, the client can terminate the transaction, with the
                            intent of making any changes to the service state permanent. The completion participant instructs the
                            coordinator to try to commit or roll back the transaction. When the commit or roll-back operation completes, a
                            status is returned to the participant to indicate the outcome of the transaction.
                        </p>
                    </li></ol></div>

                <p>
                    Although this description of the completion protocol seems straightforward, it hides the fact that in order to
                    resolve the transaction to an outcome, several other participant protocols need to be followed.
                </p>

                <div class="variablelist"><dl><dt><span class="term">Volatile2pc</span></dt><dd>
                            <p>
                                The first of these protocols is the optional
                                <em class="firstterm">Volatile2PC</em>
                                (2PC is an abbreviation referring
                                to the two-phase commit). The Volatile2PC protocol is the WS-Atomic Transaction equivalent of the synchronization
                                protocol discussed earlier. It is typically executed where a Web service needs to flush
                                volatile (cached) state,
                                which may be used to improve performance of an application, to a database prior to the transaction
                                committing. Once flushed, the data is controlled by a two-phase aware participant.
                            </p>
                            <p>
                                When the completion participant initiates a
                                <code class="systemitem">commit</code>
                                operation, all Volatile2PC
                                participants are informed that the transaction is about to complete, via the
                                <code class="systemitem">prepare</code>
                                message. The participants can respond with one of three messages:
                                <code class="systemitem">prepared</code>
                                ,
                                <code class="systemitem">aborted</code>
                                , or
                                <code class="systemitem">readonly</code>
                                . A failure at this stage causes the
                                transaction to roll back.
                            </p>
                        </dd><dt><span class="term">Durable2PC</span></dt><dd>
                            <p>
                                The next protocol in the WS-Atomic Transaction is
                                <em class="firstterm">Durable2PC</em>
                                . The Durable2PC protocol is at
                                the core of WS-Atomic Transaction. It brings about the necessary consensus between participants in a transaction,
                                so the transaction can safely be terminated.
                            </p>
                            <p>
                                The Durable2PC protocol ensures atomicity between participants, and is based on the
                                classic technique of
                                <span>two-phase commit with presumed abort</span>
                                .
                            </p>
                            <div class="procedure" title="Procedure 4.3. Durable2PC Procedure"><a id="d5e7365"/><p class="title"><strong>Procedure 4.3. Durable2PC Procedure</strong></p><ol class="procedure" type="1"><li class="step" title="Step 1">
                                    <p>
                                        During the first phase, when the coordinator sends the prepare message, a
                                        participant must make durable any
                                        state changes that occurred during the scope of the transaction, so these changes can either be rolled back or
                                        committed later. None of the original state information can be lost at this
                                        point, since the atomic
                                        transaction may still roll back. If the participant cannot
                                        <code class="systemitem">prepare</code>
                                        , it must inform
                                        the coordinator, by means of the
                                        <code class="systemitem">aborted</code>
                                        message. The transaction will ultimately
                                        roll back. If the participant is responsible for a service that did not change any of the transaction's data,
                                        it can return the
                                        <code class="systemitem">readonly</code>
                                        message, causing it to be omitted from the second phase of
                                        the commit protocol. Otherwise, the
                                        <code class="systemitem">prepared</code>
                                        message is sent by the participant.
                                    </p>
                                </li><li class="step" title="Step 2">
                                    <p>
                                        If no failures occur during the first phase, Durable2PC proceeds to the second
                                        phase, in which the coordinator
                                        sends the
                                        <code class="systemitem">commit</code>
                                        message to participants. Participants then make permanent the
                                        tentative work done by their associated services, and send a
                                        <code class="systemitem">committed</code>
                                        message to the
                                        coordinator. If any failures occur, the coordinator sends the
                                        <code class="systemitem">rollback</code>
                                        message to all
                                        participants, causing them to discard tentative work done by their associated services, and delete any state
                                        information saved to persistent storage at
                                        <code class="systemitem">prepare</code>
                                        , if they have reached that
                                        stage. Participants respond to a rollback by sending an
                                        <code class="systemitem">aborted</code>
                                        message to the
                                        coordinator.
                                    </p>
                                </li></ol></div>
                            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                                <p>
                                    The semantics of the WS-Atomic Transaction protocol do not include the one-phase commit optimization. A full
                                    two-phase commit is always used, even where only a single participant is enlisted.
                                </p>
                            </div>
                        </dd></dl></div>
                <p>
                    <a class="xref" href="#two-pc-participant-state-transitions" title="Figure 4.10. WS-Atomic Two-Phase Participant State Transitions">Figure 4.10, “WS-Atomic Two-Phase Participant State Transitions”</a>
                    shows the state transitions of a WS-Atomic Transaction and
                    the message exchanges between coordinator and participant. Messages generated by the coordinator are represented by
                    solid lines, while the participants' messages use dashed lines.
                </p>
                <div class="figure"><a id="two-pc-participant-state-transitions"/><p class="title"><strong>Figure 4.10. WS-Atomic Two-Phase Participant State Transitions</strong></p><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/xts-fig-2pc-participant-state-transitions.png" alt="WS-Atomic Two-Phase Participant State Transitions" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7386.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7386.html" target="longdesc">D</a>]</span></div></div>
                </div></div><br class="figure-break"/>

                <p>
                    Once the Durable2PC protocol completes, the
                    <code class="systemitem">Completion</code>
                    protocol that originally began the
                    termination of the transaction can complete, and inform the client application whether the transaction was
                    committed or rolled back. Additionally, the Volatile2PC protocol may complete.
                </p>
                <p>
                    Like the
                    <code class="systemitem">prepare</code>
                    phase of Volatile2PC, the final phase is optional and can be used to
                    inform participants about the transaction's completion, so that they can release resources such as database
                    connections.
                </p>
                <p>
                    Any registered Volatile2PC participants are invoked after the transaction terminates, and are informed about the
                    transaction's completion state by the coordinator. Since the transaction has terminated, any
                    failures of
                    participants at this stage are ignored, since they have no impact on outcomes.
                </p>
                <p>
                    <a class="xref" href="#fig-at-model" title="Figure 4.11. ">Figure 4.11, “”</a>
                    illustrates the intricate interweaving of individual protocols comprising the AT as
                    a whole.
                </p>
                <div class="figure"><a id="fig-at-model"/><p class="title"><strong>Figure 4.11. </strong></p><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/xts-fig-at-model.png" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7400.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7400.html" target="longdesc">D</a>]</span></div></div>
                </div></div><br class="figure-break"/>
            </div> 


            <div class="section" title="4.3.2.3.2. Business Activities"><div class="titlepage"><div><div><h5 class="title"><a id="d5e7405"/>4.3.2.3.2. Business Activities</h5></div></div></div>
                
                <p>
                    Most B2B applications require transactional support in order to guarantee consistent outcome and correct
                    execution. These applications often involve long-running computations, loosely coupled systems, and components that
                    do not share data, location, or administration. It is difficult to incorporate atomic transactions within such
                    architectures.
                </p>
                <p>
                    For example, an online bookshop may reserve books for an individual for a specific period of time. However, if the
                    individual does not purchase the books within that period, they become available again for purchase
                    by other
                    customers. Because it is not possible to have an infinite supply of stock, some online shops may seem, from the
                    user's perspective, to reserve items for them, while actually allow others to preempt the reservation. A user may
                    discover, to his disappointment, that the item is no longer available.
                </p>
                <p>
                    A
                    <em class="firstterm">Business Activity (BA)</em>
                    is designed specifically for these kinds of long-duration
                    interactions, where it is impossible or impractical to exclusively lock resources.
                </p>
                <div class="procedure" title="Procedure 4.4. BA Process Overview"><a id="d5e7411"/><p class="title"><strong>Procedure 4.4. BA Process Overview</strong></p><ol class="procedure" type="1"><li class="step" title="Step 1">
                        <p>
                            Services are requested to do work.
                        </p>
                    </li><li class="step" title="Step 2">
                        <p>
                            Where those services have the ability to undo any work, they inform the BA, in case the BA
                            later decides the
                            cancel the work. If the BA suffers a failure. it can instruct the service to execute its
                            <code class="systemitem">undo</code>
                            behavior.
                        </p>
                    </li></ol></div>
                <p>
                    The key to BA is that how services do their work and provide compensation mechanisms is not the responsibility of
                    the WS-BA specification. It is delegated to the service provider.
                </p>
                <p>
                    The WS-BA defines a protocol for Web Services-based applications to enable existing business processing and
                    work-flow systems to wrap their proprietary mechanisms and interoperate across implementations and business
                    boundaries.
                </p>
                <p>
                    Unlike the WS-AT protocol model, where participants inform the coordinator of their state only when asked, a child
                    activity within a BA can specify its outcome to the coordinator directly, without waiting for a
                    request. A
                    participant may choose to exit the activity or may notify the coordinator of a failure at any point. This feature
                    is useful when tasks fail, since the notification can be used to modify the goals and drive processing forward,
                    without the need to wait until the end of the transaction to identify failures. A well-designed
                    Business Activity
                    should be proactive.
                </p>
                <p>
                    The BA protocols employ a compensation-based transaction model. When a participant in a business activity completes
                    its work, it may choose to exit the activity. This choice does not allow any subsequent rollback.
                    Alternatively,
                    the participant can complete its activity, signaling to the coordinator that the work it has done can be
                    compensated if, at some later point, another participant notifies a failure to the coordinator. In this latter
                    case, the coordinator asks each non-exited participant to compensate for the failure, giving them the opportunity
                    to execute whatever compensating action they consider appropriate. For instance, the participant might credit a bank
                    account which it previously debited. If all participants exit or complete without failure, the
                    coordinator notifies
                    each completed participant that the activity has been closed.
                </p>
                <p>
                    Underpinning all of this are three fundamental assumptions, detailed in
                    <a class="xref" href="#wsba-assumptions" title="Assumptions of WS-BA">Assumptions of WS-BA</a>
                    .
                </p>
                <div class="itemizedlist" title="Assumptions of WS-BA"><a id="wsba-assumptions"/><p class="title"><strong>Assumptions of WS-BA</strong></p><ul class="itemizedlist"><li class="listitem">
                        <p>
                            All state transitions are reliably recorded, including application state and coordination metadata (the record
                            of sent and received messages).
                        </p>
                    </li><li class="listitem">
                        <p>
                            All request messages are acknowledged, so that problems are detected as early as possible. This avoids
                            executing unnecessary tasks and can also detect a problem earlier when rectifying it is simpler and less
                            expensive.
                        </p>
                    </li><li class="listitem">
                        <p>
                            As with atomic transactions, a
                            <em class="firstterm">response</em>
                            is defined as a separate operation, not as the
                            output of the request. Message I/O implementations typically have timeout requirements too short for BA
                            responses. If the response is not received after a timeout, it is re-sent, repeatedly, until a response is
                            received. The receiver discards all but one identical request received.
                        </p>
                    </li></ul></div>

                <p>
                    The BA model has two participant protocols:
                    <code class="systemitem">BusinessAgreementWithParticipantCompletion</code>
                    and
                    <code class="systemitem">BusinessAgreementWithCoordinatorCompletion</code>
                    . Unlike the AT protocols which are driven from
                    the coordinator down to participants, this protocol takes the opposite approach.
                </p>

                <div class="variablelist"><dl><dt><span class="term">BusinessAgreementWithParticipantCompletion</span></dt><dd>
                            <div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1">
                                    <p>
                                        A participant is initially created in the Active state.
                                    </p>
                                </li><li class="step" title="Step 2">
                                    <p>
                                        If it finishes its work and it is no longer needed within the scope of the BA
                                        (such as when the activity
                                        operates on immutable data), the participant can unilaterally decide to exit, sending an
                                        <code class="systemitem">exited</code>
                                        message to the coordinator. However, if the participant finishes and wishes to
                                        continue in the BA, it must be able to compensate for the work it has performed.
                                        In this case, it sends a
                                        <code class="systemitem">completed</code>
                                        message to the coordinator and waits for the coordinator to notify it about
                                        the final outcome of the BA. This outcome is either a
                                        <code class="systemitem">close</code>
                                        message, meaning the BA
                                        has completed successfully, or a
                                        <code class="systemitem">compensate</code>
                                        message indicating that the participant
                                        needs to reverse its work.
                                    </p>
                                </li></ol></div>
                        </dd><dt><span class="term">BusinessAgreementWithCoordinatorCompletion</span></dt><dd>
                            <p>
                                The
                                <code class="systemitem">BusinessAgreementWithCoordinatorCompletion</code>
                                differs from the
                                <code class="systemitem">BusinessAgreementWithParticipantCompletion</code>
                                protocol in that the participant cannot
                                autonomously decide to complete its participation in the BA, even if it can be compensated.
                            </p>
                            <div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1">
                                    <p>
                                        Instead, the completion stage is driven by the client which created the BA,
                                        which sends a
                                        <code class="systemitem">completed</code>
                                        message to the coordinator.
                                    </p>
                                </li><li class="step" title="Step 2">
                                    <p>
                                        The coordinator sends a
                                        <code class="systemitem">complete</code>
                                        message to each participant, indicating that no
                                        further requests will be sent to the service associated with the participant.
                                    </p>
                                </li><li class="step" title="Step 3">
                                    <p>
                                        The participant continues on in the same manner as in the BusinessAgreementWithParticipantCompletion protocol.
                                    </p>
                                </li></ol></div>
                        </dd></dl></div>
                <p>
                    The advantage of the BA model, compared to the AT model, is that it allows the participation of services that
                    cannot lock resources for extended periods.
                </p>
                <p>
                    While the full ACID semantics are not maintained by a BA, consistency can still be maintained through
                    compensation. The task of writing correct compensating actions to preserve overall system consistency is the
                    responsibility of the developers of the individual services under control of the BA. Such compensations may use
                    backward error recovery, but forward recovery is more common.
                </p>
                <p>
                    <a class="xref" href="#fig-bawpc-state-transitions" title="Figure 4.12. ">Figure 4.12, “”</a>
                    shows the state transitions of a WS-BA
                    <code class="systemitem">BusinessAgreementWithParticipantCompletion</code>
                    participant and the message exchanges between
                    coordinator and participant. Messages generated by the coordinator are shown with solid lines, while the
                    participants' messages are illustrated with dashed lines.
                </p>
                <div class="figure"><a id="fig-bawpc-state-transitions"/><p class="title"><strong>Figure 4.12. </strong></p><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/xts-fig-bawpc-state-transitions.png" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7471.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7471.html" target="longdesc">D</a>]</span></div></div>
                </div></div><br class="figure-break"/>

                <p>
                    <a class="xref" href="#fig-bawcc-state-transitions" title="Figure 4.13. ">Figure 4.13, “”</a>
                    shows the state transitions of a WS-BA
                    <code class="systemitem">BusinessAgreementWithCoordinatorCompletion</code>
                    participant and the message exchanges between
                    coordinator and participant. Messages generated by the coordinator are shown with solid lines, while the
                    participants' messages are illustrated with dashed lines.
                </p>
                <div class="figure"><a id="fig-bawcc-state-transitions"/><p class="title"><strong>Figure 4.13. </strong></p><div class="figure-contents">
                    
                    <div class="mediaobject"><img src="images/xts-fig-bawcc-state-transitions.png" longdesc="/home/mmusgrov/tmp/narayana/6.0.0.Final/sources/documentation/project/target/docbook/publish/en-US/html_single/ld-d5e7481.html"/><div class="longdesc-link" align="right"><br clear="all"/><span class="longdesc-link">[<a href="ld-d5e7481.html" target="longdesc">D</a>]</span></div></div>
                </div></div><br class="figure-break"/>
            </div> 
        </div> 

        <div class="section" title="4.3.2.4. Application Messages"><div class="titlepage"><div><div><h4 class="title"><a id="d5e7486"/>4.3.2.4. Application Messages</h4></div></div></div>
            
            <p>
                <em class="firstterm">Application messages</em>
                are the requests and responses sent between parties, that constitute the
                work of a business process. Any such messages are considered opaque by XTS, and there is no mandatory message format,
                protocol binding, or encoding style. This means that you are free to use any appropriate Web Services
                protocol. In
                XTS, the transaction context is propagated within the headers of SOAP messages.
            </p>

            <p>
                XTS ships with support for service developers building WS-Transactions-aware services on the
     WildFly Application Server.
                Interceptors are provided for automatic context handling at both client and service, which
                significantly simplifies development, allowing you to concentrate on writing the business logic without being
                sidetracked by the transactional infrastructure. The interceptors add and remove context elements to application
                messages, without altering the semantics of the messages themselves. Any service which understands what to do with
                a WS-C context can use it. Services which are not aware of WS-C, WS-Atomic Transaction and WS-Business Activity can
                ignore the context. XTS manages contexts without user intervention.
            </p>

            <div class="section" title="4.3.2.4.1. WS-C, WS-Atomic Transaction, and WS-Business Activity Messages"><div class="titlepage"><div><div><h5 class="title"><a id="d5e7491"/>4.3.2.4.1. WS-C, WS-Atomic Transaction, and WS-Business Activity Messages</h5></div></div></div>
                
                <p>
                    Although the application or service developer is rarely interested in the messages exchanged by the transactional
                    infrastructure, it is useful to understand what kinds of exchanges occur so that the underlying
                    model can be fitted
                    in to an overall architecture.
                </p>
                <p>
                    WS-Coordination, WS-Atomic Transaction and WS-Business Activity-specific messages are transported
                    using SOAP
                    messaging over HTTP. The types of messages that are propagated include instructions to perform standard transaction
                    operations like
                    <code class="systemitem">begin</code>
                    and
                    <code class="systemitem">prepare</code>
                    .
                </p>
                <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                    <p>
                        XTS messages do not interfere with messages from the application, an application need not use the same transport
                        as the transaction-specific messages. For example, a client application might deliver its application-specific
                        messages using SOAP RPC over SMTP, even though the XTS messages are delivered using a different
                        mechanism.
                    </p>
                </div>
            </div>
        </div>

    </div>

    <div class="section" title="4.3.3. Summary"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7499"/>4.3.3. Summary</h3></div></div></div>
        
        <p>
            XTS provides a coordination infrastructure which allows transactions to run between services owned by different
            businesses, across the Internet. That infrastructure is based on the WS-C, WS-Atomic Transaction and
            WS-Business
            Activity specifications. It supports two kinds of transactions: atomic transactions and business activities, which
            can be combined in arbitrary ways to map elegantly onto the transactional requirements of the underlying
            problem. The use of the whole infrastructure is simple, because its functionality is exposed through a simple
            transactioning API. XTS provides everything necessary to keep application and transactional aspects of an
            application separate, and to ensure that a system's use of transactions does not interfere with the functional
            aspects of the system itself.
        </p>
    </div> 
</div>
</div>
    <div class="chapter" title="Chapter 5. Long Running Actions (LRA)"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7502"/>Chapter 5. Long Running Actions (LRA)</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d5e7504">5.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e7511">5.2. JAX-RS services</a></span></dt><dt><span class="section"><a href="#d5e7516">5.3. Non JAX-RS services</a></span></dt><dt><span class="section"><a href="#lra-examples">5.4. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7522">5.4.1. LRA Quickstart Examples</a></span></dt><dt><span class="section"><a href="#d5e7527">5.4.2. Participating in Long Running Actions</a></span></dt><dt><span class="section"><a href="#d5e7531">5.4.3. Making JAX-RS Invocations from JAX-RS Resource Methods</a></span></dt></dl></dd><dt><span class="section"><a href="#lra-integration">5.5. Runtime Integration</a></span></dt></dl></div>
    
    <div class="section" title="5.1. Overview"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7504"/>5.1. Overview</h2></div></div></div>
    

    <p>
    This guide describes the Naryana implementation, or Naryana LRA for short, of the MicroProfile LRA specification
    <a class="ulink" href="https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc">https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc</a>
    The specification introduces annotations and APIs for services to coordinate long running activities
    whilst still maintaining loose coupling and doing so in such a way as to guarantee a globally
    consistent outcome without the need to take locks on data for extended periods. The specification
    has similarities to WS-BA except that it uses a simplified compensation model and as such it
    can expose certain failure conditions that are not present in WS-BA. Please refer to 
    <a class="ulink" href="https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc#the-model">https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc#the-model</a> for details of the state model used by the LRA specification.
    </p>

    <p>
    The basic idea is to group a collection of compensatable JAX-RS service interactions within
    a context, called a Long Running Action (LRA). The context is propagated on JAX-RS service
    requests and responses using a JAX-RS header. The implementation automatically
    adds the header to requests and responses before and after service method invocation
    (using JAX-RS filters as an implementation technique). An attribute of the @LRA annotation
    determines how the LRA is started and/or ended.
    </p>

    <p>
    A service may join the context by, in the case of a JAX-RS resource, providing REST
    endpoints (via annotations) that the implementation should invoke when the LRA is
    later closed or cancelled. The specification is transactional in the sense that all the
    endpoints involved in the interaction are informed about the decision to close or
    cancel the context regardless of system failures.
    </p>
</div>
    <div class="section" title="5.2. JAX-RS services"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7511"/>5.2. JAX-RS services</h2></div></div></div>
    

    <p>
    Primary support is for JAX-RS based services to participate in transactional
    Long Running Actions (LRAs). Full details are available in the MP-LRA
    specification document
    <a class="ulink" href="https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc">https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc</a>.
    Also look in the examples section <a class="xref" href="#lra-examples" title="5.4. Examples">Section 5.4, “Examples”</a> below and in the MP-LRA TCK.
    </p>
</div>
    <div class="section" title="5.3. Non JAX-RS services"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7516"/>5.3. Non JAX-RS services</h2></div></div></div>
    

    <p>
    We also support POJO style participants, details of which are available in the
    specification and TCK available on the MP-LRA github repository
    <a class="ulink" href="https://github.com/eclipse/microprofile-lra">https://github.com/eclipse/microprofile-lra</a>
    </p>
</div>
    <div class="section" title="5.4. Examples"><div class="titlepage"><div><div><h2 class="title"><a id="lra-examples"/>5.4. Examples</h2></div></div></div>
    

<div class="section" title="5.4.1. LRA Quickstart Examples"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7522"/>5.4.1. LRA Quickstart Examples</h3></div></div></div>
    
    <p>
        There are some quickstarts with README.md files for using LRAs in the quickstart repository:
        <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/master/rts/lra-examples">https://github.com/jbosstm/quickstart/tree/master/rts/lra-examples</a>
        and
        <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/master/rts/lra">https://github.com/jbosstm/quickstart/tree/master/rts/lra</a>
    </p>
</div>
<div class="section" title="5.4.2. Participating in Long Running Actions"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7527"/>5.4.2. Participating in Long Running Actions</h3></div></div></div>
    
    <p>
        The following code snippet shows the basic steps for writing service methods
	(and associated participant resource) that will result in the registration
	of a participant in a new or an existing LRA.
    </p>

    <pre><code class="language-java">
@LRA(value = LRA.Type.REQUIRED, // if there is no incoming context a new one is created
     cancelOn = {
         Response.Status.INTERNAL_SERVER_ERROR // cancel on a 500 code
     },
     cancelOnFamily = {
         Response.Status.Family.CLIENT_ERROR // cancel on any 4xx code
     },
     end = false) // the LRA will continue to run when the method finishes
@Path("/book")
@POST
public Response bookTrip(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId,
                         @HeaderParam(LRA_HTTP_PARENT_CONTEXT_HEADER) URI parentLRA) {
    if (parentLRA != null) { // is the context nested
          // code which is sensitive to executing with a nested context goes here
    }
    ...
}

@LRA(LRA.Type.MANDATORY, // requires an active context before method can be executed
     end = true) // end the LRA started by the bookTrip method
@Path("/confirm")
@PUT
public Booking confirmTrip(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId,
                           @HeaderParam(LRA_HTTP_PARENT_CONTEXT_HEADER) URI parentLRA,
                           Booking booking) throws BookingException {
    if (parentLRA != null) { // is the context nested
          // code which is sensitive to executing with a nested context goes here
    }
    // lookup data associated with the incoming LRA (lraId)
    ...
}

@Complete
@Path("/complete")
@PUT
public Response completeWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)
{
    /*
     * Free up resources allocated in the context of the LRA identified by the
     * value in the injected JAX-RS header.
     *
     * Since there is no @Status method in this class, completeWork MUST be
     * idempotent and MUST return the status.
     */
    return Response.ok(ParticipantStatus.Completed.name()).build();
}

@Compensate
@Path("/compensate")
@PUT
public Response compensateWork(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId)
{
    /*
     * The LRA identified by the value in the injected JAX-RS header was
     * cancelled so the business logic should compensate for any actions
     * that have been performed while running in its context.
     *
     * Since there is no @Status method in this class, compensateWork MUST be
     * idempotent and MUST return the status
    */
    return Response.ok(ParticipantStatus.Compensated.name()).build();
}
    </code></pre>
</div>
<div class="section" title="5.4.3. Making JAX-RS Invocations from JAX-RS Resource Methods"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7531"/>5.4.3. Making JAX-RS Invocations from JAX-RS Resource Methods</h3></div></div></div>
    
    <p>
        According to the specification the LRA context (<a class="ulink" href="https://download.eclipse.org/microprofile/microprofile-lra-2.0-RC1/microprofile-lra-spec-2.0-RC1.html#_setting_the_context_on_outgoing_jax_rs_requests">https://download.eclipse.org/microprofile/microprofile-lra-2.0-RC1/microprofile-lra-spec-2.0-RC1.html#_setting_the_context_on_outgoing_jax_rs_requests</a>) is implicitly propagated to outgoing requests. The Narayana implementation enforces this requirement by storing the LRA context with the thread used to service the incoming request and then reading it if the service methods makes outgoing requests and adds the context to the outgoing headers. Although exhaustive testing of the implementation indicates that this requirement is met there is still a concern because the JAX-RS specification does not mandate that the same thread is used for the incoming and outgoing requests. We therefore recommend that the service writer explicitly set the context on outgoing requests as shown in the following code snippet:
    </p>

    <pre><code class="language-java">
    @LRA(value = LRA.Type.REQUIRED)
    @PUT
    public Response addContextHeader(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) URI lraId) {
        // some business logic

        // create an invocation builder for a remote service
        Invocation.Builder builder = ClientBuilder.newClient()
            .target(context.getBaseUri())
            .path(resource)
            .path(path)
            .request();

        // explicitly set the context
        builder.header(LRA_HTTP_CONTEXT_HEADER, lraId); // lraId must be valid

        Response response = builder.put(Entity.text("bodyText"));
            
        // more business logic

        return Response.ok().entity(lraId.toASCIIString()).build();
    }
    ...
    </code></pre>
</div>
</div>
    <div class="section" title="5.5. Runtime Integration"><div class="titlepage"><div><div><h2 class="title"><a id="lra-integration"/>5.5. Runtime Integration</h2></div></div></div>
    

    <p>
    To date we have only integrated with thorntail or standalone. The near term plan is
    to provide a quarkus extension and a WildFly subsystem for running coordinators and
    participants.
    </p>
</div>
</div>
    <div class="chapter" title="Chapter 6. RTS"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7539"/>Chapter 6. RTS</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d5e7541">6.1. Overview</a></span></dt><dt><span class="section"><a href="#_transaction_model">6.2. Transaction Model</a></span></dt><dd><dl><dt><span class="section"><a href="#_architecture">6.2.1. Architecture</a></span></dt><dt><span class="section"><a href="#_state_transitions">6.2.2. State Transitions</a></span></dt><dt><span class="section"><a href="#_the_transaction_manager_resource">6.2.3. The Transaction Manager Resource</a></span></dt></dl></dd><dt><span class="section"><a href="#_client_responsibilities">6.3. Client Responsibilities</a></span></dt><dd><dl><dt><span class="section"><a href="#_starting_a_transaction">6.3.1. Starting a Transaction</a></span></dt><dt><span class="section"><a href="#_obtaining_the_transaction_status">6.3.2. Obtaining The Transaction Status</a></span></dt><dt><span class="section"><a href="#_propagating_the_context">6.3.3. Propagating the Context</a></span></dt><dt><span class="section"><a href="#_discovering_existing_transactions">6.3.4. Discovering Existing Transactions</a></span></dt><dt><span class="section"><a href="#_ending_the_transaction">6.3.5. Ending the Transaction</a></span></dt></dl></dd><dt><span class="section"><a href="#_service_responsibilities">6.4. Service Responsibilities</a></span></dt><dd><dl><dt><span class="section"><a href="#_joining_the_transaction">6.4.1. Joining the Transaction</a></span></dt><dt><span class="section"><a href="#_leaving_the_transaction">6.4.2. Leaving the Transaction</a></span></dt><dt><span class="section"><a href="#2PC">6.4.3. Preparing and Committing Work</a></span></dt><dt><span class="section"><a href="#_recovery">6.4.4. Recovery</a></span></dt><dt><span class="section"><a href="#_pre_and_post_two_phase_commit_processing">6.4.5. Pre- and Post- Two-Phase Commit Processing</a></span></dt></dl></dd><dt><span class="section"><a href="#_container_integration">6.5. Container Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#_deploying_as_a_wildfly_subsystem">6.5.1. Deploying as a Wildfly Subsystem</a></span></dt><dt><span class="section"><a href="#_deploying_into_a_servlet_container">6.5.2. Deploying into a Servlet Container</a></span></dt></dl></dd><dt><span class="section"><a href="#_examples">6.6. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#_support_for_java_based_services">6.6.1. Support For Java based Services</a></span></dt></dl></dd><dt><span class="section"><a href="#_interoperating_with_other_transaction_models">6.7. Interoperating With Other Transaction Models</a></span></dt><dd><dl><dt><span class="section"><a href="#_jta_bridge">6.7.1. JTA Bridge</a></span></dt><dt><span class="section"><a href="#_web_services_transactions">6.7.2. Web Services Transactions</a></span></dt></dl></dd></dl></div>
    
    <div class="section" title="6.1. Overview"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7541"/>6.1. Overview</h2></div></div></div>

    

    <p>
        This guide covers the REST interfaces to the Narayana Transaction Manager. The actual protocol implemented by
        RESTAT described in this book is taken from the draft RESTAT specification
        <a class="ulink" href="https://github.com/jbosstm/documentation/blob/master/rts/docs/REST-Atomic_v2_draft_8_comments_sept_4.pdf">https://github.com/jbosstm/documentation/blob/master/rest-tx/docs/RESTAT-v2-latest.pdf</a>
        . The specification is still evolving but has reached a stability level such that it can be used in real
        world
        environments.
    </p>
    <p>
        Atomic transactions are a well-known technique for guaranteeing consistency in the presence of
        failures. The ACID properties of atomic transactions (Atomicity, Consistency, Isolation, Durability) ensure
        that even in complex business applications consistency of state is preserved, despite concurrent accesses
        and failures. This is extremely useful fault-tolerance technique, especially when multiple, possibly remote
        resources are involved.
    </p>
    <p>
        Consistency is especially important in a web application with dynamic servers. When users navigate a
        web application, they are viewing snapshots of the server state. If the snapshot is computed within a
        transaction, the state returned to the user is consistent. For many applications this is important for
        otherwise the inconsistent view of the data could be confusing to the user. Many developers have the
        incorrect perception that they do not need transactions if all they are doing is reading a database.
        However, if you are doing multiple reads and you want them to be consistent, then you need to do them within
        a transaction.
    </p>
    <p>
        Furthermore, even in the simplest of system, a single user environment where all operations are
        idempotent, retrying requires the capability to remember the list of participating resources as well as the
        operations that must be re-transmitted, potentially many times. As we shall see, fortunately this is an
        inherent part of a transaction system, provided in a reliable manner such that it can tolerate its own
        failures as well as those that occur elsewhere within the environment.
    </p>
    <p>
        Although the Web and REST have progressed well without the need for transactions there are a class of
        applications where the use of transactions, or at least atomicity, would be beneficial. To support this
        need, we have created a RESTful interface to the Narayana transaction manager.
    </p>
</div>
    <div class="section" title="6.2. Transaction Model"><div class="titlepage"><div><div><h2 class="title"><a id="_transaction_model"/>6.2. Transaction Model</h2></div></div></div>
    
    <p>
        The REST Atomic Transaction (RESTAT) model uses a traditional two-phase commit protocol with the
        following
        optimizations:
    </p>
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
            <p>
                Presumed rollback: the transaction coordinator need not record information about the participants in
                stable storage until
                it decides to commit, i.e., until after the prepare phase has completed
                successfully. A definitive
                answer that a transaction does not exist can be used to infer that it rolled
                back.
            </p>
        </li><li class="listitem">
            <p>
                One-phase: if the coordinator discovers that only a single participant is registered then it may omit
                the prepare phase.
            </p>
        </li><li class="listitem">
            <p>
                Read-only: a participant that is responsible for a service that did not modify any transactional data
                during the course of
                the transaction can indicate to the coordinator during prepare that it is a
                read-only participant
                and the coordinator can omit it from the second phase of the commit protocol.
            </p>
        </li></ul></div>
    <div class="section" title="6.2.1. Architecture"><div class="titlepage"><div><div><h3 class="title"><a id="_architecture"/>6.2.1. Architecture</h3></div></div></div>
        
        <p>
            The diagram below illustrates the various resources defined within the RESTAT protocol. We shall
            discuss
            each of these in the following sections.
        </p>
        <div class="figure"><a id="d5e7562"/><p class="title"><strong>Figure 6.1. Architecture</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/rts-architecture.png" alt="Architecture image"/></div>
        </div></div><br class="figure-break"/>
        <p>These components are enumerated below and discussed in the following sections:</p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    Transaction Manager: this is a factory resource that is responsible for creating new transactions.
                    Once created, the
                    transaction manager has no further role to play in the life of the transaction.
                </p>
            </li><li class="listitem">
                <p>
                    Transaction Coordinator: this is a specific resource for the transaction. It drives the two-phase
                    commit protocol and manages
                    interactions with participants.
                </p>
            </li><li class="listitem">
                <p>
                    Client: the user of transactions.
                </p>
            </li><li class="listitem">
                <p>
                    Service: a transaction-aware service that performs work that may need to be coordinated with other
                    such services
                    elsewhere.
                </p>
            </li><li class="listitem">
                <p>
                    Participant: a resource that manages the state changes performed by the service in the context of
                    a transaction. The
                    participant is driven through two-phase commit by the coordinator.
                </p>
            </li></ul></div>
    </div>
    <div class="section" title="6.2.2. State Transitions"><div class="titlepage"><div><div><h3 class="title"><a id="_state_transitions"/>6.2.2. State Transitions</h3></div></div></div>
        
        <p>
            A transaction coordinator and two-phase participant go through the state transitions shown:
        </p>
        <div class="figure"><a id="d5e7584"/><p class="title"><strong>Figure 6.2. StateTransitions</strong></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="images/rts-state_transitions.png" alt="StateTransitions image"/></div>
        </div></div><br class="figure-break"/>
        <p>
            As such, all of the resources in the protocol have statuses that can be represented as one of these
            values. Asking a resource to change its state from, say, Active to Committed, may drive it through all
            of the
            intermediate states and as a result trigger protocol specific events, such as driving the
            two-phase commit
            protocol.
        </p>
    </div>
    <div class="section" title="6.2.3. The Transaction Manager Resource"><div class="titlepage"><div><div><h3 class="title"><a id="_the_transaction_manager_resource"/>6.2.3. The Transaction Manager Resource</h3></div></div></div>
        
        <p>
            The transaction manager is represented by a URI (referred to as the
            <code class="systemitem">transaction-manager</code>
            URI). It enables clients to create new transaction resources and to query the list of current
            transactions.
            The actual URI depends upon how RESTAT is deployed and will be discussed later.
        </p>
    </div>
</div>
    <div class="section" title="6.3. Client Responsibilities"><div class="titlepage"><div><div><h2 class="title"><a id="_client_responsibilities"/>6.3. Client Responsibilities</h2></div></div></div>
    
    <p>The RESTAT client is responsible for creating and terminating transaction resources.</p>
    <div class="section" title="6.3.1. Starting a Transaction"><div class="titlepage"><div><div><h3 class="title"><a id="_starting_a_transaction"/>6.3.1. Starting a Transaction</h3></div></div></div>
        
        <p>
            Performing a POST on the
            <code class="systemitem">transaction-manager</code>
            URI with header as shown below will start a new transaction with a default timeout. A successful
            invocation
            returns a 201 HTTP status code and the Location header contains the URI of the newly created
            transaction
            resource, which we refer to as transaction-coordinator in the rest of this book. At least
            two related URLs
            will also be returned, one for use by the transaction terminator (typically referred to
            as the client) and
            one used for registering durable participation in the transaction (typically referred
            to as the server).
            These URIs are referred to as the transaction-terminator and
            <code class="systemitem">transaction-enlistment</code>
            URIs, respectively. Although uniform URL structures are used in the examples, these linked URLs can be
            of
            arbitrary format.
        </p>
        <pre><code class="language-html">
POST /transaction-manager HTTP/1.1
From: foo@bar.com
        </code></pre>
        <p>The corresponding response would be:</p>
        <pre><code class="language-html">
HTTP 1.1 201 Created
Location: /transaction-coordinator/1234
Link:&lt;/transaction-coordinator/1234/terminator&gt;; rel=”terminator”,
    &lt;/transaction-coordinator/1234/participant&gt;; rel=”durable-participant”,
    &lt;/transaction-coordinator/1234/vparticipant&gt;; rel=”volatile-participant”
        </code></pre>
        <p>
            The lifetime of the transaction resource can be controlled by including a timeout in milliseconds in the
            body of the POST request
        </p>
        <pre><code class="language-html">
POST /transaction-manager HTTP/1.1
From: foo@bar.com
Content-Type: text/plain
Content-Length: --

timeout=1000
        </code></pre>
        <p>
            Performing a HEAD on the
            <code class="systemitem">transaction-coordinator</code>
            URI returns the same link information.
        </p>
        <p>
            Performing a DELETE on the
            <code class="systemitem">transaction-coordinator</code>
            or
            <code class="systemitem">transaction-enlistment</code>
            URIs are not allowed (and an attempt to do so will result in a 403 status code).
        </p>
    </div>
    <div class="section" title="6.3.2. Obtaining The Transaction Status"><div class="titlepage"><div><div><h3 class="title"><a id="_obtaining_the_transaction_status"/>6.3.2. Obtaining The Transaction Status</h3></div></div></div>
        
        <p>
            Performing a GET on the
            <code class="systemitem">transaction-coordinator</code>
            URI returns the current status of the transaction:
        </p>
        <pre><code class="language-html">
GET /transaction-coordinator/1234 HTTP/1.1
Accept: application/txstatus
        </code></pre>
        <p>With an example response:</p>
        <pre><code class="language-html">
HTTP/1.1 200 OK
Content-Length: --
Content-Type: application/txstatus
Link:&lt;/transaction-coordinator/1234/terminator&gt;; rel=”terminator”,
    &lt;/transaction-coordinator/1234/participant&gt;; rel=”durable-participant”,
    &lt;/transaction-coordinator/1234/vparticipant&gt;; rel=”volatile-participant”

txstatus=TransactionActive
        </code></pre>
        <p>
            Additional information about the transaction, such as the number of participants and their individual
            URIs,
            is returned if the client specifies the application/txstatusext+xml media type. For full details
            of this
            extended media type please refer to the specification and to the xsd in the restat-util jar
            packaging (
            <a class="ulink" href="https://github.com/jbosstm/narayana/tree/master/rts/at/util/src/main/resources/restat.xsd">https://github.com/jbosstm/narayana/tree/master/rts/at/util/src/main/resources/restat.xsd
            </a>
            ).
        </p>
    </div>
    <div class="section" title="6.3.3. Propagating the Context"><div class="titlepage"><div><div><h3 class="title"><a id="_propagating_the_context"/>6.3.3. Propagating the Context</h3></div></div></div>
        
        <p>
            When making an invocation on a resource that needs to participate in a transaction, either the
            <code class="systemitem">transaction-coordinator</code>
            URI or the
            <code class="systemitem">transaction-enlistment</code>
            URI (/transaction-coordinator/1234/participant in the previous example) needs to be transmitted to the
            resource.
            <em><span class="remark">Alternatively, if the client knows which endpoints the service will use to cancel or commit its
                work, it can
                do the registration and skip this requirement to propagate the context).
            </span></em>
            If the context is to be propagated then the mechanism is private to the service writer but the following
            OPTIONAL approach is recommended:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    The URI is passed as a Link header with the relevant service interaction.
                </p>
            </li></ul></div>
        <p>
            If the RESTAT user follows this convention then we can provide tools to the service writer to
            automate
            transaction handling. For example, if the client wishes to make a transactional service request
            then it
            should include a link to the URI used for enlisting into a transaction (which the client may
            have obtained
            when it first created the transaction) as follows:
        </p>
        <pre><code class="language-html">
Link:&lt;/transaction-coordinator/1234/participant&gt;; rel=”durable-participant”
        </code></pre>
        <p>or</p>
        <pre><code class="language-html">
Link:&lt;/transaction-coordinator/1234&gt;; rel=”transaction-coordinator”
        </code></pre>
        <p>
            and similarly if the client wants to pass the volatile participant URI to the invoked REST service.
        </p>
    </div>
    <div class="section" title="6.3.4. Discovering Existing Transactions"><div class="titlepage"><div><div><h3 class="title"><a id="_discovering_existing_transactions"/>6.3.4. Discovering Existing Transactions</h3></div></div></div>
        
        <p>
            Performing a GET on the
            <code class="systemitem">transaction-manager</code>
            URI with media type
            <code class="systemitem">application/txlist</code>
            returns a list of all
            <code class="systemitem">transaction-coordinator</code>
            URIs known to the coordinator (active and in recovery). The returned response includes a link header
            with
            <code class="systemitem">rel</code>
            attribute
            <code class="systemitem">statistics</code>
            linking to a resource that contains statistical information such as the number of transactions that have
            committed and aborted.
        </p>
        <p>
            Performing a GET on the
            <code class="systemitem">transaction-manager</code>
            URI with media type
            <code class="systemitem">application/txstatusext+xml</code>
            returns extended information about the transaction-manager resource such as how long it has been up and
            all
            <code class="systemitem">transaction-coordinator</code>
            URIs.
        </p>
    </div>
    <div class="section" title="6.3.5. Ending the Transaction"><div class="titlepage"><div><div><h3 class="title"><a id="_ending_the_transaction"/>6.3.5. Ending the Transaction</h3></div></div></div>
        
        <p>
            The client can PUT a document containing the desired transaction status to the
            <code class="systemitem">transaction-terminator</code>
            URI in order to control the outcome of the transaction. Upon termination, the resource and all
            associated
            resources are implicitly deleted. If the client wishes to commit the transaction it sends the
            following
            resource update request:
        </p>
        <pre><code class="language-html">PUT /transaction-coordinator/1234/terminator HTTP/1.1
From: foo@bar.com
Content-Type: application/txstatus
Content-Length: --

txstatus=TransactionCommitted</code></pre>
        <p>
            The response body contains the transaction outcome. The state of the transaction resource must be
            <code class="systemitem">TransactionActive</code>
            for this operation to succeed otherwise a 412 status code is returned.
        </p>
        <p>The transaction may be told to rollback with the following PUT request:</p>
        <pre><code class="language-html">
PUT /transaction-coordinator/1234/terminator HTTP/1.1
From: foo@bar.com
Content-Type: application/txstatus
Content-Length: --

txstatus=TransactionRolledBack
        </code></pre>
    </div>
</div>
    <div class="section" title="6.4. Service Responsibilities"><div class="titlepage"><div><div><h2 class="title"><a id="_service_responsibilities"/>6.4. Service Responsibilities</h2></div></div></div>
    
    <p>
        Once a resource has the transaction or enlistment URI, it can register participation in the transaction (or,
        alternatively, as mentioned earlier it is possible for the client to register the service directly with the
        coordinator if it knows the services cancel and commit endpoints). Each participant must be uniquely
        identified to the transaction coordinator in order that the protocol can guarantee consistency and atomicity
        in the event of failure and recovery. The participant is free to use whatever URI structure it desires for
        uniquely identifying itself; in the rest of this manual we shall assume it is /participant-resource and
        refer to it as the
        <code class="systemitem">participant-resource</code>
        URI.
    </p>
    <div class="section" title="6.4.1. Joining the Transaction"><div class="titlepage"><div><div><h3 class="title"><a id="_joining_the_transaction"/>6.4.1. Joining the Transaction</h3></div></div></div>
        
        <div class="section" title="6.4.1.1. Two Phase Aware Participants"><div class="titlepage"><div><div><h4 class="title"><a id="_two_phase_aware_participants"/>6.4.1.1. Two Phase Aware Participants</h4></div></div></div>
            
            <p>
                A participant is registered with the
                <code class="systemitem">transaction-coordinator</code>
                using POST on the
                <code class="systemitem">participant-enlistment</code>
                URI obtained when the transaction was originally created. The request must include two link headers:
                one to uniquely identify the participant to the coordinator and one to provide a terminator resource
                (referred to as the
                <code class="systemitem">participant-terminator</code>
                URI) that the coordinator will use to terminate the participant. If the
                <code class="systemitem">rel</code>
                attributes of the link are not participant and terminator the implementation will return 400. Note,
                the following URIs are only examples, and an implementation is free to use whatever structure/format
                it likes:
            </p>
            <pre><code class="language-html">
POST /transaction-coordinator/1234/participant
HTTP/1.1
From: foo@bar.com
Link:&lt;/participant-resource&gt;; rel=”participant”,
    &lt;/participant-resource/terminator&gt;; rel=”terminator”

Content-Length: 0
            </code></pre>
            <p>
                Performing a HEAD on the
                <code class="systemitem">participant-resource</code>
                URI will return the terminator reference, as shown below:
            </p>
            <pre><code class="language-html">
HEAD /participant-resource HTTP/1.1
From: foo@bar.com

HTTP/1.1 200 OK
Link:&lt;/participant-resource/terminator&gt;; rel=”terminator”
            </code></pre>
            <p>
                If the transaction is not
                <code class="systemitem">TransactionActive</code>
                when registration is attempted, then the implementation returns a 412 status code. If the
                implementation has seen this participant URI before then it returns 400. Otherwise the operation is
                considered a success and the implementation will return 201 and uses the Location header to give a
                participant specific URI that the participant may use later during prepare or for recovery purposes.
                The lifetime of this URI is the same as the
                <code class="systemitem">transaction-coordinator</code>
                URI. In the rest of this specification we shall refer to this as the
                <code class="systemitem">participant-recovery</code>
                URI (not to be confused with the
                <code class="systemitem">participant-resource</code>
                URI). An example response from the
                <code class="systemitem">transaction-coordinator</code>
                to a successful enlistment request is:
            </p>
            <pre><code class="language-html">
HTTP/1.1 201 Created
Location: /participant-recovery/1234
            </code></pre>
        </div>
        <div class="section" title="6.4.1.2. Two Phase Unaware Participants"><div class="titlepage"><div><div><h4 class="title"><a id="_two_phase_unaware_participants"/>6.4.1.2. Two Phase Unaware Participants</h4></div></div></div>
            
            <p>
                In order for a participant to be enlisted with a transaction it must be transaction aware to
                fulfill the requirements placed on it to ensure data consistency in the presence of failures or
                concurrent access. However, it is not necessary that a participant be modified such that it has a
                terminator resource as outlined previously: it simply needs a way to tell the coordinator which
                resource(s) to communicate with when driving the two-phase protocol. This type of participant will
                be referred to as Two-Phase Unaware, though strictly speaking such a participant or service does
                need to understand the protocol as mentioned earlier.
            </p>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>enlisting two-phase unaware participants is not a mandatory requirement on service writers.
                </p>
            </div>
            <p>
                During enlistment a service must provide URIs for prepare, commit, rollback and optionally a
                commit-one-phase URI:
            </p>
            <pre><code class="language-html">
POST /transaction-coordinator/1234/participant
HTTP/1.1
From: foo@bar.com
Link:&lt;/participant-resource&gt;; rel=”participant”,
    &lt;/participant-resource/prepare&gt;; rel=”prepare”,
    &lt;/participant-resource/commit&gt;; rel=”commit”,
    &lt;/participant-resource/rollback&gt;; rel=”rollback”,
    &lt;/participant-resource/commit-one-phase&gt;; rel=”commit-one-phase”

Content-Length: 0
            </code></pre>
            <p>
                Performing a HEAD on a registered participant URI must return these references, as shown below:
            </p>
            <pre><code class="language-html">
HEAD /participant-resource HTTP/1.1
From: foo@bar.com

HTTP/1.1 200 OK
Link:&lt;/participant-resource/prepare&gt;; rel=”prepare”,
    &lt;/participant-resource/commit&gt;; rel=”commit”,
    &lt;/participant-resource/rollback&gt;; rel=”rollback”,
    &lt;/participant-resource/commit-one-phase&gt;; rel=”commit-one-phase”</code></pre>
            <p>
                A service that registers a participant must therefore either define a terminator relationship
                for the participant or the relationships/resources needed for the two-phase commit protocol.
            </p>
        </div>
        <div class="section" title="6.4.1.3. Obtaining the Participant Status"><div class="titlepage"><div><div><h4 class="title"><a id="_obtaining_the_participant_status"/>6.4.1.3. Obtaining the Participant Status</h4></div></div></div>
            
            <p>
                Performing an HTTP GET request on the
                <code class="systemitem">participant-resource</code>
                URI must return the current status of the participant in the same way as for the
                <code class="systemitem">transaction-coordinator</code>
                URI discussed earlier. Determining the status of a participant whose URI has been removed is similar
                to that discussed for the
                <code class="systemitem">transaction-coordinator</code>
                URI:
            </p>
            <pre><code class="language-html">
GET /participant-resource HTTP/1.1
Accept: application/txstatus
            </code></pre>
            <p>With an example response:</p>
            <pre><code class="language-html">
HTTP/1.1 200 OK
Content-Length: --
Content-Type: application/txstatus

txstatus=TransactionActive
            </code></pre>
        </div>
    </div>
    <div class="section" title="6.4.2. Leaving the Transaction"><div class="titlepage"><div><div><h3 class="title"><a id="_leaving_the_transaction"/>6.4.2. Leaving the Transaction</h3></div></div></div>
        
        <p>
            A participant can leave the transaction at any time by sending a DELETE request to the coordinator using
            the URI it obtained during registration (i.e., the
            <code class="systemitem">participant-recovery</code>
            URI). Alternatively, it can respond to a prepare request from the coordinator with content body
            containing
            <code class="systemitem">txstatus=TransactionReadOnly</code>
            (in which case the transaction coordinator will remove it from further participation in the
            transaction). Otherwise it is the participants responsibility to participate in the
            <a class="link" href="#2PC" title="6.4.3. Preparing and Committing Work">transaction termination protocol</a>
            .
        </p>
    </div>
    <div class="section" title="6.4.3. Preparing and Committing Work"><div class="titlepage"><div><div><h3 class="title"><a id="2PC"/>6.4.3. Preparing and Committing Work</h3></div></div></div>
        
        <p>
            The coordinator drives the participant through the two-phase commit protocol by sending a PUT request to
            the
            <code class="systemitem">participant-terminator</code>
            URI, provided to the coordinator during enlistment, with the desired transaction outcome as the content
            (
            <code class="systemitem">TransactionPrepared</code>
            ,
            <code class="systemitem">TransactionCommitted</code>
            ,
            <code class="systemitem">TransactionRolledBack</code>
            or
            <code class="systemitem">TransactionCommittedOnePhase</code>
            ). For instance, here is how the prepare phase would be driven:
        </p>
        <pre><code class="language-html">
PUT /participant-resource/terminator HTTP/1.1
From: foo@bar.com
Content-Type: application/txstatus
Content-Length: --

txstatus=TransactionPrepared
        </code></pre>
        <p>
            If PUT is successful then the implementation returns 200. A subsequent GET on the URI will return
            the current status of the participant as described previously. It is not always necessary to enquire as
            to the status of the participant once the operation has been successful.
        </p>
        <p>
            If PUT fails, e.g., the participant cannot be prepared, then the service writer must return 409.
            Depending upon the point in the two-phase commit protocol where such a failure occurs the transaction
            will roll back, e.g., because we use presumed abort semantics, failures prior to the end of the prepare
            phase
            <span class="strong"><strong>always</strong></span>
            result in a rollback. If the participant is not in the correct state for the requested operation, e.g.,
            <code class="systemitem">TransactionPrepared</code>
            when it has already been prepared, then the service writer will return 412.
        </p>
        <p>
            If the transaction coordinator receives any response other than 200 then the transaction
            <span class="strong"><strong>always</strong></span>
            rolls back.
        </p>
        <p>
            After a request to change the resource state using
            <code class="systemitem">TransactionRolledBack</code>
            ,
            <code class="systemitem">TransactionCommitted</code>
            or
            <code class="systemitem">TransactionCommittedOnePhase</code>
            , any subsequent PUT request will return a 409 or 410 code.
        </p>
        <p>
            The usual rules of heuristic decisions apply here (i.e., the participant cannot forget the choice
            it made until it is told to by the coordinator).
        </p>
        <p>
            Performing a DELETE on the
            <code class="systemitem">participant-resource</code>
            URI will cause the participant to forget any heuristic decision it made on behalf of the transaction. If
            the operation succeeds then 200 will be returned and the implementation will delete the resource; a
            subsequent PUT or GET request returns 410. Any other response means the coordinator will keep retrying.
        </p>
    </div>
    <div class="section" title="6.4.4. Recovery"><div class="titlepage"><div><div><h3 class="title"><a id="_recovery"/>6.4.4. Recovery</h3></div></div></div>
        
        <p>
            In general it is assumed that failed actors in this protocol, i.e., coordinator or participants,
            will recover on the same URI as they had prior to the failure. HTTP provides a number of options to
            support temporary or permanent changes of address, including 301 (Moved Permanently) and 307 (Temporary
            Redirect), if the actor is unable to recover on the same URI then requests to the original endpoints
            should return an HTTP status code of 301 (Moved Permanently), 307 (Temporary Redirect) is also
            acceptable.
        </p>
        <p>
            However, sometimes it is possible that a participant may crash and recover on a different URI,
            e.g., the original machine is unavailable, or that for expediency it is necessary to move recovery to a
            different machine. In that case it may be the case that the transaction coordinator is unable to
            complete the transaction, even during recovery. As a result this protocol defines a way for a recovering
            server to update the information maintained by the coordinator on behalf of these participants.
        </p>
        <p>
            If the recovering participant uses the
            <code class="systemitem">participant-recovery</code>
            URI returned by the coordinator during enlistment then a GET on the
            <code class="systemitem">participant-recovery</code>
            URI will return the participant resource and terminator as link headers that the participant used during
            the original registration.
        </p>
        <p>
            Performing a PUT on the
            <code class="systemitem">participant-recovery</code>
            URI will overwrite the old participant URI with the new one supplied. This operation is equivalent to
            re-enlisting the participant. This will also trigger off a recovery attempt on the associated
            transaction using the new participant URI. For example to update location URIs, a two phase aware
            participant would PUT the following document:
        </p>
        <pre><code class="language-html">
PUT /participant-recovery/1234 HTTP/1.1
From: foo@bar.com
Link:&lt;/new-participant-resource&gt;; rel=”participant”,
&lt;/participant-resource/new-terminator&gt;; rel=”terminator”

Content-Length: 0
        </code></pre>
        <p>Similarly for a two phase unaware participant.</p>
        <p>
            If, after performing the PUT request to the
            <code class="systemitem">participant-recovery</code>
            URI, the participant is not asked to complete (within an implementation dependent period) then the
            protocol requires that the participant re-issue the PUT request.
        </p>
    </div>
    <div class="section" title="6.4.5. Pre- and Post- Two-Phase Commit Processing"><div class="titlepage"><div><div><h3 class="title"><a id="_pre_and_post_two_phase_commit_processing"/>6.4.5. Pre- and Post- Two-Phase Commit Processing</h3></div></div></div>
        
        <p>
            Most modern transaction processing systems allow the creation of participants that do not take part
            in the two-phase commit protocol, but are informed before it begins and after it has completed. They are
            called Synchronizations, and are typically employed to flush volatile (cached) state, which may be being
            used to improve performance of an application, to a recoverable object or database prior to the
            transaction committing.
        </p>
        <p>
            This additional protocol is accomplished by supporting an additional two-phase commit protocol that
            encloses the protocol already discussed. This will be termed the Volatile Two Phase Commit protocol, as
            the participants involved in it are not required to be durable for the purposes of data consistency,
            whereas the other protocol will be termed the Durable Two Phase Commit protocol. The coordinator will
            not record any durable information on behalf of Volatile participants.
        </p>
        <p>
            In this enclosing protocol the Volatile prepare phase executes prior to the Durable prepare. The
            <code class="systemitem">transaction-coordinator</code>
            sends a PUT request to the registered
            <code class="systemitem">volatile-participant</code>
            : only if this prepare succeeds will the Durable protocol be executed. The
            <code class="systemitem">volatile-participant</code>
            has to indicate success by returning a 200 status code (any other code indicates failure). If the
            Durable protocol completes then this may be communicated to the Volatile participants through the commit
            or rollback phases.
            In this case the
            <code class="systemitem">transaction-coordinator</code>
            sends a PUT request to the registered
            <code class="systemitem">volatile-participant</code>
            with the outcome in the request body (using content type
            <code class="systemitem">application/txstatus</code>
            ). However, because the coordinator does not maintain any information about these participants and the
            Durable protocol has completed, this is a best-effort approach only, i.e., such participants should not
            assume they will be informed about the transaction outcome. If that is a necessity then they should
            register with the Durable protocol instead.
        </p>
        <p>
            The primary difference between the Volatile and Durable protocols is that there is no recovery
            associated with the Volatile protocol so enlistment of volatile participants does not return a
            <code class="systemitem">participant-recovery</code>
            URI. In addition there can be no heuristic outcomes associated with the Volatile protocol. Once the
            Durable protocol has started no more registration in the Volatile protocol are allowed. And finally,
            there is no one-phase commit optimization for the Volatile protocol.
        </p>
    </div>
</div>
    <div class="section" title="6.5. Container Integration"><div class="titlepage"><div><div><h2 class="title"><a id="_container_integration"/>6.5. Container Integration</h2></div></div></div>
    
    <p>
        The RESTAT protocol described here is implemented as a JAX-RS service, deploys as a Servlet 3.0
        application and depends on the Narayana TM as the back-end transaction engine. JAX-RS is the Java language
        support for building REST based applications - it is both an annotation-based API for defining resources and
        a run-time for mapping HTTP requests to Java methods. Thus any container supporting these two requirements
        (servlet 3.0 and the Narayana TM) can be used.
    </p>
    <div class="section" title="6.5.1. Deploying as a Wildfly Subsystem"><div class="titlepage"><div><div><h3 class="title"><a id="_deploying_as_a_wildfly_subsystem"/>6.5.1. Deploying as a Wildfly Subsystem</h3></div></div></div>
        
        <p>
            The RESTAT coordinator is integrated with the 8.0.0.Alpha3 and subsequent releases of the Wildfly
            application server (
            <a class="ulink" href="http://www.wildfly.org/download/">http://www.wildfly.org/download/</a>
            ) as a subsystem (called RTS) so you do not have to explicitly deploy it. You do, however, need to start
            the application server using an optional server configuration:
        </p>
        <pre class="screen"> change directory to where the application server is installed
            Linux: ./bin/standalone.sh --server-config=../../docs/examples/configs/standalone-rts.xml
            Windows: bin\standalone.bat --server-config=..\..\docs\examples\configs\standalone-rts.xml
        </pre>
        <p>
            For this mode of deployment the
            <code class="systemitem">transaction-manager</code>
            URI is
            <a class="ulink" href="http://&lt;host&gt;:&lt;port&gt;/rest-at-coordinator/tx/transaction-manager">http://&lt;host&gt;:&lt;port&gt;/rest-at-coordinator/tx/transaction-manager</a>
        </p>
    </div>
    <div class="section" title="6.5.2. Deploying into a Servlet Container"><div class="titlepage"><div><div><h3 class="title"><a id="_deploying_into_a_servlet_container"/>6.5.2. Deploying into a Servlet Container</h3></div></div></div>
        
        <p>
            For other versions of the application server you will need to deploy the coordinator as a war
            archive using the standard war deployment mechanism appropriate to your particular container. The
            archive is contained in the bin folder of the narayana download (restat-web.war). If you are building
            from source the archive is located in rts/at/webservice/target/restat-web-&lt;version&gt;.war.</p>
        <p>
            For this mode of deployment the
            <code class="systemitem">transaction-manager</code>
            URI is
            <a class="ulink" href="http://&lt;host&gt;:&lt;port&gt;/rest-tx/tx/transaction-manager">http://&lt;host&gt;:&lt;port&gt;/rest-tx/tx/transaction-manager</a>
        </p>
    </div>
</div>
    <div class="section" title="6.6. Examples"><div class="titlepage"><div><div><h2 class="title"><a id="_examples"/>6.6. Examples</h2></div></div></div>
    
    <p>
        The quickstarts contained in the release bundles or in the quickstart repo (
        <a class="ulink" href="https://github.com/jbosstm/quickstart">https://github.com/jbosstm/quickstart</a>
        ) contain examples of all the features provided by RESTAT. The unit tests in the source bundle are also a
        good resource for further examples.
    </p>
    <div class="section" title="6.6.1. Support For Java based Services"><div class="titlepage"><div><div><h3 class="title"><a id="_support_for_java_based_services"/>6.6.1. Support For Java based Services</h3></div></div></div>
        
        <p>
            For REST services written in Java there is a Utility class called org.jboss.jbossts.star.util.TxSupport
            in the source bundle (or is available at
            <a class="ulink" href="https://github.com/jbosstm/narayana">https://github.com/jbosstm/narayana</a>
            ) which contains a variety of methods which help service writers to conform to the specification. The
            majority of the RESTAT quickstarts use this utility API.
        </p>
        <p>
            Alternatively, there is a RESTAT integration API for service writers. This API takes care of
            transaction enlistment and handles the responsibility for listening for transaction completion requests
            on HTTP endpoints from the transaction coordinator. Normally when a services wishes to join an existing
            transaction it sends a message to the coordinator containing HTTP endpoints on which it will be notified
            when the transaction progresses through its prepare and commit stages. The integration API simplifies
            this task and instead the service enlists a participant which implements a callback interface
            (org.jboss.narayana.rest.integration.api.ParticipantsManager). The API will then invoke the callback
            transparently (to the service) when the completion protocol begins executing. This makes managing
            participants much cleaner for the service writer. The service writer should implement the interface
            org.jboss.narayana.rest.integration.api.Participant:
        </p>
        <pre><code class="language-java">
public interface Participant {
    Vote prepare();
    void commit() throws HeuristicException;
    void commitOnePhase();
    void rollback() throws HeuristicException;
}
        </code></pre>
        <p>and register this implementation with the participant service manager:</p>
        <pre><code class="language-java">
ParticipantsManagerFactory.getInstance().enlist(...);
        </code></pre>
        <p>The getInstance method on the ParticipantsManagerFactory returns an instance of the interface
            ParticipantsManager which is global to the (JAX-RS) application:
        </p>
        <pre><code class="language-java">
public interface ParticipantsManager {
    ...
    String enlist(String applicationId,
    String participantEnlistmentURL,
    Participant participant);
    void registerDeserializer(String applicationId,
    ParticipantDeserializer deserializer);
    void reportHeuristic(String participantId,
    HeuristicType heuristicType);
}
        </code></pre>
        <p>
            The participantEnlistmentURL in the enlist method corresponds to a running REST transaction which
            the service acquires during normal interactions with service clients. To register for completion
            callbacks the service writer registers an interface using the enlist method and passes in an
            implementation of Participant. For full details of this interface please refer to the javadoc for
            org.jboss.narayana.rest.integration.api.ParticipantsManager
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                Now when a service client terminates a transaction the services' callback methods will be
                invoked by the RESTAT coordinator which may or may not be running locally (since these are
                distributed transactions). It is interesting to note that the wildfly application server is a
                modular container so subsystems and applications run in their own class loaders. In the event of
                failures a recovery system will need to recreate participant callback registrations in order to
                complete any pending transaction and therefore will no longer have access to the original class. The
                service writer must help the recovery system in this task via the registerDeserializer call. The
                final method on the interface (reportHeuristic) is to allow services to independently abort or
                commit work before being asked to via the callback interface.
            </p>
        </div>
        <p>
            For full details of this interface please refer to the javadoc for
            org.jboss.narayana.rest.integration.api.ParticipantsManager
        </p>
        <p>
            The accessibility of the ParticipantsManagerFactory from your application depends upon whether the
            container contains the RTS subsystem. Versions of the wildfly application server from 8.0.0.Alpha3
            onwards contain this subsystem so your manifest should declare a dependency on it by adding the line
            "Dependencies: org.jboss.narayana.rts" to the MANIFEST.MF file in your archive. For other containers you
            should register the dependency programatically. The quickstarts contain examples of how to do this for
            the embedded Resteasy and Jersey JAX-RS containers (look for classes called JaxrsServer in the
            quickstart source for rts/at/service/service2 and rts/at/recovery/recovery2).
        </p>
    </div>
</div>
    <div class="section" title="6.7. Interoperating With Other Transaction Models"><div class="titlepage"><div><div><h2 class="title"><a id="_interoperating_with_other_transaction_models"/>6.7. Interoperating With Other Transaction Models</h2></div></div></div>
    
    <p>
        Narayana in general supports a number of different transaction models other than the one described in
        this book. Of particular importance are the standard ones supported by the standards, namely JTA and Web
        Services Transactions.
    </p>
    <div class="section" title="6.7.1. JTA Bridge"><div class="titlepage"><div><div><h3 class="title"><a id="_jta_bridge"/>6.7.1. JTA Bridge</h3></div></div></div>
        
        <div class="section" title="6.7.1.1. Inbound Bridge"><div class="titlepage"><div><div><h4 class="title"><a id="_inbound_bridge"/>6.7.1.1. Inbound Bridge</h4></div></div></div>
            
            <p>
                REST-AT to JTA bridge (also called inbound bridge) allows JTA resources to be enlisted in
                REST-AT transaction. Therefore, tools such as JPA and JMS can be used by JAX-RS endpoints and their
                XA resources will participate in the REST-AT transaction together with RESTful participants.
            </p>
            <p>
                This functionality is provided by Wildfly RTS subsytem. Therefore, modular dependency on
                org.jboss.narayana.rts has to be defined in deployment’s manifest file.
                In order to enable bridging, service writer has to annotate either JAX-RS resource class or specific JAX-RS resource
                method with one of two annotations: jakarta.ejb.TransactionAttribute, jakarta.transaction.Transactional.
            </p>
            <pre><code class="language-java">
@Path("/")
public class JAXRSResource {
    @GET
    public void get() {
    // Do work witout JTA.
    }

    @POST
    @TransactionAttribute
    public void post() {
    // Do work with JTA.
    }
}
            </code></pre>
            <pre><code class="language-java">
@Path("/")
@Transactional
public class JAXRSResource {
    @GET
    public void get() {
    // Do work with JTA.
    }

    @POST
    public void post() {
    // Do work with JTA.
    }
}
            </code></pre>

            <p>
                REST-AT transaction context does not provide timeout.
                When REST-AT transaction is bridged to JTA then the bridged JTA transaction
                is created with the default timeout defined by the container.
            </p>
        </div>
        <div class="section" title="6.7.1.2. Outbound Bridge"><div class="titlepage"><div><div><h4 class="title"><a id="_outbound_bridge"/>6.7.1.2. Outbound Bridge</h4></div></div></div>
            
            <p>Enabling RESTAT participants to participate in a JTA transaction.</p>
            <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
                <p>Outbound bridging is not currently implemented</p>
            </div>
        </div>
    </div>
    <div class="section" title="6.7.2. Web Services Transactions"><div class="titlepage"><div><div><h3 class="title"><a id="_web_services_transactions"/>6.7.2. Web Services Transactions</h3></div></div></div>
        
        <p>
            WS includes two transaction models referred to as WSAT and WSBA. WSAT integration with JTA is documented
            in the Transaction Bridging section of the product guide (
            <a class="ulink" href="http://narayana.io/docs/product/index.html#txbridge">http://narayana.io/docs/product/index.html#txbridge</a>
            ). By using this bridge in conjunction with the RESTAT JTA bridge full interoperability between RESTAT
            and WSAT can be realised.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                RESTAT outbound bridging is not currently supported so interoperability is one way only.
            </p>
        </div>
    </div>
</div>
</div>
    <div class="chapter" title="Chapter 7. STM"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7814"/>Chapter 7. STM</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d5e7831">7.1. An STM Example</a></span></dt><dt><span class="section"><a href="#d5e7863">7.2. Annotations</a></span></dt><dt><span class="section"><a href="#d5e7882">7.3. Containers, Volatility and Durability</a></span></dt><dt><span class="section"><a href="#d5e7896">7.4. Sharing STM Objects</a></span></dt><dt><span class="section"><a href="#d5e7914">7.5. State Management</a></span></dt><dt><span class="section"><a href="#d5e7930">7.6. Optimistic Concurrency Control</a></span></dt><dt><span class="section"><a href="#d5e7942">7.7. A Typical Use Case</a></span></dt></dl></div>
    
    <p>In this chapter we shall look at the Software Transactional Memory (STM) implementation that ships as part of
        Narayana. Software Transactional Memory (STM) has been around in research environments since the late 1990’s and has
        relatively recently started to appear in products and various programming languages. We won’t go into all of
        the details behind STM but the interested reader could look at this paper (https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf).
        However, suffice it to say that STM
        offers an approach to developing transactional applications in a highly concurrent environment with some of the
        same characteristics of ACID transactions, which you’ve probably already used through JTA. Importantly though,
        the Durability property is relaxed (removed) within STM implementations, or at least made optional. This is
        not the situation with JTA, where state changes are made durable to a relational database which supports
        the X/Open XA standard.
    </p>
    <p>
        Now you may be asking yourself "Why STM instead of JTA?" or "What are the benefits to STM that I don’t get
        from JTA?" We will try to answer those and similar questions:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
                    <p>
                        The goal of STM is to simplify object reads and writes from multiple threads/protect state from
                        concurrent updates. The Narayana STM implementation will safely manage any conflicts between these
                        threads using whatever isolation model has been chosen to protect that specific state instance. In STM,
                        there are two isolation implementations, pessimistic (the
                        default), which would cause conflicting threads to be blocked until the original has completed its
                        updates (committed or aborted the transaction); then there is the optimistic approach which allows
                        all of the threads to proceed and checks for conflicts at commit time, where one or more of the threads
                        may be forced to abort if there have been conflicting updates.
                    </p>
                </li><li class="listitem">
                    <p>
                        STM objects have state but it does not need to be persistent (durable). In fact the default behaviour
                        is for objects managed within transactional memory to be volatile, such that if the service or
                        microservice within which they are being used crashes or is spawned elsewhere, e.g., by a scheduler,
                        all state in memory is lost and the objects start from scratch. But surely you get this and more with
                        JTA (and a suitable transactional datastore) and do not need to worry about restarting your application?
                        Not quite. There is a trade-off here: we are doing away with persistent state and the overhead of reading
                        from and then writing (and sync-ing) to the datastore during each transaction. This makes updates to
                        (volatile) state very fast but you still get the benefits of atomic updates across multiple STM objects
                        (e.g., objects your team wrote then calling objects you inherited from another team and requiring them
                        to make all-or-nothing updates), as well as consistency and isolation in the presence of concurrent
                        threads/users (common in distributed microservices architectures). Furthermore, not all stateful
                        applications need to be durable - even when JTA transactions are used, they tend to be the exception
                        and not the rule.
                    </p>
                </li><li class="listitem">
                    <p>
                        Another benefit of STM is composability and modularity. You can write concurrent objects/services
                        that can be easily composed with any other services built using STM, without exposing the details of how
                        the objects/services are implemented. As we discussed earlier, this ability to compose objects you wrote
                        with those other teams may have written weeks, months or years earlier, and have A, C and I properties
                        can be hugely beneficial. Furthermore, some STM implementations, including the Narayana version, support
                        nested transactions and these allow changes made within the context of a nested (sub) transaction to
                        later be rolled back by the parent transaction.
                    </p>
               </li><li class="listitem">
                    <p>
                        Although the default for STM object state is volatile, it is possible to configure the STM implementation
                        such that an object’s state is durable. Although it’s possible to configure Narayana such that different
                        backend datastores can be used, including relational databases, the default is the local operating system
                        file system, which means you don’t need to configure anything else, such as a database.
                    </p>
            </li><li class="listitem">
                <p>
                    Many STM implementations allow "plain old language objects" to be made STM-aware with little or no changes
                    to the application code. You can build, test and deploy applications without wanting them to be STM-aware
                    and then later add those capabilities if they become necessary and without much development overhead at all.
                </p>
            </li></ol></div><p>
    </p>
    <p>The Narayana STM implementation builds on the Transactional Objects for Java (TXOJ) framework which has
        offered building blocks for the construction of transactional objects via inheritence. The interested reader
        should look at the text on TXOJ within the ArjunaCore documentation for more in depth details. However, within
        TXOJ an application class can inherit from the LockManager class to obtain persistence (D) and concurrency (I),
        whilst at the same time having the flexibility to change some of these capabilities. For example, an object
        could be volatile, i.e., no durability, and yet still maintain the other transactional properties.</p>
    <p>If you look at the abilities that TXOJ offers to developers then it shares many aspects with STM. However, the
        downside is that developers need to modify their classes through class inheritence (something which is not
        always possible), add suitable extension methods (for saving and restoring state), set locks etc. None of this
        is entirely unreasonable, but it represents a barrier to some and hence is one of the reasons we decided to
        provide a separate STM implementation.</p>
    <div class="section" title="7.1. An STM Example"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7831"/>7.1. An STM Example</h2></div></div></div>
        
        <p>In order to illustrate the Narayana STM implementation we shall use a worked example throughout the rest
            of this chapter. We'll make it simple to start with, just a atomic integer that supports set, get and
            increment methods:</p>
        <pre><code class="no-highlight">public interface Atomic
{
   public void incr (int value) throws Exception;
   public void set (int value) throws Exception;
   public int get () throws Exception;
}</code></pre>
        <p>We'll throw exceptions from each method just in case, but obviously you could just as easily catch
            any problems which occur and return booleans or some other indicator from the increment and set methods.
        </p>
        <p>In this example we'll next create an implementation class:</p>
        <pre><code class="no-highlight">public class ExampleInteger implements Atomic
{   
   public int get () throws Exception
   {
       return state;
   }

   public void set (int value) throws Exception
   {
       state = value;
   }

   public void incr (int value) throws Exception
   {
       state += value;
   }

   private int state;
}</code></pre>
        <p>The implementation is pretty straightforward and we won't go into it here. However, so far apart from
            inheriting from our Atomic interface there's nothing to call this implementation out as being atomic.
            That's because we haven't actually done anything STM related to the code yet. </p>
        <p>Now let's start to modify it by adding in STM specific elements.</p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>All class scope annotations should be applied to the interface whereas method scope annotations should
                be applied to the implementation class.</p>
        </div>
        <p>Let's start by looking at the Atomic interface. First of all any transactional objects must be
            instrumented as such for the underyling STM implementation to be able to differentiate them from
            non-transactional objects. To do that you use the Transactional annotation on the class. Next we need to
            ensure that our transactional object(s) is free from conflicts when used in a concurrent environment, so we
            have to add information about the type of operation, i.e., whether or not the method modifies the state of
            the object. You do this using either the ReadLock or WriteLock annotations.</p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>If you do not add locking annotations to the methods on your Transactional interface then Narayana
                will default to assuming they all potentially modify the object's state.</p>
        </div>
        <p>At this stage we end up with a modified interface:</p>
        <pre><code class="no-highlight">@Transactional
public interface Atomic
{
   public void incr (int value) throws Exception;
   public void set (int value) throws Exception;
   public int get () throws Exception;
}</code></pre>
        <p>And class:</p>
        <pre><code class="no-highlight">public class ExampleInteger implements Atomic
{   
   @ReadLock
   public int get () throws Exception
   {
       return state;
   }

   @WriteLock
   public void set (int value) throws Exception
   {
       state = value;
   }

   @WriteLock
   public void incr (int value) throws Exception
   {
       state += value;
   }

   private int state;
}</code></pre>
        <p>As you can see, these are fairly straightfoward (and hopefully intuitive) changes to make. Everything else
            is defaulted, though will we will discuss other annotations later once we go beyond the basic example.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>We are contemplating allowing method annotations to be applied on the interface and then overridden on
                the implementation class. For now if you follow the above conventions you will continue to be compatible
                if this change is eventually supported. https://issues.jboss.org/browse/JBTM-2172</p>
        </div>
        <p>Now we have a transactional class, by virtue of its dependency on the Atomic interface, how we go about
            creating instances of the corresponding STM object and use it (them) within transactions?</p>
        <pre><code class="no-highlight">Container&lt;Atomic&gt; theContainer = new Container&lt;Atomic&gt;();    ExampleInteger basic = new ExampleInteger();       
Atomic obj = theContainer.create(basic);
AtomicAction a = new AtomicAction();

a.begin();                

obj.set(1234);                

a.commit();        

if (obj.get() == 1234)
   System.out.println("State changed ok!");
else
   System.out.println("State not changed!");                
a = new AtomicAction();        

a.begin();        

obj.change(1);                

a.abort();        

if (obj.get() == 1234)
   System.out.println("State reverted to 1234!");
else
   System.out.println("State is wrong!");</code></pre>
        <p>For clarity we've removed some of the error checking code in the above example, but let's walk
            through exactly what is going on.</p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>Some of the discussions around AtomicAction etc. are deliberately brief here because you can find more
                information in the relevant ArjunaCore documentation.</p>
        </div>
        <p>In order for the STM subsystem to have knowledge about which classes are to be managed within the context of
            transactional memory it is necessary to provide a minimal level of instrumentation. This occurs by categorising
            STM-aware and STM-unaware classes through an interface boundary; specifically all STM-aware objects must be
            instances of classes which inherit from interfaces that themselves have been annotated to identify them as
            STM-aware. Any other objects (and their classes) which do not follow this rule will not be managed by the
            STM subsystem and hence any of their state changes will not be rolled back, for example. Therefore, the first thing
            we need to do is create an STM Container. We need to tell each Container about the type of objects for
            which it will be responsible. Then we create an instance of our ExampleInteger. However, we can't use
            it directly because at this stage its operations aren't being monitored by the Container. Therefore, we
            pass the instance to the Container and obtain a reference to an Atomic object through which we can operate
            on the STM object.</p>
        <p>At this point if we called the operations such as incr on the Atomic instance we wouldn't see any
            difference in behaviour: there are no transactions in flight to help provide the necessary properties.
            Let's change that by creating an AtomicAction (transaction) and starting it. Now when we operate on the
            STM object all of the operations, such as set, will be performed within the scope of that transaction
            because it is associated with the thread of control. At this point if we commit the transaction object the
            state changes will be made permanent (well not quite, but that's a different story and one you can see
            when we discuss the Container in more detail later.)</p>
        <p>The rest of the example code simply repeats the above, except this time instead of committing the
            transaction we roll it back. What happens in this case is that any state changes which were performed within
            the scope of the transaction are automatically undone and we get back the state of the object(s) as it
            existed prior to the operations being performed.</p>
        <p>Pretty simple and not too much additional work on the part of the developer. Most of the ways in which you
            will use the Narayana STM implementation come down to similar approaches to what we've seen in the
            example. Where things may differ are in the various advanced options available to the developer. We'll
            discuss those next as we look at all of the user classes and annotations that are available.</p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>All of the classes, interfaces and annotations that you should be using can be located within the
                org.jboss.stm and org.jboss.stm.annotations packages. All other classes etc. located within
                org.jboss.stm.internal are private implementation specific aspects of the framework and subject to
                change without warning.</p>
        </div>
    </div>
    <div class="section" title="7.2. Annotations"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7863"/>7.2. Annotations</h2></div></div></div>
        
        <p>The following annotations are available for use on STM interfaces or classes.</p>
        <div class="orderedlist"><p>@Transactional: Used on the interface. Defines that implementations of the interface are to be managed
                within a transactional container. Unless specified using other annotations, all public methods will be
                assumed to modify the state of the object, i.e., require write locks. All state variables will be saved
                and restored unless marked explicitly using the @State annotation or SaveState/RestoreState. This
                assumes currently that all state modification and locking occurs through public methods, which means
                that even if there are private, protected or package scope methods that would change the state, they
                will not be tracked. Therefore, the implementation class should not modify state unless by calling its
                own public methods. All methods should either be invoked within a transactional context or have the
                Nested annotation applied, wherein the system will automatically create a new transaction when the
                method is invoked.</p><p>@Optimistic: Used on the interface. Specifies that the framework should use optimistic concurrency
                control for managing interactions on the instances. This may mean that a transaction is forced to abort
                at the end due to conflicting updates made by other users. The default is @Pessimistic.</p><p>@Pessimistic. Used on the interface. Specifies that pessimistic concurrency control should be used.
                This means that a read or write operation may block or be rejected if another user is manipulating the
                same object in a conflicting manner. If no other annotation appears to override this, then pessimistic
                is the default for a transactional object.</p><p>@Nested: Used on the interface or class. Defines that the container will create a new transaction for
                each method invocation, regardless of whether there is already a transaction associated with the caller.
                These transactions will then either be top-level transactions or nested automatically depending upon the
                context within which they are created.</p><p>@NestedTopLevel: Used on the interface or class. Defines that the container will create a new
                transaction for each method invocation, regardless of whether there is already a transaction associated
                with the caller. These transactions will always be top-level transactions even if there is a transaction
                already associated with the invoking thread.</p><p>@ReadLock: Used on the class method. The framework will grab a read lock when the method is invoked.
            </p><p>@WriteLock: Used on the class method. The framework will grab a write lock then the method is invoked.
            </p><p>@LockFree: Used on the class method. No locks will be obtained on this method, though any transaction
                context will still be on the thread when the method is invoked.</p><p>@TransactionFree: Used on the class method. This means that the method is not transactional, so no
                context will exist on the thread or locks acquired/released when the method is invoked.</p><p>@Timeout: Used on the class method. If pessimistic concurrency control is being used then a conflict
                will immediately cause the operation to fail and the application can do something else. If instead the
                developer wants the system to retry getting the lock before returning, then this annotation defines the
                time between each retry attempt in milliseconds.</p><p>@Retry: Used on the class method. If pessimistic concurrency control is being used then a conflict
                will immediately cause the operation to fail and the application can do something else. If instead the
                developer wants the system to retry getting the lock before returning, then this annotation defines the
                number of retry attempts. </p><p>@State: Used on the class member variables to define which state will be saved and restored by the
                transaction system. By default, all member variables (non-static, non-volatile) will be saved.</p><p>@NotState: Used on the class member variables to define which state to ignore when saving/restoring
                instance data. Note that any member variable that is not annotated with NotState will be saved and
                restored by the transaction system, irrespective of whether or not it has the State annotation. You
                should use these annotations cautiously because if you limit the state which is saved (and hence
                restored) you may allow dirty data to cross transaction boundaries.</p><p>@SaveState: Used on the class method to define the specific save_state method for the class. This is
                used in preference to any @State indications on the class state. This is the case no matter where in the
                class hierarchy it occurs. So if you have a base class that uses save/restore methods the inherited
                classes must have them too if their state is to be durable. In future we may save/restore specifically
                for each class in the inheritance hierarchy.</p><p>@RestoreState: Used on the class method to define the specific restore_state method for the class.
                This is used in preference to any @State indications on the class state.</p><ol class="orderedlist" type="1"/></div>
    </div>
    <div class="section" title="7.3. Containers, Volatility and Durability"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7882"/>7.3. Containers, Volatility and Durability</h2></div></div></div>
        
        <p>By default objects created within STM do not possess the Durable aspect of traditional ACID transactions,
            i.e., they are volatile instances. This has an obvious performance benefit since there is no disk or
            replicated in-memory data store involved. However, it has disadvantages. If the objects are Pessimitic or
            Optimistic then they can be shared between threads in the same address space (JVM instance). At the time of
            writing Optimistic objects cannot be shared between address spaces.</p>
        <p>Most of the time you will want to create volatile STM objects, with the option of using optimistic of
            pessimistic concurrency control really down to the type of application you are developing. As such you use
            of Containers will be very similar to that which we have seen already:</p>
        <pre><code class="no-highlight">TestContainer&lt;Sample&gt; theContainer = new TestContainer&lt;Sample&gt;();
SampleLockable tester = new SampleLockable();
Sample proxy = theContainer.enlist(tester);</code></pre>
        <p>However, the Container class has a number of extensibility options available for the more advanced user
            and requirements, which we shall discuss in the rest of this section.</p>
        <p>By default when you create a Container it is used to manage volatile objects. In STM language we call
            these objects recoverable due to the fact their state can be recovered in the event of a transaction rolling
            back, but not if there is a crash. The Container therefore supports two types:</p>
        <pre><code class="no-highlight">public enum TYPE { RECOVERABLE, PERSISTENT };</code></pre>
        <p>You can therefore use the TYPE constructore to create a Container of either type. You can always determine
            the type of a Container later by calling the type() method.</p>
        <p>All Containers can be named with a String. We recommend uniquely naming your Container instances and in
            fact if you do not give your Container a name when it is created using the default constructure then the
            system will assign a unique name (an instance of a Narayana Uid). If you want to give you Container a name
            then you can use the constructor that takes a String and you can get the name of any Container instance by
            calling the name() method. The default type of a Container is RECOVERABLE.</p>
        <p>The Container also supports two sharing models for objects created:</p>
        <pre><code class="no-highlight">public enum MODEL { SHARED, EXCLUSIVE };</code></pre>
        <p>SHARED means the instance may be used within multiple processes. It must be PERSISTENT too; if not then
            the framework. EXCLUSIVE means that the instance will only be used within a single JVM, though it can be
            PERSISTENT or RECOVERABLE. You can get the model used by your container by calling the model() method. The
            default model for a Container is EXCLUSIVE.</p>
        <p>Given the above information, you should now be able to understand what the various constructors of the
            Container class do, since they provide the ability to modify the behaviour of any created instance through
            combinations of the above three parameters. Where a given parameter is not available in a specific
            constructor, the default value discussed previously is used.</p>
    </div>
    <div class="section" title="7.4. Sharing STM Objects"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7896"/>7.4. Sharing STM Objects</h2></div></div></div>
        
        <p>Once a Container is created, you can use the create() method to create objects (handles) within the STM.
            As shown in the previous example, you pass in an unmodified (with the possible exception of annotations)
            class instance which corresponds to the interface type given to the Container when it was created and the
            Container will return a reference to an instance of the same type:</p>
        <pre><code class="no-highlight">Sample1 obj1 = theContainer.create(new Sample1Imple(10));</code></pre>
        <p>All objects thus created are uniquely identified by the system. You can obtain their identifier (an
            instance of the Uid class) at any time by calling the getIdentifier method of the corresponding Container:
        </p>
        <pre><code class="no-highlight">Uid id = theContainer.getIdentifier(obj1)</code></pre>
        <p>This can be useful for debugging purposes. However, it can also be useful if you want to create a
            duplicate handle to the object for another thread to use. This is not strictly necessary when using the
            default Pessimistic concurrency control, but is a requirement when using Optimistic (MVCC) (see relevant
            section).</p>
        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
            <p>Do not share the same reference for an Optimistic object with multiple threads. You must use the
                clone() operation for each thread.</p>
        </div>
        <p>There are two variants of the clone() operation. Both of them require an empty instance of the original
            non-STM class to clone the data in to (this does not actually happen for Pessimistic instances, but is still
            required at present for uniformity):</p>
        <pre><code class="no-highlight">public synchronized T clone (T member, T proxy)</code></pre>
        <p>This version requires a reference to the STM object that is being cloned as the second parameter:</p>
        <pre><code class="no-highlight">Sample1 obj2 = theContainer.clone(new Sample1Imple(), obj1);</code></pre>
        <p>The second version is similar:</p>
        <pre><code class="no-highlight">public synchronized T clone (T member, Uid id)</code></pre>
        <p>This time instead of a reference you can provide the object's identifier:</p>
        <pre><code class="no-highlight">Sample1 obj2 = theContainer.clone(new Sample1Imple(), theContainer.getIdentifier(obj1));</code></pre>
        <p>You are free to use either clone() operation depending upon what information your program has available.
        </p>
    </div>
    <div class="section" title="7.5. State Management"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7914"/>7.5. State Management</h2></div></div></div>
        
        <p>Earlier in this chapter we discussed how you can instrument your implementation class member variables
            with the State and NotState annotations to indicate what state should be saved and restored by the
            transaction system. In some situations you may want even more control over this process and this is where
            the @SaveState and @RestoreState annotations come in. These annotations let you define a method which will
            be called when the system needs to save your objec's state and likewise when it needs to restore it.
        </p>
        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>You must use SaveState and RestoreState annotations together, i.e., you cannot just define one without
                the other.</p>
        </div>
        <p>Your methods can be called whatever you want but they must have the following signatures.</p>
        <p>@SaveState</p>
        <pre><code class="no-highlight">public void save_state (OutputObjectState os) throws IOException</code></pre>
        <p>@RestoreState</p>
        <pre><code class="no-highlight">public void restore_state (InputObjectState os) throws IOException</code></pre>
        <p>Each operation is then given complete control over which state variables are saved and restored at the
            appropriate time. Any state-related annotations on member instance variables are ignored by the framework so
            you must ensure that all state which can be modified within the scope of a transaction must be saved and
            restored if you want it to be manipulated appropriately by the transaction.</p>
        <p>For instance, look at the following example:</p>
        <pre><code class="no-highlight">public class DummyImple implements Dummy
{
        public DummyImple ()
        {
            _isNotState = false;
            _saved = 1234;
        }

        @ReadLock
        public int getInt ()
        {
            return _saved;
        }

        @WriteLock
        public void setInt (int value)
        {
            _saved = value;
        }

        @ReadLock
        public boolean getBoolean ()
        {
            return _isNotState;
        }                

        @WriteLock
        public void setBoolean (boolean value)
        {
            _isNotState = value;
        }

        @SaveState
        public void save_state (OutputObjectState os) throws IOException
        {
           os.packInt(_saved);
        }

        @RestoreState
        public void restore_state (InputObjectState os) throws IOException
        {
            _saved = os.unpackInt();
        }

        public int _saved;
        public boolean _isNotState;
}</code></pre>
        <p>In this example, only the int member variable is saved and restored. This means that any changes made to
            the other member variable(s) within the scope of any transaction, in this case the boolean, will not be
            undone in the event the transaction(s) rolls back.</p>
        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
            <p>Use the SaveState and RestoreState annotations with care as you could cause dirty data to be visible
                between transactions if you do not save and restore all of the necessary state.</p>
        </div>
    </div>
    <div class="section" title="7.6. Optimistic Concurrency Control"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7930"/>7.6. Optimistic Concurrency Control</h2></div></div></div>
        
        <p>Per object concurrency control is done through locks and type specific concurrency control is available.
            You can define locks on a per object and per method basis, and combined with nested transactions this
            provides for a flexible way of structuring applications that would typically not block threads unless there
            is really high contention. All but the @Transactional annotation are optional, with sensible defaults taken
            for everything else including locks and state.</p>
        <p>However, the locking strategy we had originally was pessimistic. Most transaction systems utilize what is
            commonly referred to as pessimistic concurrency control mechanisms: in essence, whenever a data structure or
            other transactional resource is accessed, a lock is obtained on it as described earlier. This lock will
            remain held on that resource for the duration of the transaction and the benefit of this is that other users
            will not be able to modify (and possibly not even observe) the resource until the holding transaction has
            terminated. There are a number of disadvantages of this style: (i) the overhead of acquiring and maintaining
            concurrency control information in an environment where conflict or data sharing is not high, (ii) deadlocks
            may occur, where one user waits for another to release a lock not realizing that that user is waiting for
            the release of a lock held by the first.</p>
        <p>The obvious alternative to this approach is optimistic or MVCC. Therefore, optimistic concurrency control
            assumes that conflicts are not high and tries to ensure locks are held only for brief periods of time:
            essentially locks are only acquired at the end of the transaction when it is about to terminate. This kind
            of concurrency control requires a means to detect if an update to a resource does conflict with any updates
            that may have occurred in the interim and how to recover from such conflicts. Typically detection will
            happen using timestamps, whereby the system takes a snapshot of the timestamps associated with resources it
            is about to use or modify and compares them with the timestamps available when the transaction commits.
        </p>
        <p>As discussed previously, there are two annotations: @Optimistic and @Pessimistic, with Pessimistic being
            the default, i.e., if no annotation is present, then the STM framework will assume you want pessimistic
            concurrency control. These are defined on a per interface basis and define the type of concurrency control
            implementation that is used whenever locks are needed.</p>
        <pre><code class="no-highlight">@Transactional
@Optimistic
public class SampleLockable implements Sample
{
   public SampleLockable (int init)
   {
      _isState = init;
   }

   @ReadLock
   public int value ()
   {
      return _isState;
   }

   @WriteLock
   public void increment ()
   {
      _isState++;
   }

   @WriteLock
   public void decrement ()
   {
      _isState--;
   }

   @State
   private int _isState;
}</code></pre>
        <p>And that's it. No other changes are needed to the interface or to the implementation. However, at
            present there is a subtle change in the way in which you create your objects. Recall how that was done
            previously and then compare it with the style necessary when using optimistic concurrency control:</p>
        <pre><code class="no-highlight">Container theContainer = new Container();
Sample obj1 = theContainer.create(new SampleLockable(10));
Sample obj2 = theContainer.clone(new SampleLockable(10),obj1);</code></pre>
        <p>In the original pessimistic approach the instance obj1 can be shared between any number of threads and the
            STM implementation will ensure that the state is manipulated consistently and safely. However, with
            optimistic concurrency we need to have one instance of the state per thread. So in the above code we first
            create the object (obj1) and then we create a copy of it (obj2), passing a reference to the original to the
            container.</p>
        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2>
            <p>Remember that the same reference to Optimistic (MVCC) objects cannot be shared between different
                threads: you must use the clone() operation on the corresponding Container for each thread which wishes
                to use the object.</p>
        </div>
    </div>
    <div class="section" title="7.7. A Typical Use Case"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7942"/>7.7. A Typical Use Case</h2></div></div></div>
        
        <p>In this chapter we have considered all of the publicly available interfaces and classes for the STM
            framework within Narayana. There is deliberately a lot of flexibility on offer but much of it will only be
            needed by more advanced users and use cases. In this section we shall consider the most typical way in which
            we believe users will want to use the STM implementation. Let's consider the interface first:</p>
        <pre><code class="no-highlight">@Transactional
public interface Sample    
{
       public void increment ();
       public void decrement ();

       public int value ();
}</code></pre>
        <p>Whilst MVCC (optimistic concurrency control) is available, it is most useful in environments with a high
            degree of contention. Even then, with the ability to control the timeout and retry values of the locking
            used by the pessimistic concurrency control option, the surety of making progress in a longer running
            transaction and not being forced to roll back later can be an advantage. Therefore, pessimistic (the
            default) is probably the approach you will want to take initially.</p>
        <p>Now let's look at the implementation class:</p>
        <pre><code class="no-highlight">public class MyExample implements Sample    
{
        public MyExample ()
        {
            this(0);
        }        

        public MyExample (int init)
        {
            _isState = init;
        }

        @ReadLock
        public int value ()
        {
            return _isState;
        }

        @WriteLock
        public void increment ()
        {
            _isState++;
        }

        @WriteLock
        public void decrement ()
        {
            _isState--;
        }

        private int _isState;
}</code></pre>
        <p>By this point it should look fairly straightforward. We've kept it simple deliberately, but it can be
            as complex as your application requires. There are no nested transactions at work here, but you can easily
            add them using the Nested annotation. Remember that they give you improved modularity as well as the ability
            to better control failures.</p>
        <p>Because STM implementations typically relax or remove the durability aspect, you are more likely to want
            to create volatile objects, i.e., objects that do not survive the crash and repair of the JVM on which they
            are created. Therefore, you should use the default Container constructor, unless you want to control the
            name of the instance and in which case you can pass in an arbitrary string. Then all that is left is the
            creation and manipulation of AtomicActions as you invoke the relevant methods on your object(s).</p>
        <pre><code class="no-highlight">MyExample ex = new MyExample(10);        
Container&lt;Sample&gt; theContainer = new Container&lt;Sample&gt;();    Sample obj1 = theContainer.create(ex);        
AtomicAction act = new AtomicAction();

act.begin();                

obj1.increment();                

act.commit();</code></pre>
    </div>
</div>
    <div class="chapter" title="Chapter 8. Compensating transactions"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7952"/>Chapter 8. Compensating transactions</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d5e7954">8.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e7971">8.2. Compensations Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e7974">8.2.1. CDI annotations</a></span></dt><dt><span class="section"><a href="#d5e8049">8.2.2. Recovery</a></span></dt><dt><span class="section"><a href="#d5e8068">8.2.3. Limitation</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e8072">8.3. Resources</a></span></dt><dt><span class="section"><a href="#d5e8091">8.4. Notes</a></span></dt></dl></div>
  
  <div class="section" title="8.1. Overview"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7954"/>8.1. Overview</h2></div></div></div>
    
    <p>
      Compensating transactions are acknowledged as a good fit for long lived transactions.
      The idea comes out of (<a class="ulink" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">the Sagas paper, Princeton University, 1987</a>).
      The concept of the original paper talks about a single node database but the concepts described can readily be applied to distributed transactions.
    </p>
    <p>
      Structurally, applications utilising Sagas may consist of several atomic transactions each working with a separate system
      and with corresponding compensation handlers to deal with failures. The Saga as a whole then presents an atomic work of unit
      where changes made by atomic transactions are visible immediately but in the case of failure a recovery handling is employed.
      As such, saga transactions can cooperate with, but don’t mandate full ACID - within that model, they would be considered as relaxing
      the isolation property.
      You can read a bit more in the blogpost
      <a class="ulink" href="http://jbossts.blogspot.cz/2017/06/sagas-and-how-they-differ-from-two.html">http://jbossts.blogspot.cz/2017/06/sagas-and-how-they-differ-from-two.html</a>.
    </p>
    <p>
      Compensating transaction fall within backward recovery. The compensation transaction is defined as a work of unit that consists
      from one or more actions. Each action processes some work and up to that provides compensation handler with the definition
      of the undo-like operation. When a failure occurs the transaction manager invokes the compensating handlers (the undo operation)
      to allow the application to reconcile work processed by the proper action.
    </p>
    <p>
      With regards to Narayana, and when considering its impact on the CAP theorem
      <a class="ulink" href="http://www.julianbrowne.com/article/viewer/brewers-cap-theorem">CAP theorem</a> which dictates us that because of network
      can’t be considered reliable we need to choose between one of availability or consistency, our compensations approach relaxes
      some degree of availability.
    </p>
    <p>
      Compensating transactions are currently implemented in Narayana in way of
      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
          <p>Compensation framework (more below)</p>
        </li><li class="listitem">
          <p>WS-BA transactions in XTS module</p>
        </li><li class="listitem">
          <p>REST-JDI in plans https://issues.jboss.org/browse/JBTM-1488</p>
        </li></ul></div><p>
    </p>
  </div>
  <div class="section" title="8.2. Compensations Framework"><div class="titlepage"><div><div><h2 class="title"><a id="d5e7971"/>8.2. Compensations Framework</h2></div></div></div>
    
    <p>
      Narayana contains a compensations framework to assist users with developing transactional applications
      which require the use of compensating transactions. The compensating transaction behaviour can be expressed
      using either CDI annotations or via a programmatic API.
    </p>
    <div class="section" title="8.2.1. CDI annotations"><div class="titlepage"><div><div><h3 class="title"><a id="d5e7974"/>8.2.1. CDI annotations</h3></div></div></div>
      
      <p>
        Application developer annotates methods with the CDI annotations to define actions and undo operations
        which are managed by Transaction Manager. Narayana handles the state of the compensating transaction and drives
        undo operation if necessary. The manner how the annotations are used is pretty similar to standard CDI transaction
        annotations (e.g. in Jakarta EE).
      </p>
      <p>
        For the better understanding we recommend to check the
        <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/master/compensating-transactions/mongodb-simple">compensating transactions quickstart</a>.
      </p>
      <p>
        The “entry point” is marking a method with <code class="code">@Compensatable</code> annotation. This defines demarcation for the compensating transaction
        to start a new one, to join to an existing one or to throw exception if a compensating transaction context does not yet exist
        - the behaviour is the same as you can know from with the Jakarta EE
        <code class="code"><a class="ulink" href="https://javadoc.io/static/jakarta.platform/jakarta.jakartaee-api/10.0.0/jakarta/ejb/TransactionAttribute.html">@TransactionAttribute</a></code>.
        On top of that the <code class="code">@Compensatable</code> annotation permits you to define which exception type made the transaction to be cancelled
        or not cancelled.
      </p>
      <p>
        When the compensating transaction context exists there you can call methods marked with <code class="code">@TxCompensate</code> and <code class="code">@TxConfirm</code>
        annotations. Both expected to be parameterized with a handler class. That’s a class implementing either
        <code class="code">org.jboss.narayana.compensations.api.CompensationHandler</code>
        (with definition of one method called <code class="code">compensate</code>) or <code class="code">org.jboss.narayana.compensations.api.ConfirmationHandler</code>
        (with definition of one method called <code class="code">confirm</code>). Handlers intercepts the execution when the transaction reaches a specific state
        - the compensate method is called when it fails or is cancelled, the confirm method is called when it ends successfully.
      </p>
      <p>
        The CDI bean marking a method with <code class="code">@TxCompensate</code>/<code class="code">@TxConfirm</code> and the handlers can inject
        (<a class="ulink" href="https://jakarta.ee/specifications/cdi/3.0/jakarta-cdi-spec-3.0.html#built_in_annotation_literals">@Inject</a>)
        a POJO object (a DTO) marked as <code class="code">@CompensationScoped</code>. This annotation defines the data being set to this object
        in the bean in the scope of the specific compensating transaction will be available in the handlers
        (<code class="code">@TxCompensate</code>/<code class="code">@TxConfirm</code>) intercepting the compensating transaction.
        It’s important the <code class="code">@CompensationScoped</code> POJOs being implemented as
        <code class="code"><a class="ulink" href="https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html">Serializable</a></code>
        as they are saved during transaction processing to the transaction log store. Let’s imagine a situation where some part
        of the compensating transaction work is processed and JVM, where Narayana transaction manager resides, is crashed.
        After the restart Narayana needs to understand the state before the crash. That information is persisted in the transaction log store.
        Narayana loads the POJO state and passes it to handlers - to get proceed with confirmation or compensation.
      </p>
      <div class="section" title="8.2.1.1. List of available CDI annotations"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8001"/>8.2.1.1. List of available CDI annotations</h4></div></div></div>
        
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
            <p>
              <code class="code">@Compensatable</code> - declaratively control compensation transaction boundaries on CDI managed beans.
              This is similar to what is known from Jakarta EE world, how <a class="ulink" href="https://javadoc.io/static/jakarta.platform/jakarta.jakartaee-api/10.0.0/jakarta/ejb/TransactionAttribute.html">@TransactionAttribute</a> drives
              the global transaction behaviour. Compensatable framework uses CDI (you can define how interacts
              with other compensating transaction in the scope - you can use the type as known from Jakarta EE,
              which means <code class="code">MANDATORY</code>, <code class="code">SUPPORTS</code>, <code class="code">REQUIRED</code> etc.)
            </p>
          </li><li class="listitem">
            <p>
              <code class="code">@TxConfirm</code> - callback handler for confirming any work done within this annotated method,
              implementing <code class="code">org.jboss.narayana.compensations.api.ConfirmationHandler</code>.
            </p>
          </li><li class="listitem">
            <p>
              <code class="code">@TxCompensate</code> - callback handler for compensating work which was done, implementing
              <code class="code">org.jboss.narayana.compensations.api.CompensationHandler</code>.
            </p>
          </li><li class="listitem">
            <p>
              <code class="code">@CompensationScoped</code> - CDI bean is to be scoped to the current active compensation-based transaction.
            </p>
          </li><li class="listitem">
            <p>
              <code class="code">@CancelOnFailure</code> - states that the compensation-based transaction must cancel,
              if a <code class="code">RuntimeException</code> is thrown. A similar effect could be achieved by setting parameter <code class="code">cancelOn</code>
              of <code class="code">@Compensatable</code> set with <code class="code">RuntimeException</code>. There is no timeout associated with compensatable
              units of work which implies that they must either run to completion or fail.
            </p>
          </li><li class="listitem">
            <p>
              <code class="code">org.jboss.narayana.compensations.api.CompensationManager</code> - compensation manager could be
              <a class="ulink" href="https://jakarta.ee/specifications/cdi/3.0/jakarta-cdi-spec-3.0.html#built_in_annotation_literals">@Injected</a> for being able to mark the context
              as <code class="code">setCompensateOnly</code>.
            </p>
          </li></ul></div>
      </div>
      <div class="section" title="8.2.1.2. Programmatic API"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8034"/>8.2.1.2. Programmatic API</h4></div></div></div>
        
        <p>
          The compensation framework provides a declarative API to add compensatable work and let it processed by framework.
          The application programmer injects the interface <code class="code">org.jboss.narayana.compensations.api.CompensatableAction</code>
          (<code class="code">@Inject CompensatableAction</code>). This interface contains methods to add work to the action (<code class="code">addWork</code>)
          and then execute the action <code class="code">execute</code>).
        </p>
        <p>
          Programmer then adds work items to the <code class="code">CompensatableAction</code> one by one.
          The <code class="code">addWork</code> methods offers ability to specify work item, which is instance of <code class="code">CompensatableWork</code> that declares
          only that the work has to define method to execute the work, and assign to the work item
          its <code class="code">CompensationHandler</code> and/or <code class="code">ConfirmationHandler</code>.
        </p>
        <p>
          The programmer then declares the instant when <code class="code">CompensatableAction</code> should be executed by calling the method executes.
          Execution means that work items will be executed one by one. All work items then belong under the the same compensation
          and in the case of failure of one item others will be compensated (of a compensation handler was declared).
        </p>
      </div>
    </div>
    <div class="section" title="8.2.2. Recovery"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8049"/>8.2.2. Recovery</h3></div></div></div>
      
      <p>
        Implementation of recovery for compensating transaction is not yet part of the Narayana codebase, see
        <a class="ulink" href="https://issues.jboss.org/browse/JBTM-1107">https://issues.jboss.org/browse/JBTM-1099</a> however the implementation
        is under the review.
      </p>
      <p>
        The recovery works in the following way. The state of participant is saved to Narayana object store
        (<code class="code">org.jboss.narayana.compensations.internal.ParticipantImpl</code>). The content of the store regarding of the participant
        of the compensating transaction is <code class="code">transactionId</code>, <code class="code">participantId</code>, <code class="code">compensationHandler</code>
        and <code class="code">confirmationHandler</code>. For handler could be persisted it needs to implement <code class="code">java.io.Serializable</code> interface.
      </p>
      <p>
        When crash of the Narayana occurs these data is restored and used during standard periodic recovery process.
        For restoring handlers user has to register an implementation of interface <code class="code">org.jboss.narayana.compensations.api.Deserializer</code>.
        The implementation is then used for getting implementation of the handler class which could be later used during recovery.
      </p>
      <p>
        For tracking state is used standard Narayana object store and its handling of <code class="code">com.arjuna.ats.arjuna.StateManager</code>
        methods <code class="code">save_state</code>. Narayana manages serializing and deserializing but programmer has to implement
        and registered the <code class="code">Deserializer</code> interface to get handlers restored from the object store.
      </p>
      <p>
        You can find more valuable information in the wiki article
        <a class="ulink" href="https://developer.jboss.org/wiki/XTSRecoveryInternals">XTS Recovery Internals</a>.
      </p>
    </div>
    <div class="section" title="8.2.3. Limitation"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8068"/>8.2.3. Limitation</h3></div></div></div>
      
      <p>
        Currently there is one limitation which is needed to be emphasized. If you are used to work with XTS AT transactions
        you probably take advantage of transaction bridge functionality - ability of smoothly join XTS transaction with app server
        container transaction under one transparent global transaction. This is not possible for compensating transaction.
        The lack of the bridge functionality for the compensating transactions is addressed under jira
        <a class="ulink" href="https://issues.jboss.org/browse/JBTM-1099">https://issues.jboss.org/browse/JBTM-1099</a>.
      </p>
    </div>
  </div>
  <div class="section" title="8.3. Resources"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8072"/>8.3. Resources</h2></div></div></div>
    
    <p>
      This is our blog series which is valuable to check out
    </p>
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
        <p>
          <a class="ulink" href="http://jbossts.blogspot.com/2013/05/compensating-transactions-when-acid-is.html">
            Compensating Transactions: When ACID is too much (Part 1: Introduction)
          </a>
        </p>
      </li><li class="listitem">
        <p>
          <a class="ulink" href="http://jbossts.blogspot.com/2013/05/compensating-transactions-when-acid-is_29.html">
            Compensating Transactions: When ACID is too much (Part 2: Non-Transactional Resources)
          </a>
        </p>
      </li><li class="listitem">
        <p>
          <a class="ulink" href="http://jbossts.blogspot.com/2013/06/compensating-transactions-when-acid-is_26.html">
            Compensating Transactions: When ACID is too much (Part 3: Cross-Domain Distributed Transactions)
          </a>
        </p>
      </li><li class="listitem">
        <p>
          <a class="ulink" href="http://jbossts.blogspot.com/2013/07/compensating-transactions-when-acid-is.html">
            Compensating Transactions: When ACID is too much (Part 4: Long Lived Transactions)
          </a>
        </p>
      </li><li class="listitem">
        <p>
          <a class="ulink" href="http://jbossts.blogspot.com/2014/05/bringing-transactional-guarantees-to.html">
            Bringing Transactional Guarantees to MongoDB: Part 1
          </a>
        </p>
      </li></ul></div>
  </div>
  <div class="section" title="8.4. Notes"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8091"/>8.4. Notes</h2></div></div></div>
    
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
        <p>
          Compensations framework directly depends on Weld as a result of <a class="ulink" href="https://issues.jboss.org/browse/JBTM-2704">JBTM-2704</a>
        </p>
      </li></ul></div>
  </div>
</div>
    <div class="chapter" title="Chapter 9. OSGi"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8097"/>Chapter 9. OSGi</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#chap-integrate-with-karaf">9.1. Integrate with Karaf</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8101">9.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d5e8124">9.1.2. Quickstart</a></span></dt><dt><span class="section"><a href="#d5e8128">9.1.3. Admin Commands Support</a></span></dt></dl></dd></dl></div>
    
    <div class="section" title="9.1. Integrate with Karaf"><div class="titlepage"><div><div><h2 class="title"><a id="chap-integrate-with-karaf"/>9.1. Integrate with Karaf</h2></div></div></div>
    
<div class="section" title="9.1.1. Introduction"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8101"/>9.1.1. Introduction</h3></div></div></div>
    
    <p>
       The Narayana has been introduced in the Karaf 4.1.0-SNAPSHOT. You need to build from <a class="ulink" href="https://github.com/apache/karaf">
       https://github.com/apache/karaf</a>.
    </p>
    <p>
       The narayana configuration file could be found in &lt;karaf-4.1.0-SNAPSHOT&gt;/etc/org.jboss.nararayana.cfg
    </p>
    <div class="table"><a id="org-jboss-narayana-cfg"/><p class="title"><strong>Table 9.1. Configuration</strong></p><div class="table-contents">
        
        <table summary="Configuration" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>ObjectStoreEnvironmentBean.objectStoreDir</td><td>${karaf.data}/narayana</td></tr><tr><td>ObjectStoreEnvironmentBean.communicationStore.objectStoreDir</td><td>${karaf.data}/narayana</td></tr><tr><td>HornetqJournalEnvironmentBean.storeDir</td><td>${karaf.data}/narayana/hornetq</td></tr></tbody></table>
    </div></div><br class="table-break"/>
    <p>You could use the more keys in the jbossts-properties.xml</p>
</div>
<div class="section" title="9.1.2. Quickstart"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8124"/>9.1.2. Quickstart</h3></div></div></div>
    
    <p>You could build and run the 
        <a class="ulink" href="https://github.com/jbosstm/quickstart/tree/master/karaf/osgi-jta">
            Karaf osgi-jta Quicksart
        </a>
    </p>
</div>
<div class="section" title="9.1.3. Admin Commands Support"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8128"/>9.1.3. Admin Commands Support</h3></div></div></div>
    
    <p>We support the following commands in the karaf console</p>
    <div class="table"><a id="karaf-admin-console"/><p class="title"><strong>Table 9.2. Admin Command Cli</strong></p><div class="table-contents">
        
        <table summary="Admin Command Cli" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>narayana:refresh</td><td>Refresh the view of the object store</td></tr><tr><td>narayana:types</td><td>List record types</td></tr><tr><td>narayana:select type</td><td>Select a particular transaction type</td></tr><tr><td>narayana:ls [type]</td><td>List the transactions</td></tr><tr><td>narayana:attach id</td><td>Attach to a transaction log</td></tr><tr><td>narayana:detach id</td><td>Detach to the transaction log</td></tr><tr><td>narayana:forget idx</td><td>Move the specified heuristic participant back to the prepared list</td></tr><tr><td>narayana:delete idx</td><td>Delete the specified heuristic participant</td></tr></tbody></table>
    </div></div><br class="table-break"/>
</div>
</div>
</div>
    <div class="chapter" title="Chapter 10. Appendixes"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8163"/>Chapter 10. Appendixes</h2></div></div></div><div class="toc"><dl><dt><span class="appendix"><a href="#d5e8165">A. Object store implementations</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8167">A.1. The ObjectStore</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8197">A.1.1. Persistent object stores</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#d5e8317">B. Core Class Definitions</a></span></dt><dt><span class="appendix"><a href="#d5e8346">C. IDL definitions</a></span></dt><dt><span class="appendix"><a href="#_transaction_statuses">D. REST-AT Transaction Statuses</a></span></dt><dt><span class="appendix"><a href="#d5e8416">E. QA Testsuite</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8419">E.1.  JDBCResources 01 &amp; 02</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8421">E.1.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e8439">E.1.2.  JDBCResources 01 &amp; 02 Summary</a></span></dt><dt><span class="section"><a href="#d5e8454">E.1.3.  JDBCResources 01 &amp; 02 Interfaces</a></span></dt><dt><span class="section"><a href="#d5e8463">E.1.4.  JDBCResources 01 &amp; 02 Implementations</a></span></dt><dt><span class="section"><a href="#d5e8472">E.1.5.  JDBCResources 01 &amp; 02 Server</a></span></dt><dt><span class="section"><a href="#d5e8477">E.1.6.  JDBCResources 01 &amp; 02 Setups</a></span></dt><dt><span class="section"><a href="#d5e8490">E.1.7.  JDBCResources 01 &amp; 02 Clients</a></span></dt><dt><span class="section"><a href="#d5e8599">E.1.8.  JDBCResources 01 &amp; 02 Outcomes</a></span></dt><dt><span class="section"><a href="#d5e8614">E.1.9.  JDBCResources 01 &amp; 02 Cleanups</a></span></dt><dt><span class="section"><a href="#d5e8620">E.1.10.  JDBCResources 01 &amp; 02 Configurations</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e8655">E.2.  JDBCResources 03 &amp; 04</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8657">E.2.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e8676">E.2.2.  JDBCResources 03 &amp; 04 Summary</a></span></dt><dt><span class="section"><a href="#d5e8691">E.2.3.  JDBCResources 03 &amp; 04 Interfaces</a></span></dt><dt><span class="section"><a href="#d5e8699">E.2.4.  JDBCResources 03 &amp; 04 Implementations</a></span></dt><dt><span class="section"><a href="#d5e8708">E.2.5.  JDBCResources 03 &amp; 04 Server</a></span></dt><dt><span class="section"><a href="#d5e8713">E.2.6.  JDBCResources 03 &amp; 04 Setups</a></span></dt><dt><span class="section"><a href="#d5e8724">E.2.7.  JDBCResources 03 &amp; 04 Clients</a></span></dt><dt><span class="section"><a href="#d5e8743">E.2.8.  JDBCResources 03 &amp; 04 Outcomes</a></span></dt><dt><span class="section"><a href="#d5e8749">E.2.9.  JDBCResources 03 &amp; 04 Cleanups</a></span></dt><dt><span class="section"><a href="#d5e8755">E.2.10.  JDBCResources 03 &amp; 04 Configurations</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e8762">E.3.  CurrentTests</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8764">E.3.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e8771">E.3.2.  CurrentTests01 Summary</a></span></dt><dt><span class="section"><a href="#d5e8785">E.3.3.  CurrentTests Clients</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e8897">E.4.  OTSServer</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8899">E.4.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e8909">E.4.2.  OTSServer Summary</a></span></dt><dt><span class="section"><a href="#d5e8922">E.4.3.  OTSServer Clients</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e8995">E.5.  AITResources</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e8997">E.5.1. Overview</a></span></dt><dt><span class="section"><a href="#d5e9014">E.5.2.  AITResources 01 &amp; 02 Summary</a></span></dt><dt><span class="section"><a href="#d5e9029">E.5.3.  AITResources Interfaces</a></span></dt><dt><span class="section"><a href="#d5e9049">E.5.4.  AITResources Implementations</a></span></dt><dt><span class="section"><a href="#d5e9056">E.5.5.  AITResources Server</a></span></dt><dt><span class="section"><a href="#d5e9069">E.5.6.  AITResources Clients</a></span></dt><dt><span class="section"><a href="#d5e9132">E.5.7.  AITResources Outcomes</a></span></dt><dt><span class="section"><a href="#d5e9139">E.5.8.  AITResources Memory Tests</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e9156">E.6.  CrashRecovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e9158">E.6.1.  CrashRecovery Summary</a></span></dt></dl></dd></dl></dd></dl></div>
    
    <div class="appendix" title="Appendix A. Object store implementations"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8165"/>Appendix A. Object store implementations</h2></div></div></div>
    
    <div class="section" title="A.1. The ObjectStore"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8167"/>A.1. The ObjectStore</h2></div></div></div>
        
        <p>
            This appendix examines the various ArjunaCore object store implementations and gives guidelines for creating other
            implementations and plugging into an application.
        </p>
        <p>
            This release of Narayana
            contains several different implementations of a basic object store. Each
            serves a particular purpose and is generally optimized for that purpose. Each of the implementations implements
            the
            <code class="interfacename">ObjectStoreAPI</code>
            interface, which defines the minimum operations which must be
            provided for an object store implementation to be used by the Transaction Service. You can override the default
            object store implementation at runtime by setting the
            <code class="varname">com.arjuna.ats.arjuna.objectstore.objectStoreType</code>
            property variable to one of the types
            described below.
        </p>
        <div class="example"><a id="d5e8173"/><p class="title"><strong>Example A.1. 
                Class
                <code class="classname">StateStatus</code>
            </strong></p><div class="example-contents">
            
            <pre><code class="language-java">
/*
 * This is the base class from which all object store types are derived.
 * Note that because object store instances are stateless, to improve
 * efficiency we try to only create one instance of each type per process.
 * Therefore, the create and destroy methods are used instead of new
 * and delete. If an object store is accessed via create it *must* be
 * deleted using destroy. Of course it is still possible to make use of
 * new and delete directly and to create instances on the stack.
 */

public class StateStatus
{
    public static final int OS_ORIGINAL;
    public static final int OS_SHADOW;
    public static final int OS_UNCOMMITTED;
    public static final int OS_UNCOMMITTED_HIDDEN;
    public static final int OS_UNKNOWN;
}

public class StateType
{
    public static final int OS_COMMITTED;
    public static final int OS_COMMITTED_HIDDEN;
    public static final int OS_HIDDEN;
    public static final int OS_INVISIBLE;
}

public abstract class ObjectStore implements BaseStore, ParticipantStore,
                                             RecoveryStore, TxLog
{
    public ObjectStore (String osRoot);
    public synchronized boolean allObjUids (String s, InputObjectState buff)
        throws ObjectStoreException;
    public synchronized boolean allObjUids (String s, InputObjectState buff,
                                            int m) throws ObjectStoreException;

    public synchronized boolean allTypes (InputObjectState buff)
        throws ObjectStoreException;
    public synchronized int currentState(Uid u, String tn)
        throws ObjectStoreException;
    public synchronized boolean commit_state (Uid u, String tn)
        throws ObjectStoreException;
    public synchronized boolean hide_state (Uid u, String tn)
        throws ObjectStoreException;
    public synchronized boolean reveal_state (Uid u, String tn)
        throws ObjectStoreException;
    public synchronized InputObjectState read_committed (Uid u, String tn)
        throws ObjectStoreException;
    public synchronized InputObjectState read_uncommitted (Uid u, String tn)
        throws ObjectStoreException;
    public synchronized boolean remove_committed (Uid u, String tn)
        throws ObjectStoreException;
    public synchronized boolean remove_uncommitted (Uid u, String tn)
        throws ObjectStoreException;
    public synchronized boolean write_committed (Uid u, String tn,
                                                 OutputObjectState buff)
        throws ObjectStoreException;
    public synchronized boolean write_uncommitted (Uid u, String tn,
                                                   OutputObjectState buff)
        throws ObjectStoreException;
    public static void printState (PrintStream strm, int res);
};
</code></pre>
        </div></div><br class="example-break"/>
        <p>
      Narayana
            programmers do not usually need to interact with any of the object store implementations
            directly, apart from possibly creating them in the first place. Even this is not necessary if the default store
            type is used, since Narayana
            creates stores as necessary. All stores manipulate instances of the
            class
            <code class="classname">ObjectState</code>
            . These instances are named using a
            <code class="systemitem">type</code>
            (via the
            object's
            <code class="methodname">type()</code>
            operation) and a
            <code class="systemitem">Uid</code>
            .
        </p>
        <p>
            For atomic actions purposes, object states in the store can be principally in two distinct states:
            <code class="literal">OS_COMMITTED</code>
            or
            <code class="literal">OS_UNCOMMITTED</code>
            . An object state starts in the
            <code class="literal">OS_COMMITTED</code>
            state, but when it is modified under the control of an atomic action, a new second
            object state may be written that is in the
            <code class="literal">OS_UNCOMMITTED</code>
            state. If the action commits, this
            second object state replaces the original and becomes
            <code class="literal">OS_COMMITTED</code>
            . If the action aborts, this
            second object state is discarded. All of the implementations provided with this release handle these state
            transitions by making use of shadow copies of object states. However, any other implementation that maintains this
            abstraction is permissible.
        </p>
        <p>
            Object states may become hidden, and thus inaccessible, under the control of the crash recovery system.
        </p>
        <p>
            You can browse the contents of a store through the
            <code class="methodname">allTypes</code>
            and
            <code class="methodname">allObjUids</code>
            operations.
            <code class="methodname">allTypes</code>
            returns
            an
            <code class="classname">InputObjectState</code>
            containing all of the type names of all objects in a store, terminated by a null
            name.
            <code class="methodname">allObjUids</code>
            returns an
            <code class="classname">InputObjectState</code>
            containing all of the Uids of all objects of a given type,
            terminated by the special
            <code class="methodname">Uid.nullUid()</code>
            .
        </p>

        <div class="section" title="A.1.1. Persistent object stores"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8197"/>A.1.1. Persistent object stores</h3></div></div></div>
            
            <p>
                This section briefly describes the characteristics and optimizations of each of the supplied implementations of
                the persistent object store. Persistent object states are mapped onto the structure of the file system supported
                by the host operating system.
            </p>

            <div class="section" title="A.1.1.1. Common functionality"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8200"/>A.1.1.1. Common functionality</h4></div></div></div>
                
                <p>
                    In addition to the features mentioned earlier, all of the supplied persistent object stores obey the following
                    rules:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>
                            Each object state is stored in its own file, which is named using the Uid of the object.
                        </p>
                    </li><li class="listitem">
                        <p>
                            The type of an object, as given by the
                            <code class="methodname">type()</code>
                            operation, determines the directory
                            into which the object is placed.
                        </p>
                    </li><li class="listitem">
                        <p>
                            All of the stores have a common root directory that is determined when Narayana
                            is
                            configured. This directory name is automatically prepended to any store-specific root information.
                        </p>
                    </li><li class="listitem">
                        <p>
                            All stores also have the notion of a localized root directory that is automatically
                            prepended to the type
                            of the object to determine the ultimate directory name. The localized root name is specified when the
                            store is created. The default name is
                            <code class="literal">defaultStore</code>
                            .
                        </p>
                    </li></ul></div>
                <pre class="screen">&lt;ObjectStore root Directory from configure&gt;     &lt;filename&gt;/JBossTS/ObjectStore/&lt;/filename&gt;
   &lt;ObjectStore Type1&gt;                          &lt;filename&gt;FragmentedStore/&lt;/filename&gt;
      &lt;Default root&gt;                            &lt;filename&gt;defaultStore/&lt;/filename&gt;
         &lt;StateManager&gt;                         &lt;filename&gt;StateManager&lt;/filename&gt;
            &lt;LockManager&gt;                       &lt;filename&gt;LockManager/&lt;/filename&gt;
               &lt;User Types&gt;      
      &lt;Localised root 2&gt;                        &lt;filename&gt;myStore/&lt;/filename&gt;
         &lt;StateManager&gt;                         &lt;filename&gt;StateManager/&lt;/filename&gt;

   &lt;ObjectStore Type2&gt;                          &lt;filename&gt;ActionStore/&lt;/filename&gt;
         &lt;Default root&gt;                         &lt;filename&gt;defaultStore/&lt;/filename&gt;
</pre>
            </div>

            <div class="section" title="A.1.1.2. The shadowing store"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8215"/>A.1.1.2. The shadowing store</h4></div></div></div>
                
                <p>
                    The shadowing store s the original version of the object store, which was provided in prior
                    releases. It is
                    implemented by the class
                    <code class="classname">ShadowingStore</code>
                    . It is simple but slow. It uses pairs of files
                    to represent objects. One file is the shadow version and the other is the committed version. Files are opened,
                    locked, operated upon, unlocked, and closed on every interaction with the object store. This causes
                    a lot of
                    I/O overhead.
                </p>
                <p>
                    If you are overriding the object store implementation, the type of this object store is
                    <code class="literal">ShadowingStore</code>
                    .
                </p>
            </div>


            <div class="section" title="A.1.1.3. No file-level locking"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8221"/>A.1.1.3. No file-level locking</h4></div></div></div>
                
                <p>
                    Since transactional objects are concurrency-controlled through
                    <code class="classname">LockManager</code>,
                    you do not
                    need to impose additional locking at the file level. The basic ShadowingStore implementation handles
                    file-level locking. Therefore, the default object store implementation for Narayana,
                    <code class="systemitem">ShadowNoFileLockStore</code>
                    , relies upon user-level locking. This enables it to provide
                    better performance than the
                    <code class="systemitem">ShadowingStore</code>
                    implementation.
                </p>
                <p>
                    If you are overriding the object store implementation, the type of this object store is
                    <code class="literal">ShadowNoFileLockStore</code>
                    .
                </p>
            </div>

            <div class="section" title="A.1.1.4. The hashed store"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8229"/>A.1.1.4. The hashed store</h4></div></div></div>
                
                <p>
                    The HashedStore has the same structure for object states as the ShadowingStore, but has an alternate
                    directory
                    structure that is better suited to storing large numbers of objects of the same type. Using this store,
                    objects are scattered among a set of directories by applying a hashing function to the object's Uid. By
                    default, 255 sub-directories are used. However, you can override this by setting the
                    <code class="varname">ObjectStoreEnvironmentBean.hashedDirectories</code>
                    environment variable accordingly.
                </p>
                <p>
                    If you are overriding the object store implementation, the type of this object store is
                    <code class="literal">HashedStore</code>
                    .
                </p>
            </div>


            <div class="section" title="A.1.1.5. The JDBC store"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8235"/>A.1.1.5. The JDBC store</h4></div></div></div>
                
                <p>
                    The JDBCStore uses a JDBC database to save persistent object states. When used in conjunction with
                    the
                    Transactional Objects for Java API, nested transaction support is available. In the current implementation,
                    all object states are stored as
                    <em class="firstterm">Binary Large Objects (BLOBs)</em>
                    within the same table. The
                    limitation on object state size imposed by using BLOBs is
                    <code class="literal">64k</code>
                    . If you try to store an
                    object state which exceeds this limit, an error is generated and the state is not stored. The transaction is
                    subsequently forced to roll back.
                </p>
                <p>
                    When using the JDBC object store, the application must provide an implementation of the
                    <code class="interfacename">JDBCAccess</code>
                    interface, located in the com.arjuna.ats.arjuna.objectstore package:
                </p>
                <div class="example"><a id="d5e8242"/><p class="title"><strong>Example A.2. 
                        Interface
                        <code class="interfacename">JDBCAccess</code>
                    </strong></p><div class="example-contents">
                    
                    <pre><code class="language-java"> public interface JDBCAccess
{
    public Connection getConnection () throws SQLException;
    public void putConnection (Connection conn) throws SQLException;
    public void initialise (Object[] objName);
}
</code></pre>
                </div></div><br class="example-break"/>
                <p>
                    The implementation of this class is responsible for providing the
                    <code class="classname">Connection</code>
                    which the
                    JDBC ObjectStore uses to save and restore object states:
                </p>
                <div class="variablelist"><dl><dt><span class="term">
                            <code class="methodname">getConnection</code>
                        </span></dt><dd>
                            <p>
                                Returns the Connection to use. This method is called whenever a connection is required,
                                and the
                                implementation should use whatever policy is necessary for determining what connection to return. This
                                method need not return the same
                                <code class="classname">Connection</code>
                                instance more than once.
                            </p>
                        </dd><dt><span class="term">putConnection</span></dt><dd>
                            <p>
                                Returns one of the
                                <code class="classname">Connections</code>
                                acquired from
                                <code class="methodname">getConnection</code>
                                . Connections are returned if any errors occur when using them.
                            </p>
                        </dd><dt><span class="term">initialise</span></dt><dd>
                            <p>
                                Used to pass additional arbitrary information to the implementation.
                            </p>
                        </dd></dl></div>
                <p>
                    The JDBC object store initially requests the number of
                    <code class="classname">Connections</code>
                    defined in the
                    <code class="varname">ObjectStoreEnvironmentBean.jdbcPoolSizeInitial</code>
                    property and will use no more than defined
                    in the
                    <code class="varname">ObjectStoreEnvironmentBean.jdbcPoolSizeMaximum property</code>
                    .
                </p>
                <p>
                    The implementation of the
                    <code class="interfacename">JDBCAccess</code>
                    interface to use should be set in the
                    <code class="varname">ObjectStoreEnvironmentBean.jdbcUserDbAccessClassName</code>
                    property variable.
                </p>
                <p>
                    If overriding the object store implementation, the type of this object store is
                    <span class="type">JDBCStore</span>
                    .
                </p>
                <p>
                    A JDBC object store can be used for managing the transaction log. In this case, the transaction log
                    implementation should be set to
                    <code class="literal">JDBCActionStore</code>
                    and the
                    <code class="classname">JDBCAccess</code>
                    implementation must be provided via the
                    <code class="varname">ObjectStoreEnvironmentBean.jdbcTxDbAccessClassName property</code>
                    variable. In this case, the default table name is
                    <code class="systemitem">JBossTSTxTable</code>
                    .
                </p>
                <p>
                    You can use the same
                    <code class="classname">JDBCAccess</code>
                    implementation for both the user object store and the
                    transaction log.
                </p>
            </div>

            <div class="section" title="A.1.1.6. The cached store"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8281"/>A.1.1.6. The cached store</h4></div></div></div>
                
                <p>
                    This object store uses the hashed object store, but does not read or write states to the persistent backing
                    store immediately. It maintains the states in a volatile memory cache and either flushes the cache
                    periodically or when it is full. The failure semantics associated with this object store are different from
                    the normal persistent object stores, because a failure could result in states in the cache being lost.
                </p>
                <p>
                    If overriding the object store implementation, the type of this object store is
                    <span class="type">CacheStore</span>
                    .
                </p>
                <div class="variablelist" title="Configuration Properties"><p class="title"><strong>Configuration Properties</strong></p><dl><dt><span class="term">ObjectStoreEnvironmentBean.cacheStoreHash</span></dt><dd>
                            <p>
                                sets the number of internal stores to hash the states over. The default value is 128.
                            </p>
                        </dd><dt><span class="term">ObjectStoreEnvironmentBean.cacheStoreSize</span></dt><dd>
                            <p>
                                the maximum size the cache can reach before a flush is triggered. The default is 10240 bytes.
                            </p>
                        </dd><dt><span class="term">ObjectStoreEnvironmentBean.cacheStoreRemovedItems</span></dt><dd>
                            <p>
                                the maximum number of removed items that the cache can contain before a flush is triggered. By default,
                                calls to remove a state that is in the cache will simply remove the state from the cache, but leave a
                                blank entry (rather than remove the entry immediately, which would affect the performance of the
                                cache). When triggered, these entries are removed from the cache. The default value is twice the size of
                                the hash.
                            </p>
                        </dd><dt><span class="term">ObjectStoreEnvironmentBean.cacheStoreWorkItems</span></dt><dd>
                            <p>
                                the maximum number of items that are allowed to build up in the cache before it is
                                flushed. The default
                                value is 100.
                                <code class="varname">ObjectStoreEnvironmentBean.cacheStoreScanPeriod</code>
                                sets the time in
                                milliseconds for periodically flushing the cache. The default is 120 seconds.
                            </p>
                        </dd><dt><span class="term">ObjectStoreEnvironmentBean.cacheStoreSync</span></dt><dd>
                            <p>
                                determines whether flushes of the cache are sync-ed to disk. The default is
                                <code class="literal">OFF</code>
                                . To
                                enable, set to
                                <code class="literal">ON</code>
                                .
                            </p>
                        </dd></dl></div>
            </div>


            <div class="section" title="A.1.1.7. LogStore"><div class="titlepage"><div><div><h4 class="title"><a id="d5e8311"/>A.1.1.7. LogStore</h4></div></div></div>
                
                <p>
                    This implementation is based on a traditional transaction log. All transaction states within the
                    same process
                    (VM instance) are written to the same log (file), which is an append-only entity. When transaction data would
                    normally be deleted, at the end of the transaction, a
                    <code class="systemitem">delete</code>
                    record is added to the
                    log instead. Therefore, the log just keeps growing. Periodically a thread runs to prune the log of entries
                    that have been deleted.
                </p>
                <p>
                    A log is initially given a maximum capacity beyond which it cannot grow. After it reaches this size, the
                    system creates a new log for transactions that could not be accommodated in the original log. The new log and
                    the old log are pruned as usual. During the normal execution of the transaction system, there may be an
                    arbitrary number of log instances. These should be garbage collected by the system,(or the recovery
                    sub-system, eventually.
                </p>
                <p>
                    Check the Configuration Options table for how to configure the LogStore.
                </p>
            </div>
        </div>
    </div>
</div>
    <div class="appendix" title="Appendix B. Core Class Definitions"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8317"/>Appendix B. Core Class Definitions</h2></div></div></div>
    
    <p>
        This appendix contains an overview of those classes that the application programmer will typically use. The aim of
        this appendix is to provide a quick reference guide to these classes for use when writing applications in
        ArjunaCore. For clarity only the public and protected interfaces of the classes will be given.
    </p>

    <div class="example"><a id="d5e8320"/><p class="title"><strong>Example B.1. 
            Class
            <code class="classname">LockManager</code>
        </strong></p><div class="example-contents">
        
        <pre><code class="language-java">public class LockResult
{
    public static final int GRANTED;
    public static final int REFUSED;
    public static final int RELEASED;
};

public class ConflictType
{
    public static final int CONFLICT;
    public static final int COMPATIBLE;
    public static final int PRESENT;
};

public abstract class LockManager extends StateManager
{
    public static final int defaultRetry;
    public static final int defaultTimeout;
    public static final int waitTotalTimeout;

    public final synchronized boolean releaselock (Uid lockUid);
    public final synchronized int setlock (Lock toSet);
    public final synchronized int setlock (Lock toSet, int retry);
    public final synchronized int setlock (Lock toSet, int retry, int sleepTime);
    public void print (PrintStream strm);
    public String type ();
    public boolean save_state (OutputObjectState os, int ObjectType);
    public boolean restore_state (InputObjectState os, int ObjectType);

    protected LockManager ();
    protected LockManager (int ot);
    protected LockManager (int ot, int objectModel);
    protected LockManager (Uid storeUid);
    protected LockManager (Uid storeUid, int ot);
    protected LockManager (Uid storeUid, int ot, int objectModel);

    protected void terminate ();
};
</code></pre>
    </div></div><br class="example-break"/>

    <div class="example"><a id="d5e8324"/><p class="title"><strong>Example B.2. 
            Class
            <code class="classname">StateManager</code>
        </strong></p><div class="example-contents">
        
        <pre><code class="language-java">public class ObjectStatus
{
    public static final int PASSIVE;
    public static final int PASSIVE_NEW;
    public static final int ACTIVE;
    public static final int ACTIVE_NEW;
};

public class ObjectType
{
    public static final int RECOVERABLE;
    public static final int ANDPERSISTENT;
    public static final int NEITHER;
};
 
public abstract class StateManager
{
    public boolean restore_state (InputObjectState os, int ot);
    public boolean save_state (OutputObjectState os, int ot);
    public String type ();

    public synchronized boolean activate ();
    public synchronized boolean activate (String rootName);
    public synchronized boolean deactivate ();
    public synchronized boolean deactivate (String rootName);
    public synchronized boolean deactivate (String rootName, boolean commit);

    public synchronized int status ();
    public final Uid get_uid ();
    public void destroy ();
    public void print (PrintStream strm);

    protected void terminate ();

    protected StateManager ();
    protected StateManager (int ot);
    protected StateManager (int ot, int objectModel);
    protected StateManager (Uid objUid);
    protected StateManager (Uid objUid, int ot);
    protected StateManager (Uid objUid, int ot, int objectModel);
    protected synchronized final void modified ();
};
</code></pre>
    </div></div><br class="example-break"/>

    <div class="example"><a id="d5e8328"/><p class="title"><strong>Example B.3. 
            Classes
            <code class="classname">OutputObjectState</code>
            and
            <code class="classname">InputObjectState</code>
        </strong></p><div class="example-contents">
        
        <pre><code class="language-java">class OutputObjectState extends OutputBuffer
{
    public OutputObjectState (Uid newUid, String typeName);

    public boolean notempty ();
    public int size ();
    public Uid stateUid ();
    public String type ();
};
class InputObjectState extends ObjectState
{
    public OutputObjectState (Uid newUid, String typeName, byte[] b);

    public boolean notempty ();
    public int size ();
    public Uid stateUid ();
    public String type ();
};
</code></pre>
    </div></div><br class="example-break"/>

    <div class="example"><a id="d5e8333"/><p class="title"><strong>Example B.4. 
            Classes
            <code class="classname">OutputBuffer</code>
            and
            <code class="classname">InputBuffer</code>
        </strong></p><div class="example-contents">
        
        <pre><code class="language-java">public class OutputBuffer
{
    public  OutputBuffer ();

    public final synchronized boolean valid ();
    public synchronized byte[] buffer();
    public synchronized int length ();

    /* pack operations for standard Java types */

    public synchronized void packByte (byte b) throws IOException;
    public synchronized void packBytes (byte[] b) throws IOException;
    public synchronized void packBoolean (boolean b) throws IOException;
    public synchronized void packChar (char c) throws IOException;
    public synchronized void packShort (short s) throws IOException;
    public synchronized void packInt (int i) throws IOException;
    public synchronized void packLong (long l) throws IOException;
    public synchronized void packFloat (float f) throws IOException;
    public synchronized void packDouble (double d) throws IOException;
    public synchronized void packString (String s) throws IOException;
};
public class InputBuffer
{
    public  InputBuffer ();

    public final synchronized boolean valid ();
    public synchronized byte[] buffer();
    public synchronized int length ();

    /* unpack operations for standard Java types */

    public synchronized byte unpackByte () throws IOException;
    public synchronized byte[] unpackBytes () throws IOException;
    public synchronized boolean unpackBoolean () throws IOException;
    public synchronized char unpackChar () throws IOException;
    public synchronized short unpackShort () throws IOException;
    public synchronized int unpackInt () throws IOException;
    public synchronized long unpackLong () throws IOException;
    public synchronized float unpackFloat () throws IOException;
    public synchronized double unpackDouble () throws IOException;
    public synchronized String unpackString () throws IOException;
};
</code></pre>
    </div></div><br class="example-break"/>

    <div class="example"><a id="d5e8338"/><p class="title"><strong>Example B.5. 
            Class
            <code class="classname">Uid</code>
        </strong></p><div class="example-contents">
        
        <pre><code class="language-java">public class Uid implements Cloneable
{
    public Uid ();
    public Uid (Uid copyFrom);
    public Uid (String uidString);
    public Uid (String uidString, boolean errorsOk);
    public synchronized void pack (OutputBuffer packInto) throws IOException;
    public synchronized void unpack (InputBuffer unpackFrom) throws IOException;

    public void print (PrintStream strm);
    public String toString ();
    public Object clone () throws CloneNotSupportedException;
    public synchronized void copy (Uid toCopy) throws UidException;
    public boolean equals (Uid u);
    public boolean notEquals (Uid u);
    public boolean lessThan (Uid u);
    public boolean greaterThan (Uid u);

    public synchronized final boolean valid ();
    public static synchronized Uid nullUid ();
};
</code></pre>
    </div></div><br class="example-break"/>

    <div class="example"><a id="d5e8342"/><p class="title"><strong>Example B.6. 
            Class
            <code class="classname">AtomicAction</code>
        </strong></p><div class="example-contents">
        
        <pre><code class="language-java">public class AtomicAction
{
    public AtomicAction ();

    public void begin () throws SystemException, SubtransactionsUnavailable,
                                NoTransaction;
    public void commit (boolean report_heuristics) throws SystemException, 
                                                          NoTransaction, HeuristicMixed,
                                                          HeuristicHazard,TransactionRolledBack;
    public void rollback () throws SystemException, NoTransaction;
    public Control control () throws SystemException, NoTransaction;
    public Status get_status () throws SystemException;
    /* Allow action commit to be supressed */    
    public void rollbackOnly () throws SystemException, NoTransaction;

    public void registerResource (Resource r) throws SystemException, Inactive;
    public void registerSubtransactionAwareResource (SubtransactionAwareResource sr)
        throws SystemException, NotSubtransaction;
    public void registerSynchronization (Synchronization s) throws SystemException,
                                                                   Inactive;
};
</code></pre>
    </div></div><br class="example-break"/>

</div>
    <div class="appendix" title="Appendix C. IDL definitions"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8346"/>Appendix C. IDL definitions</h2></div></div></div>
    
    <p>
        Because of differences between ORBs, and errors in certain ORBs, the idl available with 
        may differ from that
        shown below. You should always inspect the idl files prior to implementation to determine what, if any, differences
        exist.
    </p>
    <div class="example"><a id="d5e8349"/><p class="title"><strong>Example C.1. CosTransactions.idl</strong></p><div class="example-contents">
        
        <pre><code class="language-java">#ifndef COSTRANSACTIONS_IDL_
#define COSTRANSACTIONS_IDL_
module CosTransactions
{
    enum Status { StatusActive, StatusMarkedRollback, StatusPrepared,
        StatusCommitted, StatusRolledback, StatusUnknown,
           StatusPreparing, StatusCommitting, StatusRollingBack,
        StatusNoTransaction };

    enum Vote { VoteCommit, VoteRollback, VoteReadOnly };
    // Standard exceptions - some Orb supports them
exception TransactionRequired {};
exception TransactionRolledBack {};
exception InvalidTransaction {};
    // Heuristic exceptions
exception HeuristicRollback {};
       exception HeuristicCommit {};
       exception HeuristicMixed {};
       exception HeuristicHazard {};
    // Exception from ORB
exception WrongTransaction {};
    // Other transaction related exceptions
exception SubtransactionsUnavailable {};
exception NotSubtransaction {};
exception Inactive {};
exception NotPrepared {};
exception NoTransaction {};
exception InvalidControl {};
exception Unavailable {};
exception SynchronizationUnavailable {};
    // Forward references for later interfaces
interface Control;
interface Terminator;
interface Coordinator;
interface Resource;
interface RecoveryCoordinator;
interface SubtransactionAwareResource;
interface TransactionFactory;
interface TransactionalObject;
interface Current;
interface Synchronization;
    // Formally part of CosTSInteroperation
struct otid_t
{
    long formatID;
    long bequal_length;
    sequence &lt;octet&gt; tid;
};
struct TransIdentity
       {
           Coordinator coord;
       Terminator term;
           otid_t otid;
       };
struct PropagationContext
      {
       unsigned long timeout;
          TransIdentity currentTransaction;
       sequence &lt;TransIdentity&gt; parents;
       any implementation_specific_data;
      };
      interface Current : CORBA::Current
      {
       void begin () raises (SubtransactionsUnavailable);
       void commit (in boolean report_heuristics) raises (NoTransaction, HeuristicMixed, HeuristicHazard, TransactionRolledBack);
       void rollback () raises (NoTransaction);
       void rollback_only () raises (NoTransaction);

       Status get_status ();
       string get_transaction_name ();
       void set_timeout (in unsigned long seconds);

       Control get_control ();
       Control suspend ();
       void resume (in Control which) raises (InvalidControl);
      };
interface TransactionFactory
      {
       Control create (in unsigned long time_out);
           Control recreate (in PropagationContext ctx);
      };
interface Control
      {
       Terminator get_terminator () raises (Unavailable);
       Coordinator get_coordinator () raises (Unavailable);
      };
interface Terminator
      {
       void commit (in boolean report_heuristics) raises (HeuristicMixed, HeuristicHazard, TransactionRolledBack);
       void rollback ();
      };
      interface Coordinator
      {
       Status get_status ();
       Status get_parent_status ();
       Status get_top_level_status ();

       boolean is_same_transaction (in Coordinator tc);
       boolean is_related_transaction (in Coordinator tc);
       boolean is_ancestor_transaction (in Coordinator tc);
       boolean is_descendant_transaction (in Coordinator tc);
       boolean is_top_level_transaction ();

           unsigned long hash_transaction ();
       unsigned long hash_top_level_tran ();

       RecoveryCoordinator register_resource (in Resource r) raises (Inactive);
       void register_synchronization (in Synchronization sync) raises (Inactive, SynchronizationUnavailable);
       void register_subtran_aware (in SubtransactionAwareResource r) raises (Inactive, NotSubtransaction);

       void rollback_only () raises (Inactive);

       string get_transaction_name ();

       Control create_subtransaction () raises (SubtransactionsUnavailable, Inactive);

       PropagationContext get_txcontext () raises (Unavailable);
      };
      interface RecoveryCoordinator
      {
       Status replay_completion (in Resource r) raises (NotPrepared);
      };
interface Resource
       {
       Vote prepare () raises (HeuristicMixed, HeuristicHazard);
       void rollback () raises (HeuristicCommit, HeuristicMixed, HeuristicHazard);
       void commit () raises (NotPrepared, HeuristicRollback, HeuristicMixed, HeuristicHazard);
       void commit_one_phase () raises (HeuristicHazard);
       void forget ();
      };
interface SubtransactionAwareResource : Resource
      {
       void commit_subtransaction (in Coordinator parent);
       void rollback_subtransaction ();
      };
interface TransactionalObject
      {
      };   
interface Synchronization : TransactionalObject
      {
       void before_completion ();
       void after_completion (in Status s);
      };
};
#endif
</code></pre>
    </div></div><br class="example-break"/>

    <div class="example"><a id="d5e8352"/><p class="title"><strong>Example C.2. ArjunaOTS.IDL</strong></p><div class="example-contents">
        
        <pre><code class="language-java">#ifndef ARJUNAOTS_IDL_
#define ARJUNAOTS_IDL_

#include &lt;idl/CosTransactions.idl&gt;
module ArjunaOTS
{
    exception ActiveTransaction {};
    exception BadControl {};
    exception Destroyed {};
    exception ActiveThreads {};
    exception InterpositionFailed {};

    interface UidCoordinator : CosTransactions::Coordinator
    {
   readonly attribute string uid;
   readonly attribute string topLevelUid;
    };
    interface ActionControl : CosTransactions::Control
    {
        CosTransactions::Control getParentControl ()
                                                raises (CosTransactions::Unavailable,
                                                  CosTransactions::NotSubtransaction);
        void destroy () raises (ActiveTransaction, ActiveThreads, BadControl,
                                Destroyed);
    };

    interface ArjunaSubtranAwareResource : 
                                     CosTransactions::SubtransactionAwareResource
    {
   CosTransactions::Vote prepare_subtransaction ();
    };
    interface ArjunaTransaction : UidCoordinator, CosTransactions::Terminator
    {
    };

    interface OTSAbstractRecord : ArjunaSubtranAwareResource
    {
        readonly attribute long typeId;
        readonly attribute string uid;

        boolean propagateOnAbort ();
        boolean propagateOnCommit ();

        boolean saveRecord ();

        void merge (in OTSAbstractRecord record);
        void alter (in OTSAbstractRecord record);

        boolean shouldAdd (in OTSAbstractRecord record);
        boolean shouldAlter (in OTSAbstractRecord record);
        boolean shouldMerge (in OTSAbstractRecord record);
        boolean shouldReplace (in OTSAbstractRecord record);
    };
};</code></pre>
    </div></div><br class="example-break"/>
</div>
    <div class="appendix" title="Appendix D. REST-AT Transaction Statuses"><div class="titlepage"><div><div><h2 class="title"><a id="_transaction_statuses"/>Appendix D. REST-AT Transaction Statuses</h2></div></div></div>
    
    <p>
        Resources return the following status values in response to GET requests on the appropriate
        transaction-coordinator or
        <code class="systemitem">participant-resource</code>
        URI:
    </p>
    <div class="variablelist"><dl><dt><span class="term">
                TransactionRollbackOnly
            </span></dt><dd>
                <p>
                    the status of the endpoint is that it will roll back eventually.
                </p>
            </dd><dt><span class="term">
                TransactionRollingBack
            </span></dt><dd>
                <p>
                    the endpoint is in the process of rolling back. If the recipient has already rolled back then it must return a 410
                    error code.
                </p>
            </dd><dt><span class="term">
                TransactionRolledBack
            </span></dt><dd>
                <p>
                    the endpoint has rolled back.
                </p>
            </dd><dt><span class="term">
                TransactionCommitting
            </span></dt><dd>
                <p>
                    the endpoint is in the process of committing. This does not mean that the final outcome will be Committed. If the
                    recipient has already committed then it must return a 410 error code.
                </p>
            </dd><dt><span class="term">
                TransactionCommitted
            </span></dt><dd>
                <p>
                    the endpoint has committed.
                </p>
            </dd><dt><span class="term">
                TransactionCommittedOnePhase
            </span></dt><dd>
                <p>
                    the recipient has committed the transaction without going through a prepare phase. If the recipient has previously
                    been asked to prepare then it must return a 412 error code. If the recipient has already terminated,
                    then it must return a 410 error code.
                </p>
            </dd><dt><span class="term">
                TransactionHeuristicRollback
            </span></dt><dd>
                <p>
                    all of the participants rolled back when they were asked to commit.
                </p>
            </dd><dt><span class="term">
                TransactionHeuristicCommit
            </span></dt><dd>
                <p>
                    all of the participants committed when they were asked to rollback.
                </p>
            </dd><dt><span class="term">
                TransactionHeuristicHazard
            </span></dt><dd>
                <p>
                    some of the participants rolled back, some committed and the outcome of others is indeterminate.
                </p>
            </dd><dt><span class="term">
                TransactionHeuristicMixed
            </span></dt><dd>
                <p>
                    some of the participants rolled back whereas the remainder committed.
                </p>
            </dd><dt><span class="term">
                TransactionPreparing
            </span></dt><dd>
                <p>
                    the endpoint is preparing.
                </p>
            </dd><dt><span class="term">
                TransactionPrepared
            </span></dt><dd>
                <p>
                    the endpoint has prepared.
                </p>
            </dd><dt><span class="term">
                TransactionActive
            </span></dt><dd>
                <p>
                    the transaction is active, i.e., has not begun to terminate.
                </p>
            </dd><dt><span class="term">
                TransactionStatusUnknown
            </span></dt><dd>
                <p>
                    the status of the transaction is unknown
                </p>
            </dd></dl></div>
</div>
    <div class="appendix" title="Appendix E. QA Testsuite"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8416"/>Appendix E. QA Testsuite</h2></div></div></div>
  

<p>
In the source git repository we maintain a testsuite for integration testing.
</p>


<div class="section" title="E.1.  JDBCResources 01 &amp; 02"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8419"/>E.1.  JDBCResources 01 &amp; 02</h2></div></div></div>
<div class="section" title="E.1.1. Overview"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8421"/>E.1.1. Overview</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Tests 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">JDBC Support</li></ul></div>
  </li><li class="listitem">
    Series 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">JTSResources01: Implicit context propagation</li><li class="listitem">JTSResources02: Explicit context propagation</li></ul></div>
  </li><li class="listitem">
    Sub-series 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">_ibmdb2_jndi</li><li class="listitem">_mssqlserver_jndi</li><li class="listitem">_mysql_jndi</li><li class="listitem">_oracle_thin_jndi</li><li class="listitem">_pgsql_jndi</li><li class="listitem">_sybase_jndi</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.1.2.  JDBCResources 01 &amp; 02 Summary"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8439"/>E.1.2.  JDBCResources 01 &amp; 02 Summary</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Building blocks: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Interfaces: 1</li><li class="listitem">Implementations: 2</li><li class="listitem">Servers: 2</li><li class="listitem">Setups: 2</li><li class="listitem">Clients: 16</li><li class="listitem">Outcomes: 4</li><li class="listitem">Cleanups: 1</li></ul></div>
  </li><li class="listitem">
    Tests: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configurations: 32</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.1.3.  JDBCResources 01 &amp; 02 Interfaces"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8454"/>E.1.3.  JDBCResources 01 &amp; 02 Interfaces</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    InfoTable
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"> insert(in string name, in string value)</li><li class="listitem"> update(in string name, in string value)</li><li class="listitem"> select(in string name, out string value)</li><li class="listitem"> delete(in string name)</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.1.4.  JDBCResources 01 &amp; 02 Implementations"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8463"/>E.1.4.  JDBCResources 01 &amp; 02 Implementations</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    JDBCInfoTableImpl01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a single JDBC connection for all operations</li></ul></div>
  </li><li class="listitem">
    JDBCInfoTableImpl02 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a JDBC connection per operation</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.1.5.  JDBCResources 01 &amp; 02 Server"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8472"/>E.1.5.  JDBCResources 01 &amp; 02 Server</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Server01: 1 x JDBCInfoTableImpl01</li><li class="listitem">Server02: 1 x JDBCInfoTableImpl02</li></ul></div>
</div>
<div class="section" title="E.1.6.  JDBCResources 01 &amp; 02 Setups"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8477"/>E.1.6.  JDBCResources 01 &amp; 02 Setups</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Setup01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates Table InfoTable (Name VARCHAR(64), Value VARCHAR(64)) 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Inserts 10 entries ("Name_’X’", "Value_’X’") [Where X is 0 … 9]</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Setup02 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates Table InfoTable (Name VARCHAR(64), Value VARCHAR(64)) 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Inserts 10 entries ("Name_’X’", "Value_’X’") [Where X is 0 … 9]</li></ul></div>
      </li></ul></div>
  </li></ul></div>

</div>
<div class="section" title="E.1.7.  JDBCResources 01 &amp; 02 Clients"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8490"/>E.1.7.  JDBCResources 01 &amp; 02 Clients</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Client01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains an InfoTable object</li><li class="listitem">Inserts 10 entries, no transaction</li><li class="listitem">Verify existence of inserted entries, no transaction</li></ul></div>
  </li><li class="listitem">
    Client02 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains an InfoTable object</li><li class="listitem">Inserts 10 entries, within transaction</li><li class="listitem">Verify existence of inserted entries, within transaction</li></ul></div>
  </li><li class="listitem">
    Client03 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains an InfoTable object</li><li class="listitem">Inserts 10 entries, within transaction</li><li class="listitem">Update entry, with transaction which rolls back</li><li class="listitem">Verify existence of inserted entries, within transaction</li></ul></div>
  </li><li class="listitem">
    Client04 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains an InfoTable object</li><li class="listitem">Inserts 10 entries, within transaction</li><li class="listitem">Delete entry, with transaction which rolls back</li><li class="listitem">Verify existence of inserted entries, within transaction</li></ul></div>
  </li><li class="listitem">
    Client05 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains an InfoTable object</li><li class="listitem">Inserts 10 entries, within transaction</li><li class="listitem">Update entry, within transaction</li><li class="listitem">Update same entry with old value, no transaction</li><li class="listitem">Verify existence of inserted entries, within transaction</li></ul></div>
  </li><li class="listitem">
    Client06 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains an InfoTable object</li><li class="listitem">Inserts 10 entries, within transaction</li><li class="listitem">Update entry, no transaction</li><li class="listitem">Update same entry with old value, within transaction</li><li class="listitem">Verify existence of inserted entries, within transaction</li></ul></div>
  </li><li class="listitem">
    Client07 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, split alternatively, over each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">No transaction</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client08 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, split alternatively, over each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">Within transaction</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client09 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, split alternatively, over each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">Within transaction, per update</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client10 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, split alternatively, over each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">Within transaction, which rolls back</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client11 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, split alternatively, over each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">Within transaction, per update, which rolls back</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client12 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, in each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">No transaction</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client13 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, in each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">Within transaction</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client14 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, in each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">Within transaction, per update</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client15 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, in each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">Within transaction, which rolls back</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Client16 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains two InfoTable objects</li><li class="listitem">Update 10 entries, in each object 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "Value_’9-X’") [Where X is 0 … 9]</li><li class="listitem">Within transaction, per update, which rolls back</li></ul></div>
      </li></ul></div>
  </li></ul></div>

</div>
<div class="section" title="E.1.8.  JDBCResources 01 &amp; 02 Outcomes"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8599"/>E.1.8.  JDBCResources 01 &amp; 02 Outcomes</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Outcome01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Verify existence and values of inserted entries</li></ul></div>
  </li><li class="listitem">
    Outcome02 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Verify existence and values [reverse] of inserted entries</li></ul></div>
  </li><li class="listitem">
    Outcome03 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Verify existence and values of inserted entries, in two InfoTables</li></ul></div>
  </li><li class="listitem">
    Outcome04 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Verify existence and values [reverse] of inserted entries, in two InfoTables</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.1.9.  JDBCResources 01 &amp; 02 Cleanups"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8614"/>E.1.9.  JDBCResources 01 &amp; 02 Cleanups</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Cleanup01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Drops Table "InfoTable"</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.1.10.  JDBCResources 01 &amp; 02 Configurations"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8620"/>E.1.10.  JDBCResources 01 &amp; 02 Configurations</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"> Test001: 1 x Server01 + 1 x Client01</li><li class="listitem"> Test002: 1 x Server01 + 1 x Client02</li><li class="listitem"> Test003: 1 x Server01 + 1 x Client03</li><li class="listitem"> Test004: 1 x Server01 + 1 x Client04</li><li class="listitem"> Test005: 1 x Server01 + 1 x Client05</li><li class="listitem"> Test006: 1 x Server01 + 1 x Client06</li><li class="listitem"> Test007: 1 x Server02 + 1 x Client01</li><li class="listitem"> Test008: 1 x Server02 + 1 x Client02</li><li class="listitem"> Test009: 1 x Server02 + 1 x Client03</li><li class="listitem"> Test010: 1 x Server02 + 1 x Client04</li><li class="listitem"> Test011: 1 x Server02 + 1 x Client05</li><li class="listitem"> Test012: 1 x Server02 + 1 x Client06</li><li class="listitem"> Test013: 2 x Server01 + 1 x Client07 + Outcome02</li><li class="listitem"> Test014: 2 x Server01 + 1 x Client08 + Outcome02</li><li class="listitem"> Test015: 2 x Server01 + 1 x Client09 + Outcome02</li><li class="listitem"> Test016: 2 x Server01 + 1 x Client10 + Outcome01</li><li class="listitem"> Test017: 2 x Server01 + 1 x Client11 + Outcome01</li><li class="listitem"> Test018: 2 x Server02 + 1 x Client07 + Outcome02</li><li class="listitem"> Test019: 2 x Server02 + 1 x Client08 + Outcome02</li><li class="listitem"> Test020: 2 x Server02 + 1 x Client09 + Outcome02</li><li class="listitem"> Test021: 2 x Server02 + 1 x Client10 + Outcome01</li><li class="listitem"> Test022: 2 x Server02 + 1 x Client11 + Outcome01</li><li class="listitem"> Test023: 2 x Server01 + 1 x Client12 + Outcome04</li><li class="listitem"> Test024: 2 x Server01 + 1 x Client13 + Outcome04</li><li class="listitem"> Test025: 2 x Server01 + 1 x Client14 + Outcome04</li><li class="listitem"> Test026: 2 x Server01 + 1 x Client15 + Outcome03</li><li class="listitem"> Test027: 2 x Server01 + 1 x Client16 + Outcome03</li><li class="listitem"> Test028: 2 x Server02 + 1 x Client12 + Outcome04</li><li class="listitem"> Test029: 2 x Server02 + 1 x Client13 + Outcome04</li><li class="listitem"> Test030: 2 x Server02 + 1 x Client14 + Outcome04</li><li class="listitem"> Test031: 2 x Server02 + 1 x Client15 + Outcome03</li><li class="listitem"> Test032: 2 x Server02 + 1 x Client16 + Outcome03</li></ul></div>
</div>

</div>


<div class="section" title="E.2.  JDBCResources 03 &amp; 04"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8655"/>E.2.  JDBCResources 03 &amp; 04</h2></div></div></div>

<div class="section" title="E.2.1. Overview"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8657"/>E.2.1. Overview</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Tests 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">JDBC Support – Conflict over resource</li><li class="listitem">May fail: Depending on DB’s behaviour</li></ul></div>
  </li><li class="listitem">
    Series 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">JTSResources03: Implicit context propagation</li><li class="listitem">JTSResources04: Explicit context propagation</li></ul></div>
  </li><li class="listitem">
    Sub-series 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">_ibmdb2_jndi</li><li class="listitem">_mssqlserver_jndi</li><li class="listitem">_mysql_jndi</li><li class="listitem">_oracle_thin_jndi</li><li class="listitem">_pgsql_jndi</li><li class="listitem">_sybase_jndi</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.2.2.  JDBCResources 03 &amp; 04 Summary"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8676"/>E.2.2.  JDBCResources 03 &amp; 04 Summary</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Building blocks: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Interfaces: 1</li><li class="listitem">Implementations: 2</li><li class="listitem">Servers: 2</li><li class="listitem">Setups: 1</li><li class="listitem">Clients: 1</li><li class="listitem">Outcomes: 1</li><li class="listitem">Cleanups: 1</li></ul></div>
  </li><li class="listitem">
    Tests: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configurations: 4</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.2.3.  JDBCResources 03 &amp; 04 Interfaces"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8691"/>E.2.3.  JDBCResources 03 &amp; 04 Interfaces</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    NumberTable 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">get(in string name, out long value)</li><li class="listitem">set(in string name, in long value)</li><li class="listitem">increase(in string name)</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.2.4.  JDBCResources 03 &amp; 04 Implementations"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8699"/>E.2.4.  JDBCResources 03 &amp; 04 Implementations</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    JDBCNumberTableImpl01
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a single JDBC connection for all operations</li></ul></div>
  </li><li class="listitem">
    JDBCNumberTableImpl02
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a JDBC connection per operation</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.2.5.  JDBCResources 03 &amp; 04 Server"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8708"/>E.2.5.  JDBCResources 03 &amp; 04 Server</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Server01: 1 x JDBCNumberTableImpl01</li><li class="listitem">Server02: 1 x JDBCNumberTableImpl02</li></ul></div>
</div>
<div class="section" title="E.2.6.  JDBCResources 03 &amp; 04 Setups"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8713"/>E.2.6.  JDBCResources 03 &amp; 04 Setups</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Setup01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates Table NumberTable 
        <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name VARCHAR(64), Value INTEGER)</li></ul></div>
      </li><li class="listitem">Inserts n entries 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Name_’X’", "0") [Where X is 0 … n - 1]</li></ul></div>
      </li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.2.7.  JDBCResources 03 &amp; 04 Clients"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8724"/>E.2.7.  JDBCResources 03 &amp; 04 Clients</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Client01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Operation 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Obtains an NumberTable object</li><li class="listitem">Begin transaction</li><li class="listitem">Gets Values for "Name_0" and "Name_1"</li><li class="listitem">Increase value associated with "Name_0"</li><li class="listitem">Sleeps 15 sec.</li><li class="listitem">Increase value associated with "Name_1"</li><li class="listitem">Gets Values for "Name_0" and "Name_1"</li><li class="listitem">Commit(true) transaction</li></ul></div>
      </li><li class="listitem">Passes if: 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">New values are the same, and equals old values plus one, or</li><li class="listitem">InvocationException thrown with Reason "ReasonCantSerializeAccess"</li></ul></div>
      </li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.2.8.  JDBCResources 03 &amp; 04 Outcomes"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8743"/>E.2.8.  JDBCResources 03 &amp; 04 Outcomes</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Outcome01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Verify first n entries (0 … n - 1) have value n</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.2.9.  JDBCResources 03 &amp; 04 Cleanups"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8749"/>E.2.9.  JDBCResources 03 &amp; 04 Cleanups</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Cleanup01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Drops Table "NumberTable"</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.2.10.  JDBCResources 03 &amp; 04 Configurations"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8755"/>E.2.10.  JDBCResources 03 &amp; 04 Configurations</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"> Test01: 1 x Server01 + 2 x Client01 + Outcome01</li><li class="listitem"> Test02: 2 x Server01 + 2 x Client01 + Outcome01</li><li class="listitem"> Test03: 1 x Server02 + 2 x Client01 + Outcome01</li><li class="listitem"> Test04: 2 x Server02 + 2 x Client01 + Outcome01</li></ul></div>
</div>

</div>


<div class="section" title="E.3.  CurrentTests"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8762"/>E.3.  CurrentTests</h2></div></div></div>
<div class="section" title="E.3.1. Overview"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8764"/>E.3.1. Overview</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Tests 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Test Current interface</li><li class="listitem">Close to "Unit Tests"</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.3.2.  CurrentTests01 Summary"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8771"/>E.3.2.  CurrentTests01 Summary</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Building blocks: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Interfaces: 0</li><li class="listitem">Implementations: 0</li><li class="listitem">Servers: 0</li><li class="listitem">Clients: 34</li><li class="listitem">Outcomes: 0</li></ul></div>
  </li><li class="listitem">
    Tests: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configurations: 34</li><li class="listitem">TestXX.java maps to Test0XX.conf</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.3.3.  CurrentTests Clients"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8785"/>E.3.3.  CurrentTests Clients</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Tests 01 through 16: Complete transaction and then check that a further operation throws NoTransaction:
    <div class="itemizedlist"><div class="table"><a id="d5e8790"/><p class="title"><strong>Table E.1. Tests 01 through 16</strong></p><div class="table-contents">

<table summary="Tests 01 through 16" border="1"><colgroup><col width="1*" class="col1"/><col width="1*" class="col2"/><col width="1*" class="col3"/><col width="1*" class="col4"/><col width="1*" class="col5"/></colgroup><thead><tr><th bgcolor="#EEEEEE">Op To Check </th><th bgcolor="#EEEEEE">None</th><th bgcolor="#EEEEEE">begin commit(true)</th><th bgcolor="#EEEEEE">begin commit(false)</th><th bgcolor="#EEEEEE">begin rollback</th></tr></thead><tbody><tr><td bgcolor="#EEEEEE">commit(true)</td><td>Test01</td><td>Test05</td><td>Test09</td><td>Test13</td></tr><tr><td bgcolor="#EEEEEE">commit(false)</td><td>Test02</td><td>Test06</td><td>Test10</td><td>Test14</td></tr><tr><td bgcolor="#EEEEEE">rollback()</td><td>Test03</td><td>Test07</td><td>Test11</td><td>Test14</td></tr><tr><td bgcolor="#EEEEEE">rollback_only()</td><td>Test04</td><td>Test08</td><td>Test12</td><td>Test15</td></tr></tbody></table>
</div></div><br class="table-break"/><ul class="itemizedlist"/></div>

  </li><li class="listitem">
    Test17 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create a series if 1000 transactions, terminated with commit(true)</li><li class="listitem">Checks all names (get_transaction_name) are unique</li></ul></div>
  </li><li class="listitem">
    Test18 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create a series if 1000 transactions, terminated with commit(false)</li><li class="listitem">Checks all names (get_transaction_name) are unique</li></ul></div>
  </li><li class="listitem">
    Test19 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create a series if 1000 transactions, terminated with rollback()</li><li class="listitem">Checks all names (get_transaction_name) are unique</li></ul></div>
  </li><li class="listitem">
    Test20 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create and suspends 1000 transactions</li><li class="listitem">Resumes transactions in series</li><li class="listitem">Checks names (get_transaction_name) correspond</li></ul></div>
  </li><li class="listitem">
    Test21 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Preamble: None</li><li class="listitem">Checks if suspend return null, then not transaction</li></ul></div>
  </li><li class="listitem">
    Test22 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Preamble: begin(), commit(true)</li><li class="listitem">Checks if suspend return null, then not transaction</li></ul></div>
  </li><li class="listitem">
    Test23 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Preamble: begin(), commit(false)</li><li class="listitem">Checks if suspend return null, then not transaction</li></ul></div>
  </li><li class="listitem">
    Test24 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Preamble: begin(), rollback()</li><li class="listitem">Checks if suspend return null, then not transaction</li></ul></div>
  </li><li class="listitem">
    Test25 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Checks resume(null) does not throw InvalidControl</li></ul></div>
  </li><li class="listitem">
    Test26 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Checks that resume() of transaction terminated with commit(true) throws InvalidControl</li></ul></div>
  </li><li class="listitem">
    Test27 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Checks that resume() of transaction terminated with commit(false) throws InvalidControl</li></ul></div>
  </li><li class="listitem">
    Test28 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Checks that resume() of transaction terminated with rollback() throws InvalidControl</li></ul></div>
  </li><li class="listitem">
    Test29 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Preamble: None</li><li class="listitem">Checks that get_status() when no transaction returns StatusNoTransaction</li></ul></div>
  </li><li class="listitem">
    Test30 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Preamble: begin(), commit(true)</li><li class="listitem">Checks that get_status() when no transaction returns StatusNoTransaction</li></ul></div>
  </li><li class="listitem">
    Test31 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Preamble: begin(), commit(false)</li><li class="listitem">Checks that get_status() when no transaction returns StatusNoTransaction</li></ul></div>
  </li><li class="listitem">
    Test32 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Preamble: begin(), rollback()</li><li class="listitem">Checks that get_status() when no transaction returns StatusNoTransaction</li></ul></div>
  </li><li class="listitem">
    Test33 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Checks that get_status() when in transaction returns StatusActive</li></ul></div>
  </li><li class="listitem">
    Test34 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Checks that get_status() when in transaction marked roll back only returns StatusMarkedRollback</li></ul></div>
  </li></ul></div>
</div>
</div>


<div class="section" title="E.4.  OTSServer"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8897"/>E.4.  OTSServer</h2></div></div></div>

<div class="section" title="E.4.1. Overview"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8899"/>E.4.1. Overview</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Tests 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests OTSServer (a TransactionFactory interface implementation)</li><li class="listitem">Test001 to Test006 (Test003 to Test006 requires "DYNAMIC") - ClientXX.java maps to Test0XX.conf</li><li class="listitem">Test007 to Test012 - ClientXX.java maps to Test0XX.conf with args 1000</li><li class="listitem">Test013 to Test016 - Client13: x1, x2 with args 4 250 and x3, x4 with args 4 100</li><li class="listitem">Test017 to Test020 - Client13: x1, x2 with args 4 250 and x3, x4 with args 4 100</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.4.2.  OTSServer Summary"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8909"/>E.4.2.  OTSServer Summary</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Building blocks: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Interfaces: 0</li><li class="listitem">Implementations: 0</li><li class="listitem">Servers: 1 (OTS_Server)</li><li class="listitem">Clients: 14</li><li class="listitem">Outcomes: 0</li></ul></div>
  </li><li class="listitem">
    Tests: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configurations: 20</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.4.3.  OTSServer Clients"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8922"/>E.4.3.  OTSServer Clients</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Test01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0)</li><li class="listitem">Check its status is StatusActive</li><li class="listitem">Check commit(true) does not throw exception</li></ul></div>
  </li><li class="listitem">
    Test02 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0)</li><li class="listitem">Check its status is StatusActive</li><li class="listitem">Check rollback() does not throw exception</li></ul></div>
  </li><li class="listitem">
    Test03 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(4)</li><li class="listitem">Check its status is StatusRolledBack, after 8 seconds</li></ul></div>
  </li><li class="listitem">
    Test04 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(4)</li><li class="listitem">Check commit(true) throws INVALID_TRANSACTION or BAD_OPERATION, after 8 seconds</li></ul></div>
  </li><li class="listitem">
    Test05 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(4)</li><li class="listitem">Check commit(false) throws INVALID_TRANSACTION or BAD_OPERATION, after 8 seconds</li></ul></div>
  </li><li class="listitem">
    Test06 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(4)</li><li class="listitem">Check commit(true) throws INVALID_TRANSACTION or BAD_OPERATION, after 8 seconds</li></ul></div>
  </li><li class="listitem">
    Test07 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0)</li><li class="listitem">Check its status is StatusActive</li><li class="listitem">Check commit(true) does not throw exception, repeat n times</li></ul></div>
  </li><li class="listitem">
    Test08 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0)</li><li class="listitem">Check its status is StatusActive</li><li class="listitem">Check commit(false) does not throw exception, repeat n times</li></ul></div>
  </li><li class="listitem">
    Test09 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0)</li><li class="listitem">Check its status is StatusActive</li><li class="listitem">Check rollback() does not throw exception, repeat n times</li></ul></div>
  </li><li class="listitem">
    Test10 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0), repeat n times</li><li class="listitem">Check each status is StatusActive</li><li class="listitem">Check each commit(true) does not throw exception</li></ul></div>
  </li><li class="listitem">
    Test11 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0), repeat n times</li><li class="listitem">Check each status is StatusActive</li><li class="listitem">Check each commit(false) does not throw exception</li></ul></div>
  </li><li class="listitem">
    Test12 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0), repeat n times</li><li class="listitem">Check each status is StatusActive</li><li class="listitem">Check each rollback() does not throw exception</li></ul></div>
  </li><li class="listitem">
    Test13 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create n threads which does m times
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0)</li><li class="listitem">Check its status is StatusActive</li><li class="listitem">Checks commit(true), commit(false), rollback(), alternatively, does not throw an exception</li></ul></div>
      </li></ul></div>
  </li><li class="listitem">
    Test14 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create n threads which does
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates a transaction via transactionFactory.create(0) m times</li><li class="listitem">Check each status is StatusActive</li><li class="listitem">Checks each commit(true), commit(false), rollback(), alternatively, does not throw an exception</li></ul></div>
      </li></ul></div>
  </li></ul></div>
</div>
</div>


<div class="section" title="E.5.  AITResources"><div class="titlepage"><div><div><h2 class="title"><a id="d5e8995"/>E.5.  AITResources</h2></div></div></div>
<div class="section" title="E.5.1. Overview"><div class="titlepage"><div><div><h3 class="title"><a id="d5e8997"/>E.5.1. Overview</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    AIT 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Advanced(/Arjuna) Integrated(/Interface) Transactions</li><li class="listitem">Transactional Objects for Java</li></ul></div>
  </li><li class="listitem">
    Series 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">AITResources01: Implicit context propagation</li><li class="listitem">AITResources02: Explicit context propagation</li></ul></div>
  </li><li class="listitem">
    Tests 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Transaction Engine</li><li class="listitem">AIT support</li><li class="listitem">Context propagation</li><li class="listitem">Memory problems</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.5.2.  AITResources 01 &amp; 02 Summary"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9014"/>E.5.2.  AITResources 01 &amp; 02 Summary</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Building blocks: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Interfaces: 2 (Counter &amp; PingPong)</li><li class="listitem">Implementations: 4 (3 Counter, 1 PingPong)</li><li class="listitem">Servers: 10</li><li class="listitem">Clients: 17</li><li class="listitem">Outcomes: 2</li></ul></div>
  </li><li class="listitem">
    Tests: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Functional: 44</li><li class="listitem">Memory: 14</li><li class="listitem">Configurations: 58</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.5.3.  AITResources Interfaces"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9029"/>E.5.3.  AITResources Interfaces</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Counter 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">get()</li><li class="listitem">set()</li><li class="listitem">increase()</li><li class="listitem">getMemory()</li></ul></div>
  </li><li class="listitem">
    PingPong 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">hit(count, ping, pong) 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">If count != 0, call hit on ping, with count-1, and ping and pong swapped</li><li class="listitem">If count == 0, increase a value in object</li></ul></div>
      </li><li class="listitem">bad_hit(count, bad_count, ping, pong) 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">similar to hit(), except if bad_count == 0, abort transaction</li></ul></div>
      </li><li class="listitem">get()</li><li class="listitem">getMemory()</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.5.4.  AITResources Implementations"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9049"/>E.5.4.  AITResources Implementations</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"> AITCounterImpl01 - Operations create [nested] transactions (AtomicTransaction)</li><li class="listitem"> AITCounterImpl02 - Operations create [nested] transactions (OTS.current)</li><li class="listitem"> AITCounterImpl03 - Operations do not create transactions</li><li class="listitem"> AITPingPongImpl01 - Operations create [nested] transactions (AtomicTransaction)</li></ul></div>
</div>
<div class="section" title="E.5.5.  AITResources Server"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9056"/>E.5.5.  AITResources Server</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"> Server01: 1 x AITCounterImpl01</li><li class="listitem"> Server02: 4 x AITCounterImpl01</li><li class="listitem"> Server03: 1 x AITCounterImpl02</li><li class="listitem"> Server04: 4 x AITCounterImpl02</li><li class="listitem"> Server05: 1 x AITCounterImpl01, 1 x AITCounterImpl02</li><li class="listitem"> Server06: 2 x AITCounterImpl01, 2 x AITCounterImpl02</li><li class="listitem"> Server07: 1 x AITPingPongImpl01</li><li class="listitem"> Server08: 2 x AITPingPongImpl01</li><li class="listitem"> Server09: 1 x AITCounterImpl03</li><li class="listitem"> Server10: 4 x AITCounterImpl03</li></ul></div>
</div>
<div class="section" title="E.5.6.  AITResources Clients"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9069"/>E.5.6.  AITResources Clients</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    Client01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Performs 1000 increase(), no client transaction</li><li class="listitem">Does get() to check counter value now 1000</li></ul></div>
  </li><li class="listitem">
    Client02 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Performs 1000 increase(), each with own transaction</li><li class="listitem">Transactions are alternatively committed/rolled back</li><li class="listitem">Does get() to check counter value now 500</li></ul></div>
  </li><li class="listitem">
    Client03 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory check version of Client01</li></ul></div>
  </li><li class="listitem">
    Client04 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory check version of Client02</li></ul></div>
  </li><li class="listitem">
    Client05 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Performs 10 hit(), with count 0,1,2 … 9, ping and pong same, no client transaction</li><li class="listitem">Does get() to check value now 10</li></ul></div>
  </li><li class="listitem">
    Client06 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Performs 10 hit(), with count 0,1,2 … 9, ping and pong different, no client transaction</li><li class="listitem">Does get(), on both ping and pong, to check values are now 5</li></ul></div>
  </li><li class="listitem">
    Client07 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory check version of Client05</li></ul></div>
  </li><li class="listitem">
    Client08 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory check version of Client06</li></ul></div>
  </li><li class="listitem">
    Client09 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Performs 1000 successful increase(), no client transaction</li></ul></div>
  </li><li class="listitem">
    Client10 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Performs 10 bad_hit(), with count 0,1,2 … 9, for each bad_count 0 … count, ping and pong same, no client transaction</li><li class="listitem">Does get() to check value now 0</li></ul></div>
  </li><li class="listitem">
    Client11 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Performs 10 bad_hit(), with count 0,1,2 … 9 , for each bad_count 0 … count, ping and pong different, no client transaction</li><li class="listitem">Does get(), on both ping and pong, to check values are now 0</li></ul></div>
  </li><li class="listitem">
    Client12 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory check version of Client10</li></ul></div>
  </li><li class="listitem">
    Client13 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory check version of Client11</li></ul></div>
  </li><li class="listitem">
    Client14 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates n threads, which each performs m successful increase(), no client transaction</li><li class="listitem">Does get() to check counter value now n * m</li></ul></div>
  </li><li class="listitem">
    Client15 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory check version of Client14</li></ul></div>
  </li><li class="listitem">
    Client16 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creates n threads, which each performs m successful increase(), each with own transaction, commits if increase() was successful, rolls bask if increase() was unsuccessful</li><li class="listitem">Does get() to check counter value now n * m</li></ul></div>
  </li><li class="listitem">
    Client17 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Memory check version of Client16</li></ul></div>
  </li></ul></div>
</div>
<div class="section" title="E.5.7.  AITResources Outcomes"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9132"/>E.5.7.  AITResources Outcomes</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"> Outcome01</li><li class="listitem"> Checks if a counter has an "expected value"</li><li class="listitem"> Outcome02</li><li class="listitem"> Checks if two counters has an "expected value"</li></ul></div>
</div>
<div class="section" title="E.5.8.  AITResources Memory Tests"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9139"/>E.5.8.  AITResources Memory Tests</h3></div></div></div>
  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    General form: 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Perform test pattern (reduced) 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Make sure all classes loaded</li><li class="listitem">Caches full</li></ul></div>
      </li><li class="listitem">Get memory of all Clients and Servers 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Repeat: run GC, get memory until no further decreases</li></ul></div>
      </li><li class="listitem">Perform test pattern </li><li class="listitem">Get memory of all Clients and Servers 
      <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Repeat: run GC, get memory until no further decreases</li></ul></div>
      </li><li class="listitem">Perform check </li></ul></div>
  </li></ul></div>
</div>
</div>


<div class="section" title="E.6.  CrashRecovery"><div class="titlepage"><div><div><h2 class="title"><a id="d5e9156"/>E.6.  CrashRecovery</h2></div></div></div>

<div class="section" title="E.6.1.  CrashRecovery Summary"><div class="titlepage"><div><div><h3 class="title"><a id="d5e9158"/>E.6.1.  CrashRecovery Summary</h3></div></div></div>

  <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
    CrashRecovery01 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests replay_completion (Implicit context propagation)</li></ul></div>
  </li><li class="listitem">
    CrashRecovery02 (_1: One resource &amp; _2: Two resource) 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests behaviour server crash (Implicit context propagation)</li></ul></div>
  </li><li class="listitem">
    CrashRecovery03 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests replay_completion called with null (Implicit context propagation)</li></ul></div>
  </li><li class="listitem">
    CrashRecovery04 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests replay_completion (Explicit context propagation)</li></ul></div>
  </li><li class="listitem">
    CrashRecovery05 (_1: One resource &amp; _2: Two resource) 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests behaviour server crash (Explicit context propagation)</li></ul></div>
  </li><li class="listitem">
    CrashRecovery06 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests replay_completion called with null (Explicit context propagation)</li></ul></div>
  </li><li class="listitem">
    CrashRecovery07 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests behaviour client crash (Implicit context propagation)</li></ul></div>
  </li><li class="listitem">
    CrashRecovery08 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests behaviour client crash (Explicit context propagation)</li></ul></div>
  </li><li class="listitem">
    CrashRecovery09 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests automatic TO (AIT) resource initiated crash recovery (Implicit context propagation)</li><li class="listitem">Not supported by system, if passes caused by recovery manager initiated crash recovery ]</li></ul></div>
  </li><li class="listitem">
    CrashRecovery10 
    <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tests automatic TO (AIT) resource initiated crash recovery (Explicit context propagation)</li><li class="listitem">Not supported by system, if passes caused by recovery manager initiated crash recovery ]</li></ul></div>
  </li></ul></div>
</div>
</div>
</div>
</div>
</div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script></body></html>