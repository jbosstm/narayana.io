<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>Failure Recovery</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

h6 > .content > .title,h7,h8,h9 {
    font-family:"Open Sans","DejaVu Sans",sans-serif;
    font-weight:normal;
    font-size:.85em;
    font-style:normal;
    color:#ba8425;
    text-rendering:optimizeLegibility;
    margin-top:1em;
    margin-bottom:1em;
    line-height:2em
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/*! Stylesheet for CodeRay to loosely match GitHub themes | MIT License */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid;opacity:.35;padding:0 .5em 0 0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff!important;background:navy!important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:navy}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:teal}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:teal}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:teal}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:teal}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Failure Recovery</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_configuring_the_failure_recovery_subsystem_for_your_orb">Configuring the failure recovery subsystem for your ORB</a></li>
<li><a href="#_jts_specific_recovery">JTS specific recovery</a>
<ul class="sectlevel2">
<li><a href="#_xa_resource_recovery">XA resource recovery</a></li>
<li><a href="#_recovery_behavior">Recovery behavior</a></li>
<li><a href="#_expired_entry_removal">Expired entry removal</a></li>
<li><a href="#_recovery_domains">Recovery domains</a></li>
</ul>
</li>
<li><a href="#_transaction_status_and_replay_comparison">Transaction status and <code>replay_comparison</code></a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The failure recovery subsystem of Narayana ensure that results of a transaction are applied consistently to all resources affected by the transaction, even if any of the application processes or the hardware hosting them crash or lose network connectivity.
In the case of hardware crashes or network failures, the recovery does not take place until the system or network are restored, but the original application does not need to be restarted.
Recovery is handled by the Recovery Manager process.
For recover to take place, information about the transaction and the resources involved needs to survive the failure and be accessible afterward.
This information is held in the <code>ActionStore</code>, which is part of the <code>ObjectStore</code>.
If the <code>ObjectStore</code> is destroyed or modified, recovery may not be possible.</p>
</div>
<div class="paragraph">
<p>Until the recovery procedures are complete, resources affected by a transaction which was in progress at the time of the failure may be inaccessible.
Database resources may report this as as tables or rows held by in-doubt transactions.
For TXOJ resources, an attempt to activate the Transactional Object, such as when trying to get a lock, fails.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuring_the_failure_recovery_subsystem_for_your_orb"><a class="anchor" href="#_configuring_the_failure_recovery_subsystem_for_your_orb"></a>Configuring the failure recovery subsystem for your ORB</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although some ORB-specific configuration is necessary to configure the ORB sub-system, the basic settings are ORB-independent.
The configuration which applies to Narayana is in the <code>RecoveryManager-properties.xml</code> file and the <code>orportability-properties.xml</code> file.
Contents of each file are below.</p>
</div>
<div class="listingblock">
<div class="title">RecoverManager-properties.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">RecoveryEnvironmentBean.recoveryActivatorClassNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    com.arjuna.ats.internal.jts.orbspecific.recovery.RecoveryEnablement
<span class="tag">&lt;/entry&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">orportability-properties.xml</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.arjuna.orbportability.orb.PostInit2</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>com.arjuna.ats.internal.jts.recovery.RecoveryInit<span class="tag">&lt;/entry&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These entries cause instances of the named classes to be loaded.
The named classes then load the ORB-specific classes needed and perform other initialization.
This enables failure recovery for transactions initiated by or involving applications using this property file.
The default <code>RecoveryManager-properties.xml</code> file and <code>orportability-properties.xml</code> with the distribution include these entries.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Failure recovery is NOT supported with the JavaIDL ORB that is part of JDK.
Failure recovery is supported for JacOrb only.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To disable recovery, remove or comment out the <code>RecoveryEnablement</code> line in the property file.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jts_specific_recovery"><a class="anchor" href="#_jts_specific_recovery"></a>JTS specific recovery</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_xa_resource_recovery"><a class="anchor" href="#_xa_resource_recovery"></a>XA resource recovery</h3>
<div class="paragraph">
<p>Recovery of XA resources accessed via JDBC is handled by the <code>XARecoveryModule</code>. This module includes both transaction-initiated and resource-initiated recovery.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transaction-initiated recovery is possible where the particular transaction branch progressed far enough for a <code>JTA_ResourceRecord</code> to be written in the ObjectStore.
The record contains the information needed to link the transaction to information known by the rest of Narayana in the database.</p>
</li>
<li>
<p>Resource-initiated recovery is necessary for branches where a failure occurred after the database made a persistent record of the transaction, but before the <code>JTA_ResourceRecord</code> was written.
Resource-initiated recovery is also necessary for datasources for which it is impossible to hold information in the <code>JTA_ResourceRecord</code> that allows the recreation in the RecoveryManager of the <code>XAConnection</code> or <code>XAResource</code> used in the original application.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Transaction-initiated recovery is automatic.
The <code>XARecoveryModule</code> finds the <code>JTA_ResourceRecord</code> which needs recovery, using the two-pass mechanism described above.
It then uses the normal recovery mechanisms to find the status of the transaction the resource was involved in, by running <code>replay_completion</code> on the <code>RecoveryCoordinator</code> for the transaction branch.
Next, it creates or recreates the appropriate <code>XAResource</code> and issues <code>commit</code> or <code>rollback</code> on it as appropriate.
The <code>XAResource</code> creation uses the same database name, username, password, and other information as the application.</p>
</div>
<div class="paragraph">
<p>Resource-initiated recovery must be specifically configured, by supplying the <code>RecoveryManager</code> with the appropriate information for it to interrogate all the <code>XADataSources</code> accessed by any Narayana application.
The access to each <code>XADataSource</code> is handled by a class that implements the <code>com.arjuna.ats.jta.recovery.XAResourceRecovery</code> interface.
Instances of this class are dynamically loaded, as controlled by property <code>JTAEnvironmentBean.xaResourceRecoveryInstances</code> .</p>
</div>
<div class="paragraph">
<p>The <code>XARecoveryModule</code> uses the <code>XAResourceRecovery</code> implementation to get an <code>XAResource</code> to the target datasource.
On each invocation of periodicWorkSecondPass`, the recovery module issues an <code>XAResource.recover</code> request.
This request returns a list of the transaction identifiers that are known to the datasource and are in an in-doubt state.
The list of these in-doubt Xids is compared across multiple passes, using <code>periodicWorkSecondPass-es</code>.
Any Xid that appears in both lists, and for which no <code>JTA_ResourceRecord</code> is found by the intervening transaction-initiated recovery, is assumed to belong to a transaction involved in a crash before any <code>JTA_Resource_Record</code> was written, and a <code>rollback</code> is issued for that transaction on the <code>XAResource</code>.</p>
</div>
<div class="paragraph">
<p>This double-scan mechanism is used because it is possible the Xid was obtained from the datasource just as the original application process was about to create the corresponding JTA_ResourceRecord.
The interval between the scans should allow time for the record to be written unless the application crashes (and if it does, rollback is the right answer).</p>
</div>
<div class="paragraph">
<p>An <code>XAResourceRecovery</code> implementation class can contain all the information needed to perform recovery to a specific datasource.
Alternatively, a single class can handle multiple datasources which have some similar features.
The constructor of the implementation class must have an empty parameter list, because it is loaded dynamically.
The interface includes an <code>initialise</code> method, which passes in further information as a <code>string</code>.
The content of the string is taken from the property value that provides the class name.
Everything after the first semi-colon is passed as the value of the string.
The <code>XAResourceRecovery</code> implementation class determines how to use the string.</p>
</div>
<div class="paragraph">
<p>An <code>XAResourceRecovery</code> implementation class, <code>com.arjuna.ats.internal.jdbc.recovery.BasicXARecovery</code>, supports resource-initiated recovery for any XADataSource.
For this class, the string received in method <code>initialise</code> is assumed to contain the number of connections to recover, and the name of the properties file containing the dynamic class name, the database username, the database password and the database connection URL.
The following example is for an Oracle 8.1.6 database accessed via the Sequelink 5.1 driver:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>XAConnectionRecoveryEmpay=com.arjuna.ats.internal.jdbc.recovery.BasicXARecovery;2;OraRecoveryInfo</pre>
</div>
</div>
<div class="paragraph">
<p>This implementation is only meant as an example, because it relies upon usernames and passwords appearing in plain text properties files.
You can create your own implementations of <code>XAConnectionRecovery</code>.
See the javadocs and the example <code>com.arjuna.ats.internal.jdbc.recovery.BasicXARecovery</code>.</p>
</div>
<div class="listingblock">
<div class="title">XAConnectionRecovery implementation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.arjuna.ats.internal.jdbc.recovery</span>;

<span class="keyword">import</span> <span class="include">com.arjuna.ats.jdbc.TransactionalDriver</span>;
<span class="keyword">import</span> <span class="include">com.arjuna.ats.jdbc.common.jdbcPropertyManager</span>;
<span class="keyword">import</span> <span class="include">com.arjuna.ats.jdbc.logging.jdbcLogger</span>;

<span class="keyword">import</span> <span class="include">com.arjuna.ats.internal.jdbc</span>.*;
<span class="keyword">import</span> <span class="include">com.arjuna.ats.jta.recovery.XAConnectionRecovery</span>;
<span class="keyword">import</span> <span class="include">com.arjuna.ats.arjuna.common</span>.*;
<span class="keyword">import</span> <span class="include">com.arjuna.common.util.logging</span>.*;

<span class="keyword">import</span> <span class="include">java.sql</span>.*;
<span class="keyword">import</span> <span class="include">javax.sql</span>.*;

<span class="keyword">import</span> <span class="include">jakarta.transaction</span>.*;

<span class="keyword">import</span> <span class="include">javax.transaction.xa</span>.*;
<span class="keyword">import</span> <span class="include">java.util</span>.*;

<span class="keyword">import</span> <span class="include">java.lang.NumberFormatException</span>;

<span class="comment">/**
 * This class implements the XAConnectionRecovery interface for XAResources.
 * The parameter supplied in setParameters can contain arbitrary information
 * necessary to initialise the class once created. In this instance it contains
 * the name of the property file in which the db connection information is
 * specified, as well as the number of connections that this file contains
 * information on (separated by ;).
 * &lt;p&gt;
 * IMPORTANT: this is only an *example* of the sorts of things an
 * XAConnectionRecovery implementor could do. This implementation uses
 * a property file which is assumed to contain sufficient information to
 * recreate connections used during the normal run of an application so that
 * we can perform recovery on them. It is not recommended that information such
 * as user name and password appear in such a raw text format as it opens up
 * a potential security hole.
 * &lt;p&gt;
 * The db parameters specified in the property file are assumed to be
 * in the format:
 * &lt;p&gt;
 * DB_x_DatabaseURL=
 * DB_x_DatabaseUser=
 * DB_x_DatabasePassword=
 * DB_x_DatabaseDynamicClass=
 * &lt;p&gt;
 * DB_JNDI_x_DatabaseURL=
 * DB_JNDI_x_DatabaseUser=
 * DB_JNDI_x_DatabasePassword=
 * &lt;p&gt;
 * where x is the number of the connection information.
 *
 * @since JTS 2.1.
 */</span>

<span class="directive">public</span> <span class="type">class</span> <span class="class">BasicXARecovery</span> <span class="directive">implements</span> XAConnectionRecovery {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> dbTag = <span class="string"><span class="delimiter">&quot;</span><span class="content">DB_</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> urlTag = <span class="string"><span class="delimiter">&quot;</span><span class="content">_DatabaseURL</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> passwordTag = <span class="string"><span class="delimiter">&quot;</span><span class="content">_DatabasePassword</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> userTag = <span class="string"><span class="delimiter">&quot;</span><span class="content">_DatabaseUser</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> dynamicClassTag = <span class="string"><span class="delimiter">&quot;</span><span class="content">_DatabaseDynamicClass</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">String</span> jndiTag = <span class="string"><span class="delimiter">&quot;</span><span class="content">JNDI_</span><span class="delimiter">&quot;</span></span>;
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">char</span> BREAKCHARACTER = <span class="string"><span class="delimiter">'</span><span class="content">;</span><span class="delimiter">'</span></span>;  <span class="comment">// delimiter for parameters</span>
    <span class="directive">private</span> <span class="type">int</span> numberOfConnections;
    <span class="directive">private</span> <span class="type">int</span> connectionIndex;
    <span class="directive">private</span> <span class="predefined-type">Properties</span> props;
    <span class="comment">/*
     * Some XAConnectionRecovery implementations will do their startup work
     * here, and then do little or nothing in setDetails. Since this one needs
     * to know dynamic class name, the constructor does nothing.
     */</span>
    <span class="directive">public</span> BasicXARecovery() <span class="directive">throws</span> <span class="exception">SQLException</span> {
        numberOfConnections = <span class="integer">1</span>;
        connectionIndex = <span class="integer">0</span>;
        props = <span class="predefined-constant">null</span>;
    }

    <span class="comment">/**
     * The recovery module will have chopped off this class name already.
     * The parameter should specify a property file from which the url,
     * user name, password, etc. can be read.
     */</span>

    <span class="directive">public</span> <span class="type">boolean</span> initialise(<span class="predefined-type">String</span> parameter) <span class="directive">throws</span> <span class="exception">SQLException</span> {
        <span class="type">int</span> breakPosition = parameter.indexOf(BREAKCHARACTER);
        <span class="predefined-type">String</span> fileName = parameter;

        <span class="keyword">if</span> (breakPosition != -<span class="integer">1</span>) {
            fileName = parameter.substring(<span class="integer">0</span>, breakPosition - <span class="integer">1</span>);

            <span class="keyword">try</span> {
                numberOfConnections = <span class="predefined-type">Integer</span>.parseInt(parameter.substring(breakPosition + <span class="integer">1</span>));
            } <span class="keyword">catch</span> (<span class="exception">NumberFormatException</span> e) {
                <span class="comment">//Produce a Warning Message</span>
                <span class="keyword">return</span> <span class="predefined-constant">false</span>;
            }
        }

        PropertyManager.addPropertiesFile(fileName);

        <span class="keyword">try</span> {
            PropertyManager.loadProperties(<span class="predefined-constant">true</span>);

            props = PropertyManager.getProperties();
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            <span class="comment">//Produce a Warning Message</span>

            <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        }

        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }

    <span class="directive">public</span> <span class="directive">synchronized</span> <span class="predefined-type">XAConnection</span> getConnection() <span class="directive">throws</span> <span class="exception">SQLException</span> {
        JDBC2RecoveryConnection conn = <span class="predefined-constant">null</span>;

        <span class="keyword">if</span> (hasMoreConnections()) {
            connectionIndex++;

            conn = getStandardConnection();

            <span class="keyword">if</span> (conn == <span class="predefined-constant">null</span>)
                conn = getJNDIConnection();

            <span class="keyword">if</span> (conn == <span class="predefined-constant">null</span>)
            <span class="comment">//Produce a Warning message</span>
        }

        <span class="keyword">return</span> conn;
    }

    <span class="directive">public</span> <span class="directive">synchronized</span> <span class="type">boolean</span> hasMoreConnections() {
        <span class="keyword">if</span> (connectionIndex == numberOfConnections)
            <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }

    <span class="directive">private</span> <span class="directive">final</span> JDBC2RecoveryConnection getStandardConnection() <span class="directive">throws</span> <span class="exception">SQLException</span> {
        <span class="predefined-type">String</span> number = <span class="keyword">new</span> <span class="predefined-type">String</span>(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + connectionIndex);
        <span class="predefined-type">String</span> url = <span class="keyword">new</span> <span class="predefined-type">String</span>(dbTag + number + urlTag);
        <span class="predefined-type">String</span> password = <span class="keyword">new</span> <span class="predefined-type">String</span>(dbTag + number + passwordTag);
        <span class="predefined-type">String</span> user = <span class="keyword">new</span> <span class="predefined-type">String</span>(dbTag + number + userTag);
        <span class="predefined-type">String</span> dynamicClass = <span class="keyword">new</span> <span class="predefined-type">String</span>(dbTag + number + dynamicClassTag);
        <span class="predefined-type">Properties</span> dbProperties = <span class="keyword">new</span> <span class="predefined-type">Properties</span>();
        <span class="predefined-type">String</span> theUser = props.getProperty(user);
        <span class="predefined-type">String</span> thePassword = props.getProperty(password);

        <span class="keyword">if</span> (theUser != <span class="predefined-constant">null</span>) {
            dbProperties.put(ArjunaJDBC2Driver.userName, theUser);
            dbProperties.put(ArjunaJDBC2Driver.password, thePassword);

            <span class="predefined-type">String</span> dc = props.getProperty(dynamicClass);

            <span class="keyword">if</span> (dc != <span class="predefined-constant">null</span>)
                dbProperties.put(ArjunaJDBC2Driver.dynamicClass, dc);

            <span class="keyword">return</span> <span class="keyword">new</span> JDBC2RecoveryConnection(url, dbProperties);
        } <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    <span class="comment">/*
     * Example:
     *
     * DB2_DatabaseURL=jdbc\:arjuna\:sequelink\://qa02\:20001
     * DB2_DatabaseUser=tester2
     * DB2_DatabasePassword=tester
     * DB2_DatabaseDynamicClass=
     *      com.arjuna.ats.internal.jdbc.drivers.sequelink_5_1
     *
     * DB_JNDI_DatabaseURL=jdbc\:arjuna\:jndi
     * DB_JNDI_DatabaseUser=tester1
     * DB_JNDI_DatabasePassword=tester
     * DB_JNDI_DatabaseName=empay
     * DB_JNDI_Host=qa02
     * DB_JNDI_Port=20000
     */</span>

    <span class="directive">private</span> <span class="directive">final</span> JDBC2RecoveryConnection getJNDIConnection() <span class="directive">throws</span> <span class="exception">SQLException</span> {
        <span class="predefined-type">String</span> number = <span class="keyword">new</span> <span class="predefined-type">String</span>(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span> + connectionIndex);
        <span class="predefined-type">String</span> url = <span class="keyword">new</span> <span class="predefined-type">String</span>(dbTag + jndiTag + number + urlTag);
        <span class="predefined-type">String</span> password = <span class="keyword">new</span> <span class="predefined-type">String</span>(dbTag + jndiTag + number + passwordTag);
        <span class="predefined-type">String</span> user = <span class="keyword">new</span> <span class="predefined-type">String</span>(dbTag + jndiTag + number + userTag);
        <span class="predefined-type">Properties</span> dbProperties = <span class="keyword">new</span> <span class="predefined-type">Properties</span>();
        <span class="predefined-type">String</span> theUser = props.getProperty(user);
        <span class="predefined-type">String</span> thePassword = props.getProperty(password);

        <span class="keyword">if</span> (theUser != <span class="predefined-constant">null</span>) {
            dbProperties.put(ArjunaJDBC2Driver.userName, theUser);
            dbProperties.put(ArjunaJDBC2Driver.password, thePassword);
            <span class="keyword">return</span> <span class="keyword">new</span> JDBC2RecoveryConnection(url, dbProperties);
        } <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Multiple recovery domains and resource-initiated recovery</div>
<code>XAResource.recover</code> returns the list of all transactions that are in-doubt with in the datasource.
If multiple recovery domains are used with a single datasource, resource-initiated recovery sees transactions from other domains.
Since it does not have a <code>JTA_ResourceRecord</code> available, it rolls back the transaction in the database, if the Xid appears in successive recover calls.
To suppress resource-initiated recovery, do not supply an <code>XAConnectionRecovery</code> property, or confine it to one recovery domain.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_recovery_behavior"><a class="anchor" href="#_recovery_behavior"></a>Recovery behavior</h3>
<div class="paragraph">
<p>Property <code>OTS_ISSUE_RECOVERY_ROLLBACK</code> controls whether the <code>RecoveryManager</code> explicitly issues a rollback request when <code>replay_completion</code> asks for the status of a transaction that is unknown.
According to the <code>presume-abort</code> mechanism used by OTS and JTS, the transaction can be assumed to have rolled back, and this is the response returned to the Resource`, including a subordinate coordinator, in this case.
The <code>Resource</code> should then apply that result to the underlying resources.
However, it is also legitimate for the superior to issue a rollback, if <code>OTS_ISSUE_RECOVERY_ROLLBACK</code> is set to <code>YES</code>.</p>
</div>
<div class="paragraph">
<p>The OTS transaction identification mechanism makes it possible for a transaction coordinator to hold a <code>Resource</code> reference that will never be usable.
This can occur in two cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The process holding the <code>Resource</code> crashes before receiving the commit or rollback request from the coordinator.</p>
</li>
<li>
<p>The <code>Resource</code> receives the commit or rollback, and responds.
However, the message is lost or the coordinator process has crashed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the first case, the <code>RecoveryManager</code> for the <code>Resource``ObjectStore</code> eventually reconstructs a new <code>Resource</code> (with a different CORBA object reference (IOR), and issues a <code>replay_completion</code> request containing the new <code>Resource</code> IOR.
The <code>RecoveryManager</code> for the coordinator substitutes this in place of the original, useless one, and issues <code>commit</code> to the new reconstructed <code>Resource</code>.
The <code>Resource</code> has to have been in a commit state, or there would be no transaction intention list.
Until the <code>replay_completion</code> is received, the <code>RecoveryManager</code> tries to send <code>commit</code> to its <code>Resource</code> reference.
This will fail with a CORBA System Exception.
Which exception depends on the ORB and other details.</p>
</div>
<div class="paragraph">
<p>In the second case, the <code>Resource</code> no longer exists.
The <code>RecoveryManager</code> at the coordinator will never get through, and will receive System Exceptions forever.</p>
</div>
<div class="paragraph">
<p>The <code>RecoveryManager</code> cannot distinguish these two cases by any protocol mechanism.
There is a perceptible cost in repeatedly attempting to send the commit to an inaccessible <code>Resource</code>. In particular, the timeouts involved will extend the recovery iteration time, and thus potentially leave resources inaccessible for longer.</p>
</div>
<div class="paragraph">
<p>To avoid this, the <code>RecoveryManager</code> only attempts to send <code>commit</code> to a <code>Resource</code> a limited number of times.
After that, it considers the transaction assumed complete.
It retains the information about the transaction, by changing the object type in the ActionStore`, and if the <code>Resource</code> eventually does wake up and a <code>replay_completion</code> request is received, the <code>RecoveryManager</code> activates the transaction and issues the commit request to the new Resource IOR.
The number of times the <code>RecoveryManager</code> attempts to issue <code>commit</code> as part of the periodic recovery is controlled by the property variable <code>COMMITTED_TRANSACTION_RETRY_LIMIT</code>, and defaults to <code>3</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_expired_entry_removal"><a class="anchor" href="#_expired_entry_removal"></a>Expired entry removal</h3>
<div class="paragraph">
<p>The operation of the recovery subsystem causes some entries to be made in the <code>ObjectStore</code> that are not removed in normal progress.
The <code>RecoveryManager</code> has a facility for scanning for these and removing items that are very old.
Scans and removals are performed by implementations of the <code>&gt;com.arjuna.ats.arjuna.recovery.ExpiryScanner</code>.
Implementations of this interface are loaded by giving the class names as the value of the property <code>RecoveryEnvironmentBean.expiryScannerClassNames</code>.
The <code>RecoveryManager</code> calls the <code>scan</code> method on each loaded <code>ExpiryScanner</code> implementation at an interval determined by the property <code>RecoveryEnvironmentBean.expiryScanInterval</code>.
This value is given in hours, and defaults to <code>12</code>.
A property value of <code>0</code> disables any expiry scanning.
If the value as supplied is positive, the first scan is performed when <code>RecoveryManager</code> starts.
If the value is negative, the first scan is delayed until after the first interval, using the absolute value.</p>
</div>
<div class="paragraph">
<p>There are two kinds of item that are scanned for expiry:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contact items</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One contact item is created by every application process that uses Narayana.
They contain the information that the <code>RecoveryManager</code> uses to determine if the process that initiated the transaction is still alive, and what the transaction status is.
The expiry time for these is set by the property <code>RecoveryEnvironmentBean.transactionStatusManagerExpiryTime</code>, which is expressed in hours.
The default is <code>12</code> , and <code>0</code> suppresses the expiration.
This is the interval after which a process that cannot be contacted is considered to be dead.
It should be long enough to avoid accidentally removing valid entries due to short-lived transient errors such as network downtime.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assumed complete transactions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The expiry time is counted from when the transactions were assumed to be complete.
A <code>replay_completion</code> request resets the clock.
The risk with removing assumed complete transactions it that a prolonged communication outage means that a remote <code>Resource</code> cannot connect to the <code>RecoveryManager</code> for the parent transaction.
If the assumed complete transaction entry is expired before the communications are recovered, the eventual <code>replay_completion</code> will find no information and the <code>Resource</code> will be rolled back, although the transaction committed.
Consequently, the expiry time for assumed complete transactions should be set to a value that exceeds any anticipated network outage.
The parameter is <code>ASSUMED_COMPLETE_EXPIRY_TIME</code>.
It is expressed in hours, with <code>240</code> being the default, and <code>0</code> meaning never to expire.</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">ExpiryScanner properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">RecoveryEnvironmentBean.expiryScannerClassNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner
    com.arjuna.ats.internal.jts.recovery.contact.ExpiredContactScanner
    com.arjuna.ats.internal.jts.recovery.transactions.ExpiredToplevelScanner
    com.arjuna.ats.internal.jts.recovery.transactions.ExpiredServerScanner
<span class="tag">&lt;/entry&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two `ExpiryScannner&#8217;s for the assumed complete transactions, because there are different types in the ActionStore.</p>
</div>
</div>
<div class="sect2">
<h3 id="_recovery_domains"><a class="anchor" href="#_recovery_domains"></a>Recovery domains</h3>
<div class="paragraph">
<p>A key part of the recovery subsystem is that the <code>RecoveryManager</code> hosts the OTS <code>RecoveryCoordinator</code> objects that handle recovery for transactions initiated in application processes.
Information passes between the application process and the <code>RecoveryManager</code> in one of three ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RecoveryCoordinator</code> object references (IORs) are created in the application process.
They contain information identifying the transaction in the object key.
They pass the object key to the <code>Resource</code> objects, and the <code>RecoveryManager</code> receives it.</p>
</li>
<li>
<p>The application process and the <code>RecoveryManager</code> access the same <code>jbossts-properties.xml</code>, and therefore use the same <code>ObjectStore</code>.</p>
</li>
<li>
<p>The <code>RecoveryCoordinator</code> invokes CORBA directly in the application, using information in the contact items.
Contact items are kept in the <code>ObjectStore</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Multiple recovery domains may useful if you are doing a migration, and separate <code>ObjectStores</code> are useful.
However, multiple RecoveryManagers can cause problems with XA datasources if resource-initiated recovery is active on any of them.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transaction_status_and_replay_comparison"><a class="anchor" href="#_transaction_status_and_replay_comparison"></a>Transaction status and <code>replay_comparison</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>When a transaction successfully commits, the transaction log is removed from the system.
The log is no longer required, since all registered Resources have responded successfully to the two-phase commit sequence.
However, if a <code>Resource</code> calls <code>replay_completion</code> on the <code>RecoveryCoordinator</code> after the transaction it represents commits, the status returned is <code>StatusRolledback</code>.
The transaction system does not keep a record of committed transactions, and assumes that in the absence of a transaction log, the transaction must have rolled back.
This is in line with the <code>presumed abort protocol</code> used by the OTS.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-09-27 14:38:03 +0100
</div>
</div>
</body>
</html>