<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>TXBridge Guide</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

h6 > .content > .title,h7,h8,h9 {
    font-family:"Open Sans","DejaVu Sans",sans-serif;
    font-weight:normal;
    font-size:.85em;
    font-style:normal;
    color:#ba8425;
    text-rendering:optimizeLegibility;
    margin-top:1em;
    margin-bottom:1em;
    line-height:2em
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/*! Stylesheet for CodeRay to loosely match GitHub themes | MIT License */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid;opacity:.35;padding:0 .5em 0 0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff!important;background:navy!important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:navy}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:teal}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:teal}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:teal}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:teal}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body id="_txbridge" class="book toc2 toc-left">
<div id="header">
<h1>TXBridge Guide</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_contextual_overview">1.1. Contextual Overview</a></li>
<li><a href="#_transaction_bridging">1.2. Transaction Bridging</a></li>
</ul>
</li>
<li><a href="#_transaction_bridge_architecture">2. Transaction <code>Bridge</code> Architecture</a>
<ul class="sectlevel2">
<li><a href="#_overview">2.1. Overview</a></li>
<li><a href="#_shared_design_elements">2.2. Shared Design Elements</a></li>
<li><a href="#_inbound_bridging">2.3. Inbound Bridging</a></li>
<li><a href="#_outbound_bridging">2.4. Outbound Bridging</a></li>
<li><a href="#_crash_recovery">2.5. Crash Recovery</a></li>
</ul>
</li>
<li><a href="#_using_the_transaction_bridge">3. Using the Transaction Bridge</a>
<ul class="sectlevel2">
<li><a href="#_introduction_2">3.1. Introduction</a></li>
<li><a href="#_enabling">3.2. Enabling</a></li>
<li><a href="#_inbound_bridging_2">3.3. Inbound Bridging</a></li>
<li><a href="#_outbound_bridging_2">3.4. Outbound Bridging</a></li>
<li><a href="#_loops_and_diamonds">3.5. Loops and Diamonds</a></li>
<li><a href="#_distributed_jta_and_the_jts">3.6. Distributed JTA and the JTS</a></li>
<li><a href="#_logging">3.7. Logging</a></li>
</ul>
</li>
<li><a href="#_known_limitations">4. Known Limitations</a></li>
<li><a href="#_design_notes">5. Design Notes</a>
<ul class="sectlevel2">
<li><a href="#_general_points">5.1. General Points</a></li>
<li><a href="#_crash_recovery_considerations">5.2. Crash Recovery Considerations</a></li>
<li><a href="#_test_framework">5.3. Test framework</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>1. Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_contextual_overview"><a class="anchor" href="#_contextual_overview"></a>1.1. Contextual Overview</h3>
<div class="paragraph">
<p>Transactions provide a structuring mechanism for business logic.
Use of transactions allows for grouping of data manipulations into constructs with certain properties.
Traditional ACID transactions provide for properties of Atomicity, Consistency, Isolation and Durability.</p>
</div>
<div class="paragraph">
<p>In JavaEE applications, transaction support is provided via the Java Transaction API (JTA).
The classes and interfaces in the <code>jakarta.transaction</code> and <code>javax.transaction.xa</code> packages provide a means by which the programmer may manage transaction demarcation (<code>begin</code>, <code>commit</code>, <code>rollback</code>) and, where necessary, interact with the transaction management system (e.g. <code>enlistResource</code>).
In many JavaEE applications, further abstractions are provided on top of the JTA.
For example, EJB3 <code>@TransactionAttribute</code> annotations may be used for transaction boundary demarcation in preference to explicit calls to the JTA&#8217;s UserTransaction interface.</p>
</div>
<div class="paragraph">
<p>In distributed applications, the JTA implementation may provide propagation of transaction context and transaction control calls between containers (JVMs) using either a propriety transport or JTS, the Java mapping of the CORBA OTS standard on an RMI/IIOP transport.
In Narayana, both local and distributed (JTS) implementations of the JTA are available.</p>
</div>
<div class="paragraph">
<p>In Web Services applications, ACID transaction management and interoperable context propagation is provided for by the WS-AT standard.
Narayana XTS provides an implementation of both the 1.1 and 1.2 versions of this standard.
Bridging is provided only on the more recent version.
At the time of writing the standard covers only the web services API and protocol, not the Java API through which the protocol may be driven.
Therefore, XTS provides a custom Java API to users, with characteristics broadly similar to the JTA.</p>
</div>
<div class="paragraph">
<p>For applications that combine traditional JavaEE transaction management and Web Service transaction management, it is often desirable to have some mechanism for linking these transaction types, such that a single transaction may span business logic written for either transaction type.
Examples include exposing existing JavaEE transactional business logic (e.g. EJBs) as transactional Web Services, or allowing JavaEE transactional components to utilize transactional Web Services.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transaction_bridging"><a class="anchor" href="#_transaction_bridging"></a>1.2. Transaction Bridging</h3>
<div class="paragraph">
<p>We use the term Transaction Bridging to describe the process of linking the JavaEE and Web Services transaction domains.
The transaction bridge component (txbridge) of Narayana provides bi-directional linkage, such that either type of transaction may encompass business logic designed for use with the other type.</p>
</div>
<div class="paragraph">
<p>The technique used by the bridge is a combination of interposition and protocol mapping.</p>
</div>
<div class="paragraph">
<p>Interposition is used in transaction systems to allow a tree of transaction coordinators to be constructed, usually for performance reasons.
Interposed coordinators function as transaction managers for nodes below them in the tree, whilst appearing as resources (participants in WS-AT terminology) to the node above them.</p>
</div>
<div class="paragraph">
<p>Within a single transaction domain, interposition may be used to allow remote nodes to minimize the number of network calls necessary at transaction termination.
The top level node is known as the root coordinator, whilst interposed coordinators are termed subordinate.
This name indicates that they are not autonomously responsible for determining the transaction outcome, but rather are driven by their parent coordinator.
Therefore, whilst a top level coordinator exposes only the <code>commit</code> and <code>rollback</code> methods for transaction termination and handles the 2PC internally, the subordinates additionally expose the prepare method to their parent, behaving much like resources during the termination protocol.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/txbridge-guide-interposition.png" alt="txbridge guide interposition">
</div>
<div class="title">Figure 1. Transaction interposition in a distributed JTA environment</div>
</div>
<div class="paragraph">
<p>In the transaction bridge, an interposed coordinator is registered into the existing transaction and performs the additional task of protocol mapping.
That is, it appears to its parent coordinator to be a resource of its native transaction type, whilst appearing to its children to be a coordinator of their native transaction type, even though these transaction types differ.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/txbridge-guide-bridgeinterposition.png" alt="txbridge guide bridgeinterposition">
</div>
<div class="title">Figure 2. Transactional bridging interposition</div>
</div>
<div class="paragraph">
<p>The interposed coordinator is responsible for performing mapping between the transaction protocols.
There is a strong correspondence between the API and protocol used by the JTA and WS-AT transaction types, which is unsurprising given their common heritage and shared problem domain.
However, method signatures, exception types and such do differ.
The bridge provides a abstraction layer to mask these distinctions as far as possible.</p>
</div>
<div class="paragraph">
<p>The net result of this is that existing business logic perceives its expected transaction environment, even though the transaction in which it is executing may be subordinate to one of a different type.
No changes are necessary to existing transactional applications to allow them to operate in the scope of foreign transactions.
This facilitates reuse of existing business logic components in new environments and increases the possibilities for new architectures and interoperability.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_transaction_bridge_architecture"><a class="anchor" href="#_transaction_bridge_architecture"></a>2. Transaction <code>Bridge</code> Architecture</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview"><a class="anchor" href="#_overview"></a>2.1. Overview</h3>
<div class="paragraph">
<p>The transaction bridge resides in the package <code>org.jboss.jbossts.txbridge</code> and its <code>subpackages.</code>.
It consists of two distinct sets of classes, one for bridging in each direction.</p>
</div>
<div class="paragraph">
<p>The process of inflowing a WS-AT transaction context on a Web Service call into the container and converting it to a local JTA transaction context such that existing transactional JavaEE code (e.g. EJBs) may be called within its scope, is termed Inbound Transaction Bridging.
When using inbound bridging, a parent WS-AT transaction coordinator has a subordinate JTA coordinator interposed into it via the transaction bridge.</p>
</div>
<div class="paragraph">
<p>The process of outflowing a WS-AT transaction context on a call to a transactional Web Service from a business logic method operating in a JavaEE transaction scope, is termed Outbound Transaction Bridging.
When using outbound bridging, a parent JTA transaction coordinator has a subordinate WS-AT coordinator interposed into it via the transaction bridge.</p>
</div>
<div class="paragraph">
<p>For the purpose of understanding this naming convention, it is simplest to view the JTA as being local to the container in which it operates, whilst the Web Service protocol provides for transaction context propagation between servers.
This is an accurate representation of the situation that exists where the local JTA version of Narayana is being used alongside Narayana XTS in an application server.
However, it is an oversimplification of the situation where the JTS option is used.
We will return to this case later.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="images/txbridge-guide-architecture.png" alt="txbridge guide architecture">
</div>
<div class="title">Figure 3. Simplified <code>Bridge</code> Architecture</div>
</div>
</div>
<div class="sect2">
<h3 id="_shared_design_elements"><a class="anchor" href="#_shared_design_elements"></a>2.2. Shared Design Elements</h3>
<div class="paragraph">
<p>The design of the inbound and outbound bridges is conceptually very similar.
Each provides the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>BridgeManager</code>, essentially a factory singleton, providing a means of managing <code>Bridge</code> and resource/participant instances.
The chief role of the <code>BridgeManager</code> is to ensure a distinct mapping of a parent transaction context to a single <code>Bridge</code> and resource/participant instance.</p>
</li>
<li>
<p>A <code>Bridge</code>, which provides Thread to transaction context association and disassociation functions for the subordinate transaction.
The <code>Bridge</code> is usually called from the <code>Handler</code>, but may optionally be driven directly.</p>
</li>
<li>
<p>A <code>Handler</code>, which is registered into the JAX-WS processing pipeline to provide minimally invasive management of Thread to transaction context bindings via the <code>Bridge</code>, an appropriate instance of which it obtains from the <code>BridgeManager</code>.
Whilst the bridge provides handlers only for JAX-WS, it&#8217;s possible to use these as a model for the implementation of JAX-RPC versions if desired.</p>
</li>
<li>
<p>A <code>VolatileParticipant</code> and <code>DurableParticipant</code> (in the case of the InboundBridge) or <code>Synchronization</code> and <code>XAResource</code> (in the case of the OutboundBridge) which are enlisted into the parent transaction and wrap the Subordinate transaction coordinator, providing mapping of the transaction termination protocol operations.</p>
</li>
<li>
<p>A <code>RecoveryManager</code>, which is responsible for automatically restoring the state of crashed transactions and allowing them to complete correctly.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_inbound_bridging"><a class="anchor" href="#_inbound_bridging"></a>2.3. Inbound Bridging</h3>
<div class="paragraph">
<p>The process flow when using the inbound bridge is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A remote client starts a WS-AT transaction and invokes a transactional Web Service in the scope of that transaction.
The inbound WS invocation therefore has SOAP headers containing the WS-AT transaction context.
The coordinator used for this transaction is the root coordinator.
It may be remote from either or both of the client and the service it is invoking.
The client needs access to a WS-AT implementation, but not a JTA or the transaction bridge deployed.</p>
</li>
<li>
<p>The call arrives at a web service container, which must have Narayana JTA or JTS, XTS and the transaction bridge deployed.
The JAX-WS handler chain for the web service should have both the XTS WS-AT transaction header processor and the inbound bridge handler registered, such that they are invoked in that order.</p>
</li>
<li>
<p>The transaction header processor takes the WS-AT transaction context from XML, creates a corresponding WS-AT TxContext and associates it to the Thread.
The bridge handler calls the <code>InboundBridgeManager</code> to obtain an <code>InboundBridge</code> instance corresponding to the TxContext.</p>
</li>
<li>
<p>As the <code>BridgeManager</code> is seeing the TxContext for the first time, it creates a new <code>Bridge</code> instance.
It also creates a new <code>Bridge</code>, <code>VolatileParticipant</code>, and <code>DurableParticipant</code> and registers them with the WS-AT transaction coordinator.
These <code>Participants</code> wrap a subordinate JTA transaction.</p>
</li>
<li>
<p>The bridge header processor starts the bridge, which associates the JTA subordinate transaction context to the Thread.
At this point the Thread has transaction contexts for both WS-AT and JTA.</p>
</li>
<li>
<p>The JAX-WS pipeline processing continues, eventually calling whatever business logic is exposed.
This may be e.g. an EJB using JSR-181 annotations.
The business logic may use the JTA transaction in the normal manner e.g. enlisting Synchronizations and <code>XAResources</code> or performing other transactional activity either directly or though the usual JavaEE abstractions.</p>
</li>
<li>
<p>On the return path, the bridge header processor disassociates the JTA transaction context from the Thread via the <code>Bridge</code>.
The XTS context processor then does likewise for the WS-AT TxContext.</p>
</li>
<li>
<p>On subsequent web services calls to the same or other web services from the same client, the process is repeated.
However, the <code>BridgeManager</code> will, upon seeing the same WS-AT transaction context again, return the existing <code>Bridge</code> instance and not register further Participant instances.
This allows substantially better performance than registering one Participant per web service invocation.</p>
</li>
<li>
<p>Upon transaction termination by the client, the WS-AT transaction coordinator will drive the enlisted bridge <code>Participants</code> through the transaction termination protocol.
The <code>Participants</code> maps these calls down to the JTA subtransaction coordinator, which in turn passes them on to any Synchronizations or <code>XAResources</code> enlisted in the transaction.
This process is not visible to the business logic, except in so far as it may have registered its own Synchronizations, <code>XAResources</code> or <code>Participants</code> with the transaction.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_outbound_bridging"><a class="anchor" href="#_outbound_bridging"></a>2.4. Outbound Bridging</h3>
<div class="paragraph">
<p>The process flow when using the outbound bridge is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A client starts a JTA transaction and invokes a remote transactional Web Service in the scope of that transaction.
The client must have Narayana JTA (or JTS) and XTS deployed, as well as the transaction bridge.
The coordinator used for the JTA transaction is the root coordinator.
The server hosting the target web service needs a WS-AT transaction implementation but not a JTA or the transaction bridge.</p>
</li>
<li>
<p>The outbound WS invocation flows though a handler chain that has the outbound transaction bridge handler and XTS header context processor registered, such that they are invoked in that order.</p>
</li>
<li>
<p>The bridge handler calls the outbound bridge manager to obtain an outbound bridge instance corresponding to the JTA transaction context.
As the <code>BridgeManager</code> is seeing the context for the first time, it creates a new <code>Bridge</code> instance.
It also creates a <code>Synchronization</code> and <code>XAResource</code> instance to wrap the subordinate WS-AT transaction and registers these with the JTA transaction.</p>
</li>
<li>
<p>The bridge handler starts the bridge, which associates the subordinate WS-AT transaction context to the Thread.
The WS-AT header context processor then serializes this into XML in the headers of the outbound Web Services call.</p>
</li>
<li>
<p>The receiving Web Service sees a WS-AT context and can work with it in the normal manner, without knowing it is a subordinate context.</p>
</li>
<li>
<p>On the return path, the bridge handler disassociates the WS-AT TxContext from the Thread via the <code>Bridge</code>.</p>
</li>
<li>
<p>On subsequent calls to the same or other transactional Web Services in the scope of the same JTA transaction, the process is repeated.
However, the <code>BridgeManager</code> will, upon seeing the same JTA transaction context again, return the existing <code>Bridge</code> and not register another <code>Synchronization</code> or <code>XAResource</code> with the parent JTA transaction.
This allows substantially better performance than registering once per web service invocation.</p>
</li>
<li>
<p>Upon transaction termination by the client, the JTA transaction coordinator will drive the enlisted bridge <code>Synchronization</code> and <code>XAResource</code> through the transaction termination protocol.
The <code>XAResource</code> maps these calls down to the WS-AT subtransaction coordinator, which in turn passes them on to any Volatile or Durable <code>Participants</code> enlisted in the transaction.
This process is not visible to the business logic, except in so far as it may have registered its own <code>Participants</code>, <code>XAResources</code> or <code>Synchronizatons</code> with the transaction.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_crash_recovery"><a class="anchor" href="#_crash_recovery"></a>2.5. Crash Recovery</h3>
<div class="paragraph">
<p>The bridge includes independent crash recovery systems for the inbound and outbound sides.
These are automatically installed and activated as part of the bridge deployment.
They rely upon the recovery mechanisms in the JTA and XTS components, which are likewise deployed and activated by default as part of their respective components.</p>
</div>
<div class="paragraph">
<p>It is the responsibility of the application(s) to use suitable <code>XAResources</code> (inbound) or <code>DurableParticipants</code> (outbound).
In general the former will be from XA datasources or messaging systems, whilst the latter will be custom implementations.
In either case it is important to ensure recovery is correctly configured for the resource manager(s) before using them in production, via the bridge or otherwise.
The Narayana documentation set details crash recovery configuration, as does the application server administration guide.
For resource manager specific information e.g. Oracle db permissions settings for recovery connections, please consult the vendor&#8217;s documentation.</p>
</div>
<div class="paragraph">
<p>A bridged transaction will involve several distinct log writes, potentially on multiple hosts.
Resolving the transaction may require more than one crash recovery cycle, due to ordering constrains on the events taking place during recovery.
If a transaction fails to recover after all servers have been restored to service for more than two recovery cycles duration, the Narayana objectstore browser and server logs may be useful for diagnosing the issue.
Where a transaction involves multiple bridges the number of recovery cycles required to resolve it may further increase.
For systems requiring maximum availability it is therefore not recommended to span a transaction through more than one bridge.</p>
</div>
<div class="paragraph">
<p>Note that the 1PC commit optimization should not be used with outbound bridged transactions in which the subordinate may contain more than one Participant.
Even where only one Participant is used, crash recovery logs may not correctly reflect the actual transaction outcome.
The 1PC optimization is on be default and may be disabled by setting <code>&lt;property name="commitOnePhase"&gt;false &lt;/property&gt;</code> on <code>CoordinatorEnvironmentBean</code>.</p>
</div>
<div class="paragraph">
<p>See the 'Design Notes' appendix for detailed information on potential crash recovery scenarios and how each is handled.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_transaction_bridge"><a class="anchor" href="#_using_the_transaction_bridge"></a>3. Using the Transaction Bridge</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction_2"><a class="anchor" href="#_introduction_2"></a>3.1. Introduction</h3>
<div class="paragraph">
<p>This section describes how to use the transaction bridge in your applications.
It is recommended you first read the preceding chapters for a theoretical background in the way the bridge functions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enabling"><a class="anchor" href="#_enabling"></a>3.2. Enabling</h3>
<div class="paragraph">
<p>TXBridge is integrated with the XTS subsystem of the WildFly Application Server.
The XTS subsystem is enabled using the <code>standalone-xts.xml</code> configuration</p>
</div>
<div class="olist arabic">
<div class="title">Procedure: Starting WildFly Application Server with XTS Enabled</div>
<ol class="arabic">
<li>
<p>Change to the WildFly Application Server directory:</p>
<div class="paragraph">
<p><code>cd $JBOSS_HOME</code></p>
</div>
</li>
<li>
<p>Copy the example XTS configuration into the configurations directory:</p>
<div class="paragraph">
<p><code>cp docs/examples/configs/standalone-xts.xml standalone/configuration</code></p>
</div>
</li>
<li>
<p>Start WildFly Application Server, specifying the xts configuration:</p>
<div class="paragraph">
<p>Linux:</p>
</div>
<div class="paragraph">
<p><code>bin/standalone.sh --server-config=standalone-xts.xml</code></p>
</div>
<div class="paragraph">
<p>Windows:</p>
</div>
<div class="paragraph">
<p><code>bin\standalone.bat --server-config=standalone-xts.xml</code></p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_inbound_bridging_2"><a class="anchor" href="#_inbound_bridging_2"></a>3.3. Inbound Bridging</h3>
<div class="paragraph">
<p>To use the inbound bridge, register the JAX-WS handler into the handler chain of any Web Service as follows:</p>
</div>
<div class="listingblock">
<div class="title">Registering the <code>handler</code> for Inbound Bridging</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;handler-chain&gt;</span>
    <span class="tag">&lt;protocol-bindings&gt;</span>##SOAP11_HTTP<span class="tag">&lt;/protocol-bindings&gt;</span>
    <span class="tag">&lt;handler&gt;</span>
        <span class="tag">&lt;handler-name&gt;</span>TransactionBridgeHandler<span class="tag">&lt;/handler-name&gt;</span>
        <span class="tag">&lt;handler-class&gt;</span>org.jboss.jbossts.txbridge.inbound.JaxWSTxInboundBridgeHandler<span class="tag">&lt;/handler-class&gt;</span>
    <span class="tag">&lt;/handler&gt;</span>

    <span class="tag">&lt;handler&gt;</span>
        <span class="tag">&lt;handler-name&gt;</span>WebServicesTxContextHandler<span class="tag">&lt;/handler-name&gt;</span>
        <span class="tag">&lt;handler-class&gt;</span>com.arjuna.mw.wst11.service.JaxWSHeaderContextProcessor<span class="tag">&lt;/handler-class&gt;</span>
    <span class="tag">&lt;/handler&gt;</span>
<span class="tag">&lt;/handler-chain&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The web service may then operate as though running in the scope of a JTA transaction, as indeed it is.
For example, it can call (or indeed simply be) an EJB3 business logic method annotated with <code>@TansactionAttribute(TransactionAttributeType.MANDATORY)</code>.</p>
</div>
<div class="paragraph">
<p>Note that the handlers expect a WS-AT transaction context to be present on all inbound invocations.
If you wish deploy your service in such a way as to make transactional invocation optional, you must expose it though two different endpoints, one transactional and one not, with the handlers registered only on the former.
This limitation may be addressed in future versions.</p>
</div>
<div class="paragraph">
<p>If WS-AT transaction context contains transaction timeout then the bridged JTA transaction is created with this timeout.
If the context does not provide the information then the bridged JTA transaction is created with the default timeout defined by the container.</p>
</div>
</div>
<div class="sect2">
<h3 id="_outbound_bridging_2"><a class="anchor" href="#_outbound_bridging_2"></a>3.4. Outbound Bridging</h3>
<div class="paragraph">
<p>To use the outbound bridge, register the JAX-WS handler into the handler chain of any Web Service client application as follows:</p>
</div>
<div class="listingblock">
<div class="title">Registering the <code>handler</code> for Outbound Bridging</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;handler-chain&gt;</span>
    <span class="tag">&lt;protocol-bindings&gt;</span>##SOAP11_HTTP<span class="tag">&lt;/protocol-bindings&gt;</span>
    <span class="tag">&lt;handler&gt;</span>
        <span class="tag">&lt;handler-name&gt;</span>TransactionBridgeHandler<span class="tag">&lt;/handler-name&gt;</span>
        <span class="tag">&lt;handler-class&gt;</span>org.jboss.jbossts.txbridge.outbound.JaxWSTxOutboundBridgeHandler<span class="tag">&lt;/handler-class&gt;</span>
    <span class="tag">&lt;/handler&gt;</span>

    <span class="tag">&lt;handler&gt;</span>
        <span class="tag">&lt;handler-name&gt;</span>WebServicesTxContextHandler<span class="tag">&lt;/handler-name&gt;</span>
        <span class="tag">&lt;handler-class&gt;</span>com.arjuna.mw.wst11.client.JaxWSHeaderContextProcessor<span class="tag">&lt;/handler-class&gt;</span>
    <span class="tag">&lt;/handler&gt;</span>
<span class="tag">&lt;/handler-chain&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The web service client may then make calls to web service implementations that expect to be invoked in the scope of a WS-AT transaction.</p>
</div>
<div class="paragraph">
<p>Note that the handlers expect a JTA transaction context to be present on the client thread used to make the outbound web service invocation.
If the context is not always present, different stubs must be used for the transactional and non-transactional cases and the handler chain registered only on the former.
This limitation may be addressed in future versions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_loops_and_diamonds"><a class="anchor" href="#_loops_and_diamonds"></a>3.5. Loops and Diamonds</h3>
<div class="paragraph">
<p>In distributed environments that utilize transaction bridging, it is possible to construct arrangements of servers such that a transaction context passes though more than one interposition.
These can give rise to some undesirable issues, including locking and performance problems.</p>
</div>
<div class="paragraph">
<p>A simple case would be a loop in which a JTA transaction context is bridged outbound to a WS-AT context, passed though one or more remote servers and inflowed back to the original server through an inbound bridge.
This may result in a new subordinate JTA context, rather than reuse of the existing parent context in the original server.</p>
</div>
<div class="paragraph">
<p>This situation has two main observable effects.
Firstly, the parent JTA transaction and indirectly subordinate JTA transaction are considered distinct and <code>XAResources</code> may not be shared between them.
In most cases this will cause isolation between the transactions, such that they do not share locks or see eachother&#8217;s changes.
This may cause deadlocks in the application.
Secondly, performance will be poor relative to reuse of the original context, particularly if the interposition chain becomes long.</p>
</div>
<div class="paragraph">
<p>A similar problem exists where a transaction context is propagated from a single source to a single destination server via two or more separate routes, the abstract paths forming a diamond shape.
In such case the intermediate nodes operate independently and will bridge the original context to two separate interposed contexts.
To the destination server these will appear unrelated, rather than as representations of the same transaction.
Thus instead of recombining into a single shared transaction context at the destination, they will behave as different transactions, giving rise once again to potential deadlock and performance issues.</p>
</div>
<div class="paragraph">
<p>These problems may be partially addressed by having a shared context mapping service available on the network, which each bridge consults when working with a previously unseen transaction context for the first time.
Using such a mechanism, bridge instances may identify transactions for which an established mapping already exists and reuse that relationship rather than creating a new one.</p>
</div>
<div class="paragraph">
<p>This shared service model does however cause some issues of its own with regard to performance and availability.
It is not currently implemented.
Therefore, users are urged to be cautious when constructing distributed applications.
Whilst location abstraction is sometimes desirable, is is important to maintain a clear understanding of the deployment relationships between transactional components in the system.</p>
</div>
</div>
<div class="sect2">
<h3 id="_distributed_jta_and_the_jts"><a class="anchor" href="#_distributed_jta_and_the_jts"></a>3.6. Distributed JTA and the JTS</h3>
<div class="paragraph">
<p>The JavaEE transaction engine in Narayana comes in two varieties.
These are the local only JTA, which does not support propagation of transaction context or transaction control calls between JVMs and the JTAX, which provides the JTA API implemented by a JTS engine that does support distributed usage.</p>
</div>
<div class="paragraph">
<p>WildFly Application Server</p>
</div>
<div class="paragraph">
<p>uses the local JTA implementation by default, but can be reconfigured to use the JTS via the JTA API, such that it supports distributed transactions without requiring any changes to business applications.</p>
</div>
<div class="paragraph">
<p>In environments requiring transaction propagation of JTA transactions, it is feasible to use either the JTS or an outbound and inbound bridge pair to achieve this.
In the former case the transport is RMI/IIOP for the transaction control and RMI/IIOP or JRMP for the transactional business logic calls.
In the latter case the transport is Web Services for both transaction control and business logic.</p>
</div>
<div class="paragraph">
<p>From a transaction management perspective the JTS solution is preferred, due to simplicity (no protocol mapping is needed), maturity (Narayana JTS was the world&#8217;s first JTS implementation and has been extensively used and tested in production environments) and performance (binary vs. xml).</p>
</div>
<div class="paragraph">
<p>It is possible to use transactions that propagate context on some calls via JTS and on others via Web Services, such as a client invoking both EJBs via RMI/IIOP and Web services with WS-AT context.
In such cases it&#8217;s possible for a transaction to have multiple representations that the infrastructure cannot determine are related, even if they actually represent different contexts in the same interposition hierarchy.
Care must therefore be taken to avoid the problems described previously in 'Loops and Diamonds'.</p>
</div>
</div>
<div class="sect2">
<h3 id="_logging"><a class="anchor" href="#_logging"></a>3.7. Logging</h3>
<div class="paragraph">
<p>The transaction bridge uses the jboss-logging system.
When running inside WildFly Application Server, logging is configured via logging subsystem&#8217;s configuration in <code>standalone-xts.xml</code> file.
To enable full logging for the transaction bridge, which may be useful for debug purposes, the following logger should be added:</p>
</div>
<div class="listingblock">
<div class="title">Configuring Transaction Bridge Logging</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;logger</span> <span class="attribute-name">category</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.jboss.jbossts.txbridge</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;level</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ALL</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/logger&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the transaction bridge is a thin layer on top of the XTS and JTA/JTS components of Narayana, and that it also interacts with other parts of the application server.
To gain a comprehensive understanding of the system&#8217;s operation, it may be necessary to enable verbose logging for some of these other components also.
The Narayana logging system is discussed in detail in the accompanying documentation set, but for ease of reference the following may be used to enable verbose logging:</p>
</div>
<div class="listingblock">
<div class="title">Configuring verbose logging</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;logger</span> <span class="attribute-name">category</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.arjuna</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;level</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ALL</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/logger&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note also that deployment ordering issues can result in Narayana components, including the transaction bridge, becoming active before the logging system is fully configured.
In such cases a default logging level may apply during startup, resulting in some more detailed debug messages being missed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_known_limitations"><a class="anchor" href="#_known_limitations"></a>4. Known Limitations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The current transaction bridge release has the following limitations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The bridge operates only on WS-AT 1.2, not 1.0, although XTS includes implementations of both versions of WS-AT.
Care must therefore be taken to deploy and configure the system correctly.</p>
</li>
<li>
<p>The bridge provides JAX-WS handlers only, not JAX-RPC, although it is possible to create such if required.</p>
</li>
<li>
<p>Long running activities that occur during the transaction termination process may cause timeouts in the transaction system, which can in turn cause inconsistent transaction outcomes or incomplete transaction termination.
To minimize this problem, it is advised to manually flush data that would otherwise be flushed by Synchronizations during termination, such as hibernate session state.</p>
</li>
<li>
<p>A transaction context must always be present on the Thread in order for the context processors to operate correctly, as detailed previously in 'Using the Transaction Bridge'.</p>
</li>
<li>
<p>A subordinate transaction context will be created and registered into the parent transaction unconditionally, which can cause unnecessary overhead in situations where no transactional activity takes place in the scope of the subordinate.
Care should be taken to register the bridge handlers only on methods that do require them.
In future releases this may be addressed by the use of WS-Policy or lazy initialization techniques.</p>
</li>
<li>
<p>Transaction mappings are local to BridgeManagers, which are singletons.
This means mappings are classloader scoped and not shared across JVMs.
This gives rise to issues where transactional resources are accessed indirectly though multiple bridges or transaction context transports, as described in 'Loops and Diamonds'.</p>
</li>
<li>
<p>Crash recovery is subject to certain timing issues, due to the interaction between recovery of the JTA/XA and XTS sides of the transaction.
It may take more than one crash recovery cycle for a bridged transaction to recover fully.
Note that recovery of subordinate transactions is dependent on the recovery of their parent, so care must be taken to ensure the correct recovery of any external transaction manager used in that role.
The transaction bridge does not currently provide dedicated tooling for the manual resolution of orphaned subordinates, instead relying on the general purpose objectstore maintenance tooling provided by Narayana.</p>
</li>
<li>
<p>Note that crash recovery will not behave correctly for outbound bridged transactions if 1PC commit optimization is used in the parent JTA transaction.
This is not specific to the bridge, but rather is a generic issue with any transaction in which a single resource is an interposed subordinate coordinator.
Inbound bridges transactions are unaffected as XTS (WS-AT) does not utilize a 1PC optimization.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_design_notes"><a class="anchor" href="#_design_notes"></a>5. Design Notes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_points"><a class="anchor" href="#_general_points"></a>5.1. General Points</h3>
<div class="paragraph">
<p>This section records key design points relating to the bridge implementation.
The target audience for this section is software engineers maintaining or extending the transaction bridge implementation.
It is unlikely to contain material useful to users, except in so far as they wish to contribute to the project.
An in-depth knowledge of Narayana internals may be required to make sense of some parts of this appendix.</p>
</div>
<div class="paragraph">
<p>The <code>txbridge</code> is written as far as possible as a user application layered on top of the JTA and XTS implementations.
It accesses these underlying components through standard or supported APIs as far as possible.
For example, <code>XAResource</code> is favored over <code>AbstractRecord</code>, the JCA standard <code>XATerminator</code> is used for driving subordinates and so on.
This facilitates modularity and portability.</p>
</div>
<div class="paragraph">
<p>It follows that functionality required by the bridge should first be evaluated for inclusion in one of the underlying modules, as experience has shown it is often also useful for other user applications.
For example, improvements to allows subordinate termination code portability between JTA and JTS, and support for subordinate crash recovery have benefited from this approach.
The <code>txbridge</code> remains a thin layer on top of this functionality, containing only purpose specific code.</p>
</div>
<div class="paragraph">
<p>The 'loops and diamonds' problem boils down to providing deterministic, bi-directional 1:1 mapping between an Xid (which is fixed length) and a WS-AT context (which is unbounded length in the spec, although bounded for instances created by the XTS).
Consistent hashing techniques get you so far with independent operation, but the only 100% solution is to have a shared service on the network providing the mapping lookup.
Naturally this then becomes a single point of failure as well as a scalability issue.
For some scenarios it may be possible to use interceptors to propagate the Xid on the web services call as extra data, instead of trying to reproduce the mapping at the other end.
Unfortunately XA does not provide for this kind of extensibility, although CORBA does, leading to the possibility of solving the issue without a centralized approach in mixed JTS+WS-AT environments.</p>
</div>
<div class="paragraph">
<p>Requiring a tx context on all calls is a bit limiting, but JBossWS native lacks a WS-Policy implementation.
Things may change with the move to CXF.
This is really a wider issue with XTS, not just the bridge.</p>
</div>
</div>
<div class="sect2">
<h3 id="_crash_recovery_considerations"><a class="anchor" href="#_crash_recovery_considerations"></a>5.2. Crash Recovery Considerations</h3>
<div class="paragraph">
<p>As usual with transactions, it&#8217;s the crash recovery that provides for the most complexity.
Recovery for the inbound and outbound sides is handled independently.
Because of event ordering between recovery modules (JTA, XTS), it requires two complete cycles to resolve some of these crash recovery situations.</p>
</div>
<div class="sect3">
<h4 id="_inbound_crash_recovery"><a class="anchor" href="#_inbound_crash_recovery"></a>5.2.1. Inbound Crash Recovery</h4>
<div class="paragraph">
<p>An inbound transaction involves at least four log writes.
Top down (i.e. in reverse order of log creation) these are: The WS-AT coordinator log (assumed here to be XTS, but may be 3rd party), the XTS Participant log in the receiving server, the JCA Subordinate transaction log and at least one XA Resource Manager log (which are 3rd party e.g. Oracle).</p>
</div>
<div class="paragraph">
<p>There is no separate log created by the <code>txbridge</code>.
The XTS Participant log inlines the Serializable <code>BridgeDurableParticipant</code> via its writeObject method.
Recorded state includes its identity (the Xid) and the identity of the separately logged JTA subordinate tx (a Uid).</p>
</div>
<div class="paragraph">
<p>XTS is responsible for the top level coordinator log.
Narayana is responsible for the JTA subordinate tx log and 3rd party RMs are each responsible for their own.</p>
</div>
<div class="paragraph">
<p>The following situations may exist at recovery time, according to the point in time at which the crash occurred:</p>
</div>
<div class="paragraph">
<p>RM log only: In this case, the <code>InboundBridgeRecoveryManager&#8217;s `XAResourceOrphanFilter</code> implementation will be invoked via Narayana <code>XARecoveryModule</code>, will recognize the orphaned Xids by their formatId (which they inherit from the JCA subordinate, which the <code>txbridge</code> previously created with a specially constructed inflowed Xid) and will vote to have the <code>XARecoveryModule</code> roll them back as no corresponding JCA subordinate log exists, so presumed abort applies.</p>
</div>
<div class="paragraph">
<p>RM log and JTA subordinate tx log: The <code>InboundBridgeRecoverytManager&#8217;s scan of indoubt subordinate JTA transactions identifies the JTA subordinate as being orphaned and rolls it back, which in turn causes the rollback of the RM&#8217;s `XAResource</code>.</p>
</div>
<div class="paragraph">
<p>RM log, JTA subordinate log and XTS Participant log: XTS is responsible for detecting that the Participant is orphaned (by re-sending Prepared to the Coordinator and receiving 'unknown tx' back) and initiating rollback under the presumed abort convention.</p>
</div>
<div class="paragraph">
<p>WS-AT coordinator log and all downstream logs: The coordinator re-sends Commit to the Participant and the transaction completes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_outbound_crash_recovery"><a class="anchor" href="#_outbound_crash_recovery"></a>5.2.2. Outbound Crash Recovery</h4>
<div class="paragraph">
<p>An outbound transaction involves log writes for the JTA parent transaction and the XTS <code>BridgeWrapper</code> coordinator.
There is not a separate log created by the <code>txbridge</code>.
The JTA tx log inlines the Serializable <code>BridgeXAResource</code> via its writeObject method.
Recorded state includes the JTA tx id and <code>BridgeWrapper</code> id String.
In addition a Web Service participating in the subordinate transaction will create a log.
Assuming it&#8217;s XTS, the participant side log will inline any <code>Serializable Durable2PCParticipant</code>, effectively forming the RM log.</p>
</div>
<div class="paragraph">
<p>The following situations may exist at recovery time, according to the point in time at which the crash occurred:</p>
</div>
<div class="paragraph">
<p>RM log (i.e. XTS Participant log, inlining <code>Serializable Durable2PCParticipant</code>) only: XTS is responsible for detecting that the Participant is orphaned (its direct parent, the subordinate coordinator, is missing) and rolling it back.
The bridge recovery code is not involved – XTS recovery deserializes and drives any app DurableParticipants directly.</p>
</div>
<div class="paragraph">
<p>RM log and XTS subordinate log: The <code>DurableParticipant</code>(s) (i.e. client side) and XTS subordinate coordinator / <code>BridgeWrapper</code> (i.e. server side) and reinstantiated by XTS.
The <code>BridgeWrapper</code>, being subordinate to a missing parent, must be identified and explicitly rolledback by the bridge recovery code.
The bridge recovery manager is itself a RecoveryModule, thus invoked periodically to perform this task.
It identified its own <code>BridgeWrapper</code> instance from amongst all those awaiting recovery by means of an id prefix specific to the <code>txbridge</code> code.
See <code>JBTM-725</code> for further details.</p>
</div>
<div class="paragraph">
<p>RM log, XTS subordinate log and JTA parent log (with inlined <code>BridgeXAResource</code>): Top down recovery by the JTA recovery module drives tx to completion, taking the normal JTA parent&#8594;`BridgeXAResource`&#8594;XTS subordinate&#8594;`DurableParticipant` path.
Note that if the bridge is the only <code>XAResource</code> in the parent, the JTA must have 1PC commit optimization disabled or it won&#8217;t write a log for recovery.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_test_framework"><a class="anchor" href="#_test_framework"></a>5.3. Test framework</h3>
<div class="paragraph">
<p>The test suite for the <code>txbridge</code> is split along two axis.
Firstly, the inbound and outbound sides of the bridge have their own test suites in a parallel code package hierarchy.
These are largely mirrors, containing tests which have matching intent but different implementation details.
Secondly, the tests are split between those for normal execution and those for crash recovery.</p>
</div>
<div class="paragraph">
<p>The tests use a framework consisting of a basic servlet acting as client (the code pre-dates the availability of XTS lightweight client), a basic web service as server and a set of utility classes implementing the appropriate interfaces (<code>Participant</code>/<code>Synchronization</code>/<code>XAResource</code>).
These classes contain the bare minimum of test logic.
In order to make the tests as easy to understand and modify as possible, an attempt is made to capture the entirety of the test logic within the junit test function instead of splitting it over the framework classes.
To facilitate this, extensive use is made of byteman and its associated dtest library, which provides basic distributed mock-like execution tracing and configuration.
You probably need to take a detour and read the dtest docs before proceeding further.</p>
</div>
<div class="paragraph">
<p>The basic tests all follow the same pattern: make a call through the bridge, following different logic paths in each test, and verify that the test resources see the expected method calls.
For example, in a test that runs a transaction successfully, expect to see commit called on enlisted resources and rollback not called.
For a test that configures the prepare to fail, expect to see rollback called and commit not called.
The tests verify behavior in the presence of 'expected' errors e.g. prepare failures, but generally don&#8217;t cover unexpected failures e.g. exceptions thrown from commit.</p>
</div>
<div class="paragraph">
<p>Test normal execution targets in the <code>tests/build.xml</code> assume the server is started manually with byteman installed and has XTS, <code>txbridge</code> and the test artifacts deployed.
Note that it also contains targets that may be called to achieve the last of these steps.</p>
</div>
<div class="paragraph">
<p>The crash rec tests start (and subsequently restart) the server automatically, but assume the that XTS, <code>txbridge</code> and the test artifacts are deployed.
To manage the server they need to be provided with <code>JBOSS_HOME</code> and <code>JAVA_HOME</code> values in the <code>build.xml</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-10-16 15:47:44 +0200
</div>
</div>
</body>
</html>